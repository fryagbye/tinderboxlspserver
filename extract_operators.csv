Name,OpClass,OpScope,OpType,OpReturnType,OperatorFlag,OriginalVersion,CodeFirstAdded,CodeAltered,ChangeRefSet,OSVersion,NumberOfArgs,HasNeededArguments,IsDotOp,HasDotOpVersion,HasLoopVariable,HasRegExArgument,HasScopeArgument,HasConditionalArgument,HasOptionalArgument,HasStyledOutput,HonoursLinkType,HasNoCodeSample,Text,TextJa
- (i.e. subtraction),Operator,Item,Mathematical,Number,false,1.0.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"- (i.e. subtraction)
The subtraction operator, - (minus sign character), returns the remainder of the argument before it when the argument after it is subtracted.
	$MyNumber = 3-4; 
When mixing data types (a '-' might be intended as a hyphen) or if working with lists—i.e. List & Set types—see notes under concatenation.","- （すなわち減算）
減算演算子「-」（マイナス記号）は、その前の引数からその後の引数を引いた結果を返します。
	$MyNumber = 3-4; 
データ型を混在させる場合（「-」がハイフンを意図している可能性があります）、またはリスト（すなわち List型やSet型）を扱う場合は、連結（concatenation）の項にある注記を参照してください。"
-= (i.e. decrement),Operator,Item,Mathematical,Number,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"-= (i.e. decrement)
This assignment operator is a convenient shorthand for decrementing an attribute. For example, the two following statements are equivalent:
$MyNumber -= 3; 
$MyNumber = $MyNumber - 3; 
This operator may also be used with Lists and Sets.","-= (デクリメント)
この代入演算子は、属性の値を減算するための便利な短縮形です。例えば、以下の2つの文は等価です。
$MyNumber -= 3; 
$MyNumber = $MyNumber - 3; 
この演算子は、リスト（List）型やセット（Set）型でも使用できます。"
!= (i.e. value inequality),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"!= (i.e. inequality test)
The operator to test inequality (i.e. 'is not the same as') is '!=', an exclamation mark followed by an equals sign.
This operator is used either in agent queries or in the conditional part of an if(condition){action} code. It is the functional opposite of the '==' equality test.
This test cannot be meaningfully applied to Set or List type attribute data, as the entire attribute value is matched, rather than individual values as might otherwise be assumed. For these data types use the .contains() or .icontains() operators instead, noting the scope for ambiguous matching due to stemming of words (""car"" with match ""car"", ""cars"" and ""carrot"").
Because equality comparisons of Date-type data match at day scope, rather than full date/time values (for legacy reasons), use interval() to compare Date-type inequality.
Equality testing can be negated, i.e. nested for a non-match, or combined with greater/less than for a range of tests as further explored in Basic Comparison Codes.
For a case-insensitive lexical equality test, use a lowercase on-the-fly transform:
	""Absquatulate"".lowercase != ""Absquatulate"" 
If we set $MyString to ""Absquatulate"", then:
	$MyString.lowercase != ""Absquatulate"" 
If $MyOtherString(Some note) has the value ""Absquatulate"", then:
	$MyString.lowercase != $MyOtherString(Some note) 
Note the stored left-side value is not altered, but its transformed version is used in the test giving a case-insensitive comparison. This method only works for upper/lower case comparisons; accented characters are lexically different characters regardless of case.","!= （不等価テスト）
不等価（すなわち「～と同じではない」）をテストする演算子は '!=' で、感嘆符の後に等号が続きます。
この演算子は、エージェントのクエリ、または if(condition){action} コードの条件部分で使用されます。これは '==' 等価テストの機能的な対極にあります。
このテストは、Set 型または List 型の属性データには意味のある適用ができません。想定されるような個別の値ではなく、属性値全体が照合されるためです。これらのデータ型については、代わりに .contains() または .icontains() 演算子を使用してください。その際、単語のステミング（「car」が「car」、「cars」、「carrot」に一致するなど）による曖昧な一致の可能性があることに注意してください。
Date 型データの等価比較は、（過去の経緯から）完全な日付/時刻値ではなく日付単位で一致するため、Date 型の不等価を比較するには interval() を使用してください。
等価テストは否定（つまり、不一致のためにネストする）したり、「Basic Comparison Codes」で詳しく説明されているように、範囲テストのために大なり/小なり記号と組み合わせたりすることができます。
大文字と小文字を区別しない語彙の等価テストには、その場での lowercase 変換を使用します：
	""Absquatulate"".lowercase != ""Absquatulate"" 
$MyString を ""Absquatulate"" に設定した場合、次のようになります：
	$MyString.lowercase != ""Absquatulate"" 
$MyOtherString(Some note) の値が ""Absquatulate"" である場合、次のようになります：
	$MyString.lowercase != $MyOtherString(Some note) 
保存されている左辺の値は変更されず、変換されたバージョンがテストで使用されることで、大文字と小文字を区別しない比較が行われることに注意してください。この方法は大文字と小文字の比較にのみ有効です。アクセント付き文字は、大文字小文字に関わらず語彙的に異なる文字として扱われます。"
... (i.e. range),Operator,Item,Mathematical,List,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"... (i.e. range)
The range operator constructs a list of numbers from a specified starting point to a specified end point. Note: the range operator is written as 3 dots and not an ellipsis character. White space immediately before or after the operator is ignored as with other mathematical operators. For example:
	1…3 → ""1;2;3""
	3 … 1 → ""3;2;1""
Note do not use enclosing quotes or square brackets with the range operator as the operator will not be correctly evaluated, resulting in the wrong outcome.
	[1…3] → ""1 ... 3"" WRONG!
	""1…3"" → ""1 ... 3"" WRONG!
The range operator binds more tightly than arithmetic operators. Thus
	1...3 * 2 → ""2;4;6""
and is the is the same as
	(1..3) * 2 → ""2;4;6"" 
i.e. the parentheses in the second example are not needed.
The range operator can be useful for performing a task a specific number of times using the List.each() operator:
	 1...10.each(x){var vPath=""/container/item ""+x; create(vPath);} 
and in that example the value of the loop variable x is the value for the source list generated by the range operator, i.e. it is the same as would occur in this literal example:
	""1;2;3;4;5;6;7;8;9;10"".each(x){var vPath=""/container/item ""+x; create(vPath);} 
In both cases, on the second iteration of the .each() loop, the loop variable x would have the value 2.
Using non-literal range specifiers
It may be useful to define one or both range limits. For example, if $MyNumber is 3:
	$MyList = [1 ... $MyNumber]; gives ""1;2;3""
or if variable vNum is 4:
	$MyList = 1 ..vNum; gives ""1;2;3;5""
But for more complex expressions using chained operators, parentheses my be needed to hint intent to Tinderbox. Thus, if $MySet has 4 items:
	$MyList = 1 ... $MySet.size; gives ""1"" WRONG
so add parentheses around the expression:
	$MyList = 1 ... ($MySet.size); gives ""1;2;3;4"" CORRECT
If chaining operators to range specified using expressions, consider using parentheses around the whole range definition:
	(1 ... ($MySet.size)).each(x){$Text+= x+""\n"";}; 
The last example actually works without the parentheses but illustrates the concept.
Using range to supply a loop counter
When working with List.each(), it can be useful to know which source list item is being currently in scope. It is possible to use a variable (see here), but the range operator offers another method. In this method a range-generated list is iterated and in-loop the list being processed is called via List.at(). It in important to note that as .at() numbers from zero, either the range must start from zero, or the range item used with at must be adjusted by -1.
In the following example, $MyList holds the data of interest, and a zero-based range with be generated:
	(0 ... ($MyList.count)).each(N){
		$MyList.at(N) ..tc.
	}
Thus for loop #3, the value of N will be 2 (recall the range code is making a zero based list of numbers). Thus in-loop, $MyList.at(N) will be the same as $MyList.at(2), i.e. addressing the the third item in $MyList.","範囲演算子（range operator）は、指定された開始点から指定された終了点までの数値のリストを作成します。注意：範囲演算子は、省略記号（…）ではなく、3つのドット（...）で記述されます。他の数学演算子と同様に、演算子の直前または直後の空白は無視されます。例：
	1...3 → ""1;2;3""
	3 ... 1 → ""3;2;1""
範囲演算子を引用符や角括弧で囲まないように注意してください。演算子が正しく評価されず、誤った結果を招く可能性があります。
	[1...3] → ""1 ... 3"" 誤り！
	""1...3"" → ""1 ... 3"" 誤り！
範囲演算子は算術演算子よりも強く結びつきます。したがって、
	1...3 * 2 → ""2;4;6""
となり、これは
	(1...3) * 2 → ""2;4;6""
と同じです。つまり、2番目の例の括弧は不要です。
範囲演算子は、List.each() 演算子を使用して特定の回数だけタスクを実行する際に便利です。
	 1...10.each(x){var vPath=""/container/item ""+x; create(vPath);} 
この例では、ループ変数 x の値は範囲演算子によって生成されたソースリストの値になります。つまり、次のリテラルの例と同じことが起こります。
	""1;2;3;4;5;6;7;8;9;10"".each(x){var vPath=""/container/item ""+x; create(vPath);} 
どちらの場合も、.each() ループの2回目のイテレーションで、ループ変数 x の値は 2 になります。

非リテラルの範囲指定子の使用
範囲の境界の一方または両方を定義すると便利な場合があります。例えば、$MyNumber が 3 の場合：
	$MyList = [1 ... $MyNumber]; は ""1;2;3"" を与えます。
あるいは、変数 vNum が 4 の場合：
	$MyList = 1 ..vNum; は ""1;2;3;5"" を与えます。
しかし、チェーン演算子を使用したより複雑な式の場合、Tinderbox に意図を伝えるために括弧が必要になることがあります。例えば、$MySet に 4 つの項目がある場合：
	$MyList = 1 ... $MySet.size; は ""1"" を与えます（誤り）。
そのため、式の周囲に括弧を追加します。
	$MyList = 1 ... ($MySet.size); は ""1;2;3;4"" を与えます（正しい）。
式を使用して指定された範囲に演算子をチェーンする場合は、範囲定義全体を括弧で囲むことを検討してください。
	(1 ... ($MySet.size)).each(x){$Text+= x+""\n"";}; 
最後の例は実際には括弧がなくても動作しますが、概念を説明しています。

範囲を使用してループカウンターを提供する
List.each() を使用する場合、現在どのソースリスト項目がスコープ内にあるかを知ると便利なことがあります。変数を使用することも可能ですが（こちらを参照）、範囲演算子は別の方法を提供します。この方法では、範囲によって生成されたリストが反復処理され、ループ内で処理中のリストが List.at() を介して呼び出されます。.at() は 0 から数え始めるため、範囲を 0 から開始するか、at で使用する範囲項目を -1 調整する必要があることに注意してください。
次の例では、$MyList が対象のデータを保持しており、0 ベースの範囲が生成されます。
	(0 ... ($MyList.count)).each(N){
		$MyList.at(N) ..tc.
	}
したがって、3回目のループでは、N の値は 2 になります（範囲コードが 0 ベースの数値リストを作成していることを思い出してください）。その結果、ループ内では $MyList.at(N) は $MyList.at(2) と同じになり、つまり $MyList の 3 番目の項目を参照することになります。"
(!$AttributeName) (i.e. a short form test for no value),Operator,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"(!$AttributeName)
In queries and conditional action code expressions, preceding a '$'-prefixed attribute name with an exclamation mark functions as a shortened form of the Boolean test for a false value. Due to limitations in the underlying parser, an inequality test expression must be enclosed in parentheses.Thus the following are functional equivalents:
	$MyBoolean==false 
	(!$MyBoolean) 
Do not use this form or you may get unexpected results:
	!$MyBoolean Do not use this format, without parentheses!
In both cases the result is false if the value of $MyBoolean is false. 
Usefully Tinderbox also useful supports such short-form !$AttributeName tests for all the other attribute data types, returning true if the attribute has a default value. Per data type, this equates to long form tests like:
	$MyBoolean==false 
	$MyColor=="""" 
	$MyDate==""never"" 
	$MyDictionary=="""" 
	$MyFile=="""" 
	$MyInterval==""00:00"" 
	$MyList==[] (or (deprecated) $MyList=="""") 
	$MyNumber==0 
	$MySet==[] (or (deprecated) $MyList=="""") 
	$MyString=="""" 
	$MyURL=="""" 
This also holds for system-only data types:
	$MyAction=="""" 
	$MyFont=="""" 
In all these cases a short-form test returns true if the attribute value is the default for that data type.
This test is the logical opposite of the $AttributeName test.","(!$AttributeName)
クエリや条件付きのアクションコード式において、'$' が付いた属性名の前に感嘆符（!）を置くと、Boolean の偽（false）判定の短縮形として機能します。基礎となるパーサーの制限により、この否定判定式は括弧で囲む必要があります。したがって、以下は機能的に同等です：
	$MyBoolean==false 
	(!$MyBoolean) 
以下の形式は使用しないでください。予期しない結果を招く可能性があります：
	!$MyBoolean （括弧なしのこの形式は使用しないでください！）
どちらの場合も、$MyBoolean の値が false であれば、結果は false となります。
便利なことに、Tinderbox は他のすべての属性データ型に対しても、このような !$AttributeName 短縮形式のテストをサポートしており、属性がデフォルト値である場合に true を返します。データ型ごとに、これは以下のような長い形式のテストと同等です：
	$MyBoolean==false 
	$MyColor=="""" 
	$MyDate==""never"" 
	$MyDictionary=="""" 
	$MyFile=="""" 
	$MyInterval==""00:00"" 
	$MyList==[] （または（非推奨）$MyList==""""） 
	$MyNumber==0 
	$MySet==[] （または（非推奨）$MyList==""""） 
	$MyString=="""" 
	$MyURL=="""" 
これはシステム専用のデータ型にも当てはまります：
	$MyAction=="""" 
	$MyFont=="""" 
これらのすべてのケースにおいて、短縮形式のテストは、属性値がそのデータ型のデフォルト値である場合に true を返します。
このテストは $AttributeName テストの論理的な反対です。"
* (i.e. multiplication),Operator,Item,Mathematical,Number,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"* (i.e. multiplication)
The multiplication operator, * (asterisk character), returns the multiplication of the arguments before and after it.
	$MyNumber = 3*4; 
Both arguments are normally Number-type data.
Multiplying Strings
Sometimes there is a need to expand or repeat a String. For this, the multiplication operator * may be used. Due to Tinderbox's internal type coercion effects, the number argument must be used as the first argument; placing it after the * will cause a silent fail with no resulting output. Thus, the expression:
	$MyString = 3*""xyz ""; 
evaluates to a string ""xyz xyz xyz"". But this:
	$MyString = ""xyz ""*3; WRONG!
will return nothing.
Multiplying Lists and Sets
Lists and Sets of numbers may be multiplied by a number. Two lists of numbers may be multiplied if they have the same length, in which case their elements are multiplied.
	[1;2;3;4] * [1;2;3;4]; ➛ [1;4;9;12] 
or, using the range operator:
	1...4 * 1...4 ➛ 1;4;9;12","*（乗算）
乗算演算子 *（アスタリスク記号）は、その前後の引数を乗算した結果を返します。
	$MyNumber = 3*4;
通常、両方の引数は数値（Number）型のデータです。

文字列の乗算
文字列を拡張したり繰り返したりする必要がある場合があります。このため、乗算演算子 * を使用できます。Tinderbox の内部的な型強制（type coercion）の影響により、数値の引数を第1引数として使用する必要があります。* の後に数値を配置すると、結果が出力されず、暗黙的に失敗します。したがって、次の式：
	$MyString = 3*""xyz "";
は文字列 ""xyz xyz xyz"" と評価されます。しかし、次のように：
	$MyString = ""xyz ""*3; 誤り！
と記述しても、何も返されません。

リストとセットの乗算
数値のリスト（List）やセット（Set）は、数値と乗算できます。2つの数値リストは、それらの長さが同じであれば乗算でき、その場合、各要素が乗算されます。
	[1;2;3;4] * [1;2;3;4]; ➛ [1;4;9;12]
または、範囲演算子（range operator）を使用して：
	1...4 * 1...4 ➛ 1;4;9;12"
/ (i.e. division),Operator,Item,Mathematical,Number,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"/ (i.e. division)
The division operator, / (forward slash character), returns the argument before it divided by the argument after it.
	$MyNumber = 3/4; 
By default, up to 5 decimal places are returned, so:
	$MyNumber = 10/3; 
results in $MyNumber having a value of 3.33333. 
Be aware the forward slash character has many other symbolic meanings (POSIX folder delimiter, linguistic use e.g. 'and/or', date component delimiters, etc.). Be careful to ensure to quote or escape the / character where you do not want Tinderbox to assume a division.","除算演算子 /（スラッシュ）は、前の引数を後の引数で割った結果を返します。
	$MyNumber = 3/4; 
デフォルトでは小数点以下最大5桁まで返されるため、
	$MyNumber = 10/3; 
とすると、$MyNumberの値は3.33333になります。
スラッシュ記号には、他にも多くの意味（POSIXのフォルダ区切り文字、'and/or'などの言語的用法、日付の区切り文字など）があることに注意してください。Tinderboxに除算と解釈させたくない箇所では、/ 文字を引用符で囲むかエスケープするようにしてください。"
& (i.e. query logical AND join),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"& (i.e. query logical AND join)
The ampersand, &, is used in queries and conditional statements as a logical AND join. Thus:
	if ($HasStock == true & $Price > 20) {$Badge=""ok"";} 
The note's $Badge is only set if both the first and the second argument are true.
See also the OR join and conditional statements using multiple arguments.","&（クエリの論理積結合）
アンパサンド（&）は、クエリや条件文で論理積（AND）結合として使用されます。
例：
	if ($HasStock == true & $Price > 20) {$Badge=""ok"";} 
第1引数と第2引数の両方が真（true）の場合にのみ、そのノートの$Badgeが設定されます。
論理和（OR）結合や、複数の引数を使用した条件文も参照してください。"
&= (i.e. logical AND assignment),Operator,Item,Assignment,assignment,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"&= (i.e. logical AND assignment)
To make it easier to write rules succinctly, you can use the assignment:
	$TheAttribute &= the_expression; 
…which sets $TheAttribute to the value of the_expression only if it is currently evaluated as true AND the_expression is also evaluates as true. Thus, if $TheAttribute is false, the expression is still evaluated. An attribute that has no value set (or inherited) is evaluated as false.
For most attributes, especially new user attributes, the default value will evaluate as false. But, $TheAttribute's data type does not have to be Boolean.
For new String-type attributes (and string-based Action/Color/File/Font/Interval/List/Set/URL types) the default is an empty string """". For Number-type, is it 0 (zero). For Date-type, it is the string ""never"". For Boolean-type, is it 'false' (with no quotes, and shown as un-ticked if displayed via a tick-box). The """", 0 and ""never"" values—for the appropriate data types—evaluate as false. But, be aware that not all system attributes follow this assumption. For instance, the $Color default is preset to use a named Tinderbox colour, so its default value (even if inherited) would evaluate as true .
Prototypes have no direct effect as the outcome, as it initially depends on the evaluation of the left-side attribute value regardless of whether document default, prototype inherited or locally set.
For example, for the Boolean-type attribute $Urgent:
	$Urgent &= any(children,$Urgent); 
Thus a project is considered urgent if it has been declared to be urgent itself and if any child is urgent.
See also the logical OR assignment.
Errors to the function logic were corrected.","&= (論理AND代入)
ルールを簡潔に記述しやすくするために、以下の代入式を使用できます：
	$TheAttribute &= the_expression; 
これは、$TheAttribute が現在「真 (true)」と評価されており、かつ the_expression も「真」と評価される場合にのみ、$TheAttribute に the_expression の値を設定します。したがって、$TheAttribute が「偽 (false)」である場合でも、式は評価されます。値が設定（または継承）されていない属性は、「偽」として評価されます。
ほとんどの属性、特に新しいユーザー属性では、デフォルト値は「偽」と評価されます。ただし、$TheAttribute のデータ型は必ずしもブール型である必要はありません。
新しい文字列型属性（および Action, Color, File, Font, Interval, List, Set, URL などの文字列ベースの型）のデフォルトは、空文字列 """" です。数値型の場合は 0 (ゼロ) です。日付型の場合は ""never"" という文字列です。ブール型の場合は 'false' です（引用符なし。チェックボックスで表示される場合は未チェック状態）。これらの """"、0、""never"" という値は、それぞれのデータ型において「偽」と評価されます。ただし、すべてのシステム属性がこの前提に従うわけではないことに注意してください。例えば、$Color のデフォルトは特定の Tinderbox カラー名に設定されているため、そのデフォルト値は（継承されたものであっても）「真」と評価されます。
プロトタイプが結果に直接影響を与えることはありません。結果は、ドキュメントのデフォルト、プロトタイプからの継承、またはローカルでの設定に関係なく、まず左辺の属性値の評価に依存するためです。
例えば、ブール型属性 $Urgent の場合：
	$Urgent &= any(children,$Urgent); 
これにより、プロジェクト自体が緊急（urgent）と宣言されており、かつ、いずれかの子要素も緊急である場合にのみ、そのプロジェクトは緊急であると見なされます。
「論理OR代入」も参照してください。
関数のロジックに関するエラーが修正されました。"
%matches (query back-references),Property,Query,Data manipulation,List,false,9.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"%matches
The expression %matches represents a list that contains all available back-references to regular expression matches. This is equivalent to the list of back reference values [$0;$1;$2….$N], where N is the count of available regular expression matches.
If $MyString is ""I do not like green eggs and ham."", then for this code:
	if($MyString.contains(""like (((green) (eggs)) and ham)"")){
		$MyList = %matches;
	};
$MyList now holds 5 back-references:
* $0: like green eggs and ham
* $1 green eggs and ham
* $2 green eggs
* $3 green
* $4 eggs
Query back-references are discussed in fuller detail here.","%matches
式 %matches は、利用可能なすべての正規表現マッチの後方参照を含むリストを表します。これは、後方参照の値のリスト [$0;$1;$2….$N]（N は利用可能な正規表現マッチの数）と同等です。
もし $MyString が ""I do not like green eggs and ham."" である場合、以下のコードにおいて：
	if($MyString.contains(""like (((green) (eggs)) and ham)"")){
		$MyList = %matches;
	};
$MyList は 5 つの後方参照を保持することになります：
* $0: like green eggs and ham
* $1 green eggs and ham
* $2 green eggs
* $3 green
* $4 eggs
クエリの後方参照については、こちらで詳しく説明されています。"
+ (i.e. addition),Operator,Item,Mathematical,Number,false,1.0.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"+ (i.e. addition)
The addition operator, + (plus sign character), returns the sum of the arguments before and after it.
	$MyNumber = 3+4; 
The + sign is also used for string concatenation. Depending on context, Tinderbox will decide which operation is intended by the + sign. This is a very good reason to always enclose literal text strings in quotes.","+ (加算)
加算演算子 + (プラス記号) は、その前後の引数の合計を返します。
	$MyNumber = 3+4; 
+ 記号は文字列の結合にも使用されます。コンテキストに応じて、Tinderbox は + 記号によってどちらの操作が意図されているかを判断します。これは、リテラル文字列を常に引用符で囲むべき非常に良い理由です。"
+ (i.e. string concatenation),Operator,Item,Mathematical,Number,false,1.0.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"+ (i.e. string concatenation)
The concatenation operator, + (plus sign character), joins the strings/references/expressions before and after it. Thus, the expression
	$FullName = $FirstName+"" ""+$LastName; 
evaluates a first name ""Jane"" and last name ""Doe"" to give a string value ""Jane Doe"" for the FullName attribute. If the right-side code is more complex, consider adding parentheses to help signal user intent to Tinderbox.
Mixing data types
If the right side inputs mix text and numbers—they need treating as numbers (even if stored in strings)—see more on concatenation versus addition.
The + (plus sign) character is also used for numerical addition. Depending on context, Tinderbox will decided which operation is intended by the + sign. This is a very good reason to always enclose literal text strings in quotes.
Concatenating Lists (List & Set type data)
Note that here both List-type and Set-type attributes can be considered the same as data sources, i.e. right-side inputs. 
To concatenate lists, it might appear logical to do this:
	$MyList = $SomeList+$SomeSet; WRONG!
The result is no value is passed to $MyList. When adding lists to lists there are a variety of approaches. Note that depending on the nature of the task, and the method below that is used, it may first be necessary to reset the receiving list to the default (empty) value.
Use the '+=' increment operator:
	$MyList += $SomeList+$SomeSet;
Add to the existing list (older older style—use the above method):
	$MyList = $MyList + $SomeList+$SomeSet;
Or, if if intentionally replacing current $MyList values with new ones, this may be used:
	$MyList = ($SomeList+$SomeSet);
The additional parentheses help Tinderbox to understand all the right-side lists need to be made into one list before being passed to the left-side.","+（すなわち文字列結合）
結合演算子である +（プラス記号）は、その前後の文字列、参照、式を結合します。したがって、次の式
	$FullName = $FirstName+"" ""+$LastName; 
は、名（FirstName）の ""Jane"" と姓（LastName）の ""Doe"" を評価し、FullName 属性に文字列値 ""Jane Doe"" を与えます。右辺のコードがより複雑な場合は、ユーザーの意図を Tinderbox に伝えるために括弧を追加することを検討してください。

データ型の混在
右辺の入力にテキストと数値が混在しており、それらを（たとえ文字列として保存されていても）数値として扱う必要がある場合は、「結合（concatenation）対 加算（addition）」の詳細を参照してください。
+（プラス記号）文字は、数値の加算にも使用されます。文脈に応じて、Tinderbox は + 記号によってどちらの操作が意図されているかを判断します。これは、リテラルなテキスト文字列を常に引用符で囲むべき非常に大きな理由となります。

リストの結合（List 型および Set 型データ）
ここでは、List 型と Set 型の両方の属性をデータソース、つまり右辺の入力として同じように扱える点に注意してください。
リストを結合する場合、次のようにするのが論理的に思えるかもしれません：
	$MyList = $SomeList+$SomeSet; 違い！
その結果、$MyList には値が渡されません。リストにリストを追加する場合は、さまざまなアプローチがあります。タスクの性質や、以下で使用する方法によっては、あらかじめ受け取り側のリストをデフォルト（空）の値にリセットする必要がある場合があることに注意してください。

'+=' 増分演算子を使用する：
	$MyList += $SomeList+$SomeSet;

既存のリストに追加する（古いスタイル。上記の方法を使用してください）：
	$MyList = $MyList + $SomeList+$SomeSet;

あるいは、現在の $MyList の値を意図的に新しい値に置き換える場合は、次のように記述します：
	$MyList = ($SomeList+$SomeSet);
追加の括弧は、Tinderbox が右辺のすべてのリストを左辺に渡す前に、それらを 1 つのリストにまとめる必要があることを理解するのに役立ちます。"
+= (i.e. increment),Operator,Item,Mathematical,Number,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"+= (i.e. increment)
This assignment operator is a convenient shorthand for incrementing an attribute. For example, the two following statements are equivalent:
$MyNumber += 3; 
$MyNumber = $MyNumber + 3; 
This operator may also be used with Lists and Sets, and += may be used to append strings:
$MyString += ""!""","+= （インクリメント）
この代入演算子は、属性の値を増加させるための便利な短縮表記です。例えば、以下の2つの文は同等です：
$MyNumber += 3;
$MyNumber = $MyNumber + 3;
この演算子はリスト（List）やセット（Set）にも使用でき、+= を使って文字列を結合することもできます：
$MyString += ""!"""
< (i.e. less than),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"$MyNumber  is true 
	$MyNumber  is false 
Further explored in Basic Comparison Codes.","$MyNumber  は true です 
	$MyNumber  は false です 
詳細は Basic Comparison Codes で詳しく説明されています。"
<= (i.e. less than or equal to),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"$MyNumber  is true 
	$MyNumber  is true 
	$MyNumber  is false 
Further explored in Basic Comparison Codes; in some date comparison cases, a two term query may be needed instead.","$MyNumber は true です
$MyNumber は true です
$MyNumber は false です
詳細は「Basic Comparison Codes」で解説されています。一部の日付比較のケースでは、代わりに2項クエリが必要になる場合があります。"
= (i.e. value assignment),Operator,Item,Assignment,assignment,false,1.0.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"= (i.e. value assignment)
A single = symbol is used only as a method of assignment. In contrast, for tests of equivalence use a double equals sign e.g. == ):
	$AttributeA = $AttributeB; (attribute value
	$AttributeA = data; (literal data)
	$AttributeA = 4 * ($Price / 2); (expression)
The assignment is always from right to left; the left-side attribute takes the value of the right side attribute/expression. It is more usual for the right side to be evaluated (an expression) than the left, though the latter can occur.
Thus assignment sets the value of the specified left-side attribute the given right-side evaluated result; most often this is simply an attribute value. Where the right-side value is an attribute name, the $-prefix must be used. Take a note that has a $Color value of ""red"" and the $Rule:
	$MyUserColor = ""Color""; 
The result is not the text value red but rather it is a text value ""Color"". Most likely there is no defined named colour named ""Color"" so some other colour value, not the intended one, stored in $MyUserColor. If you want the value of an attribute, i.e. the $Color value of 'red' in this example, then your $Rule should be:
	$MyUserColor = $Color; 
You must use the $-prefix: see further detail below.
Actions and rules are allowed to specify a different referenced note, just as they can with a source attribute reference: 
	$AttribName(parent)=""theValue""; 
	$AttribName(/path/to/note)=""theValue"";
	$AttribName(/path/to/note)=$MyValue(parent); 
	$AttribName($AnotherAttribute)=""theValue""; 
In the last case the secondary attribute will hold a note name or path. Complex use of left-side expressions is allowed.
Do not mix $Attribute and Attribute(regex) syntax in a single call, i.e. $Attribute(regex), as this will cause expected results. Use one syntax or the other. This possible conflict should only ever occur in the context of queries or operations that allow query-style code.
If a value only needs to be assigned once, consider using a logical OR join.
Using Paths (offset addressing)
	$AttributeA = $AttributeB( note/item/path )
This sets the value of the $AttributeA to that of the $AttributeB of the same note (i.e. this or current), if no argument is specified, or of a note specified through name, item or path. (See more on paths). From v4.6, paths may also be used on the left side of the overall expression:
	$AttributeA( note/item/path ) = $AttributeB
	$AttributeA( note/item/path ) = $AttributeB( note/item/path )
Using query back-references
NOTE: the following syntax can only be used in the context of a query. In a query (an agent's query or an if() condition in an action) it is possible to combine a regex query with an action that uses the value of the found regex:
	query: $Text.contains(""email: "")
	action: $TheAddress=$1;
…will set TheAddress attribute value to the regex found in text. It is assumed that back-references $1-$9 may be used, assuming the regex generates more than one such references.","=（値の代入）
単一の = 記号は、代入のメソッドとしてのみ使用されます。対照的に、同等性のテストには二重等号（例： == ）を使用します。
	$AttributeA = $AttributeB; （属性値）
	$AttributeA = data; （リテラルデータ）
	$AttributeA = 4 * ($Price / 2); （式）
代入は常に右から左へ行われます。左側の属性が、右側の属性または式の値を取ります。通常、左側よりも右側が評価（式）されることが多いですが、左側が評価されることもあります。
したがって、代入は指定された左側の属性に、与えられた右側の評価結果を設定します。ほとんどの場合、これは単なる属性値です。右側の値が属性名である場合は、$ プレフィックスを使用する必要があります。$Color の値が ""red"" であるノートと、以下の $Rule を例に取ります。
	$MyUserColor = ""Color""; 
この結果はテキスト値の red ではなく、テキスト値の ""Color"" になります。おそらく ""Color"" という名前の定義済みカラーは存在しないため、$MyUserColor には意図したものではない別のカラー値が格納されます。属性の値、つまりこの例で言えば 'red' という $Color の値が欲しい場合は、$Rule は以下のようになります。
	$MyUserColor = $Color; 
必ず $ プレフィックスを使用してください。詳細は後述します。
アクションやルールでは、ソース属性の参照と同様に、別の参照ノートを指定することができます。
	$AttribName(parent)=""theValue""; 
	$AttribName(/path/to/note)=""theValue"";
	$AttribName(/path/to/note)=$MyValue(parent); 
	$AttribName($AnotherAttribute)=""theValue""; 
最後のケースでは、二次属性がノート名またはパスを保持します。左側での複雑な式の使用も許可されています。
単一の呼び出し内で $Attribute と Attribute(regex) 構文を混在させないでください（例：$Attribute(regex)）。これは予期しない結果を引き起こします。どちらか一方の構文を使用してください。この競合の可能性は、クエリスタイルのコードを許可するクエリまたは操作のコンテキストでのみ発生します。
値を一度だけ代入する必要がある場合は、論理和（OR）結合の使用を検討してください。
パスの使用（オフセットアドレッシング）
	$AttributeA = $AttributeB( note/item/path )
これは、$AttributeA の値を、引数が指定されていない場合は同じノート（つまり this または current）、指定されている場合は名前、項目、またはパスを通じて指定されたノートの $AttributeB の値に設定します（パスの詳細を参照）。v4.6 からは、式全体の左側でもパスを使用できるようになりました。
	$AttributeA( note/item/path ) = $AttributeB
	$AttributeA( note/item/path ) = $AttributeB( note/item/path )
クエリの後方参照の使用
注意：以下の構文はクエリのコンテキスト内でのみ使用できます。クエリ（エージェントのクエリまたはアクション内の if() 条件）において、正規表現クエリと、見つかった正規表現の値を使用するアクションを組み合わせることが可能です。
	query: $Text.contains(""email: (.*)"")
	action: $TheAddress=$1;
…これにより、TheAddress 属性の値がテキスト内で見つかった正規表現に設定されます。正規表現が複数の参照を生成する場合、後方参照 $1-$9 が使用できることが想定されています。"
== (i.e. value equality),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"== (i.e. value equality)
The operator to test equality (i.e. 'is the same as') is '==', two equals signs. Note that this replaces older syntax where a single equals sign was used contextually for both assignment and equality tests.
This operator is used either in agent queries or in the conditional part of an if(condition){action} code. It is the functional opposite of the '!=' inequality test.
This test cannot be meaningfully applied to Set or List type attribute data, as the entire attribute value is matched, rather than individual values as might otherwise be assumed. For these data types use the .contains() or .icontains() operators instead, noting the scope for ambiguous matching due to stemming of words (""car"" will match ""car"", ""cars"" and ""carrot"").
Because equality comparisons of Date-type data match at day scope, rather than full date/time values (for legacy reasons), use interval() to compare Date-type equality.
Equality testing can be negated, i.e. tested for a non-match, or combined with greater/less than for a range of tests as further explored in Basic Comparison Codes.
For a case-insensitive lexical equality test, use a lowercase on-the-fly transform:
	""Absquatulate"".lowercase == ""absquatulate"" 
If we set $MyString to ""Absquatulate"", then:
	$MyString.lowercase == ""absquatulate"" 
If $MyOtherString(Some note) has the value ""absquatulate"", then:
	$MyString.lowercase == $MyOtherString(Some note) 
Note the stored left-side value is not altered, but its transformed version is used in the test giving a case-insensitive comparison. This method only works for upper/lower case comparisons; accented characters are lexically different characters regardless of case.
Equality and List or Sets
Using == (and !=) with Lists & Sets means you are checking the entire literal contents, i.e. string like ""ant;bee;cow"" rather than by individual sub-value: ""ant"" and ""bee"" and ""cow"". Thus the equality test cannot be used to check if the attribute contains a discrete value, use .contains() instead (or .icontains() for case-insensitive matches). Importantly, when testing a string (or expression resolving to a string) equivalence against a list, it is the list that must be tested using .contains(). This is best shown using string literals representing a String type and a List type:
	""cow"".contains(""ant;bee;cow"") (does not work as expected)
	""ant;bee;cow"".contains(""cow"") 
	""ant;bee;Cow"".contains(""cow"") 
The first, testing the string, resolves to false but the second, testing the list, gives true. The third is false but would be true if using an .icontains() test. Thus when equivalence testing a string against a list, always run the .contains() on the list and not the string.
To test two lists hold the same values (and only those values), in the same case, in the same order, the == equivalence operator can be used as this tests the stored concatenated value lists in each case. To check common items shared by two lists use list.intersect().
Testing a List vs. a Set, it would be sensible to apply a .sort() or .isort() to each, reflecting that the sort state of a list is unknown and a == test compares the stored concatenated value string: the test would fail if the lists held the same values but stored in different orders. This shows up a difference between lists and sets. Although the literal value of a set may hold values in any order, when tested in code, they are being tested after sorting into (some**) order. Incidentally, this is why you cannot set a sort order as you can with a list as internally your given sort order is ignored. Consider $MySetA and $MyListA both with the values [ant;bee;cow]. $MySetB and $MyListB both have the value [bee;ant]. So:
	$MySetA == $MySetB gives false 
	$MyListA == $MyListB gives false 
both are expected. Now, make both the B attributes value ""bee;ant;cow""
	$MySetA == $MySetB gives true 
	$MyListA == $MyListB gives false 
This is because the Set compares the literal result of sorted values, whereas the List
 does not. But:
	$MyListA == $MyListB.sort gives true 
This is in effect what's happening with the sets, as in:
	$MyListA.sort == $MyListB.sort 
whereas in our last example above, $MyListA was already in default sort order so no applied sort was required. From experiment, this seems to be a (case-sensitive) computer lexical sort, i.e. [Bee;ant;bee] with capitals preceding lowercase letters in the sort.","==（すなわち値の等価性）
等価性（すなわち「〜と同じである」こと）をテストするための演算子は、2つの等号「==」です。これは、代入と等価テストの両方に文脈的に1つの等号が使用されていた古い構文に代わるものであることに注意してください。

この演算子は、エージェントクエリ、または if(condition){action} コードの条件部分で使用されます。これは、不等価テスト「!=」の機能的な反対語です。

このテストは、Set型またはList型の属性データに適用しても意味がありません。なぜなら、想定されるような個別の値ではなく、属性値全体が照合されるからです。これらのデータ型には、代わりに .contains() または .icontains() 演算子を使用してください。その際、語幹抽出（stemming）による曖昧なマッチングの範囲に注意してください（「car」は「car」、「cars」、「carrot」にマッチします）。

Date型の等価比較は、（歴史的な理由により）完全な日時値ではなく日付の範囲で一致するため、Date型の等価性を比較するには interval() を使用してください。

等価テストは、否定（すなわち不一致のテスト）することも、あるいは「Basic Comparison Codes（基本的な比較コード）」で詳述されているように、より大きい/より小さいと組み合わせて範囲テストを行うこともできます。

大文字小文字を区別しない語彙的な等価テストを行うには、実行時の小文字変換を使用します。
	""Absquatulate"".lowercase == ""absquatulate"" 
$MyString を ""Absquatulate"" に設定した場合：
	$MyString.lowercase == ""absquatulate"" 
$MyOtherString(Some note) の値が ""absquatulate"" の場合：
	$MyString.lowercase == $MyOtherString(Some note) 
左側に格納されている元の値は変更されず、変換されたバージョンがテストに使用されることで、大文字小文字を区別しない比較が行われることに注意してください。この方法は大文字と小文字の比較にのみ有効です。アクセント付き文字は、大文字小文字に関わらず語彙的に異なる文字として扱われます。

等価性と List または Set
List および Set で ==（および !=）を使用すると、個別のサブ値（「ant」、「bee」、「cow」など）ではなく、リテラル内容全体（「ant;bee;cow」のような文字列）をチェックすることになります。したがって、等価テストを使用して属性に特定の個別値が含まれているかどうかを確認することはできません。代わりに .contains()（大文字小文字を区別しない場合は .icontains()）を使用してください。重要な点として、文字列（または文字列に解決される式）のリストに対する同等性をテストする場合、.contains() を実行する必要があるのはリスト側です。これは、String型とList型を表す文字列リテラルを使用した以下の例でよくわかります。
	""cow"".contains(""ant;bee;cow"") （期待通りに動作しません）
	""ant;bee;cow"".contains(""cow"") 
	""ant;bee;Cow"".contains(""cow"") 
最初の例（文字列をテスト）は false になりますが、2番目（リストをテスト）は true になります。3番目は false ですが、.icontains() テストを使用すれば true になります。したがって、文字列とリストの同等性をテストするときは、常に文字列ではなくリストに対して .contains() を実行してください。

2つのリストが同じ値を（その値のみを）、同じ大文字小文字で、同じ順序で保持しているかテストするには、== 等価演算子を使用できます。これは、各ケースで格納されている連結された値リストをテストするためです。2つのリスト間で共有されている共通の項目をチェックするには、list.intersect() を使用してください。

List と Set をテストする場合、各々に .sort() または .isort() を適用するのが賢明です。これは、リストのソート状態が不明であり、== テストが連結された値文字列を比較するため、リストが同じ値を保持していても格納順序が異なればテストが失敗することを反映しています。これは List と Set の違いを示しています。Set のリテラル値は任意の順序で値を保持できますが、コードでテストされる際は（何らかの**）順序でソートされた後にテストされます。ちなみに、これが List のようにソート順を設定できない理由です。内部的に指定したソート順は無視されるためです。

値 [ant;bee;cow] を持つ $MySetA と $MyListA、および値 [bee;ant] を持つ $MySetB と $MyListB を考えてみましょう。
	$MySetA == $MySetB は false を返す
	$MyListA == $MyListB は false を返す
これらは両方とも予想通りです。次に、両方の B 属性の値を ""bee;ant;cow"" にします。
	$MySetA == $MySetB は true を返す
	$MyListA == $MyListB は false を返す
これは、Set がソートされた値のリテラル結果を比較するのに対し、List はそうしないためです。しかし、次のようにすると：
	$MyListA == $MyListB.sort は true を返す
これは実質的に Set で起こっていることであり、以下のようになります。
	$MyListA.sort == $MyListB.sort 
直前の例では、$MyListA はすでにデフォルトのソート順であったため、明示的なソートの適用は必要ありませんでした。実験によると、これは（大文字小文字を区別する）コンピュータの語彙ソートのようです。つまり、ソート順では [Bee;ant;bee] のように大文字が小文字より先に来ます。"
> (i.e. greater than),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"> (i.e. greater than)
The operator used to test if the left side of an expression is greater than the right side. This operator is used either in agent queries or in the conditional part of an if(condition){action} code. If $MyNumber is 3:
	$MyNumber > 2 is true 
	$MyNumber > 4 is false 
Further explored in Basic Comparison Codes.",">（～より大きい）
式の左辺が右辺より大きいかどうかを判定するために使用される演算子。この演算子は、エージェントのクエリ、または if(condition){action} コードの条件部分で使用されます。$MyNumber が 3 の場合：
	$MyNumber > 2 は true（真）
	$MyNumber > 4 は false（偽）
詳細は「Basic Comparison Codes（基本的な比較コード）」でさらに詳しく説明されています。"
>= (i.e. greater than or equal to),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,">= (i.e. greater than or equal to)
The operator used to test if the left side of an expression is greater than or equal to the right side. This operator is used either in agent queries or in the conditional part of an if(condition){action} code. If $MyNumber is 3:
	$MyNumber >= 2 is true 
	$MyNumber >= 3 is true 
	$MyNumber >= 4 is false 
Further explored in Basic Comparison Codes; in some date comparison cases, a two term query may be needed instead.",">= （〜以上）
式の左辺が右辺以上であるかどうかを判定するために使用される演算子です。この演算子は、エージェントクエリ、または if(condition){action} コードの条件節で使用されます。$MyNumber が 3 の場合：
	$MyNumber >= 2 は true 
	$MyNumber >= 3 は true 
	$MyNumber >= 4 は false 
詳細は「Basic Comparison Codes」を参照してください。一部の日付比較では、代わりに2項クエリが必要になる場合があります。"
| (i.e. query logical OR join),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"| (i.e. query logical OR join)
The pipe, |, is used in queries and conditional statements as a logical OR join. Thus:
	if ($HasStock == true | $Price > 20) {$Badge=""ok"";} 
The note's $Badge is only set if either the first or the second argument are true.
See also the AND join and conditional statements using multiple arguments.","| (例: クエリの論理和結合)
パイプ (|) は、クエリや条件文において論理和 (OR) 結合として使用されます。したがって：
	if ($HasStock == true | $Price > 20) {$Badge=""ok"";} 
ノートの $Badge は、第1引数または第2引数のいずれかが真である場合にのみ設定されます。
論理積 (AND) 結合、および複数の引数を使用した条件文も参照してください。"
|= (i.e. logical OR assignment),Operator,Item,Assignment,assignment,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"|= (i.e. logical OR assignment)
To make it easier to write rules succinctly, you may use the assignment:
	$TheAttribute |= the_expression; 
…which sets $TheAttribute to the value of the_expression if it is already true OR if the_expression is true. An attribute that has no locally set (or inherited) value is evaluated as false. Thus there are two possible outcomes:
* if $TheAttribute is set to a value that evaluates (the left side of the code) as true. Therefore, regardless of the state of the_expression, the_expression (the right side of the code) is not evaluated and $TheAttribute retains its current value.
* if $TheAttribute is set to a value evaluates (the left side of the code) as false. Therefore the_expression (the right side of the code) is evaluated. If the_expression evaluates as true $TheAttribute takes the value of the_expression. On subsequent iteration of the code $TheAttribute thus evaluates as true. But, if the_expression evaluated to false, both it and the overall action evaluate as false, i.e. $TheAttribute's value remains unchanged.
A more verbose (and less efficient at scale) way to write the same test without the |= operator is
	if((!$TheAttribute)){ ..o the_expression;} 
where '(!$TheAttribute)' is a short-form test meaning if the value of attribute named TheAttribute tests as false. A false value arises differently for for different attribute data types, but for for a string, the above can be further unpacked as:
	if($TheAttribute!=""""){ ..o the_expression;} 
In practical terms this means the left side, usually an attribute, is set to the right side value only if it is not already set locally at note level. This is because for most attributes, especially new user attributes, the default value will evaluate as false. But, $TheAttribute's data type does not have to be Boolean.
For new String-type attributes (and string-based Action/Color/File/Font/Interval/List/Set/URL types) the default is an empty string """". For Number-type, is it 0 (zero). For Date-type, it is the string ""never"". For Boolean-type, is it ' false' (with no enclosing quotes, and shown as un-ticked if displayed via a tick-box). The """", 0 and ""never"" values—for the appropriate data types—evaluate as false. But, be aware that not all system attributes follow this assumption. For instance, the $Color default is preset to use a named Tinderbox colour, so its default value (even if inherited) would evaluate as true .
Prototypes have no direct effect as the outcome, as it initially depends on the evaluation of the left-side attribute value regardless of whether document default, prototype inherited or locally set.
This operator's behaviour makes the |= usage very useful for doing tasks like making code run only once; on the second pass the left side already has a value so no change occurs. This avoids scenarios like successive applications of a rule causing multiple concatenation of strings (one extra each iteration).
For example, for the Boolean-type attribute $Urgent:
	$Urgent |= any(children,$Urgent); 
A project is urgent if it has been declared to be urgent itself, or if any child is urgent.
If using |= assignments, it can be useful to have a means to reset an attribute to default to re-enable |= value assignment.
See also the logical AND assignment (which is likely used less often).","|=（論理和代入）
より簡潔にルールを記述するために、以下の代入式を使用できます。
	$TheAttribute |= the_expression;
これは、$TheAttributeがすでに真であるか、あるいはthe_expressionが真である場合に、$TheAttributeにthe_expressionの値を設定します。ローカルに設定された値（または継承された値）を持たない属性は、偽として評価されます。したがって、起こりうる結果は次の2つです。
* $TheAttributeに（コードの左辺として）真と評価される値が設定されている場合。この場合、the_expression（コードの右辺）の状態にかかわらず、the_expressionは評価されず、$TheAttributeは現在の値を保持します。
* $TheAttributeに（コードの左辺として）偽と評価される値が設定されている場合。この場合、the_expression（コードの右辺）が評価されます。もしthe_expressionが真と評価されれば、$TheAttributeはthe_expressionの値を取ります。それ以降のコード実行では、$TheAttributeは真として評価されます。しかし、the_expressionが偽と評価された場合は、それ自体もアクション全体も偽と評価され、$TheAttributeの値は変更されないままとなります。
|= 演算子を使わずに、同じテストをより冗長に（そして大規模な場合はより非効率に）記述すると、以下のようになります。
	if((!$TheAttribute)){ ..o the_expression;}
ここで「(!$TheAttribute)」は、TheAttributeという名前の属性の値が偽としてテストされる場合を意味する短縮形式のテストです。偽の値の現れ方は属性のデータ型によって異なりますが、String（文字列型）の場合、上記はさらに次のように展開できます。
	if($TheAttribute!=""""){ ..o the_expression;}
実用的な観点では、これは「左辺（通常は属性）は、ノートレベルでまだローカルに設定されていない場合にのみ、右辺の値に設定される」ということを意味します。これは、ほとんどの属性（特に新しいユーザー属性）において、デフォルト値が偽として評価されるためです。ただし、$TheAttributeのデータ型はBooleanである必要はありません。
新しいString型の属性（および文字列ベースのAction/Color/File/Font/Interval/List/Set/URL型）の場合、デフォルトは空の文字列 """" です。Number型の場合は 0 です。Date型の場合は ""never"" という文字列です。Boolean型の場合は 'false' です（囲み引用符はなく、チェックボックスで表示される場合はチェックが外れた状態）。データ型に応じたこれらの """"、0、""never"" という値は、偽として評価されます。ただし、すべてのシステム属性がこの前提に従っているわけではないことに注意してください。例えば、$Colorのデフォルトは特定の名前付きTinderboxカラーを使用するようにプリセットされているため、そのデフォルト値は（たとえ継承されたものであっても）真として評価されます。
プロトタイプは結果に直接影響を与えません。なぜなら、結果はまず、ドキュメントのデフォルトであるか、プロトタイプから継承されたものであるか、あるいはローカルに設定されたものであるかに関わらず、左辺の属性値の評価に依存するからです。
この演算子の挙動により、|= は「コードを一度だけ実行する」といったタスクに非常に便利です。2回目のパスでは左辺にすでに値があるため、変更は発生しません。これにより、ルールの連続実行によって文字列が何度も連結される（実行のたびに1つずつ増える）といったシナリオを避けることができます。
例えば、Boolean型の属性 $Urgent の場合：
	$Urgent |= any(children,$Urgent);
あるプロジェクトが緊急（urgent）であるとは、そのプロジェクト自体が緊急であると宣言されているか、あるいはその子のいずれかが緊急である場合を指します。
|= 代入を使用する場合、属性をデフォルト値にリセットする手段を用意しておくと、|= による値の代入を再度有効にするのに役立つことがあります。
「論理積代入（logical AND assignment）」も参照してください（こちらの使用頻度は低いと考えられます）。"
$AttributeName (i.e. a short form test for value),Operator,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"$AttributeName
In queries and conditional action code expressions, using just an attribute name preceded by a $ character functions as a shortened form of the Boolean test for a true value. Thus the following are functional equivalents:
	$MyBoolean==true 
	$MyBoolean 
In both cases the result is true if the value of $MyBoolean is true.
In all other contexts, the $AttributeName syntax implies a reference to that attribute.
Usefully Tinderbox also useful supports such short-form $AttributeName tests for all the other attribute data types, returning true if the attribute has a non-default value. Per data type, this equates to long form tests like:
	$MyAction!="""" 
	$MyColor!="""" 
	$MyDate!=never 
	$MyFile!="""" 
	$MyInterval!=""00:00"" 
	$MyList!=[] or $MyList!="""" 
	$MyNumber!=0 
	$MySet!=[] or $MySet!="""" 
	$MyString!="""" 
	$MyURL!="""" 
In all these cases a short-form test returns true if the attribute value is not the default for that data type.
A reverse short form test is also offered by (!$AttributeName), i.e. the same syntax with a preceding exclamation mark and enclosing parentheses. In theory, the latter parentheses are not necessary, but in practice it helps Tinderbox when parsing a query.","$AttributeName
クエリや条件付きアクションコードの条件式において、属性名の前に $ 記号を付けただけの記述は、値が真（true）であるかを判定するブール値テストの短縮形として機能します。そのため、以下の2つは機能的に同等です。
	$MyBoolean==true
	$MyBoolean
どちらの場合も、$MyBoolean の値が true であれば結果は真（true）となります。
それ以外のすべてのコンテキストにおいて、$AttributeName という構文はその属性への参照を意味します。
便利なことに、Tinderbox は他のすべての属性データ型についても、このような $AttributeName 短縮形テストをサポートしており、属性がデフォルト値以外である場合に true を返します。データ型ごとに、これは以下のようなロング形式のテストに相当します。
	$MyAction!=""""
	$MyColor!=""""
	$MyDate!=never
	$MyFile!=""""
	$MyInterval!=""00:00""
	$MyList!=[] または $MyList!=""""
	$MyNumber!=0
	$MySet!=[] または $MySet!=""""
	$MyString!=""""
	$MyURL!=""""
これらのケースすべてにおいて、短縮形テストは属性値がそのデータ型のデフォルト値でない場合に true を返します。
また、(!$AttributeName) による逆の短縮形テストも用意されています。これは、同じ構文の前に感嘆符（!）を付け、全体を括弧で囲んだものです。理論的には括弧は必須ではありませんが、実務上は Tinderbox がクエリを解析（パース）する際の助けになります。"
$AttributeName[(scope)],Property,Item,Assignment,source context dependent,false,4.6.0,Baseline,,,,1,true,false,false,false,false,true,false,false,false,,false,"$AttributeName
In action code contexts, an attribute's name prefixed with a $-character implies a reference to that attribute, thus a placeholder for that attribute's value. In a coding context is acts as a variable name where the variable name must be that of an existing attribute and the variable's value is got from or set to that attribute.
A reference on the right side of an expression fetches the attribute's value. A reference on the left side of an expression has its value set to the result of the right side. The following example combines these uses whereby in the current object (a note, agent, adornment, etc.), the user attribute $MyNumber is being set to the value of system attribute $ChildCount:
	$MyNumber = $ChildCount; 
In queries and conditional expressions, and attribute reference implies a shortened Boolean test.
The test can be turned in a negative (i.e. that no value is set) by using a '!' prefix: see !$AttributeName, occasionally if the !-prefix does not work, try enclosing the expression in parentheses (!$AttributeName) to help signal intent to Tinderbox's action code parser.
$AttributeName(scope)
Besides the basic form above, which is essentially $AttributeName(this), an offset address can also be made to the value of an attribute in another object— i.e. other than the one in current focus, by using an extended syntax where the scope argument (defining scope) to refer to one or more note(s).
Importantly, here the scope argument is not evaluated for expressions unlike in some action code operators. This means that here, scope cannot be a complex code expression. However, where that need arises eval() may offer a workaround or consider using a user attribute to hold the output of the expression and then use that attribute's value (i.e. in the manner of bullet #4 above).
The extended syntax form may be used on the left or right side of an action code expression. In other words, you can use this syntax to fetch (right side) or set (left side) an attribute value from some other object. Generally, offset addresses are used on the right side to fetch data from another object.
Examples, right side:
	$MyString = $MyString(""Some other note""); 
	$MyNumber = $MyNumber(""A root container/Some Container/Some other note""); 
	$MyString = $MyString(agent); (this designator only works in agents)
	$MyString = $MyString(adornment); (this designator only works in adornments)
	$MyList = $MyString(""Some other note;Another note;Different note""); 
Examples, left-side:
	$MyString(""Another note"") = $MyString(""A note""); 
	$MyDate(parent) = $MyDate; 
In fact, an offset can even be used on both sides of the expression. For instance, the rule in a note ""Some note"" might use the following code to refer to attributes in two other notes:
	$MyColor(""A note"") = $MyColor(""Another note"");","$AttributeName
アクションコードの文脈において、属性名に $ 記号を冠したものはその属性への参照を意味し、その属性の値のプレースホルダーとして機能します。コーディングにおいては変数名のように振る舞いますが、その変数名は既存の属性名である必要があり、変数の値はその属性から取得されるか、あるいはその属性に設定されます。

式の右辺にある参照は属性の値を取得（フェッチ）します。式の左辺にある参照は、右辺の結果をその値として設定されます。以下の例はこれらを組み合わせたもので、現在のオブジェクト（ノート、エージェント、アドーンメント等）において、ユーザー属性 $MyNumber にシステム属性 $ChildCount の値を設定しています。
	$MyNumber = $ChildCount; 

クエリや条件式において、属性の参照は簡略化されたブール値テストを意味します。
「!」プレフィックスを付けることで、テストを否定（例：値が設定されていないこと）に転じることができます。「!$AttributeName」を参照してください。稀に「!」プレフィックスがうまく機能しない場合は、意図を Tinderbox のアクションコード・パーサーに明確に伝えるために、式を括弧で囲んで「(!$AttributeName)」と試してみてください。

$AttributeName(scope)
前述の基本形式（本質的には $AttributeName(this) と同等）の他に、拡張構文を用いて、現在フォーカスされているもの以外のオブジェクト（他のノート等）の属性値を指定する「オフセット・アドレス」を利用できます。ここで scope 引数は、参照対象となる 1 つ以上のノートを定義します。

重要な点として、一部のアクションコード演算子とは異なり、ここでの scope 引数は「式」として評価されません。つまり、scope に複雑なコード式を記述することはできません。その必要がある場合は、eval() を使用して回避するか、あるいは式の結果を保持するためのユーザー属性を用意し、その属性の値を使用することを検討してください（前述の 4 番目の項目と同様の方法）。

拡張構文形式は、アクションコード式の左辺と右辺のどちらでも使用できます。つまり、この構文を使って他のオブジェクトから属性値を取得（右辺）することも、設定（左辺）することも可能です。一般的に、オフセット・アドレスは他のオブジェクトからデータを取り出すために右辺で使用されます。

右辺の例：
	$MyString = $MyString(""Some other note""); 
	$MyNumber = $MyNumber(""A root container/Some Container/Some other note""); 
	$MyString = $MyString(agent); （この指定子はエージェント内でのみ動作します）
	$MyString = $MyString(adornment); （この指定子はアドーンメント内でのみ動作します）
	$MyList = $MyString(""Some other note;Another note;Different note""); 

左辺の例：
	$MyString(""Another note"") = $MyString(""A note""); 
	$MyDate(parent) = $MyDate; 

実際、式の両辺でオフセットを使用することも可能です。例えば、""Some note"" というノートのルール内で、他の 2 つのノートの属性を参照するために以下のようなコードを記述できます。
	$MyColor(""A note"") = $MyColor(""Another note"");"
$N (query back-reference),Property,Query,Data manipulation,String,false,9.5.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"$N 
The value of the numbered back-reference for the current query (agent or if() conditional).
The valid range for N is from 0 (zero) to 9.
The back-reference $0 always refers to the the whole matched string (or sub-string) for the stated query regex, i.e. it may match all or part of the target string. $1 to $9 refer to any further defined back-references within the overall regex, i.e. sub-strings within $0.
Back-references are numbered in the order created. The order is usually left-to right in order the parentheses open, noting that this allows for nesting of back-references.
Query back-references are discussed in fuller detail here.","$N
現在のクエリ（エージェントまたは if() 条件式）における番号付き後方参照の値。
Nの有効な範囲は0から9までです。
後方参照 $0 は常に、指定されたクエリ正規表現に一致した文字列（または部分文字列）全体を指します。つまり、ターゲット文字列の全部または一部に一致する可能性があります。$1 から $9 は、正規表現内でさらに定義された後方参照、すなわち $0 内の部分文字列を指します。
後方参照は作成された順に番号が付けられます。通常、括弧が開く順に従って左から右へと番号が振られます。これにより、後方参照の入れ子構造が可能になります。
クエリの後方参照についての詳細は、こちらで詳しく説明されています。"
abs(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"abs(sourceNum)
abs() computes the absolute value of its sourceNum argument. This is the non-negative value of sourceNum without regard to its sign. Thus both these result in a $MyNumber value of 3.5:
	$MyNumber = abs(3.5); 
	$MyNumber = abs(-3.5); 
The operator can also evaluate a numerical attribute:
	$MyNumber = abs($SomeNumber); 
A numerical string attribute will be parsed to a number. If $MyString is a value of ""-5"", $MyNumber will be 5:
	$MyNumber = abs($MyString);","abs(sourceNum)
abs() は引数 sourceNum の絶対値を計算します。これは sourceNum の符号を無視した非負の値です。したがって、以下のどちらの結果も $MyNumber の値は 3.5 になります。
	$MyNumber = abs(3.5); 
	$MyNumber = abs(-3.5); 
この演算子は数値属性を評価することもできます。
	$MyNumber = abs($SomeNumber); 
数値形式の文字列属性は数値として解析されます。もし $MyString の値が ""-5"" であれば、$MyNumber は 5 になります。
	$MyNumber = abs($MyString);"
"action([scope,]codeStr)",Function,Item,Data manipulation,success boolean,false,5.8.0,Baseline,9.5.0,,,2,true,false,false,false,false,false,false,true,false,,false,"action([scope, ]codeStr)
action(codeStr)
This function allows execution of the codeStr without the need for a return value. This allows an action be set within an attribute, and perform that action as part of a rule or agent action. The optional scope argument allows the action to be run on a note other than the current note
For example, the Rule
	action('$Color= ""bright red""');
will set the note's primary colour ($Color). 
Note that that in its simplest form, an action() call is a quote-enclosed string. As action codes tend to use double-quoted strings, it may often be necessary to use single quotes for the outer enclosure, as in the example above.
The action() function returns the evaluated result of the codeStr within it. In the above case if $MyString were set to store the result, the value would be true—because the action completed successfully. So, in most cases, there is no requirement for a left-side attribute to accept any output. By comparison, the related eval(expression) function evaluates an expression and returns a value. Whereas eval() is designed to intentionally return an output, action() performs an action such as an assignment.
An action() call can be used with a do(macro) call to create a form of function as macros allow input arguments (its arguments): see do().
The action() call is particularly useful during export where it is desirable to run some action code in the context of the template during template rendering (evaluation)—see more below.
Calling stamp code via action()
If a stamp's code is long/complex it can be convenient to store it in a code note. Thus if a code note 'Test-stamp' held the action code $Colour=""red"";, then a stamp with the code:
	action($Text(""Test-stamp"")); 
when run would result in the stamped note(s) turning red. The example is trivial but shows the technique. Note the offset address in the stamp to the code note is case sensitive and should use a unique $Name (or else cite the full $Path to the code note). Local attribute references, i.e. $Color or $ChildCount, are bound to the note being stamped: it is not possible to reference values in the code note using a designator.
On-the-fly Attribute references using action()
Occasionally it is necessary to make at attribute value reference string from a variable, i.e. if the variable holds 'Path' the result being '$Path' as opposed to the value of $Path. Whilst $MyString refers to the value of attribute MyString, what if the attribute name is itself the value of a variable in the current code? Here action() solves the problem. For instance, if vAnAttr holds as its value the name of an attribute, e.g. ""SomeAttribute"" then the following does not work:
	$MyString = ""$"" + vAnAttr; WRONG ($MyString is the value of $SomeAtttribute)
as $MyString is not set to the value of $SomeAttr. Instead use action():
	action('$MyString = ""$"" + vAnAttr'); CORRECT ($MyString is the string '$SomeAtttribute')
To build a series of $-prefixed attribute references in a loop, use action() instead of eval(), as described in more detail here.
action(scope, code)
If an optional first scope argument is provided, the code is not run on the current note but on that defined by scope (defining scope). Thus:
	action(""Some note"",""$Color = 'blue';""); 
will set the colour of note ""Some note"" to blue.
This option can avoid needing to use offset references in code, especially if the offset address is being defined by a variable.","action([scope, ]codeStr)
action(codeStr)

この関数は、戻り値を必要とせずに codeStr を実行することを可能にします。これにより、属性内にアクションを設定し、ルールやエージェントのアクションの一部としてそのアクションを実行できるようになります。オプションの scope 引数を使用すると、現在のノート以外のノートに対してアクションを実行できます。

例えば、ルール：
	action('$Color= ""bright red""');
は、そのノートの基本色（$Color）を設定します。

最も単純な形式では、action() の呼び出しは引用符で囲まれた文字列であることに注意してください。アクションコードでは二重引用符（""）が使用される傾向があるため、上記の例のように、外側の囲みには一重引用符（'）を使用する必要がある場合が多くなります。

action() 関数は、その内部の codeStr を評価した結果を返します。上記のケースで、もし $MyString が結果を保存するように設定されていた場合、その値は true になります（アクションが正常に完了したため）。したがって、ほとんどの場合、出力を受け取るための左辺の属性は必要ありません。対照的に、関連する eval(expression) 関数は式を評価して値を返します。eval() が意図的に出力を返すように設計されているのに対し、action() は代入などのアクションを実行します。

action() の呼び出しは、do(macro) の呼び出しと共に使用して、マクロが入力引数（その引数）を許可する一種の関数を作成するために使用できます。do() を参照してください。

action() の呼び出しは、テンプレートのレンダリング（評価）中にテンプレートのコンテキスト内で何らかのアクションコードを実行することが望ましいエクスポート（書き出し）時に特に有用です（詳細は後述）。

action() を介したスタンプコードの呼び出し
スタンプのコードが長く複雑な場合は、それをコードノートに保存しておくと便利です。したがって、「Test-stamp」というコードノートにアクションコード $Color=""red""; が保持されている場合、以下のコードを持つスタンプ：
	action($Text(""Test-stamp"")); 
を実行すると、スタンプされたノートは赤くなります。この例は単純ですが、その手法を示しています。スタンプ内でのコードノートへのオフセットアドレスは、大文字と小文字を区別し、一意の $Name を使用する必要があります（そうでない場合は、コードノートへの完全な $Path を引用してください）。$Color や $ChildCount などのローカル属性の参照は、スタンプされるノートにバインドされます。指定子（designator）を使用してコードノート内の値を参照することはできません。

action() を使用した動的な属性参照
変数から属性値の参照文字列を作成する必要がある場合があります。つまり、変数に 'Path' が保持されている場合に、$Path の値ではなく、結果として '$Path' という文字列を得たい場合です。$MyString は属性 MyString の値を参照しますが、属性名自体が現在のコード内の変数の値である場合はどうすればよいでしょうか？ここで action() が問題を解決します。例えば、vAnAttr が値として属性名（例：""SomeAttribute""）を保持している場合、以下は機能しません：
	$MyString = ""$"" + vAnAttr; WRONG ($MyString は $SomeAttribute の値になります)
これは、$MyString が $SomeAttr の値に設定されないためです。代わりに action() を使用します：
	action('$MyString = ""$"" + vAnAttr'); CORRECT ($MyString は文字列 '$SomeAttribute' になります)
ループ内で一連の $ プレフィックス付きの属性参照を構築するには、こちらで詳しく説明されているように、eval() の代わりに action() を使用してください。

action(scope, code)
オプションの最初の scope 引数が指定されている場合、コードは現在のノートではなく、scope で定義されたノート（定義スコープ）で実行されます。したがって：
	action(""Some note"",""$Color = 'blue';""); 
は、""Some note"" というノートの色を青に設定します。
このオプションを使用すると、特にオフセットアドレスが変数によって定義されている場合に、コード内でオフセット参照を使用する必要を避けることができます。"
"any(scope, condition)",Function,Group,Non-query Boolean,boolean test,false,4.0.0,Baseline,,,,2,true,false,false,false,true,true,true,false,false,,false,"any(scope, condition)
This Boolean operator examines notes at scope (defining scope) and determines whether any note(s) in the defined group evaluates condition as true.
scope may be any group designator, or group defined by find().
The overall condition must not be enclosed in quotes, though a literal string value within the query will need to be quoted. For example:
	any(children,$Status==""Important"") 
	any(children,$Overdue==true) 
	any(children,$Overdue) (using short form test)
	any(children,$Overdue==false) 
	any(children,!$Overdue) (using short form test)
If trying to resolve contains() for multiple matches, use any(children,$Name==""string""). Thus of it is desired for an agent to list the parent containers of all notes titled 'foo', the agent query would be:
	any(children,$Name==""foo"") 
If agents are present, it may be sensible to filter for aliases:
	any(children,$Name==""foo"") & !$IsAlias 
See also: every().","any(scope, condition)
このブーリアン演算子は、scope（範囲）にあるノートを調べ、定義されたグループ内のいずれかのノートが condition（条件）を真（true）と評価するかどうかを判定します。
scope には、任意のグループ指定子、または find() によって定義されたグループを使用できます。
全体の condition は引用符で囲んではいけませんが、クエリ内のリテラル文字列値は引用符で囲む必要があります。例：
	any(children,$Status==""Important"") 
	any(children,$Overdue==true) 
	any(children,$Overdue) （短縮形式のテストを使用）
	any(children,$Overdue==false) 
	any(children,!$Overdue) （短縮形式のテストを使用）
複数の合致に対して contains() を解決しようとする場合は、any(children,$Name==""string"") を使用します。したがって、'foo' という名前のすべてのノートの親コンテナをリストアップするエージェントが必要な場合、エージェントのクエリは次のようになります：
	any(children,$Name==""foo"") 
エージェントが存在する場合、エイリアスをフィルタリングするのが賢明かもしれません：
	any(children,$Name==""foo"") & !$IsAlias 
参照：every()"
atan(radiansNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"atan(radiansNum)
atan() converts its radiansNum, in radians, to the arctangent of that value.
	$MyNumber = atan(6); 
returns 1.405647649 for an input of 6 radians.","atan(radiansNum)
atan()は、ラジアン単位のradiansNumを、その値のアークタンジェントに変換します。
	$MyNumber = atan(6); 
6ラジアンの入力に対して1.405647649を返します。"
attribute(attributeNameStr).keys,Function,Document,Document configuration,List,false,9.5.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"attribute(attributeNameStr).keys
This returns a List of the attribute dictionary keys for the attribute named in the attributeNameStr argument. Keys are returned in the order listed for attribute(), and not in alphabetical order—as might be intuited. Being a Dictionary operator, it is possible to retrieve all the above as a list of key:value pairs. Note that any attribute name (any valid name) must be supplied as first argument:
	$MyList = attribute(""Width"").keys; 
returns the entire contents of the Dictionary key:value pairs for the attribute Width.
 From v10.1.1, attributeNameStr may be a variable or attribute value instead of a literal string. As the attribute name may thus be a variable, a more useful method is to iterate the list of keys:

var:list vKeys;
var:string vOutput;
vKeys = attribute(anAttribute).keys;
vKeys.each(aKey){
	vOutput += aKey + "": "" + attribute(anAttribute)[aKey] + ""\n"";
};
$Text = vOutput;
By combining with document(), it is possible to make a stamp that creates a listing of all user attributes in the current document, iterate each one, report only keys with a value and place the resulting data in the $Text of the stamped note the stamp code is;

var:list vKeys;
var:string vOutput;
var:list vAttributes = document[""user-attributes""];
vOutput += ""TBX filename "" + document[name] + ""\n"";
vOutput += ""Number of  user attributes: "" + vAttributes.count + ""\n--------------------\n"";
vAttributes.each(anAttribute){
	vOutput += ""--------------------\n"" + anAttribute + ""\n"" +""----------\n"";
	vKeys = attribute(anAttribute).keys;
	vKeys.each(aKey){
		if(attribute(anAttribute)[aKey] != """" & aKey != ""category""){
			vOutput += aKey + "": "" + attribute(anAttribute)[aKey] + ""\n"";
		};
	};
};
$Text = vOutput;","attribute(attributeNameStr).keys
これは、引数 attributeNameStr で指定された名前の属性に対応する、属性辞書のキーのリスト（List）を返します。キーは、直感的に期待されるようなアルファベット順ではなく、attribute() でリストされる順序で返されます。辞書演算子（Dictionary operator）であるため、これらすべてを key:value ペアのリストとして取得することが可能です。注意点として、最初の引数には（任意の有効な）属性名を指定する必要があります。
	$MyList = attribute(""Width"").keys; 
これは、属性「Width」の辞書の key:value ペアの内容全体を返します。

v10.1.1 以降、attributeNameStr にはリテラル文字列の代わりに変数や属性値を使用できるようになりました。属性名を変数にできるようになったことで、キーのリストをイテレート（反復処理）するという、より便利な手法が利用可能になります。

var:list vKeys;
var:string vOutput;
vKeys = attribute(anAttribute).keys;
vKeys.each(aKey){
	vOutput += aKey + "": "" + attribute(anAttribute)[aKey] + ""\n"";
};
$Text = vOutput;

document() と組み合わせることで、現在のドキュメント内のすべてのユーザー属性のリストを作成し、各属性をイテレートして、値を持つキーのみ（""category"" を除く）を抽出し、その結果をスタンプが適用されたノートの $Text に配置するようなスタンプを作成できます。そのスタンプのコードは以下の通りです。

var:list vKeys;
var:string vOutput;
var:list vAttributes = document[""user-attributes""];
vOutput += ""TBX filename "" + document[name] + ""\n"";
vOutput += ""Number of  user attributes: "" + vAttributes.count + ""\n--------------------\n"";
vAttributes.each(anAttribute){
	vOutput += ""--------------------\n"" + anAttribute + ""\n"" +""----------\n"";
	vKeys = attribute(anAttribute).keys;
	vKeys.each(aKey){
		if(attribute(anAttribute)[aKey] != """" & aKey != ""category""){
			vOutput += aKey + "": "" + attribute(anAttribute)[aKey] + ""\n"";
		};
	};
};
$Text = vOutput;"
attribute(attributeNameStr)[keyStr],Function,Document,Document configuration,Dictionary,false,9.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"attribute(attributeNameStr)[keyStr]
The attribute() operator, for the specified attribute attributeNameStr, returns a Dictionary of key values that describe that attribute. attributeNameStr may also be a variable or attribute value instead of a literal string. Keys names are all-lowercase and case-sensitive. The current keys are listed below. Keys are editable value attribute 
* category (read-only): the category (group) in which the attribute appears.
* default: the attribute default value.
* description: a short description the the attribute. For user attributes, this needs to be set by the user (either here via the Inspector).
* lines: the number of lines used for display of values in Displayed Attributes and Get Info tables. Only used for data types Dictionary, List, Set, String.
* readonly (read-only): is true for read-only attributes, else no value. This setting is explained under non-editable notes.
* sequential (read-only): only used by Number data types. A string value YES if true, else no value. 
* suggested: the suggested values. Empty unless set by the user. Only used by data types Dictionary, List, Set, and String.
* type (read-only): a string describing the Data type of the attribute.
Some read-only properties may be modified via the User Attributes Inspector, but not via action code.
Key values
If any key is not set, e.g. there are no 'suggested' values, then an empty string is returned for that key.
All keys return a value called via keyStr. The most appropriate attribute type is shown as the recipient of the data:
	$MyString = attribute(""Width"")[""category""] 
	$MyList = attribute(""Width"")[""default""] 
	$MyString = attribute(""Width"")[""description""] 
	$MyNumber = attribute(""Width"")[""lines""] 
	$MyBoolean = attribute(""Width"")[""readonly""] 
	$MyBoolean = attribute(""Width"")[""sequential""] (as 'YES' coerces to true)
	$MyList = attribute(""Width"")[""suggested""] 
	$MyString = attribute(""Width"")[""type""] 
Note that when using literal (i.e. actual) attribute name or keys it is recommended the word(s) are quote enclosed as above. If using variables, as in the earlier code examples, quotes are not used as this aids the Tinderbox parser detecting literal vs. variable usage.
Attribute categories
All attributes belong to an organisation group, and this is stored in the category property. Note that whilst system attributes comprise a series of groups, all user attributes are in group 'user'.
Editing key values
Some keys can be modified via action code, all others are read-only. Actions may modify the default, description, lines, or suggested values of an attribute:
	attribute(""attributeName"")[""suggested""]=""value 1; value 2""; 
sets two values for the attribute's suggested values list. Likewise a default value can be set:
	attribute(""attributeName"")[""default""]=""value 1""; 
Or a description:
	attribute(""Price"")[""description""]=""The price of the item.""; 
Thus, for instance, action code might find the discrete values for an attributes (use values() or collect(), etc.) and use that list to set/update the attributes suggested values (i.e. the suggested key value).
Setting property values
Both the attribute name and/or the facet to be set may be enclosed in quotation marks (previously, use of quotes caused a failure):
	attribute(AttributeName)[facet]=""testing""; 
or
	attribute(""AttributeName"")[""facet""]=""testing"";","attribute(attributeNameStr)[keyStr]
attribute() オペレータは、指定された属性 attributeNameStr について、その属性を説明するキー値のディクショナリを返します。attributeNameStr は、リテラル文字列の代わりに変数や属性値にすることもできます。キー名はすべて小文字で、大文字と小文字を区別します。現在のキーは以下の通りです。

* category (読み取り専用): 属性が表示されるカテゴリ（グループ）。
* default: 属性のデフォルト値。
* description: 属性の短い説明。ユーザー属性の場合、これはユーザーが（ここ、またはインスペクタを介して）設定する必要があります。
* lines: Displayed Attributes（表示属性）および Get Info（情報取得）テーブルでの値の表示に使用される行数。データ型が Dictionary、List、Set、String の場合にのみ使用されます。
* readonly (読み取り専用): 読み取り専用属性の場合は true、それ以外の場合は値なし。この設定については、編集不可能なノート（non-editable notes）の項で説明されています。
* sequential (読み取り専用): Number データ型でのみ使用されます。true の場合は文字列値 YES、それ以外の場合は値なし。
* suggested: 推奨値。ユーザーによって設定されない限り空です。データ型が Dictionary、List、Set、String の場合にのみ使用されます。
* type (読み取り専用): 属性のデータ型を示す文字列。

一部の読み取り専用プロパティは、ユーザー属性インスペクタを介して変更できますが、アクションコードを介して変更することはできません。

キー値
いずれかのキーが設定されていない場合（例：'suggested' 値がない場合）、そのキーに対しては空の文字列が返されます。
すべてのキーは、keyStr を介して呼び出される値を返します。データの受け取り側として最も適切な属性タイプを以下に示します。
	$MyString = attribute(""Width"")[""category""] 
	$MyList = attribute(""Width"")[""default""] 
	$MyString = attribute(""Width"")[""description""] 
	$MyNumber = attribute(""Width"")[""lines""] 
	$MyBoolean = attribute(""Width"")[""readonly""] 
	$MyBoolean = attribute(""Width"")[""sequential""] ('YES' は true に強制変換されるため)
	$MyList = attribute(""Width"")[""suggested""] 
	$MyString = attribute(""Width"")[""type""] 
リテラル（つまり実際の）属性名やキーを使用する場合は、上記のように単語を引用符で囲むことが推奨されます。以前のコード例のように変数を使用する場合は、引用符を使用しません。これにより、Tinderbox パーサーがリテラルと変数の使用を検出しやすくなります。

属性カテゴリ
すべての属性は組織グループに属しており、これは category プロパティに保存されます。システム属性は一連のグループで構成されていますが、すべてのユーザー属性は 'user' グループに含まれることに注意してください。

キー値の編集
一部のキーはアクションコードを介して変更できますが、それ以外はすべて読み取り専用です。アクションでは、属性の default、description、lines、または suggested 値を変更できます。
	attribute(""attributeName"")[""suggested""]=""value 1; value 2""; 
は、属性の推奨値リストに 2 つの値を設定します。同様に、デフォルト値を設定することもできます。
	attribute(""attributeName"")[""default""]=""value 1""; 
または説明：
	attribute(""Price"")[""description""]=""The price of the item.""; 
したがって、例えばアクションコードで属性の個別の値を取得し（values() や collect() などを使用）、そのリストを使用して属性の推奨値（つまり suggested キー値）を設定または更新することができます。

プロパティ値の設定
属性名と、設定するファセット（facet）のいずれか、または両方を引用符で囲むことができます（以前は引用符を使用すると失敗していました）：
	attribute(AttributeName)[facet]=""testing""; 
または
	attribute(""AttributeName"")[""facet""]=""testing"";"
attributeEncode(dataStr),Function,Item,Formatting,String,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"attributeEncode(dataStr)
This function encodes all instances of the following in the argument string dataStr to numeric HTML entities . Thus:
* left angle bracket → &amp;lt; 
* right angle bracket → &amp;gt; 
* ampersand → &amp;amp; 
* (straight) double quote → &amp;quot; 
* (straight) apostrophe → &amp;apos; 
* line feed character (ASCII #10) → &amp;#10; 
**This assists with OPML work as paragraph breaks are not allowed within XML attribute values.
For example, if the source dataStr is ""this & that"":
	$MyString = attributeEncode(""this & that"") outputs ""this &amp;amp; that"".
An older export code equivalent was opmlEncode(); the latter is deprecated in favour of the form value(attributeEncode(…)).
XML export
As attributeEncode() encodes all the unsafe XML characters, this operator can be thought of as 'xmlEncode()', so can even be used to encode $Text.
For website XML sitemaps, e.g. for indexing/SEO purposes, that need to report page URLs in XML (as opposed to HTML) avoid path but instead use value(attributeEncode($HTMLExportPath)).","attributeEncode(dataStr)
この関数は、引数の文字列 dataStr に含まれる以下の文字を、すべて数値 HTML エンティティにエンコードします。
* 左アングルブラケット（<） → &amp;lt; 
* 右アングルブラケット（>） → &amp;gt; 
* アンパサンド（&） → &amp;amp; 
* （ストレート）ダブルクォート（""） → &amp;quot; 
* （ストレート）アポストロフィ（'） → &amp;apos; 
* 改行文字（ASCII #10） → &amp;#10; 
これは、XML の属性値内では改行が許可されていないため、OPML 関連の作業を行う際に役立ちます。
例えば、元の dataStr が ""this & that"" の場合：
$MyString = attributeEncode(""this & that"") は ""this &amp;amp; that"" を出力します。
以前のエクスポートコードにおける同等の機能は opmlEncode() でしたが、現在は opmlEncode() は非推奨となり、value(attributeEncode(…)) という形式の使用が推奨されています。

XML エクスポート
attributeEncode() は安全でない XML 文字をすべてエンコードするため、このオペレーターは「xmlEncode()」として考えることができ、$Text のエンコードにも使用できます。
インデックス作成や SEO 目的などで、HTML ではなく XML 形式でページ URL を記述する必要がある Web サイトの XML サイトマップなどでは、path ではなく value(attributeEncode($HTMLExportPath)) を使用してください。"
"avg_if(scope, condition, expressionStr)",Function,Conditional Group,Mathematical,Number,false,4.6.0,Baseline,,,,3,true,false,false,false,false,true,true,false,false,,false,"avg_if(scope, condition, expressionStr)
The function avg_if() computes the arithmetic mean of a list of the values of scope items, and returns a List-type data. Each of the items in scope (defining scope) is tested and ignored it if it fails to meet condition, otherwise items supply a value to then adding the value of each list item evaluated using the designated expressionStr. Be aware that the per-item value might be a literal value, an attribute value, or a value/string of content based on that item's expressionStr.
For a related, less focussed, operator see avg().
This computes the arithmetic mean of the value of a expressionStr in a group, as filtered by a condition expression. See avg() for a for a related non-conditional operator.
scope describes the note(s) to be examined and may be any group designator including a find() query.
condition is action code forming a valid conditional query test, i.e. it equates to true when matched. Some query-style operators terms may allow use of regular expressions.
expressionStr may be any valid expression, but will usually be a reference to an attribute; short form Boolean attribute expressions are acceptable.
For example:
	$MyNumber = avg_if(children(/Catalog),$Price!=0,$Price); 
sets $MyNumber to the average price of all the items in Catalog, ignoring any items that have a price of 0.","avg_if(scope, condition, expressionStr)
avg_if() 関数は、scope 内の項目の値のリストの算術平均を計算し、リスト型のデータを返します。scope（定義範囲）内の各項目がテストされ、条件に適合しない場合は無視されます。適合する場合は、指定された expressionStr を使用して評価された各リスト項目の値が計算に加えられます。各項目の値は、リテラル値、属性値、またはその項目の expressionStr に基づく値や内容の文字列である可能性があることに注意してください。
関連する、より限定的でない演算子については avg() を参照してください。
これは、条件式によってフィルタリングされたグループ内の expressionStr の値の算術平均を計算します。関連する非条件演算子については avg() を参照してください。
scope は調査対象のノートを記述し、find() クエリを含む任意のグループ指定子を指定できます。
condition は、有効な条件付きクエリテストを形成するアクションコードです（つまり、一致したときに真（true）になります）。一部のクエリ形式の演算子語句では、正規表現の使用が許可される場合があります。
expressionStr は任意の有効な式を指定できますが、通常は属性への参照になります。短縮形式のブール属性式も使用可能です。
例：
	$MyNumber = avg_if(children(/Catalog),$Price!=0,$Price); 
この例では、$MyNumber に Catalog のすべての項目の平均価格を設定しますが、価格が 0 の項目は無視します。"
"avg(scope, expressionStr)",Function,Group,Mathematical,Number,false,4.6.0,Baseline,,,,2,true,false,true,false,false,true,false,false,false,,false,"avg(scope, expressionStr)
This computes the arithmetic mean of the value of a expressionStr in a scope. See avg_if() for a for a related conditional operator.
scope describes the notes to be examined and may be any group designator including a find() query.
expressionStr may be any valid expression, but will usually be a reference to an attribute; short form Boolean attribute expressions are acceptable.
For example:
	$MyNumber = avg(children(/Catalog),$Price); 
returns the average price of all the items in Catalog.","avg(scope, expressionStr)
この関数は、scope（範囲）内における expressionStr（式）の値の算術平均を計算します。関連する条件演算子については avg_if() を参照してください。
scope は、調査対象のノートを記述するもので、find() クエリを含む任意のグループ指定子（group designator）を使用できます。
expressionStr は、任意の有効な式を使用できますが、通常は属性への参照です。短縮形式のブール（Boolean）属性式も使用可能です。
例：
	$MyNumber = avg(children(/Catalog),$Price); 
これは Catalog 内のすべての項目の平均価格を返します。"
"between(valueNum, minNum, maxNum)",Function,Item,Query Boolean,boolean test,false,5.0.0,Baseline,,,,3,true,false,false,false,false,false,false,false,false,,false,"between(valueNum, minNum, maxNum)
Returns Boolean true if the valueNum is greater or equal to minNum and less than maxNum. The comparison method is based on the type of valueNum; numerical, lexical, string and set comparisons are chosen as needed.
The logic is:
	((valueNum >= minNum) & (valueNum true if valueNum==minNum but false if valueNum==maxNum.
If $MyNumber is 7, then:
	$MyBoolean = between($MyNumber, 1, 5); is false 
	$MyBoolean = between($MyNumber, 1, 9); is true 
More realistically the operator would be used in a query or a conditional expression:
	if(between($MyNumber, 1, 5)){…}else{…}; would test as true and execute the code in the first conditional branch.
Do not use this operator for testing Date-type attributes directly. Either use days() instead or use between() with format() or Date.format() to create a suitable string values for testing.
In the query creation pop-ups of agent and Find dialogs this function is listed as ""is between"".
Legacy issues
This operator replaces the legacy #between query operator.","between(valueNum, minNum, maxNum)
valueNumがminNum以上かつmaxNum未満の場合に、Booleanのtrueを返します。比較方法はvalueNumの型に基づき、数値、辞書順、文字列、セットの比較が必要に応じて選択されます。
ロジックは以下の通りです：
	((valueNum >= minNum) & (valueNum true if valueNum==minNum but false if valueNum==maxNum.
$MyNumberが7の場合：
	$MyBoolean = between($MyNumber, 1, 5); はfalseです。
	$MyBoolean = between($MyNumber, 1, 9); はtrueです。
より実用的には、この演算子はクエリや条件式で使用されます：
	if(between($MyNumber, 1, 5)){…}else{…}; はtrueと判定され、最初の条件分岐のコードを実行します。
Date型の属性を直接テストするためにこの演算子を使用しないでください。代わりにdays()を使用するか、あるいはbetween()とformat()またはDate.format()を組み合わせて、テストに適した文字列値を作成してください。
エージェントや検索ダイアログのクエリ作成ポップアップでは、この関数は「is between」としてリストされています。
レガシーに関する事項
この演算子は、レガシーなクエリ演算子 #between を置き換えるものです。"
capitalize(dataStr),Function,Item,Formatting,String,false,4.6.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"capitalize(dataStr)
The contents of text string dataStr is returned with the first letter of each word in upper case.
Functionally equivalent to String.capitalize.
if $MyString is ""hello world"":
	$MyString = $MyString.capitalize(); 
sets it to ""Hello World"".","capitalize(dataStr)
テキスト文字列 dataStr の各単語の先頭文字を大文字にして返します。
String.capitalize と機能的に同等です。
もし $MyString が ""hello world"" の場合：
	$MyString = $MyString.capitalize(); 
は、これを ""Hello World"" に設定します。"
ceil(sourceNum),Function,Item,Mathematical,Number,false,6.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"ceil(sourceNum)
rounds the number value of sourceNum up to next whole integer.
See also Number.floor() and Number.round().
If $MyNumber is 3.2 then:
	$MyNumber = ceil($MyNumber); 
sets $MyNumber to 4. Note unlike normal rounding the value is set upwards to the next integer (i.e. whole number).","I will translate the text to Japanese.

ceil(sourceNum)
sourceNum の数値を、次の整数に切り上げます。
Number.floor() および Number.round() も参照してください。
$MyNumber が 3.2 の場合：
	$MyNumber = ceil($MyNumber);
は $MyNumber を 4 に設定します。通常の四捨五入とは異なり、値は次の整数（すなわち整数）に切り上げられることに注意してください。"
changed([scope]),Operator,Item,Data manipulation,success boolean,false,9.6.0,Baseline,,,,1,false,true,false,false,false,true,false,true,false,,false,"changed()
changed([scope])
The changed() operator tells the current item to update itself. A likely use for the operator is to refresh Poster notes. There is an optional scope argument, indicating which note(s) need updating. If no scope argument is passed, the target is assumed to be the currently selected note.
The operator needs no left-side argument, so may be called as a simple expression:
	changed(); 
or, more specifically:
	changed(""Some poster note"");","changed()
changed([scope])
changed() 演算子は、現在のアイテムに自身を更新するよう指示します。この演算子の主な用途は、Poster（ポスター）ノートをリフレッシュすることです。オプションの scope 引数を使用して、更新が必要なノートを指定できます。scope 引数が渡されない場合、現在選択されているノートが対象であると見なされます。
この演算子は左辺の引数を必要としないため、次のように単純な式として呼び出すことができます。
	changed();
または、より具体的に：
	changed(""Some poster note"");"
"collect_if(scope, condition, expressionStr)",Function,Conditional Group,"Dictionary, Set & List operations",List,false,4.0.0,Baseline,,,,3,true,false,true,false,true,true,true,false,false,,false,"collect_if(group, condition, expressionStr)
The function collect_if() returns a List by collecting all the notes in scope (defining scope), testing each note in scope and ignoring it if it fails to meet condition, then adding the value of each list item evaluated using the designated expressionStr. Be aware that the per-item value might be a literal value, an attribute value, or a value/string of content based on that item's expressionStr.
For a related, less focussed, operator see collect().
scope may be any group designator, or group defined by find(). In addition, scope may be argument that designates a particular (single) note other than 'this' collect() omits notes for which $Searchable is false.
condition is action code forming a valid conditional test, i.e. it equates to true when matched.
expressionStr can be any expression, but is typically an attribute's name. If the collected per-item value type is multi-value, i.e. Set or a List type data , collect() adds its elements to the returned list. Thus if an item's evaluated value is a list of 3 terms, that item contributes 3 items to the operator's returned list rather than 1 item.
If the collected expressionStr is not a Set or List type attribute, but contains a semicolon, quotation mark, or parentheses, the value will be added to the result as a quoted string. This behaviour is designed correct a variety of confusing edge cases.
For example,
	$MyList = collect_if(children,$Status==""Important"",$Name); 
will construct a List of the names of all of this note's important children.
Note that collect_if's function is related to agents; many tasks you might perform with collect_if could be done as well, or better, with an agent. 
If a list of unique values is required, i.e. set rather than a list, simply pass the output to a Set attribute. Thus if:
	$MyList = collect_if(children,$Age>6,$FavFruit); $MyList is [Apples;Oranges;Pears;Apples]
	$MySet = collect(children,$Age>6,$FavFruit); $MySet is [Apples;Oranges;Pears] 
If the collected attribute is a Set or a List, collect() adds its elements to the result. If the collected attribute is not a Set or a List, but contains a semicolon, quotation mark, or parentheses, the value will be added to the result as a quoted string. This should avoid a variety of confusing edge case outcomes.
collect_if() resets its regular expression match list for each note it tests. Thus, $1 will be the first matched subexpression for this note, rather than the first matched subexpression for the entire collect_if() statement.
collect_if() vs. list.collect_if()
For working with Lists or Sets of actual values, also see list.collect_if().","collect_if(group, condition, expressionStr)

collect_if() 関数は、スコープ（定義範囲）内のすべてのノートを収集し、各ノートに対して条件（condition）をテストして、条件に合致しないものを除外した上で、指定された式（expressionStr）を使用して評価された各項目の値を集めてリスト（List）を返します。項目ごとの値は、リテラル値、属性値、またはその項目の式に基づいた内容の文字列である可能性があることに注意してください。

関連する、より汎用的な（絞り込みのない）オペレータについては、collect() を参照してください。

scope（範囲）には、任意のグループ指定子、または find() で定義されたグループを指定できます。さらに、scope は「this」以外の特定の（単一の）ノートを指す引数にすることもできます。collect() は $Searchable が false であるノートを除外します。

condition（条件）は、有効な条件テストを形成するアクションコードです。つまり、一致したときに真（true）となるものです。

expressionStr（式）は任意の式にできますが、通常は属性名です。収集された項目ごとの値の型が多値（Set型またはList型）である場合、collect() はその要素を返されるリストに追加します。したがって、ある項目の評価値が3つの項目のリストである場合、その項目はオペレータが返すリストに1項目ではなく3項目として寄与します。

収集された expressionStr が Set または List 型の属性ではなく、セミコロン、引用符、または括弧を含む場合、その値は引用符で囲まれた文字列として結果に追加されます。この挙動は、混乱を招くさまざまなエッジケースを修正するように設計されています。

例えば、
	$MyList = collect_if(children,$Status==""Important"",$Name); 
は、このノートの「重要（Important）」な子すべての名前のリストを構築します。

collect_if の機能はエージェントに関連していることに注意してください。collect_if で実行する多くのタスクは、エージェントを使っても同様に、あるいはより適切に実行できる場合があります。

一意の値のリスト、つまりリストではなくセット（Set）が必要な場合は、出力を Set 型の属性に渡すだけです。例えば：
	$MyList = collect_if(children,$Age>6,$FavFruit); $MyList は [Apples;Oranges;Pears;Apples] です。
	$MySet = collect(children,$Age>6,$FavFruit); $MySet は [Apples;Oranges;Pears] です。

収集された属性が Set または List の場合、collect() はその要素を結果に追加します。収集された属性が Set または List ではないが、セミコロン、引用符、または括弧を含む場合、その値は引用符で囲まれた文字列として結果に追加されます。これにより、混乱を招くさまざまなエッジケースの結果を回避できるはずです。

collect_if() は、テストする各ノートに対して正規表現の一致リストをリセットします。したがって、$1 は collect_if() 文全体に対する最初のマッチした部分式ではなく、そのノートに対する最初のマッチした部分式になります。

collect_if() 対 list.collect_if()
実際の値のリストまたはセットを操作する場合は、list.collect_if() も参照してください。"
"collect(scope, expressionStr)",Function,Group,"Dictionary, Set & List operations",List,false,4.0.0,Baseline,,,,2,true,false,true,false,false,true,false,false,false,,false,"collect(scope, expressionStr)
The function collect returns a List by collecting all the notes in scope (defining scope), and adding the value of each list item evaluated using the designated expressionStr. Be aware that the per-item value might be a literal value, an attribute value, or a value/string of content based on that item's expressionStr. 
For a related, more focussed, operator see collect_if().
scope may be any group designator, or group defined by find(). In addition, scope may be argument that designates a particular (single) note other than 'this'. collect() omits notes for which $Searchable is false.
expressionStr can be any expression, but is typically an attribute's name. If the collected per-item value type is multi-value, i.e. Set or a List type data , collect() adds its elements to the returned list. Thus if an item's evaluated value is a list of 3 terms, that item contributes 3 items to the operator's returned list rather than 1 item.
If the collected expressionStr is not a Set or List type attribute, but contains a semicolon, quotation mark, or parentheses, the value will be added to the result as a quoted string. This behaviour is designed correct a variety of confusing edge cases.
For example,
	$MyList = collect(children,$Name); 
constructs a set with the name of each child of the note.
For example,
	$MyList = collect(children(/agents/books),$Name); 
does the same for children of the note 'books' inside 'agents'.
	$MyList = collect(children,$Width * $Height); 
collects a series of numerical values of each child's map icon height/width in Tinderbox map units. Thus if a child had a $Width of 4 and $Height of 2, the collect() result for that item would be 8.
If a list of unique values is required, i.e. set rather than a list, simply pass the output to a Set attribute. Thus if:
	$MyList = collect(children,$FavFruit); $MyList is [Apples;Oranges;Pears;Apples]
	$MySet = collect(children,$FavFruit); $MySet is [Apples;Oranges;Pears]
collect() vs. list.collect()
For working with Lists or Sets of actual values, also see list.collect().","collect(scope, expressionStr)
collect関数は、scope（範囲）内のすべてのノートを収集し、指定されたexpressionStr（式）を用いて評価された各項目の値を追加することで、リスト（List）を返します。各項目の値は、リテラル値、属性値、またはその項目のexpressionStrに基づくコンテンツの値や文字列である可能性があることに注意してください。
関連する、より機能を絞ったオペレータについては、collect_if()を参照してください。
scopeには、任意のグループ指定子、またはfind()で定義されたグループを使用できます。さらに、scopeには'this'以外の特定の（単一の）ノートを指定する引数を使用することもできます。collect()は、$Searchableがfalseであるノートを除外します。
expressionStrには任意の式を指定できますが、通常は属性名です。収集された各項目の値の型が多値（SetまたはList型のデータ）である場合、collect()はその要素を返されるリストに追加します。したがって、ある項目の評価値が3つの項目からなるリストである場合、その項目はオペレータの戻り値リストに対して、1つではなく3つの項目を提供することになります。
収集されたexpressionStrがSetまたはList型の属性ではない一方で、セミコロン、引用符、または括弧が含まれている場合、その値は引用符で囲まれた文字列として結果に追加されます。この動作は、さまざまな紛らわしいエッジケースを修正するために設計されています。
例：
	$MyList = collect(children,$Name); 
は、ノートの各子の名前を持つリストを構築します。
例：
	$MyList = collect(children(/agents/books),$Name); 
は、'agents'内の'books'ノートの子に対して同様の処理を行います。
	$MyList = collect(children,$Width * $Height); 
は、各子のマップアイコンの高さと幅を掛け合わせた数値を、Tinderboxのマップ単位で収集します。例えば、ある子の$Widthが4で$Heightが2の場合、その項目に対するcollect()の結果は8になります。
一意の（重複のない）値のリスト、つまりリストではなくセット（Set）が必要な場合は、単に出力をSet型の属性に渡します。
例：
	$MyList = collect(children,$FavFruit); // $MyListは [Apples;Oranges;Pears;Apples]
	$MySet = collect(children,$FavFruit);  // $MySetは [Apples;Oranges;Pears]
collect() vs. list.collect()
実際の値のリストまたはセットを操作する場合は、list.collect()も参照してください。"
Color.blue(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.blue()
Color.blue
This property sets or returns the value of the blue channel of an RGB colour. The value may be set with a number (0–255) or hex number (#00–#ff). The return value (if coerced to a string or number) is always a number, i.e. 255 and not #ff. By comparison the rgb() operator requires that the values for all three colour channels be set. Examples:
	$MyColor.blue = 255; 
	$MyColor.blue = ""#ff""; 
	$MyOtherColor.green = $MyColor.blue; (value of $MyOtherColor green channel is that of $MyColor blue channel)
	$MyNumber = $MyColor.blue;  (gives 255)
	$MyString = $MyColor.blue;  (gives ""255"")","Color.blue
このプロパティは、RGBカラーのブルー（青）チャンネルの値を設定、または返します。値は数値（0–255）または16進数（#00–#ff）で設定できます。戻り値（文字列または数値に型強制された場合）は常に数値であり、つまり #ff ではなく 255 となります。対照的に、rgb()演算子では3つのカラーチャンネルすべての値を設定する必要があります。例：
	$MyColor.blue = 255; 
	$MyColor.blue = ""#ff""; 
	$MyOtherColor.green = $MyColor.blue; （$MyOtherColorのグリーンチャンネルの値は、$MyColorのブルーチャンネルの値になります）
	$MyNumber = $MyColor.blue;  （255になります）
	$MyString = $MyColor.blue;  （""255""になります）"
Color.brightness(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.brightness()
Color.brightness
This property sets or returns the brightness value of the associated Color-type attribute. The value is a number in the range 0-100. This operator is intended to replace the existing brightness() operator. Examples:
	$MyColor.brightness = 50; (sets 50% brightness)
	$MyColor2.brightness = $MyColor.brightness; (matches brightness levels) 
	$MyNumber = $MyColor.brightness; (returns 50, from above example)","Color.brightness()
Color.brightness
このプロパティは、関連付けられたColor型属性の明度（brightness）の値を設定または返します。値は0から100の範囲の数値です。このオペレータは、既存の brightness() オペレータを置き換えることを目的としています。例：
	$MyColor.brightness = 50; （明度を50%に設定）
	$MyColor2.brightness = $MyColor.brightness; （明度レベルを一致させる）
	$MyNumber = $MyColor.brightness; （上の例から50を返す）"
Color.format(),Function,Item,Formatting,String,false,5.8.0,Baseline,,,,,true,true,false,false,false,false,false,false,false,,false,"Color.format()
Returns Color as a hex-string, regardless of source data is a hex value or named color.
Thus if $MyColor is ""bright red"":
	$MyString = $MyColor.format(); gives ""#ff0000""
	$MyString = $MyColor; gives ""bright red""
Whilst if $MyColor is ""#330099"":
	$MyColor.format(); gives ""#330099""
	$MyString = $MyColor; gives ""#330099""
Therefore for a Color-type attribute set to a named colour, to get that name string simply pass the attribute's value to a string. So if $MyColor is ""bright blue"", this:
	$MyString = $MyColor; 
…gives ""bright blue"" and this:
	$MyString = $MyColor + "" (""+$MyColor.format()+"")""; 
…gives ""bright blue (#0000ff)"".
This supplements the existing format() function.","Color.format()
元のデータが16進数値か名前付きカラーかに関わらず、カラーを16進数形式の文字列として返します。
したがって、$MyColor が ""bright red"" の場合：
	$MyString = $MyColor.format(); は ""#ff0000"" を返します。
	$MyString = $MyColor; は ""bright red"" を返します。
一方、$MyColor が ""#330099"" の場合：
	$MyColor.format(); は ""#330099"" を返します。
	$MyString = $MyColor; は ""#330099"" を返します。
したがって、名前付きカラーが設定された Color 型属性からその名前の文字列を取得するには、単に属性の値を文字列に渡します。例えば、$MyColor が ""bright blue"" の場合：
	$MyString = $MyColor; 
…は ""bright blue"" を返し、以下のように記述すると：
	$MyString = $MyColor + "" (""+$MyColor.format()+"")""; 
…は ""bright blue (#0000ff)"" を返します。
これは既存の format() 関数を補完するものです。"
Color.green(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.green()
Color.green
This property sets or returns the value of the green channel of an RGB colour. The value may be set with a number (0–255) or hex number (#00–#ff). The return value (if coerced to a string or number) is always a number, i.e. 255 and not #ff. By comparison the rgb() operator requires that the values for all three colour channels be set. Examples:
	$MyColor.green = 255; 
	$MyColor.green = ""#ff""; 
	$MyOtherColor.red = $MyColor.green; (value of $MyOtherColor red channel is that of $MyColor green channel)
	$MyNumber = $MyColor.green;  (gives 255)
	$MyString = $MyColor.green;  (gives ""255"")","Color.green()
Color.green
このプロパティは、RGBカラーのグリーンチャネルの値を設定または返します。値は数値（0〜255）または16進数（#00〜#ff）で設定できます。戻り値は（文字列または数値に強制変換された場合）、常に数値です。つまり、#ff ではなく 255 となります。対照的に、rgb() オペレータは3つのカラーチャネルすべての値を設定する必要があります。例：
	$MyColor.green = 255; 
	$MyColor.green = ""#ff""; 
	$MyOtherColor.red = $MyColor.green; （$MyOtherColor のレッドチャネルの値が $MyColor のグリーンチャネルの値になります）
	$MyNumber = $MyColor.green; （255 を返します）
	$MyString = $MyColor.green; （""255"" を返します）"
Color.hue(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.hue()
Color.hue
This property sets or returns the hue value of the associated Color-type attribute. The value is a number in the range 0-360. This operator is intended to replace the existing hue() operator. Examples:
	$MyColor.hue = 270; (sets hue of 270 degrees)
	$MyColor2 = $MyColor.hue; (matches hues) 
	$MyNumber = $MyColor.hue; (returns 270, from above example)","Color.hue()
Color.hue
このプロパティは、関連付けられたColor型属性の色相（hue）の値を設定または返します。値は0から360の範囲の数値です。このオペレータは、既存のhue()オペレータを置き換えることを目的としています。例：
	$MyColor.hue = 270; (色相を270度に設定)
	$MyColor2 = $MyColor.hue; (色相を一致させる)
	$MyNumber = $MyColor.hue; (上の例から270を返す)"
Color.red(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.red()
Color.red
This property sets or returns the value of the blue channel of an RGB colour. The value may be set with a number (0–255) or hex number (#00–#ff). The return value (if coerced to a string or number) is always a number, i.e. 255 and not #ff. By comparison the rgb() operator requires that the values for all three colour channels be set. Examples:
	$MyColor.red = 255; 
	$MyColor.red = ""#ff""; 
	$MyOtherColor.blue = $MyColor.red;  (value of $MyOtherColor blue channel is that of $MyColor red channel)
	$MyNumber = $MyColor.red;  (gives 255)
	$MyString = $MyColor.red;  (gives ""255"")","Color.red()
Color.red
このプロパティは、RGBカラーの赤チャンネルの値を設定または返します。値は数値（0〜255）または16進数（#00〜#ff）で設定できます。戻り値（文字列または数値に変換された場合）は常に数値、つまり #ff ではなく 255 のような値となります。対照的に、rgb() オペレータは3つすべてのカラーチャンネルの値を設定する必要があります。例：
	$MyColor.red = 255; 
	$MyColor.red = ""#ff""; 
	$MyOtherColor.blue = $MyColor.red;  ($MyOtherColor の青チャンネルの値が $MyColor の赤チャンネルの値になります)
	$MyNumber = $MyColor.red;  (255 を返します)
	$MyString = $MyColor.red;  (""255"" を返します)"
Color.saturation(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.saturation()
Color.saturation
This property sets or returns the saturation value of the associated Color-type attribute. The value is a number in the range 0-100. This operator is intended to replace the existing saturation() operator. Examples:
	$MyColor.saturation = 50; (sets 50% saturation)
	$MyColor2.saturation = $MyColor.saturation; (matches saturation levels) 
	$MyNumber = $MyColor.saturation; (returns 50, from above example)","Color.saturation()
Color.saturation
このプロパティは、関連付けられたColor型属性の彩度（saturation）の値を設定または返します。値は0から100の範囲の数値です。このオペレータは、既存のsaturation()オペレータを置き換えることを意図しています。例：
	$MyColor.saturation = 50; （彩度を50%に設定）
	$MyColor2.saturation = $MyColor.saturation; （彩度レベルを一致させる）
	$MyNumber = $MyColor.saturation; （上の例から、50を返す）"
compositeFor(nameStr),Function,Composite,Composite,List,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr)
returns a List-type list of paths of all notes in the composite containing note nameStr.
	$MyList = compositeFor(""Total""); 
By using designator this for item, any note in the composite can refer to its containing composite.
	$MyList = compositeFor(this); 
If the name of a composite is known, but not the note name(s) or any of its constituents, use compositeWithName().","compositeFor(nameStr)
ノート nameStr を含むコンポジット内のすべてのノートのパスを、List型のリストで返します。
	$MyList = compositeFor(""Total""); 
item に指定子 this を使用することで、コンポジット内の任意のノートが自身を含むコンポジットを参照できます。
	$MyList = compositeFor(this); 
コンポジットの名前はわかっているが、ノートの名前やその構成要素がわからない場合は、compositeWithName() を使用してください。"
compositeFor(nameStr):count,Property,Composite,Composite,Number,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):count
returns the Number of notes in the composite containing note nameStr.
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MyNumber = compositeFor(this):count; 
	$MyNumber = my:count;","compositeFor(nameStr):count
ノート nameStr を含むコンポジット内のノートの数を返します。
このコードでは 'my' 指定子を使用して、より短い形式で記述することもできます。これらは機能的に同等です：
	$MyNumber = compositeFor(this):count; 
	$MyNumber = my:count;"
compositeFor(nameStr):kind,Property,Composite,Composite,String,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):kind
returns the String name of the composite from which the composite containing note nameStr was instantiated.
For example, if a composite was created from the built-in 'list' composite, this function will return ""list"". The query:
	$MyString = compositeFor(this):kind==""book""; 
would locate all notes that participate in composites instantiated from ""book"" – all books.
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MyString = compositeFor(this):kind; 
	$MyString = my:kind;","compositeFor(nameStr):kind
ノート nameStr を含むコンポジットの生成元となったコンポジットの名前を文字列で返します。
例えば、組み込みの 'list' コンポジットからコンポジットが作成された場合、この関数は ""list"" を返します。以下のクエリ：
	$MyString = compositeFor(this):kind==""book"";
は、""book"" からインスタンス化されたコンポジットに参加しているすべてのノート（すべての本）を特定します。
このコードでは、'my' 指定子を使用して短縮形を使うこともできます。以下は機能的に等価です：
	$MyString = compositeFor(this):kind;
	$MyString = my:kind;"
compositeFor(nameStr):name,Property,Composite,Composite,String,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):name
returns the String name of the composite containing note nameStr. This expression is read/write: 
	$MyString = compositeFor(this):name=""example""; 
renames the composite containing the note running this code to 'example'.
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MyString = compositeFor(this):name; 
	$MyString = my:name;","compositeFor(nameStr):name
ノート nameStr を含むコンポジットの名前（文字列）を返します。この式は読み書き可能です。
	$MyString = compositeFor(this):name=""example""; 
このコードを実行しているノートを含むコンポジットの名前を「example」に変更します。
このコードでは、'my' デジグネーターを使用して短縮形で記述することもできます。以下は機能的に同等です。
	$MyString = compositeFor(this):name; 
	$MyString = my:name;"
compositeFor(nameStr):role(roleStr),Property,Composite,Composite,List,false,7.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):role(roleStr)
returns a List-type list of paths of all notes in the composite containing note nameStr, but including only the note or notes with the designated role roleStr. For example, to set the color of all notes with the role ""author"": 
	$MyList = $Color(compositeFor(""great books""):role(""author""))=""red""; 
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MyList = compositeFor(this):role(""some role""); 
	$MyList = my:role(""some role"");","compositeFor(nameStr):role(roleStr)
ノート nameStr を含むコンポジット内のすべてのノートのパスを List 型のリストとして返しますが、指定された役割 roleStr を持つノートのみが含まれます。例えば、役割が ""author"" であるすべてのノートの色を赤に設定するには、次のように記述します：
	$MyList = $Color(compositeFor(""great books""):role(""author""))=""red""; 
このコードでは、'my' 指定子を使用して短縮形を記述することもできます。これらは機能的に等価です：
	$MyList = compositeFor(this):role(""some role""); 
	$MyList = my:role(""some role"");"
compositeFor(nameStr):roles,Property,Composite,Composite,Set,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):roles
returns a Set-type list of roles that appear in the composite containing note nameStr.
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MySet = compositeFor(this):roles; 
	$MySet = my:roles;","compositeFor(nameStr):roles
ノート nameStr を含むコンポジット内に現れるロールの Set 型リストを返します。
このコードは、'my' デザイン指定子（designator）を使用して短縮して書くこともできます。以下は機能的に同等です：
	$MySet = compositeFor(this):roles;
	$MySet = my:roles;"
compositeWithName(compositeNameStr),Function,Composite,Composite,List,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeWithName(compositeNameStr)
returns a List-type list of paths of all notes within the composite with the name compositeNameStr. If several composites have the same name, data for only one of those composites is returned (first match by $OutlineOrder).
	$MyList = compositeWithName(""Lecture 16"");t
If working in the context of a note already in a composite, compositeFor(this) will also return an appropriate list of paths.","compositeWithName(compositeNameStr)
compositeNameStr という名前のコンポジット内にあるすべてのノートのパスを List 型のリストとして返します。同じ名前のコンポジットが複数ある場合、1 つのコンポジットのデータのみが返されます（$OutlineOrder で最初に一致したもの）。
	$MyList = compositeWithName(""Lecture 16"");
すでにコンポジット内にあるノートのコンテキストで作業している場合は、compositeFor(this) も適切なパスのリストを返します。"
contains(item),Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,1,true,false,true,false,true,false,false,false,false,,false,"contains(item)
Returns Boolean true if the note evaluated from a single  item is a direct child of the current note or, put conversely, if the note is the parent of item. Thus it can be thought of as an ""is parent of"" operator and, as such, a counterpart to the ""is a child of"" operator inside().
The item argument must be quoted unless an attribute reference. Ways to define item.
Examples:
	contains(""/foo"") 
This is a full path so can match only the root-level note 'foo'. But:
	contains(""bar"") 
could match any note with the name 'bar' of which there may be more than one. If there is more that one, Tinderbox chooses one. This is fine if one match was desired but if there are known to be multiple 'bar' notes and it is desired to locate parent container of every one, then a different approach is needed, using any(): the process is described under any().
NOTE: Checking attribute values, as opposed to object containment
There are a range of other tools to check if a String-, List- or Set-type attribute's value contains a desired search string/regex.
* For String attributes there are String.contains() and String.icontains().
* List and Set date type attributes also support .contains() and .icontains() though in this context the scope of regex matches is slightly different from that with a String-type attribute (see the linked articles).
* Single words alone can be checked using word(), which works across $Name, $Text and all String-type attributes.
Legacy issues
This operator replaces the legacy #contains query operator. The latter should not be used for new code.","contains(item)
単一のitemから評価されたノートが、現在のノートの直接の子である場合（逆に言えば、現在のノートがitemの親である場合）、Booleanの真（true）を返します。したがって、これは「～の親である（is parent of）」演算子と考えることができ、inside()（～の子である）演算子の対照となるものです。
item引数は、アトリビュート参照でない限り引用符で囲む必要があります。itemを定義する方法。
例：
	contains(""/foo"") 
これはフルパスであるため、ルートレベルのノート「foo」にのみ一致します。一方：
	contains(""bar"") 
は「bar」という名前を持つ任意のノートに一致する可能性があり、そのようなノートは複数存在する可能性があります。複数が存在する場合、Tinderboxはそのうちの1つを選択します。1つの一致を求めるのであればこれで問題ありませんが、複数の「bar」ノートが存在することがわかっており、それらすべての親コンテナを特定したい場合は、any() を使用した別のアプローチが必要です。このプロセスについては any() のセクションで説明されています。
注意：オブジェクトの包含関係ではなく、アトリビュート値のチェック
String型、List型、またはSet型アトリビュートの値に、目的の検索文字列や正規表現が含まれているかどうかを確認するためのツールは他にもあります。
* String型アトリビュートには、String.contains() と String.icontains() があります。
* List型およびSet型アトリビュートも .contains() と .icontains() をサポートしていますが、この文脈での正規表現の一致の範囲は、String型アトリビュートの場合とはわずかに異なります（リンク先の記事を参照）。
* 単一の単語のみをチェックする場合は word() を使用できます。これは $Name、$Text、およびすべてのString型アトリビュートで機能します。
レガシーな問題
この演算子は、レガシーな #contains クエリ演算子を置き換えるものです。後者は新しいコードで使用すべきではありません。"
cos(radiansNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"cos(radiansNum)
cos() converts its radiansNum, in radians, to the cosine of that value.
	$MyNumber = cos(6); 
returns 0.9601702867 for an input of 6 radians.","cos(radiansNum)
cos() は、ラジアン単位の radiansNum をその値のコサインに変換します。
	$MyNumber = cos(6);
6 ラジアンの入力に対して 0.9601702867 を返します。"
"count_if(scope, condition)",Function,Group,Data manipulation,Number,false,4.6.0,Baseline,,,,2,true,false,true,false,true,true,true,false,false,,false,"count_if(scope, condition)
Counts the number of notes in the list derived from scope that satisfy the evaluated expression condition.
scope describes the notes to be examined (defining scope).
condition is action code forming a valid conditional query test, i.e. it equates to true when matched. Some query-style operators terms may allow use of regular expressions.
This equivalent to use of sum_if(), as the next two code examples have the same result:
	 sum_if(group, condition,1) 
but this is perhaps more easily understood as:
	 count_if(group, condition)","count_if(scope, condition)
scopeから導き出されたリストの中で、評価された条件式（condition）を満たすノートの数をカウントします。
scopeは調査対象となるノートを指定します（スコープの定義）。
conditionは、有効な条件付きクエリテストを形成するアクションコードです。つまり、一致したときに真（true）となるものです。一部のクエリ形式の演算子では、正規表現を使用できる場合があります。
これはsum_if()を使用するのと同等であり、以下の2つのコード例は同じ結果になります。
	 sum_if(group, condition, 1) 
しかし、こちら（count_if）の方がおそらく理解しやすいでしょう：
	 count_if(group, condition)"
count(scope),Function,List,Data manipulation,Number,false,4.0.0,Baseline,,,,1,true,false,true,false,false,true,false,false,false,,false,"count(scope)
The function count() counts the Number of discrete items in the specified list, scope, which is defined as a group of items—i.e. one or more items. 
Most often, list may be a reference to a List or Set typed data. The list argument is evaluated so can use more than literal lists, including offset addresses like $Attribute(note) or more complex expressions to get data as long as the result is a list-based attribute (List or Set data types).
NOTE: where scope is a known List or Set type attribute reference, it is recommended and generally easier, and recommended, to use list.count (or alternatively the older less intuitive list.size); both the latter give the same outcome.
count(scope)
For example if $DisplayAttributes for the current note is [Color;AccentColor;NameFont] then the code
	$MyNumber = count($DisplayAttributes); 
is effectively
	$MyNumber = count([Color;AccentColor;NameFont]); 
and not surprisingly returns 3. Note that the count is not all unique values for the attribute across the whole TBX, scope is restricted to 'this' note or another nominated note. Specimen usage:
	$MyNumber = count($DisplayAttributes); 
	$MyNumber = count($DisplayAttributes(""some other note"")); 
To use count() with a list of items that are attributes or expressions, use list():
	Works: $MyNumber = count(list(4+2,9+6)); (output: 2)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Examples
The following is a trivial example (given we could use $ChildCount instead) but shows how count can be used in a more subtle way:
	$MyNumber = count(collect(children,$Name)); 
The result of collect is List-type data, in this case a number of note titles count(list) will return the number of values in the list (including duplicates). To get a de-duped count, chain the .unique operator to the list reference, inside the count() operator so the .unique filter is applied before the count is taken:
	$MyNumber = count(collect(children,$Name).unique);","count(scope)
count()関数は、指定されたリスト（scope）に含まれる個別の項目の数を数えます。scopeは項目のグループ、つまり1つ以上の項目として定義されます。
多くの場合、リストはList型またはSet型のデータへの参照です。リスト引数は評価されるため、リテラルなリストだけでなく、$Attribute(note)のようなオフセットアドレスや、結果がリストベースの属性（ListまたはSetデータ型）である限り、より複雑な式を使用してデータを取得することもできます。
注意：scopeが既知のList型またはSet型の属性参照である場合は、list.count（あるいは、より古く直感的ではないlist.size）を使用することをお勧めします。どちらも同じ結果が得られます。

count(scope)
例えば、現在のノートの$DisplayAttributesが[Color;AccentColor;NameFont]である場合、次のコードは
	$MyNumber = count($DisplayAttributes); 
実質的に
	$MyNumber = count([Color;AccentColor;NameFont]); 
となり、当然ながら3を返します。カウントはTBX全体にわたる属性のすべてのユニークな値ではなく、scopeは「この」ノートまたは指定された別のノートに限定されることに注意してください。使用例：
	$MyNumber = count($DisplayAttributes); 
	$MyNumber = count($DisplayAttributes(""some other note"")); 

属性や式である項目のリストでcount()を使用するには、list()を使用します：
	動作例：$MyNumber = count(list(4+2,9+6)); （出力：2）
リスト項目がアクションコードの式であるような、より複雑な例では、各リスト項目の式をeval()でラップする必要がある場合があります（例：list(eval(expressionA),eval(expressionB))）。

例
以下は（代わりに$ChildCountを使用できることを考えると）些細な例ですが、countをより巧妙な方法で使用する方法を示しています：
	$MyNumber = count(collect(children,$Name)); 
collectの結果はList型のデータであり、この場合は複数のノートのタイトルになります。count(list)は、リスト内の値の数（重複を含む）を返します。重複を除いたカウントを取得するには、count()演算子の中でリスト参照に.unique演算子をチェーンし、カウントが行われる前に.uniqueフィルタが適用されるようにします：
	$MyNumber = count(collect(children,$Name).unique);"
"covid([stateStr, countryStr|zipCodeStr], aDate, keywordStr)",Function,Item,Data manipulation,Number,false,8.7.0,Baseline,,,,4,true,false,false,false,false,false,false,true,false,,false,"covid(zipCodeStr, dateStr, keywordStr)
covid(stateStr, countryStr, aDate, keywordStr)
The operator covid() returns information about the 2020 pandemic of the COVID-19 virus.
covid(zipCodeStr, aDate, keywordStr)
Returns the number of cases, deaths, and recoveries reported that day in the US country that contains this zip code. For example
	$MyNumber = covid(""02148"", date(2020,1,4), ""cases""); 
This returns the number of cases reported in Middlesex County, Massachusetts for 4 January 2020. The keywordStr argument may be a quoted string with any of the following values:
* cases
* deaths
* recoveries
* name (the name of the county)
covid(stateStr, countryStr, aDate, keywordStr)
A four-argument variant allows you to query results by US state:
	$MyNumber = covid(""MA"",""US"",date(2020,1,4),""recoveries""); 
This returns the number of recoveries reported for the date 4 January 2020, from Massachusetts.
Data Source
Data are as reported by the Johns Hopkins Center For Systems Science and Engineering, and are provided by CovidNearMe.org and are provided strictly for educational and academic research purposes. Please note: data are copyright 2020 Johns Hopkins University.","covid(zipCodeStr, dateStr, keywordStr)
covid(stateStr, countryStr, aDate, keywordStr)
covid() オペレーターは、2020年の新型コロナウイルス（COVID-19）のパンデミックに関する情報を返します。
covid(zipCodeStr, aDate, keywordStr)
この郵便番号を含む米国の郡（county）において、その日に報告された症例数、死亡者数、および回復者数を返します。例えば：
	$MyNumber = covid(""02148"", date(2020,1,4), ""cases""); 
これは、2020年1月4日にマサチューセッツ州ミドルセックス郡で報告された症例数を返します。keywordStr 引数は、以下のいずれかの値を持つ引用符で囲まれた文字列を指定します：
* cases（症例数）
* deaths（死亡者数）
* recoveries（回復者数）
* name（郡の名前）
covid(stateStr, countryStr, aDate, keywordStr)
4引数のバリアントでは、米国の州ごとに結果を照会できます：
	$MyNumber = covid(""MA"",""US"",date(2020,1,4),""recoveries""); 
これは、2020年1月4日にマサチューセッツ州から報告された回復者数を返します。
データソース
データはジョンズ・ホプキンス大学システム科学工学センター（CSSE）によって報告され、CovidNearMe.org によって提供されています。これらは厳密に教育および学術研究目的で提供されています。注意：データの著作権は 2020 Johns Hopkins University に帰属します。"
"create([containerStr, ]nameStr)",Function,Item,Document configuration,String,false,8.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"create(name)
This creates a new note called nameStr at the designated location, and returns the full path to that note. If the designated note already exists, no new note is created and the operator returns the empty string.
The create() operator always returns the path to the new (or pre-existing) note.
This function needs no left-side expression argument, i.e. '$SomeAttribute=', to invoke it.
nameStr is typically actually a complete path:
	create(""/hardware/taps""); 
but if nameStr is a unique note $Name, a new note is created as a new (last) child of the current note, but only if nameStr does not already exist. For example:
	create(""taps""); 
Importantly, if nameStr is only a $Name and not a $Path, the note title nameStr it must be unique to the whole the current document. But, if nameStr is a $Path then it need only be unique within the current container. 
create(containerStr, nameStr)
A two-argument variant is also offered that allows the container for a new item to be specified, and the new item's $Name. The containerStr argument can be a path, an $ID, or an $IDString. This may be useful if you need to create several notes in the same container, for example is iterating a list with .each(). For example:
	create(""/hardware"",""taps""); 
Or, more pertinently, using a loop variable 'aPlace':
	$SomeList.each(aPlace){
		create(aPlace,""urgentTasks"");
	};
Essentially, the two-input form allows 3 forms of variation:
* different path, different name (via two nested loops—one for paths, one for names)
* different path, same name (loop with path variants)
* same path, different name (loop with name variants)
Designators and evaluation
Paths like that below, which mix literal and computed values are not evaluated, nor are inline designators:
	create(/Resources/Test/$MyString) 
Instead use code like this:
	var path=""/Resources/Test/""+$MyString;
	create(path);
Testing for pre-existing notes
Although create() will not re-create a note that already exists, a scenario in a big/complex document occurs where it may be necessary to run a number of action once only on newly created notes. How to test for a note already existing? Here is one possible solution:
	var:string vTestPath = ""/foo/bar/baz"";
	var:string vTest = $IDString(vTestPath);
	if(vTest==""""){
		$Text = create(vTestPath);
		// do tasks only needed once, for new notes
	};
A non-existent note cannot have an $IDString value. So by testing the $IDString(path) for the path of the note to be created before calling create(path), it is possible to ensure create() is only called if needed and in context all the code desired to be run, once, at new note creation.","create(name)
指定された場所に nameStr という名前の新しいノートを作成し、そのノートへのフルパスを返します。指定されたノートが既に存在する場合、新しいノートは作成されず、この演算子は空の文字列を返します。
create() 演算子は、常に新しい（または既存の）ノートへのパスを返します。
この関数を呼び出す際、「$SomeAttribute=」のような左辺の式引数は必要ありません。
nameStr は通常、実際には完全なパスです：
	create(""/hardware/taps""); 
しかし、nameStr が一意のノートの $Name である場合、nameStr がまだ存在しない場合に限り、現在のノートの新しい（最後の）子として新しいノートが作成されます。例えば：
	create(""taps""); 
重要な点として、nameStr が $Path ではなく $Name のみである場合、そのノートタイトル nameStr はドキュメント全体で一意である必要があります。しかし、nameStr が $Path である場合は、現在のコンテナ内でのみ一意であれば十分です。

create(containerStr, nameStr)
新しいアイテムのコンテナと名前を指定できる2引数のバリエーションも提供されています。containerStr 引数には、パス、$ID、または $IDString を指定できます。これは、例えば .each() でリストを反復処理して同じコンテナ内に複数のノートを作成する必要がある場合に便利です。例えば：
	create(""/hardware"",""taps""); 
あるいは、より適切にはループ変数「aPlace」を使用します：
	$SomeList.each(aPlace){
		create(aPlace,""urgentTasks"");
	};
本質的に、2引数形式では3つのパターンのバリエーションが可能です：
* 異なるパス、異なる名前（パス用と名前用の2つの入れ子になったループを使用）
* 異なるパス、同じ名前（パスを変化させるループ）
* 同じパス、異なる名前（名前を変化させるループ）

指定子と評価
以下のようにリテラルと計算された値を混在させたパスは評価されず、インライン指定子も評価されません：
	create(/Resources/Test/$MyString) 
代わりに次のようなコードを使用してください：
	var path=""/Resources/Test/""+$MyString;
	create(path);

既存のノートの確認
create() は既に存在するノートを再作成することはありませんが、大規模で複雑なドキュメントでは、新しく作成されたノートに対してのみ一度だけアクションを実行したいというシナリオが発生します。ノートが既に存在するかどうかをテストするにはどうすればよいでしょうか？一つの解決策は以下の通りです：
	var:string vTestPath = ""/foo/bar/baz"";
	var:string vTest = $IDString(vTestPath);
	if(vTest==""""){
		$Text = create(vTestPath);
		// 新しいノート作成時に一度だけ必要なタスクを実行
	};
存在しないノートは $IDString の値を持ちません。そのため、create(path) を呼び出す前に作成予定のパスの $IDString(path) をチェックすることで、必要な場合にのみ create() が呼び出されるようにし、新しいノート作成時に一度だけ実行したいコードを確実に実行させることができます。"
"createAdornment([containerStr, ] nameStr)",Function,Item,Document configuration,String,false,9.5.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"createAdornment([containerStr, ] nameStr)
The operator createAdornment(), creates an adornment at the designated path. If an adornment already exists with that path, no new adornment is created.
createAdornment(nameStr)
This creates a new adornment called nameStr at the designated location, and returns the full path to that adornment. If the designated adornment already exists, no new adornment is created and the operator returns the empty string.
The createAdornment() operator always returns the path to the new (or pre-existing) adornment. Previously, if the adornment already existed, the operator returned false.
This function needs no left-side expression argument, i.e. '$SomeAttribute=', to invoke it.
nameStr is typically actually a complete path:
	create(""/hardware/taps""); 
but if nameStr is a unique note $Name, a new adornment is created as a child of the current note. For example:
	createAdornment(""taps""); 
createAdornment(containerStr, nameStr)
A two-argument variant is also offered that allows the container for a new item to be specified, and the new item's $Name. The containerStr argument can be a path, an $ID, or an $IDString. This may be useful if you need to create several adornments in the same container, for example is iterating a list with .each(). For example:
	createAdornment(""/hardware"",""taps""); 
Or, more pertinently, using a loop variable 'aPlace':
	$SomeList.each(aPlace){
		createAdornment(aPlace,""urgentTasks"");
	};
Essentially, the two-input form allows 3 forms of variation:
* different path, different name (via two nested loops—one for paths, one for names)
* different path, same name (loop with path variants)
* same path, different name (loop with name variants)
The createAdornment() operator evaluates its first argument, permitting use of an expression to compute a value. Note that this means that paths should be quoted: createAdornment(""/Containers/People/Mark"") , as otherwise parts of paths may be evaluated as expressions. 
Designators and evaluation
Paths like that below, which mix literal and computed values are not evaluated, nor are inline designators:
	createAdornment(/Resources/Test/$MyString) 
Instead use code like this:
	var path=""/Resources/Test/""+$MyString;
	createAdornment(path);","createAdornment([containerStr, ] nameStr)
createAdornment() オペレーターは、指定されたパスにアドーンメントを作成します。そのパスに既にアドーンメントが存在する場合、新しいアドーンメントは作成されません。

createAdornment(nameStr)
これは指定された場所に nameStr という名前の新しいアドーンメントを作成し、そのアドーンメントへのフルパスを返します。指定されたアドーンメントが既に存在する場合、新しいアドーンメントは作成されず、オペレーターは空の文字列を返します。
createAdornment() オペレーターは、常に新しい（または既存の）アドーンメントへのパスを返します。以前は、アドーンメントが既に存在する場合、このオペレーターは false を返していました。
この関数を呼び出すのに、「$SomeAttribute=」のような左辺の式は必要ありません。

nameStr は通常、完全なパスです：
	create(""/hardware/taps""); 
ただし、nameStr が一意のノートの $Name である場合、新しいアドーンメントは現在のノートの子として作成されます。例：
	createAdornment(""taps""); 

createAdornment(containerStr, nameStr)
新しい項目のコンテナと、その項目の $Name を指定できる2引数のバリアントも提供されています。containerStr 引数には、パス、$ID、または $IDString を指定できます。これは、例えば .each() でリストを反復処理する際など、同じコンテナ内に複数のアドーンメントを作成する必要がある場合に便利です。例：
	createAdornment(""/hardware"",""taps""); 

あるいは、より適切には、ループ変数 'aPlace' を使用します：
	$SomeList.each(aPlace){
		createAdornment(aPlace,""urgentTasks"");
	};

本質的に、2引数形式では3つのバリエーションが可能です：
* 異なるパス、異なる名前（パス用と名前用の2つのネストされたループを使用）
* 異なるパス、同じ名前（パスが変化するループ）
* 同じパス、異なる名前（名前が変化するループ）

createAdornment() オペレーターは最初の引数を評価し、計算式の使用を可能にします。パスの一部が式として評価されるのを避けるため、パスは引用符で囲む必要があることに注意してください：createAdornment(""/Containers/People/Mark"") 

指定子と評価
以下のように、リテラルと計算された値を混在させたパスや、インライン指定子は評価されません：
	createAdornment(/Resources/Test/$MyString) 
代わりに次のようなコードを使用してください：
	var path=""/Resources/Test/""+$MyString;
	createAdornment(path);"
"createAgent([containerStr, ]nameStr)",Function,Item,Document configuration,String,false,8.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"createAgent(nameStr)
This creates a new agent called nameStr at the designated location, and returns the full path to that agent. If the designated agent already exists, no new agent is created and the operator returns the empty string.
The create() operator always returns the path to the new (or pre-existing) agent.
This function needs no left-side expression argument, i.e. '$SomeAttribute=', to invoke it.
nameStr is typically actually a complete path:
	createAgent(""/agents/urgentTasks""); 
but if name is a unique agent $Name, a new agent is created as a child of the current note. Be aware though that cannot be used if the current object is an agent rather than a note. For example:
	create(""urgentTasks""); 
create(containerStr, nameStr)
A two-argument variant is also offered that allows the container for a new item to be specified, and the new item's $Name. The containeStr argument can be a path, an $ID, or an $IDString. This may be useful if you need to create several agents in the same container, for example is iterating a list with .each(). For example:
	create(""/agents"",""urgentTasks""); 
Or, more pertinently, using a loop variable 'aPlace':
	$SomeList.each(aPlace){
		create(aPlace,""urgentTasks"");
	};
Essentially, the two-input form allows 3 forms of variation:
* different path, different name (via two nested loops—one for paths, one for names)
* different path, same name (loop with path variants)
* same path, different name (loop with name variants)
Designators and evaluation
Paths like that below, which mix literal and computed values are not evaluated, nor are inline designators:
	createAgent(""Resources/Test/$MyString) 
Instead use code like this:
	var:string vPath=""/Resources/Test/""+$MyString;
	createAgent(vPath);","createAgent(nameStr)
指定した場所に nameStr という名前の新しいエージェントを作成し、そのエージェントへのフルパスを返します。指定したエージェントが既に存在する場合、新しいエージェントは作成されず、このオペレータは空の文字列を返します。
なお、create() オペレータは常に、新規作成された（または既存の）項目のパスを返します。
この関数を呼び出す際、左辺の式（例：$SomeAttribute=）は不要です。
nameStr は通常、以下のような完全なパスで指定します：
    createAgent(""/agents/urgentTasks"");
ただし、名前がユニークな $Name である場合、現在のノートの子として新しいエージェントが作成されます。ただし、現在のオブジェクトがノートではなくエージェントである場合は、この方法は使用できないことに注意してください。例：
    create(""urgentTasks"");

create(containerStr, nameStr)
作成する項目のコンテナと $Name を指定できる2引数形式も用意されています。containerStr 引数には、パス、$ID、または $IDString を使用できます。これは、例えば .each() でリストを反復処理しながら、同じコンテナ内に複数のエージェントを作成する必要がある場合に便利です。例：
    create(""/agents"",""urgentTasks"");
あるいは、ループ変数 'aPlace' を使用する場合：
    $SomeList.each(aPlace){
        create(aPlace,""urgentTasks"");
    };
基本的に、2引数形式では以下の3パターンのバリエーションが可能です：
* 異なるパス、異なる名前（パス用と名前用の2つのネストされたループを使用）
* 異なるパス、同じ名前（パスを変化させるループ）
* 同じパス、異なる名前（名前を変化させるループ）

指定子と評価
以下のように、リテラルと計算された値を混在させたパスは評価されません。また、インライン指定子も評価されません：
    createAgent(""Resources/Test/$MyString"")
代わりに、次のようなコードを使用してください：
    var:string vPath=""/Resources/Test/""+$MyString;
    createAgent(vPath);"
"createAlias(containerStr, originalNote)",Function,Item,Document configuration,String,false,11.5.0,11.5.0,,11.5.0,,2,true,false,false,false,false,false,false,false,false,,false,"createAlias(containerStr, nameStr)
This creates a new alias of nameStr in the designated container at path containerStr. If successful, the operator returns the path of the newly created alias. If a unique, nameStr can be a $Name but will more likely be a $Path value.
Important. Note that the alias must be created in a container other than the container that holds the original note.
Example:
	var:string vNewAlias = createAlias(/path/to/Acontainer,""Foo""); 
The result is that an alias of the note 'Foo' is generated at path /path/to/Acontainer/Foo.","createAlias(containerStr, nameStr)
これは、path containerStrで指定されたコンテナ内に、nameStrの新しいエイリアスを作成します。成功した場合、このオペレータは新しく作成されたエイリアスのパスを返します。名前が一意であれば、nameStrは$Nameにすることもできますが、通常は$Path値を指定します。
重要：エイリアスは、元のノートが格納されているコンテナとは別のコンテナに作成しなければならないことに注意してください。
例：
	var:string vNewAlias = createAlias(/path/to/Acontainer,""Foo""); 
その結果、ノート「Foo」のエイリアスがパス「/path/to/Acontainer/Foo」に生成されます。"
"createAttribute(nameStr[, dataType])",Function,Item,Document configuration,n/a - no return,false,9.2.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"createAttribute(nameStr[, dataType])
The operator createAttribute(name[, type]) can create a new user attributes. If an attribute of the same nameStr already exists, the operator has no effect and returns false. Otherwise, a new user attribute is created. The nameStr argument is case-sensitive and should use the capitalisation as for the desired attribute. Thus nameStr values of Test and test result in different attributes called 'Test' and 'test'.
Optionally, a dataType argument may be supplied to determine the data type of the new attribute. Recognised values for dataType include: string, number, boolean, date, color, interval, file, list, set, url, email, and dictionary. If no dataType valued is supplied, Tinderbox creates a String-type attribute. The dataType argument is case-sensitive: number produces a number type attribute, but Number would result in a (default) string type attribute.
A basic example using just the nameStr argument, results in a new String-type attribute called 'SomeList':
	$MyBoolean = createAttribute(""SomeList""); 
But, in the example above, the chosen name for the new attribute indicates the intended data-type should be of List data type. Therefore, use of the optional dataType argument would make more sense to signal user intent to Tinderbox more clearly:
	$MyBoolean = createAttribute(""SomeList"", ""list""); 
Again, the action results in a new String-type attribute called 'SomeList'.
Note that action code cannot alter the new attribute's name or type, nor delete the attribute. This can be done but only via the User attribute inspector.
Some other aspects of the attribute, e.g. default value) can be changed after the attribute is created, using attribute(). Here below, a number-type attribute is created, its default is set and then a value is applied:
	createAttribute(""Tester"",""number""); 
	attribute(""Tester"")[""default""] = 10; 
	$Tester = 1000;","createAttribute(nameStr[, dataType])

createAttribute(name[, type]) オペレータは、新しいユーザ属性を作成できます。nameStr と同じ名前の属性が既に存在する場合、このオペレータは何も行わず false を返します。存在しない場合は、新しいユーザ属性が作成されます。引数 nameStr は大文字と小文字を区別するため、作成したい属性と同じキャピタライゼーション（大文字・小文字の使い分け）を使用する必要があります。したがって、nameStr の値が Test と test の場合、それぞれ 'Test' と 'test' という異なる属性が作成されます。

オプションで dataType 引数を指定して、新しい属性のデータ型を決定できます。dataType に指定可能な値には、string、number、boolean、date、color、interval、file、list、set、url、email、dictionary が含まれます。dataType の値が指定されない場合、Tinderbox は String 型の属性を作成します。dataType 引数は大文字と小文字を区別します。例えば、number は数値（number）型の属性を作成しますが、Number と指定した場合は（デフォルトの）文字列（string）型の属性になります。

nameStr 引数のみを使用した基本的な例では、'SomeList' という名前の String 型属性が新しく作成されます。
	$MyBoolean = createAttribute(""SomeList""); 

しかし、上記の例で選ばれた名前は、意図したデータ型が List 型であることを示唆しています。そのため、オプションの dataType 引数を使用して、Tinderbox にユーザの意図をより明確に伝える方が合理的です。
	$MyBoolean = createAttribute(""SomeList"", ""list""); 
このアクションにより、再び 'SomeList' という名前の String 型属性が作成されます。

アクションコードでは、新しい属性の名前や型を変更したり、属性を削除したりすることはできません。これらが行えるのは「User属性インスペクタ」からのみです。

属性のその他の側面（例：デフォルト値）については、属性の作成後に attribute() を使用して変更できます。以下の例では、数値型の属性が作成され、そのデフォルト値が設定された後、値が代入されています。
	createAttribute(""Tester"",""number""); 
	attribute(""Tester"")[""default""] = 10; 
	$Tester = 1000;"
"createLink(sourceItem, destinationItem[, linkTypeStr])",Function,Item,Linking,success boolean,false,9.1.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"createLink(sourceItem,destinationItem[, linkTypeStr]) 
The operator createLink() can be used for link creation. This is useful when neither the source nor the destination of the link are this note. The arguments sourceItem and destinationItem must be defined so as to identify a single (existing) item.
Example:
	$MyList2.each(anItem2){
		$MyList.each(anItem1){
			createLink(anItem1,anItem2);
		};
	};
createLink() may also cope better than linkTo() and linkFrom() with the edge case when a note's $Name (or those of other notes in the note's path) contain forward slashes. Such paths are challenge as in string form the differing meaning of the use of slashes (container delimiter vs. note title) is ambiguous to the parser.
Optionally, a link type for the new link may be specified using linkTypeStr. If that link type does not exist, it is created.","createLink(sourceItem,destinationItem[, linkTypeStr])
演算子 createLink() はリンクの作成に使用できます。これは、リンクのソースもデスティネーションも現在のノートではない場合に便利です。引数の sourceItem および destinationItem は、単一の（実在する）アイテムを特定できるように定義される必要があります。
例：
	$MyList2.each(anItem2){
		$MyList.each(anItem1){
			createLink(anItem1,anItem2);
		};
	};
createLink() は、ノートの $Name（またはそのノートのパスに含まれる他のノートの名前）にフォワードスラッシュが含まれているというエッジケースにおいて、linkTo() や linkFrom() よりも適切に処理できる場合があります。このようなパスは、文字列形式ではスラッシュの異なる意味（コンテナの区切り文字か、ノートのタイトルか）がパーサーにとって曖昧になるため、扱いが困難です。
オプションとして、linkTypeStr を使用して新しいリンクのリンクタイプを指定できます。そのリンクタイプが存在しない場合は、作成されます。"
Date.day(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.day()
Date.day
Returns the 1 or 2 digit day for the Date-type attribute specified. Valid range 1-31.
If $MyDate is 25 Oct 1415 16:20 then:
	$MyNumber = $MyDate.day; sets $MyNumber to 25 
The operator may also be used to set the attribute's day, using a valid figure
	$MyDate.day = 20; sets the day of $MyDate to 20th of the month","Date.day()
Date.day
指定された日付型（Date-type）属性の、1桁または2桁の日（day）を返します。有効な範囲は1～31です。
$MyDateが1415年10月25日 16:20である場合：
	$MyNumber = $MyDate.day; は $MyNumberを25に設定します。
このオペレーターは、有効な数値を使用して属性の日を設定するためにも使用できます。
	$MyDate.day = 20; は $MyDateの日をその月の20日に設定します。"
Date.format(formatStr),Function,Item,Formatting,String,false,5.8.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Date.format(formatStr)
Returns Date as a String, formatted as per the quoted date format string formatStr.
This supplements the existing format() function.
For example:
	$MyString = $MyDate.format(""L"") 
gets the note's creation date and formats it as a ""long local date"" such as ""Sunday, 23 March, 2007"" and sets that as the value of $MyString.
If data is a date, the format string is the same as the format used by Tinderbox's date format codes.","Date.format(formatStr)
引用符で囲まれた日付フォーマット文字列 formatStr に基づいて、日付を文字列として返します。
これは既存の format() 関数を補完するものです。
例：
	$MyString = $MyDate.format(""L"") 
は、ノートの作成日を取得し、「2007年3月23日日曜日」のような「長いローカル形式の日付」としてフォーマットして、その値を $MyString に設定します。
データが日付である場合、フォーマット文字列は Tinderbox の日付フォーマットコードで使用されるものと同じです。"
Date.hour(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.hour()
Date.hour
Returns the 1 or 2 digit hour for the Date-type attribute specified. Valid range 0-23.
If $MyDate is 25 Oct 1415 16:20 then:
	$MyNumber = $MyDate.hour; returns 16 
The operator may also be used to set the attribute's hour, using a valid figure
	$MyDate.hour = 20; sets the hour to 20 (8 PM) 
Setting time
If wanting to alter the hours element of a Date's time—or multiple time elements in one action, consider using time().","Date.hour()
Date.hour
指定された日付型属性の1桁または2桁の「時」を返します。有効な範囲は0〜23です。
$MyDateが1415年10月25日 16:20の場合：
	$MyNumber = $MyDate.hour; は16を返します。
このオペレータは、有効な数値を使用して属性の「時」を設定するためにも使用できます。
	$MyDate.hour = 20; は時間を20（午後8時）に設定します。
時刻の設定
日付の時刻の「時」要素を変更したい場合、または一度に複数の時刻要素を変更したい場合は、time()の使用を検討してください。"
Date.minute(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.minute()
Date.minute
Returns the 1 or 2 digit minute for the Date-type attribute specified. Valid range 0-59.
If $MyDate is 25 Oct 1415 15:20 then:
	$MyNumber = $MyDate.minute; returns 20 
The operator may also be used to set the attribute's minute, using a valid figure
	$MyDate.minute = 36; sets the minute to 36th of the hour 
Setting time
If wanting to alter the minutes element of a Date's time—or multiple time elements in one action, consider using time().","Date.minute()
Date.minute
指定されたDate型属性の分を1桁または2桁の数値で返します。有効な範囲は0〜59です。
$MyDateが1415年10月25日 15:20の場合：
	$MyNumber = $MyDate.minute; // 20を返します
このオペレータは、有効な数値を使用して属性の分を設定するためにも使用できます。
	$MyDate.minute = 36; // 分をその時間の36分に設定します
時刻の設定
Dateの時刻の分要素を変更したい場合、または一度のアクションで複数の時刻要素を同時に変更したい場合は、time()の使用を検討してください。"
Date.month(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.month()
Date.month
Returns the 1 or 2 digit month for the Date-type attribute specified. Valid range 1-12.
If $MyDate is 25 Oct 1415 15:20 then:
	$MyNumber = $MyDate.month returns 10 
The operator may also be used to set the attribute's month, using a valid figure.
	$MyDate.month = 6; sets the month to 6 (June)","Date.month()
Date.month
指定された日付（Date）型属性の、1桁または2桁の月を返します。有効な範囲は1〜12です。
$MyDateが 1415年10月25日 15:20 の場合：
	$MyNumber = $MyDate.month は 10 を返します。
このオペレーターは、有効な数値を使用して属性の月を設定するためにも使用できます。
	$MyDate.month = 6; は月を 6（6月）に設定します。"
Date.second(),Property,Item,Date-time,Number,false,6.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.second()
Date.second
Returns the 1 or 2 digit seconds for the Date-type attribute specified. Valid range 0-59.
If $MyDate is 25 Oct 1415 15:20:06 then:
	$MyNumber = $MyDate.second returns 6 
The operator may also be used to set the attribute's month, using a valid figure
	$MyDate.second = 24; sets the seconds element of the time to 24.
Setting time
If wanting to alter the seconds element of a Date's time—or multiple time elements in one action, consider using time().","Date.second()
Date.second
指定された日付型（Date-type）属性の1桁または2桁の秒を返します。有効な範囲は0〜59です。
$MyDate が 1415年10月25日 15:20:06 の場合：
	$MyNumber = $MyDate.second は 6 を返します。
このオペレーターは、有効な数値を使用して属性の秒（原文ではmonthとなっていますが、文脈上「秒」を指します）を設定するためにも使用できます。
	$MyDate.second = 24; は時刻の秒の要素を24に設定します。
時刻の設定
Dateの時刻の秒の要素を変更したい場合、あるいは一度のアクションで複数の時刻要素を変更したい場合は、time() の使用を検討してください。"
Date.week(),Property,Item,Date-time,Number,false,7.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.week()
Date.week
The Date operator .week() returns the number of the week in the current year. For example, January 1 is in week 1. 
Be aware that to allow for the fact the calendar year and week start are only aligned every seventh year, in some years days that the very end of the year may report as week #53.
Date.week() is read-only.
	$MyNumber = $MyDate.week(); 
Thus is $MyDate is 4 January, $MyNumber would be 1.","Date.week()
Date.week
Dateオペレータの .week() は、現在の年の週番号を返します。例えば、1月1日は第1週です。
暦年と週の開始が一致するのは7年ごとのみであるため、年によっては年末の数日が第53週として報告される場合があることに注意してください。
Date.week() は読み取り専用です。
	$MyNumber = $MyDate.week(); 
したがって、$MyDate が1月4日の場合、$MyNumber は 1 になります。"
Date.weekday(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.weekday()
Date.weekday
Returns the day number for the Date-type attribute specified. Value range is 1-7. Days number from 1 (Monday) to 7 (Sunday). This numbering allows easy testing for weekday (#1-5) vs. weekend (#6-7).
This operator is read-only and cannot be used to change a Date attributes value.
	$MyNumber = $MyDate.weekday; 
Thus if the day of $MyDate is Tuesday, $MyNumber would be 2.","I will translate the text for the `Date.weekday` operator into Japanese, maintaining technical accuracy for Tinderbox documentation.

Date.weekday()
Date.weekday
指定されたDate型属性の曜日に対応する数値を返します。値の範囲は1〜7です。1（月曜日）から7（日曜日）まで順に番号が割り当てられます。この番号付けにより、平日（1〜5）か週末（6〜7）かの判定を容易に行うことができます。
このオペレーターは読み取り専用であり、Date型属性の値を変更するために使用することはできません。
	$MyNumber = $MyDate.weekday; 
例えば、$MyDateが火曜日の場合、$MyNumberは2になります。"
Date.year(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.year()
Date.year
Returns the 1 to 4 digit year for the Date-type attribute specified.
If $MyDate is 25 Oct 1415 16:20 then:
	$MyNumber = $MyDate.year; returns 1415 
The operator may also be used to set the attribute's day, using a valid figure
	$MyDate.year = 1805; sets the year to 1805","Date.year()
Date.year
指定されたDate型属性の1〜4桁の年を返します。
$MyDateが1415年10月25日 16:20の場合：
	$MyNumber = $MyDate.year; は1415を返します。
このオペレータは、有効な数値を使用して属性の年を設定するためにも使用できます。
	$MyDate.year = 1805; は年を1805に設定します。"
date(dateStr),Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"date(dateStr) 
This constructs a Date-type object from a quoted string or string expression. Note there is an alternate method for specifying a date using the discrete elements (year, month, etc.), see here.
Originally, this is not necessary and Tinderbox would coerce the bare  dateStr to a Date-type automatically. This can still happen but best practice, now action code is more complex, is to be more explicit as to intent  by using the date() operator. (See format() and .format() to convert dates into strings).
Note that in the examples below, whilst the date() operator creates Date-type data, the examples below are actually coercing it back into a string. As formatting is locale dependent and as aTbRef is written using a UK locale (en-GB), the examples below use day-month order. Thus should be correct for most of the world except the USA and the Philippines where moth-day order is used and where readers will need to transpose the month and day segments of the example output. The action code shown is being exported via value().
Note that the seconds element of stored Date data is ignored (from v5 onwards). Thus, if present in the Date, seconds are not used and instead are coerced to '00'.
Default: using $MyDate = date(""24/10/2009""); will set $MyDate to a """" (24 October 2009). If no time is supplied hh:mm:ss are set at current system time when $MyDate is set.  In the example here, the equivalent date is set on the fly via value() so the time is the system time as at exporting the note to HTML. The resulting string is the same as you see for a date displayed as a Displayed Attribute. The exact format will depend on the users international settings—also see Document Settings ▸ Displayed Attributes date format.
Now, as above but providing an explicit time element, omitting seconds: $MyDate = date(""24/10/2009 01:30:22"") gives $MyDate a value of """"; the specified time gets used, with the seconds added in as per the system clock. If providing a full hh:mm:ss string this is honoured.
But, if you use a date formatting string, you get a formatted string of the date:
	$MyString = date(""24/10/2009 01:30:00"").format(""l""); gives $MyString a value of """"
or:
	$MyString = date(""24/10/2009 01:30:00"").format(""*""); gives $MyString a value of """"
The two methods are equivalent, note also the change of format due to use of a date format string.
An attribute can also provide part of the input:
	$EndDate = date($StartDate+""7 days""); 
With care this can be extended. In the following, $MyString is ""7 days"" and $MyNumber is 7. The outcome is that $MyDateA/B/C are all set to the same date:
	$MyDateA = date($MyDate+""7 days""); 
	$MyDateB = date($MyDate+$MyString); 
	$MyDateC = date($MyDate+($MyNumber+"" days"")); note the extra parentheses here are optional but suggested","date(dateStr) 
引用符で囲まれた文字列または文字列式からDate型のオブジェクトを構築します。個別の要素（年、月など）を使用して日付を指定する別の方法については、こちらを参照してください。

元来、これは必須ではなく、Tinderboxは生のdateStrを自動的にDate型に強制変換（coerce）していました。現在でも可能ですが、アクションコードが複雑になっているため、date()オペレータを使用して意図をより明確にすることがベストプラクティスです。（日付を文字列に変換する方法については、format()および.format()を参照してください）。

以下の例では、date()オペレータはDate型のデータを作成していますが、実際にはそれを文字列に再変換しています。書式設定はロケールに依存し、aTbRefは英国ロケール（en-GB）を使用して書かれているため、以下の例では「日/月」の順序を使用しています。したがって、米国やフィリピン（月/日の順序が使用されるため、読者は例の出力の月と日のセグメントを入れ替える必要があります）を除く世界のほとんどの地域で正しいはずです。示されているアクションコードは、value()を介してエクスポートされています。

保存されたDateデータの秒要素は無視されます（v5以降）。したがって、Dateに秒が含まれていても使用されず、代わりに「00」に強制されます。

デフォルト：$MyDate = date(""24/10/2009""); を使用すると、$MyDateに """" (2009年10月24日) が設定されます。時刻が指定されていない場合、$MyDateが設定された時のシステム時刻がhh:mm:ssに設定されます。ここでの例では、同等の日付がvalue()を介して動的に設定されるため、時刻はノートをHTMLにエクスポートした時点のシステム時刻になります。結果の文字列は、表示属性（Displayed Attribute）として表示される日付と同じになります。正確な形式はユーザーの国際設定に依存します。Document Settings ▸ Displayed Attributesの日付形式も参照してください。

上記と同様に、秒を省略して明示的な時刻要素を指定する場合：$MyDate = date(""24/10/2009 01:30:22"") は $MyDate に """" という値を与えます。指定された時刻が使用され、システムクロックに従って秒が追加されます。完全なhh:mm:ss文字列を指定した場合は、それが尊重されます。

ただし、日付書式文字列を使用すると、書式設定された日付文字列が得られます：
	$MyString = date(""24/10/2009 01:30:00"").format(""l""); は $MyString に """" という値を与えます。
または：
	$MyString = date(""24/10/2009 01:30:00"").format(""*""); は $MyString に """" という値を与えます。
これら2つの方法は同等です。日付書式文字列の使用による書式の変化にも注意してください。

属性を入力の一部として提供することもできます：
	$EndDate = date($StartDate+""7 days""); 

これは慎重に拡張することができます。以下では、$MyStringは ""7 days""、$MyNumberは 7 です。結果として、$MyDateA/B/Cはすべて同じ日付に設定されます：
	$MyDateA = date($MyDate+""7 days""); 
	$MyDateB = date($MyDate+$MyString); 
	$MyDateC = date($MyDate+($MyNumber+"" days"")); 注：ここでの余分な括弧はオプションですが、推奨されます。"
"date(yearNum, monthNum, dayNum[, hourNum, minNum])",Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,5,true,false,false,false,false,false,false,true,false,,false,"date(yearNum, monthNum, dayNum[, hourNum, minNum])
constructs a Date from individual numeric elements. This is useful, for example, if you need to assemble a date from separate attributes. Note an alternate method for specifying dates using a String representation of the whole date (or date/time), see here.
year is the 4-digit year
month is a number from 1–12
day is a number from 1 to 31
The time arguments are optional, and are specified in a 24-hour clock.
hour is a number from 0 to 23
minute is a number from 0 to 59
Using this operator, do not quote the whole argument list: these should be left as individual numbers.
Wrong: $MyDate = date(""2004,7,23,16,45""); 
Right: $MyDate = date(2004,7,23,16,45); 
Examples:
	$MyDate = date(2004,7,23,16,45); …sets 23 July 2004 16:45","date(yearNum, monthNum, dayNum[, hourNum, minNum])
個別の数値要素から日付を作成します。これは、例えば、別々の属性から日付を組み立てる必要がある場合に便利です。日付全体（または日付と時刻）を文字列で指定する別の方法については、こちらを参照してください。
year は4桁の西暦
month は1〜12の数値
day は1〜31の数値
時刻の引数はオプションであり、24時間制で指定します。
hour は0〜23の数値
minute は0〜59の数値
この演算子を使用する際、引数リスト全体を引用符で囲まないでください。これらは個別の数値として記述する必要があります。
誤：$MyDate = date(""2004,7,23,16,45""); 
正：$MyDate = date(2004,7,23,16,45); 
例：
	$MyDate = date(2004,7,23,16,45); …2004年7月23日 16:45に設定されます。"
"day(aDate, dayNum)",Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"day(theDate, dayNum)
creates a new Date based on the aDate expression, but in which the day of the month is dayNumDate is not changed unless theDate is an attribute and the attribute is re-setting itself:
	$MyDateA = day($MyDate,14); $MyDate is unaltered
	$MyDate = day($MyDate,14); $MyDate is changed
Examples. If $MyDate is July 4, 2009 then
	$MyNumber = day($MyDate); …is 4
If $MyDate is July 4,2009, then 
	$MyDate = day($MyDate,5); 
will change $MyDate to July 5, 2009.
The single-argument merthod, used to read the day in the date is documented separately: see day(aDate).","day(theDate, dayNum)
theDate式に基づき、日の値をdayNumに変更した新しい日付を作成します。theDateが属性であり、その属性自体を再設定しない限り、元の日付は変更されません。
	$MyDateA = day($MyDate,14); $MyDateは変更されません
	$MyDate = day($MyDate,14); $MyDateは変更されます
例：$MyDateが2009年7月4日の場合
	$MyNumber = day($MyDate); …は4
$MyDateが2009年7月4日の場合
	$MyDate = day($MyDate,5); 
を実行すると、$MyDateは2009年7月5日に変更されます。
日付から日を読み取るために使用される引数1つのメソッドは、別途「day(aDate)」でドキュメント化されています。"
day(aDate),Function,Item,Date-time,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"day(aDate)
returns, as a Number, the day of the month from the aDate expression, which may simply be a date-type attribute value.
	$MyNumber = day($MyDate); 
Alternatively, use Date.day.
The two-argument method, used to alter a Date, is documented separately: see day(aDate, dayNum).","day(aDate)
aDate式（単なる日付型の属性値でも可）から、月の日を数値として返します。
	$MyNumber = day($MyDate); 
あるいは、Date.dayを使用してください。
日付を変更するために使用される2引数のメソッドは、別に説明されています。day(aDate, dayNum)を参照してください。"
"days(firstDate, lastDate)",Function,Item,Date-time,Number,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"days(firstDate, lastDate) 
returns the Number of 'days' (as defined below) that elapsed between firstDate and lastDate. If lastDate is earlier than firstDate then the result is negative. 
The operator returns the number of 24-hour blocks [sic] between two dates, rounded toward zero. So if days() measures the difference between a date/time of 09:30 today and 08:30 tomorrow, the result is 0 (zero) as the difference is only 23 hours. If the times are same a whole day increment is recorded. 
Thus days does not return a simplistic calendar day difference as some users might intuit it would. If times vary between firstDate and lastDate, the returned difference figure may thus be one day high or low of an expected calendar day-based value.
If $DateA is 3 January 2016 and $DateB is 9 January 2016, then:
	$MyNumber = days($DateA,$DateB); 
sets $MyNumber to 6.
Also see minutes(date1,date2).","days(firstDate, lastDate)
firstDateとlastDateの間に経過した（以下で定義される）「日」数を返します。lastDateがfirstDateよりも前の場合は、結果は負の数になります。
このオペレーターは、2つの日付の間の24時間単位のブロック（[原文ママ]）の数を返し、0の方向に丸めます。したがって、days()が今日の09:30と明日の08:30の差を測定する場合、その差は23時間しかないため、結果は0（ゼロ）になります。時刻が同じであれば、丸1日の増分が記録されます。
このように、daysは一部のユーザーが直感的に期待するような単純なカレンダー上の日付の差を返すわけではありません。firstDateとlastDateの間で時刻が異なる場合、返される差の数値は、期待されるカレンダーに基づいた値から1日程度前後する可能性があります。
$DateAが2016年1月3日で、$DateBが2016年1月9日の場合：
	$MyNumber = days($DateA,$DateB);
は、$MyNumberを6に設定します。
minutes(date1,date2)も参照してください。"
degrees(radiansNum),Function,Item,Mathematical,Number,false,6.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"degrees(radiansNum)
Takes an angle argument, radiansNum, specified in radians and return the angle in degrees.
	$MyNumber = degrees(6); 
returns 343.7746771 for an input of 6 radians.
See also radians() which converts an angle in degrees to radians.","degrees(radiansNum)
ラジアンで指定された角度引数 radiansNum を受け取り、その角度を度数法で返します。
	$MyNumber = degrees(6);
6ラジアンの入力に対して 343.7746771 を返します。
度数法の角度をラジアンに変換する radians() も参照してください。"
delete(scope),Function,Group,Data manipulation,success boolean,false,8.7.0,Baseline,,,,1,true,false,false,false,false,true,false,false,false,,false,"delete(scope)
Deletes the note(s) designated by scope; defining scope. If a designated note does not exist, the expression has no effect and returns false, i.e. nothing happens: no deletion, no message of no deletion. If the designated note exists, it will be deleted and the expression returns its former path.
	delete(""Some note""); 
However, it is strongly suggesting using a path ($Path) for scope and not just the note's title ($Name), thus:
	delete(""/The/path/to/Some note""); 
Avoid using this operator when possible. It can automatically delete notes you intended to create, and it can potentially saw off the branch you are standing on. In almost all circumstances, it is better to move the unwanted note to a container, and then to delete the note manually if you really need to delete it at all.
The delete() operator returns true if at least one note was deleted, and false otherwise.","scopeで指定されたノートを削除します。scopeを定義してください。指定されたノートが存在しない場合、式は何の効果も持たず、falseを返します。つまり、削除も行われず、削除されなかったというメッセージも出ません。指定されたノートが存在する場合、それは削除され、式はそのノートの以前のパスを返します。
	delete(""Some note""); 
ただし、scopeにはノートのタイトル（$Name）だけでなく、パス（$Path）を使用することを強く推奨します。
	delete(""/The/path/to/Some note""); 
可能な限りこのオペレーターの使用は避けてください。作成しようとしたノートを自動的に削除してしまう可能性があり、また、自分自身が立っている枝を切り落としてしまう（実行中のコンテキスト自体を削除してしまう）可能性もあります。ほとんどすべての場合において、不要なノートはコンテナに移動させ、本当に削除する必要がある場合にのみ手動で削除する方が適切です。
delete() オペレーターは、少なくとも1つのノートが削除された場合に true を返し、そうでない場合に false を返します。"
descendedFrom(item),Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"descendedFrom(item)
Returns Boolean true if item is an ancestor of the current note, i.e. it matches all descendants of item however deep the outline branch beneath it.
The item argument must be quoted unless an attribute reference. Ways to define item.
To return a Set of all items descended from container at path '/foo/bar' use the query:
	descendedFrom(/foo/bar) 
Or if 'bar' is a unique title in the document, $Name alone can be used:
	descendedFrom(""bar"") 
the latter being the form most usually encountered.
Unlike the paring of contains() and inside(), there is no converse operator that looks for notes that are ancestors of item. 
Legacy issues
This operator replaces the legacy #descendedFrom query operator.","descendedFrom(item)
itemが現在のノートの先祖である場合、つまり、その下のコンテナ構造がどれほど深くても、itemのすべての子孫に一致する場合に、Booleanの真（true）を返します。
item引数は、属性参照でない限り引用符で囲む必要があります。itemの指定方法：
パス '/foo/bar' にあるコンテナのすべての子孫アイテムをセット（Set）として返すには、次のクエリを使用します：
	descendedFrom(/foo/bar)
または、'bar' がドキュメント内で一意の名前（$Name）である場合は、名前だけを使用できます：
	descendedFrom(""bar"")
通常は後者の形式が最もよく使われます。
contains() と inside() の組み合わせとは異なり、itemの先祖にあたるノートを探す逆の演算子は存在しません。
レガシーに関する事項
この演算子は、旧来の #descendedFrom クエリ演算子を置き換えるものです。"
Dictionary.add(itemDict),Function,Item,"Dictionary, Set & List operations",Dictionary,false,9.1.0,Baseline,,,,,true,true,false,false,false,false,false,false,false,,false,"Dictionary.add(itemDict)
This reads a Dictionary-type argument itemDict from which a key and a value are parsed. 
 	$MyDictionary = $MyDictionary.add({apple:green}); 
Note that quotes are not needed around the key and value.
If key does not exist, that key is created with a value of value.
If key exists, key is given a value of value. This replaces any/all existing values for this key.
Assume $MyDictionary has no 'apple' key. Example:
 	$MyDictionary = $MyDictionary.add({apple:fruit}); 
The key 'apple' is added and now has value 'fruit'
 	$MyDictionary = $MyDictionary.add({apple:green}); 
The key 'apple' now has a new value 'green'. Now assume the 'apple' key has multiple values of 'fruit;green;red':
	$MyDictionary = $MyDictionary.add({apple:pie}); 
Now the value is just 'pie' because an .add() operator replaces all existing value(s). 
This operator is also equivalent to:
 	Dictionary[""key""] = ""value""; 
To add an additional value(s) to existing value(s), see Dictionary.extend().
To remove a key—and any value(s) it has—from the Dictionary, there is no operator but instead the key string is deleted using a minus operator: see 'Deleting key:value pairs' here.
The .add() operator accepts quoted strings. The following expressions are equivalent:
	$MyDictionary.add({1:able}) 
	$MyDictionary.add(""{1:able}"") 
But do not use either of the following example syntax:
	$MyDictionary.add({""1:able""}) WRONG!
	$MyDictionary.add({""1"":""able""}) WRONG!
Using offset addresses within itemDict
Either the keyStr or the valueStr may need to be calculated variable, for instance the valueStr might need to be the value of an offset attribute reference, e.g. $MyString(""Some note""), or inside a loop e.g. $MyString(loopVar). These expressions cannot be resolved within the .add() operator but itemDict can be a variable. Thus, in a loop, rather than:
	vDict = vDict.add({$Name(aState)+"":""+$Color(aState)}); WRONG!
use:
	vList.each(aState){
		var:string vPair = $Name(aState)+"":""+$Color(aState);
		vDict = vDict.add({vPair});
	};
Legacy form (pre-v9.5.0)
Dictionary.add(keyStr, valueStr)
This sets a keyStr to the valueStr. 
If keyStr does not exist, that key is created with a value of valueStr.
If keyStr exists, keyStr is given value valueStr. This replaces any/all existing values for this key.
Assume $MyDictionary has no 'apple' keyStr. Example:
 	$MyDictionary = $MyDictionary.add(""apple"",""fruit""); 
The keyStr 'apple' is added and now has valueStr 'fruit'
 	$MyDictionary = $MyDictionary.add(""apple"",""green""); 
The keyStr 'apple' now has a new value 'green'. Now assume the 'apple' key has multiple values of 'fruit;green;red':
	$MyDictionary = $MyDictionary.add(""apple"",""pie""); 
Now the value is just 'pie' because an .add() operator replaces all existing valueStr(s).","Dictionary.add(itemDict)
キーと値が解析されるDictionary型の引数itemDictを読み取ります。
 	$MyDictionary = $MyDictionary.add({apple:green}); 
キーと値の周囲に引用符（クォート）は不要であることに注意してください。
キーが存在しない場合、そのキーは指定された値で作成されます。
キーが存在する場合、そのキーに値が割り当てられます。これにより、そのキーの既存のすべての値が置き換えられます。
$MyDictionaryに「apple」キーがないと仮定した例：
 	$MyDictionary = $MyDictionary.add({apple:fruit}); 
キー「apple」が追加され、値は「fruit」になります。
 	$MyDictionary = $MyDictionary.add({apple:green}); 
キー「apple」の新しい値は「green」になります。次に、「apple」キーに「fruit;green;red」という複数の値があると仮定します：
	$MyDictionary = $MyDictionary.add({apple:pie}); 
.add() オペレータは既存のすべての値を置き換えるため、値は単一の「pie」になります。
このオペレータは、以下とも同等です：
 	Dictionary[""key""] = ""value""; 
既存の値にさらに値を追加するには、Dictionary.extend() を参照してください。
Dictionaryからキー（およびそれが持つすべての値）を削除するための専用オペレータはありませんが、代わりにマイナス演算子を使用してキー文字列を削除します。こちらの「キーと値のペアの削除（Deleting key:value pairs）」を参照してください。
.add() オペレータは引用符で囲まれた文字列を受け入れます。以下の式は同等です：
	$MyDictionary.add({1:able}) 
	$MyDictionary.add(""{1:able}"") 
ただし、以下の例のような構文はいずれも使用しないでください：
	$MyDictionary.add({""1:able""}) 誤り！
	$MyDictionary.add({""1"":""able""}) 誤り！

itemDict内でのオフセットアドレスの使用
keyStrまたはvalueStrのいずれかが、計算された変数である必要がある場合があります。例えば、valueStrがオフセット属性参照（例：$MyString(""Some note"")）である必要がある場合や、ループ内（例：$MyString(loopVar)）である場合です。これらの式は .add() オペレータ内で解決することはできませんが、itemDict自体を変数にすることは可能です。したがって、ループ内において次のような記述をするのではなく：
	vDict = vDict.add({$Name(aState)+"":""+$Color(aState)}); 誤り！
次のように記述してください：
	vList.each(aState){
		var:string vPair = $Name(aState)+"":""+$Color(aState);
		vDict = vDict.add({vPair});
	};

レガシー形式（v9.5.0以前）
Dictionary.add(keyStr, valueStr)
これは keyStr に valueStr を設定します。
keyStr が存在しない場合、そのキーは valueStr という値で作成されます。
keyStr が存在する場合、そのキーには valueStr という値が割り当てられます。これにより、そのキーの既存のすべての値が置き換えられます。
$MyDictionaryに「apple」という keyStr がないと仮定した例：
 	$MyDictionary = $MyDictionary.add(""apple"",""fruit""); 
keyStr の「apple」が追加され、値は「fruit」になります。
 	$MyDictionary = $MyDictionary.add(""apple"",""green""); 
keyStr の「apple」の新しい値は「green」になります。次に、「apple」キーに「fruit;green;red」という複数の値があると仮定します：
	$MyDictionary = $MyDictionary.add(""apple"",""pie""); 
.add() オペレータは既存のすべての valueStr を置き換えるため、値は「pie」のみになります。"
Dictionary.contains(keyStr),Function,Item,Query Boolean,boolean test,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Dictionary.contains(keyStr)
The expression:
	$MyDictionary.contains(key) 
is true if the dictionary contains the designated key.
Note that keyStr is literal string and not a regex pattern (unlike the operator's use chained with some other data types).
Dictionaries are case-sensitive, but Dictionary.icontains(key) is available for case-insensitive matching.","Dictionary.contains(keyStr)
式:
	$MyDictionary.contains(key) 
は、辞書に指定されたキーが含まれている場合に真（true）となります。
keyStr はリテラル文字列であり、正規表現パターンではないことに注意してください（他のデータ型でこの演算子を連鎖させて使用する場合とは異なります）。
辞書は大文字と小文字を区別しますが、大文字小文字を区別せずに照合するには Dictionary.icontains(key) が利用可能です。"
Dictionary.count(),Property,Item,"Dictionary, Set & List operations",Number,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Dictionary.count()
Dictionary.count
A Number-type property. Returns the number of keys in the dictionary (by their nature all keys are discrete so there is not potential of duplication in the count). If:
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyNumber = $MyDictionary.count; 
MyNumber is now 3.
Dictionary.count and Dictionary.size are interchangeable. Use which ever seems more intuitive.","Dictionary.count()
Dictionary.count
Number型のプロパティ。辞書内のキーの数を返します（その性質上、すべてのキーは一意であるため、カウントに重複が生じる可能性はありません）。次の場合：
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyNumber = $MyDictionary.count; 
MyNumberは3になります。
Dictionary.countとDictionary.sizeは互換性があります。より直感的に感じられる方を使用してください。"
Dictionary.empty(),Property,Item,"Dictionary, Set & List operations",boolean test,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Dictionary.empty()
Dictionary.empty
A Boolean-type property. Returns true if the dictionary has no keys, and is false otherwise.
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyBoolean = $MyDictionary.empty; 
MyBoolean is now false
	$MyDictionary = ; (or $MyDictionary = {};)
	$MyBoolean = $MyDictionary.empty; 
MyBoolean is now true","Dictionary.empty()
Dictionary.empty
Boolean型のプロパティ。ディクショナリにキーがない場合はtrueを返し、それ以外の場合はfalseを返します。
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyBoolean = $MyDictionary.empty; 
MyBooleanはfalseになります
	$MyDictionary = ; (または $MyDictionary = {};)
	$MyBoolean = $MyDictionary.empty; 
MyBooleanはtrueになります"
Dictionary.extend(itemDict),Function,Item,"Dictionary, Set & List operations",Dictionary,false,9.1.0,Baseline,9.5.2,,,2,true,true,false,false,false,false,false,false,false,,false,"Dictionary.extend(itemDict)
This reads a Dictionary-type argument itemDict from which a key and a value are parsed. It adds the value string to the value(s) of a key.
If key does not exist, that key is created with a value of value.
If key exists, value is appended to key's existing value(s).
Assume $MyDictionary has no 'pear' key. Example:
 	$MyDictionary = $MyDictionary.extend({pear:fruit}); 
The key 'pear' is added and now has value 'fruit'. Next:
 	$MyDictionary = $MyDictionary.extend({pear:green}); 
The key 'pear' now has an additional new value 'green', but the overall value is now a list and the key:value pair is pear:fruit;green.
To set the new valueStr so it replaces all existing value(s) see Dictionary.add().
Note that quotes are not used around either/both the keyStr and valueStr. The .extend() operator accepts quoted strings. The following expressions are equivalent:
	$MyDictionary.extend({1:able}) 
	$MyDictionary.extend(""{1:able}"") 
But do not use either of the following example syntax:
	$MyDictionary.extend({""1:able""}) WRONG!
	$MyDictionary.extend({""1"":""able""}) WRONG!
Dictionary.extend(keyStr, valueStr)
This adds the valueStr string to the value(s) of a keyStr.
If keyStr does not exist, that key is created with a value of valueStr.
If keyStr exists, valueStr is appended to keyStr's existing value(s).
Assume $MyDictionary has no 'pear' keyStr. Example:
 	$MyDictionary = $MyDictionary.extend(""pear"",""fruit""); 
The keyStr 'pear' is added and now has valueStr 'fruit'. Next:
 	$MyDictionary = $MyDictionary.extend(""pear"",""green""); 
The keyStr 'pear' now has an additional new valueStr 'green', but the overall value is now a list and the key:value air is pear:fruit;green.
To set the new valueStr so it replaces all existing value(s) see Dictionary.add().
Dictionary.extend(dictStr)
The Dictionary.extend() operator takes a single argument, a dictionary—using the new {} syntax of key:pair elements which will extend the current elements.
 	$MyDictionary = $MyDictionary.extend({pear:green}); 
Note that quotes may be used around either/both the keyStr and valueStr. The following expressions are equivalent:
	$MyDictionary = $MyDictionary.extend({1:able}}; 
	$MyDictionary = $MyDictionary.extend(""{1:able}""}; 
But do not use either of the following example syntax:
	$MyDictionary = $MyDictionary.extend({""1:able""}}; WRONG!
	$MyDictionary = $MyDictionary.extend({""1"":""able""}}; WRONG!
Using offset addresses within itemDict
Either the keyStr or the valueStr may need to be calculated variable, for instance the valueStr might need to be the value of an offset attribute reference, e.g. $MyString(""Some note""), or inside a loop e.g. $MyString(loopVar). These expressions cannot be resolved within the .extend() operator but itemDict can be a variable. Thus, in a loop, rather than:
	vDict = vDict.extend({$Name(aState)+"":""+$Color(aState)}); WRONG!
use:
	vList.each(aState){
		var:string vPair = $Name(aState)+"":""+$Color(aState);
		vDict = vDict.extend({vPair});
	};","Dictionary.extend(itemDict)
これは、キーと値が解析されるDictionary型の引数itemDictを読み込みます。これは、キーの値に値の文字列を追加します。
キーが存在しない場合、そのキーは値とともに作成されます。
キーが存在する場合、値は既存のキーの値に追加されます。
$MyDictionaryに'pear'キーがないと仮定します。例：
 	$MyDictionary = $MyDictionary.extend({pear:fruit}); 
キー'pear'が追加され、値は'fruit'になります。次に：
 	$MyDictionary = $MyDictionary.extend({pear:green}); 
キー'pear'に新しい値'green'が追加されますが、全体の値はリストになり、キーと値のペアは pear:fruit;green になります。
既存のすべての値を新しいvalueStrで置き換えるように設定するには、Dictionary.add()を参照してください。
keyStrとvalueStrのいずれか、または両方の周囲に引用符は使用されないことに注意してください。.extend()オペレータは引用符で囲まれた文字列を受け入れます。以下の式は同等です：
	$MyDictionary.extend({1:able}) 
	$MyDictionary.extend(""{1:able}"") 
ただし、以下の構文例はいずれも使用しないでください：
	$MyDictionary.extend({""1:able""}) 誤り！
	$MyDictionary.extend({""1"":""able""}) 誤り！

Dictionary.extend(keyStr, valueStr)
これは、keyStrの値にvalueStr文字列を追加します。
keyStrが存在しない場合、そのキーはvalueStrの値とともに作成されます。
keyStrが存在する場合、valueStrは既存のkeyStrの値に追加されます。
$MyDictionaryに'pear'というkeyStrがないと仮定します。例：
 	$MyDictionary = $MyDictionary.extend(""pear"",""fruit""); 
keyStr 'pear'が追加され、valueStr 'fruit'を持つようになります。次に：
 	$MyDictionary = $MyDictionary.extend(""pear"",""green""); 
keyStr 'pear'に新しいvalueStr 'green'が追加されますが、全体の値はリストになり、キーと値のペアは pear:fruit;green になります。
既存のすべての値を新しいvalueStrで置き換えるように設定するには、Dictionary.add()を参照してください。

Dictionary.extend(dictStr)
Dictionary.extend()オペレータは、現在の要素を拡張するkey:pair要素の新しい {} 構文を使用した、単一の引数（辞書）を取ります。
 	$MyDictionary = $MyDictionary.extend({pear:green}); 
keyStrとvalueStrのいずれか、または両方の周囲に引用符が使用される場合があることに注意してください。以下の式は同等です：
	$MyDictionary = $MyDictionary.extend({1:able}}; 
	$MyDictionary = $MyDictionary.extend(""{1:able}""}; 
ただし、以下の構文例はいずれも使用しないでください：
	$MyDictionary = $MyDictionary.extend({""1:able""}}; 誤り！
	$MyDictionary = $MyDictionary.extend({""1"":""able""}}; 誤り！

itemDict内でのオフセットアドレスの使用
keyStrまたはvalueStrのいずれかを計算された変数にする必要がある場合があります。例えば、valueStrを $MyString(""Some note"") のようなオフセット属性参照の値にする必要がある場合や、ループ内（例: $MyString(loopVar)）などです。これらの式は .extend() オペレータ内では解決できませんが、itemDictを変数にすることは可能です。したがって、ループ内では以下のように記述するのではなく：
	vDict = vDict.extend({$Name(aState)+"":""+$Color(aState)}); 誤り！
次のように記述します：
	vList.each(aState){
		var:string vPair = $Name(aState)+"":""+$Color(aState);
		vDict = vDict.extend({vPair});
	};"
Dictionary.icontains(keyStr),Function,Item,Query Boolean,boolean test,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Dictionary.icontains(keyStr)
The expression:
	$MyDictionary.icontains(key) 
is true if the dictionary contains the designated key or case variations of it.
Note that keyStr is literal string and not a regex pattern (unlike the operator's use chained with some other data types).
Dictionaries are case-sensitive, and Dictionary.contains(key) is available for case-sensitive matching.","Dictionary.icontains(keyStr)
式：
	$MyDictionary.icontains(key)
は、辞書（Dictionary）に指定されたキー、またはその大文字小文字のバリエーションが含まれている場合に true となります。
keyStr はリテラル文字列であり、正規表現パターンではないことに注意してください（他のデータ型とチェーンしてこの演算子を使用する場合とは異なります）。
辞書は大文字小文字を区別するため、大文字小文字を区別した一致確認には Dictionary.contains(key) が利用できます。"
Dictionary.keys(),Property,Item,"Dictionary, Set & List operations",List,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Dictionary.keys()
Dictionary.keys
A List-type property. Returns a list of unsorted key names (i.e. only the keys' strings and not those of values) for this note. Unlike a List or Set, the Dictionary cannot be iterated directly using .each(). Instead, Dictionary.keys provides an iter-able list. So:
$MyDictionary.keys.each(x){
	if($MyDictionary[x] == ""Whoops""){
		 ...
	}
}
Therefore do not try: $MyDictionary.each(x)
A dictionary cannot be sorted but as above Dictionary.keys can be sorted. This is the previous example above, but with an added .sort operator inserted after .keys:
$MyDictionary.keys.sort.each(x){
	if($MyDictionary[x] == ""Whoops""){
		 ...
	}
}
Note that when iterating a dictionary with .each(X) the loop variable X is the String value of the key.
Depending on your needs you might prefer to pass the dictionary explicitly to a list attribute before doing further work:
	$MyList = $MyDictionary.keys; // then work with MyList","Dictionary.keys()
Dictionary.keys
リスト型のプロパティ。このノートのソートされていないキー名のリスト（つまり、値ではなくキーの文字列のみ）を返します。ListやSetとは異なり、Dictionaryは .each() を使用して直接反復処理（イテレート）することはできません。代わりに、Dictionary.keys が反復処理可能なリストを提供します。そのため、次のように記述します：
$MyDictionary.keys.each(x){
	if($MyDictionary[x] == ""Whoops""){
		 ...
	}
}
したがって、 $MyDictionary.each(x) とは記述しないでください。
ディクショナリ自体をソートすることはできませんが、上述の通り Dictionary.keys はソート可能です。以下は前述の例の .keys の後に .sort 演算子を挿入したものです：
$MyDictionary.keys.sort.each(x){
	if($MyDictionary[x] == ""Whoops""){
		 ...
	}
}
.each(X) でディクショナリを反復処理する場合、ループ変数 X はキーの文字列値になることに注意してください。
目的に応じて、さらに処理を進める前に、明示的にディクショナリのキーをリスト属性に渡す方が適している場合もあります：
	$MyList = $MyDictionary.keys; // その後、MyListを使用して作業する"
Dictionary.size(),Property,Item,"Dictionary, Set & List operations",Number,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Dictionary.size()
Dictionary.size
A Number-type property. Returns the number of keys in the dictionary (by their nature all keys are discrete so there is not potential of duplication in the count). If:
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyNumber = $MyDictionary.size; 
MyNumber is now 3.
Dictionary.size and Dictionary.count are interchangeable. Use which ever seems more intuitive.","Dictionary.size()
Dictionary.size
Number型のプロパティ。辞書内のキーの数を返します（その性質上、すべてのキーは一意であるため、カウントに重複が生じる可能性はありません）。次の場合：
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyNumber = $MyDictionary.size; 
MyNumberは3になります。
Dictionary.sizeとDictionary.countは互換性があります。より直感的に感じられる方を使用してください。"
dictionary(dictionaryStr),Function,Document,"Dictionary, Set & List operations",Dictionary,false,9.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"dictionary(dictionaryStr)
This operator constructs a new dictionary from a dictionaryStr. The dictionaryStr must contain pairs of keys and values separated by a colon; each key/value pair is separated by a semicolon. For example:
	$MyDictionary=dictionary(""cat:animal; dog:animal; rock: mineral""); 
The key ""cat"" has the value ""animal"", while the key ""rock"" has the value ""mineral"".
Normally the output will be passed to a Dictionary attribute, but if passed to an action code variable the latter should function as if a dictionary.
The operator's input string will be in the form of semi-colon delimited set of key:value pairs, i.e.
	$MyDictionary = dictionary(""cat:animal; dog:animal; rock:mineral""); 
Or
	$MyString = ""cat:animal; dog:animal; rock:mineral""; 
	$MyDictionary = dictionary($MyString); 
dictionary({dictionaryStr})
Using the newer {}-defined declaratory method for dictionary data:
	$MyDictionary = dictionary({cat:animal; dog:animal; rock:mineral}); 
Or
	$MyString = ""cat:animal; dog:animal; rock:mineral""; 
	$MyDictionary = dictionary({$MyString}); 
Here the braces (curly brackets) replace the need for quotes enclosing strings.
Direct creation from a string (deprecated)
It is possible that a dictionary can be made by passing an appropriately structured string to a Dictionary type attribute, thus:
	$MyDictionary = ""cat:animal; dog:animal; rock:mineral""; 
This latter usage is deprecated and the more explicit dictionary() operator should be used in its place.","dictionary(dictionaryStr)
このオペレータは、dictionaryStr から新しい辞書を構築します。dictionaryStr は、コロンで区切られたキーと値のペアを含み、各ペアはセミコロンで区切られている必要があります。例：
	$MyDictionary=dictionary(""cat:animal; dog:animal; rock: mineral""); 
キー ""cat"" は値 ""animal"" を持ち、キー ""rock"" は値 ""mineral"" を持ちます。
通常、出力は Dictionary 属性に渡されますが、アクションコードの変数に渡された場合、その変数は辞書として機能します。
オペレータの入力文字列は、セミコロンで区切られた key:value ペアの形式になります。例：
	$MyDictionary = dictionary(""cat:animal; dog:animal; rock:mineral""); 
または
	$MyString = ""cat:animal; dog:animal; rock:mineral""; 
	$MyDictionary = dictionary($MyString); 
dictionary({dictionaryStr})
辞書データの新しい {} 定義による宣言的な手法を使用する場合：
	$MyDictionary = dictionary({cat:animal; dog:animal; rock:mineral}); 
または
	$MyString = ""cat:animal; dog:animal; rock:mineral""; 
	$MyDictionary = dictionary({$MyString}); 
ここでは、中括弧（波括弧）が文字列を囲む引用符の代わりとなります。
文字列からの直接作成（非推奨）
Dictionary 型の属性に適切に構成された文字列を渡すことで、辞書を作成することも可能です。例：
	$MyDictionary = ""cat:animal; dog:animal; rock:mineral""; 
この後者の使用法は非推奨であり、代わりにより明示的な dictionary() オペレータを使用する必要があります。"
Dictionary[keyStr],Function,Item,"Dictionary, Set & List operations",source context dependent,false,9.0.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"Dictionary[keyStr]
returns the Dictionary's value for the submitted keyStr string. For example, make a dictionary:
	$MyDictionary={cat:animal; dog:animal; rock: mineral}; 
or (now deprecated):
	$MyDictionary=""cat:animal; dog:animal; rock: mineral""; 
then test like so:
	$MyString = $MyDictionary[""dog""]; 
sets MyString to the string ""animal"".
It is not required to use quotes around keyStr.
The keyStr may also be a (loop) variable, or an attribute value. The latter are evaluated before use:
	$MyList.each(anItem){$MyString = $MyString + "", "" + $MyDictionary[anItem];} 
	$MyString = $MyDictionary[$SomeAttribute];} 
This has the same effect as .at( ), but may be more convenient. Note that in both the square-bracket syntax and .at() syntax a numerical key value is interpreted as a key and not a list item number, unlike list.at().","Dictionary[keyStr]
指定したキー文字列（keyStr）に対応する辞書の値を返します。
例えば、次のように辞書を作成します：
	$MyDictionary={cat:animal; dog:animal; rock: mineral}; 
または（現在は非推奨）：
	$MyDictionary=""cat:animal; dog:animal; rock: mineral""; 
次のようにテストします：
	$MyString = $MyDictionary[""dog""]; 
これにより、$MyString に文字列 ""animal"" が設定されます。
keyStr を引用符で囲む必要はありません。
keyStr は（ループ）変数や属性値にすることも可能です。後者は使用前に評価されます：
	$MyList.each(anItem){$MyString = $MyString + "", "" + $MyDictionary[anItem];} 
	$MyString = $MyDictionary[$SomeAttribute];} 
これは .at() と同じ効果がありますが、より便利な場合があります。角括弧構文および .at() 構文では、list.at() とは異なり、数値のキー値はリストの項目番号ではなくキーとして解釈される点に注意してください。"
"distance(startItem, endItem)",Function,Item,Data manipulation,Number,false,7.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"distance(startItem, endItem)
returns a Number, the map distance (in map units) between the centres of two notes. startItem and endItem are a name, path, attribute value or expression returning a unique reference to a single note.
To find the distance between note 'AA' and note 'BB':
	$MyNumber = distance(""AA,""BB"");","distance(startItem, endItem)
2つのノートの中心間のマップ距離（マップ単位）を数値（Number）で返します。startItemとendItemは、名前、パス、属性値、または単一のノートへの一意な参照を返す式です。
ノート「AA」とノート「BB」の間の距離を求めるには：
	$MyNumber = distance(""AA"",""BB"");"
"distanceTo(startItem, endItem)",Function,Item,Data manipulation,Number,false,8.0.4,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"distanceTo(startItem, endItem)
distanceTo computes the approximate distance in kilometres between two notes for which a $Latitude and $Longitude are known. startItem and endItem are a name, path, attribute value or expression returning a unique reference to a single note.
For example, if note startItem 'Boston' has the latitude and longitude of Boston and note endItem 'Paris' has the latitude a longitude of Paris, then for 
	$MyNumber = distanceTo(""Boston"",""Paris"");  
$MyNumber is about 5582 (km).
Long distances should use a great circle route.
Note the measurement is approximate and not intended for precise navigation.","distanceTo(startItem, endItem)
distanceToは、$Latitude（緯度）と$Longitude（経度）が設定されている2つのノート間の概算距離をキロメートルで計算します。startItemおよびendItemは、名前、パス、属性値、または単一のノートを一意に参照する式です。
例えば、ノート'Boston'にボストンの緯度経度が、ノート'Paris'にパリの緯度経度が設定されている場合、
	$MyNumber = distanceTo(""Boston"",""Paris"");
と記述すると、$MyNumberは約5582（km）になります。
長距離の計算には大圏航路が使用されます。
この測定値は概算であり、精密な航法を目的としたものではないことに注意してください。"
"do(macroStr[,argumentsList])",Function,Item,Data manipulation,String,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"do(macroStr[, argumentsList])
The do() operator do lets rules and actions use macros. Action code macros cannot, generally, evaluate action (or export) code within the macro itself and so might best be thought of sections of boilerplate text with configurable text inputs.
do() always returns an output (string) and so will expect a left side attribute. To do something useful with the output consider wrapping the it in an eval() call. Assume macro ""Hello world"" has the code: ""Hello $1!"". Then:
	$ReturnString = eval(do(""Hello world"",""Nibbler"")); 
would set a $ReturnString value of ""Hello Nibbler!"".
Alternatively, if the macro is written so the left side is included, action() can be used. Macro ""Hello world2"" has the code: $ReturnString = ""Hello $1!"". Using the macro thus:
	action(do(""Hello world2"",""Cubert"")); 
which would set a $ReturnString value of the current note to ""Hello Cubert!"". Notice how action() requires no left-side receiving attribute as there is no direct output. The assignment to $ReturnString occurs within the macro; the assigned attribute being whatever system/user attribute the user decides, it is not a fixed output assignment.
An offset within an action call is also possible. Macro ""Hello world3"":
 	$ReturnString('$2') = ""Here's $1!""; 
Use the macro thus:
	action(do(""Hello world3"",""Calculon"", ""All My Circuits"")); 
which would set a $ReturnString(""All My Circuits"") to ""Here's Calculon!"".
Note that if an input is itself an expression, it may prove beneficial to evaluate it before insertion into the macro. Why? It may affect outcome if the context of the input evaluation and the output evaluation differ, e.g. where the reference 'this' might refer to a different note in each context.
do(macro[,arg1,arg2,arg3] )
The first argument is the name of the macro. Subsequent argumentsList (comma delimited) arguments are optional and are passed to the macro, which can refer to them as $1, $2, $3, and so forth.
After the macro is evaluated, its result string is returned and is parsed again as a rule, action, or expression. For example:
	$Name|=do(computeName,$Name,$Name(parent)); 
sets name to the result of a macro called computeName. This if the macro code were:
	$2: $1 
Then, if $Name were ""mammal"" and $Name(parent) were ""horse"", the result on the above call would be a new $Name of ""mammal: horse""
	do(Instructions); 
simply returns whatever text is stored in a macro called Instructions.
Macros cannot be used in agent queries (this was supported in early versions).
Macros called in action code via do() do not evaluate any embedded export codes. This is because such behaviour is reserved for export use.","do(macroStr[, argumentsList])
do() オペレータを使用すると、ルールやアクションでマクロを利用できるようになります。アクションコードのマクロは、通常、マクロ自体の中でアクションコード（またはエクスポートコード）を評価することはできず、設定可能なテキスト入力を備えたボイラープレート（定型文）セクションと考えるのが最適です。

do() は常に出力（文字列）を返すため、左辺に属性を必要とします。出力を有効に活用するには、eval() 呼び出しでラップすることを検討してください。マクロ ""Hello world"" のコードが ""Hello $1!"" であると仮定します。その場合：
	$ReturnString = eval(do(""Hello world"",""Nibbler"")); 
は、$ReturnString の値を ""Hello Nibbler!"" に設定します。

あるいは、マクロに左辺が含まれるように記述されている場合は、action() を使用できます。マクロ ""Hello world2"" のコードが $ReturnString = ""Hello $1!"" であるとします。このマクロを次のように使用します：
	action(do(""Hello world2"",""Cubert"")); 
これは、現在のノートの $ReturnString の値を ""Hello Cubert!"" に設定します。action() は直接的な出力を伴わないため、受け取り側の属性を必要としないことに注意してください。$ReturnString への代入はマクロ内で行われます。代入先の属性はユーザーが指定したシステム属性またはユーザー属性であり、固定された出力代入ではありません。

action 呼び出し内でのオフセット指定も可能です。マクロ ""Hello world3""：
 	$ReturnString('$2') = ""Here's $1!""; 
このマクロを次のように使用します：
	action(do(""Hello world3"",""Calculon"", ""All My Circuits"")); 
これは、$ReturnString(""All My Circuits"") を ""Here's Calculon!"" に設定します。

入力自体が式である場合、マクロに挿入する前にそれを評価しておくことが有益な場合があります。なぜなら、入力評価のコンテキストと出力評価のコンテキストが異なる場合（例えば、'this' の参照先がそれぞれのコンテキストで異なるノートを指す場合など）、結果に影響を及ぼす可能性があるためです。

do(macro[,arg1,arg2,arg3])
最初の引数はマクロの名前です。後続の argumentsList（カンマ区切り）はオプションの引数で、マクロに渡されます。マクロ内ではこれらを $1, $2, $3 のように参照できます。

マクロが評価された後、その結果の文字列が返され、再びルール、アクション、または式としてパースされます。例えば：
	$Name|=do(computeName,$Name,$Name(parent)); 
は、$Name を computeName というマクロの結果に設定します。もしマクロのコードが：
	$2: $1 
であった場合、$Name が ""mammal"" で $Name(parent) が ""horse"" ならば、上記の呼び出しの結果、新しい $Name は ""mammal: horse"" になります。

	do(Instructions); 
は、単純に Instructions というマクロに格納されているテキストを返します。

マクロをエージェントクエリで使用することはできません（初期のバージョンではサポートされていました）。
do() を介してアクションコード内で呼び出されるマクロは、埋め込まれたエクスポートコードを評価しません。これは、そのような動作がエクスポート用として予約されているためです。"
document.keys(),Function,Document,Document configuration,List,false,9.5.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"document.keys()
document.keys
returns a List of the document() dictionary's keys of useful properties of the current document. The operator returns the document Dictionary object as a single string, noting that no operator trailing parentheses are needed:
	$MyList = document.keys; 
The returned list is in the dictionary's stored order as listed for document().
The document.keys operator can assist in getting a readable output of all the keys and their values
	$Text =;
	document.keys.each(aKey){
		var:list vKey = document[aKey];
		$Text += aKey + "": "" + vKey.format("", "") +""\n\n"";
	};
which will list in $Text of the current note each key name and then its value with a blank line in between. For multi-item values like user-attributes and link-types list formatting applies a ', ' delimiter for legibility.","document.keys()
document.keys
現在のドキュメントの有用なプロパティを保持する document() 辞書のキーのリストを返します。このオペレーターは document 辞書オブジェクトを単一の文字列として返します。なお、末尾の括弧は不要です：
	$MyList = document.keys; 
返されるリストは、document() でリストされる辞書の格納順序に従います。
document.keys オペレーターは、すべてのキーとその値を読みやすい形式で取得するのに役立ちます。
	$Text =;
	document.keys.each(aKey){
		var:list vKey = document[aKey];
		$Text += aKey + "": "" + vKey.format("", "") +""\n\n"";
	};
これにより、現在のノートの $Text に各キー名とその値が空行を挟んでリストされます。ユーザー属性やリンクタイプのように複数の項目を持つ値については、可読性を高めるために「, 」を区切り文字としたリスト形式が適用されます。"
document(),Function,Document,Document configuration,Dictionary,false,9.6.0,Baseline,11.0.0,11.0.0,,,false,false,false,false,false,false,false,true,false,,false,"document()
document
document() or document returns a Dictionary of useful properties of the current document. The properties of the document are exposed this way (in this order in the dictionary):
* path: the POSIX file path of the current TBX file
* id: the TBX file's internal UUID.
* user-attributes: a list of all the user attributes currently defined in the document
* url: the local file:// URL of the current TBX file.
* name: the full name of the current TBX including the file extension.
* link-types: a list of discrete link types currently defined in the document. 
* file-size: the size (in bytes) of the saved Tinderbox file (from v11.0.0)
Importantly, The document() Dictionary object is read-only.
The operator returns the document Dictionary object as a single string:
	$Text = document(); 
Although trailing parentheses are not needed, when calling the 'bare' operator, add parentheses—i.e. document()— may help the user and parse not mistake the operator document for the literal string ""document"". 
As reading the Dictionary data as a single string can be hard, a neater and more easily understood method is use the document.keys() method.
It is possible to address the document() Dictionary directly for a specific key value using the document[keyStr] method.
However, calling document() with no other handling, returns the entire, unformatted Dictionary contents. To split the items onto separate lines as discrete key:value pairs, chain the .format() operator:
	$MyString = document.format(""\n""); 
To get the values (without their keys) on separate lines in the current note's $Text:
	$Text=;
	document().keys.each(aKey){
		$Text+= aKey + "": "" + document()[aKey] + ""\n"";
	};","document() または document は、現在のドキュメントの有用なプロパティを含む辞書（Dictionary）を返します。ドキュメントのプロパティは、この順序で辞書に公開されます：
* path: 現在の TBX ファイルの POSIX ファイルパス
* id: TBX ファイルの内部 UUID
* user-attributes: 現在ドキュメントで定義されているすべてのユーザー属性のリスト
* url: 現在の TBX ファイルのローカル file:// URL
* name: ファイル拡張子を含む現在の TBX のフルネーム
* link-types: 現在ドキュメントで定義されている個別のリンクタイプのリスト
* file-size: 保存された Tinderbox ファイルのサイズ（バイト単位）（v11.0.0 以降）
重要な点として、document() 辞書オブジェクトは読み取り専用です。
このオペレーターは、ドキュメントの辞書オブジェクトを単一の文字列として返します：
	$Text = document(); 
末尾の括弧は必須ではありませんが、「素の」オペレーターを呼び出す際に括弧を追加すること（すなわち document()）は、ユーザーやパーサーがオペレーターの document をリテラル文字列の ""document"" と間違えないようにするのに役立ちます。
辞書データを単一の文字列として読み取るのは難しいため、より整理され理解しやすい方法は document.keys() メソッドを使用することです。
document[keyStr] メソッドを使用して、特定のキーの値に対して document() 辞書を直接指定することも可能です。
ただし、他の処理をせずに document() を呼び出すと、フォーマットされていない辞書の内容全体が返されます。項目を個別の key:value ペアとして別々の行に分割するには、.format() オペレーターをチェーンします：
	$MyString = document.format(""\n""); 
現在のノートの $Text に、値（キーなし）を個別の行として取得するには：
	$Text=;
	document().keys.each(aKey){
		$Text+= aKey + "": "" + document()[aKey] + ""\n"";
	};"
document[keyStr],Function,Document,Document configuration,source context dependent,false,9.0.0,Baseline,11.0.0,11.0.0,,1,false,false,false,false,false,false,false,true,false,,false,"document[keyStr]
To address the document() Dictionary to access a particular key use a keyStr argument. The values for the Dictionary's available properties can be accessed individually by supplying the relevant key. Quotes around the key are optional, both forms are illustrated below:
	$MyFile = document[""path""]; 
	$MyString = document[""id""]; 
	$MyList = document[""user-attributes""]; 
	$MyURL = document[""url""]; 
	$MyString = document[""name""]; 
	$MyList = document[link-types]; 
	$MyNumber = document[file-size]; 
All property keyStr above return a string value. However, the values are more usable when passed to attributes (or variables) of the precise data types shown in the examples above.","document[keyStr]
document() 辞書の特定のキーにアクセスするには、引数 keyStr を使用します。辞書の利用可能なプロパティの値は、該当するキーを指定することで個別に取得できます。キーを囲む引用符は省略可能であり、以下の例では両方の形式を示しています。
	$MyFile = document[""path""];
	$MyString = document[""id""];
	$MyList = document[""user-attributes""];
	$MyURL = document[""url""];
	$MyString = document[""name""];
	$MyList = document[link-types];
	$MyNumber = document[file-size];
上記のプロパティの keyStr はすべて文字列値を返します。ただし、これらの値は、上の例に示されているような適切なデータ型の属性（または変数）に渡すことで、より便利に利用できます。"
drivingTimeTo(item),Function,Item,Data manipulation,Interval,false,8.0.4,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"drivingTimeTo(item) 
drivingTimeTo estimates the driving time between the location specified by the selected (current) note and the location specified by the item path.
Location essentially means explicit $Latitude and $Longitude values for both notes—i.e. start and destination, or data such as $GeocodedAddress that can be examined to retrieve suitable Lat/Long data.
The result is a time interval (interval data type) estimating the approximate driving time, based on traffic conditions prevailing when the action was invoked. For example to find the time to drive from the current location's 
if ($MyInterval==0) {
   $MyInterval = drivingTimeTo(/places/faves/Swarthmore);
}
There is no result, i.e. estimated driving time is zero (interval of 00:00) if:
* a location for either note cannot be determined
* no route can be found between the two locations (or the locale is not mapped for driving time)
* the internet is not accessible. 
Avoid excessive use
Note that this function can be slow and relies on the underlying macOS. Therefore consider using an edict rather than a rule, and avoid recalculating the driving time if you already know it. Code as in the example above should stop unneeded calls. Which such code, if there is a driving time, delete it, and the conditional guard query will allow a fresh call to drivingTimeTo().","drivingTimeTo(item)
drivingTimeToは、選択されている（現在の）ノートで指定された場所と、引数itemのパスで指定された場所の間の運転時間を推定します。
ここでの「場所」とは、基本的に両方のノート（出発地と目的地）における明示的な$Latitudeおよび$Longitudeの値、あるいは適切な緯度・経度データを取得するために参照可能な$GeocodedAddressなどのデータを指します。
結果は、アクションが呼び出された時点の交通状況に基づいた推定運転時間であり、期間（interval）データ型で返されます。例えば、現在の場所からの運転時間を求めるには次のように記述します：
if ($MyInterval==0) {
   $MyInterval = drivingTimeTo(/places/faves/Swarthmore);
}
次の場合、推定運転時間はゼロ（00:00の間隔）となります：
* いずれかのノートの場所が特定できない場合
* 2地点間のルートが見つからない場合（または、その地域が運転時間の算出に対応していない場合）
* インターネットに接続できない場合
過度な使用を避ける
この関数は動作が重くなる可能性があり、基盤となるmacOSの機能に依存していることに注意してください。そのため、rule（ルール）ではなくedict（エディクト）での使用を検討し、すでに値が判明している場合は運転時間の再計算を避けるようにしてください。上記の例のようなコードを使用することで、不要な呼び出しを抑制できます。値を更新したい場合は、既存のデータを削除すれば、条件ガードによってdrivingTimeTo()が新たに呼び出されるようになります。"
"eachLink(loopVar[,scope]){actions}",Function,Item,Linking,Dictionary,false,9.1.0,Baseline,,,,2,true,false,false,true,false,true,false,true,false,,false,"The `eachLink(loopVar){action(s)}` operator iterates through a Dictionary of data for each inbound or outbound link of the current note (excluding prototype links). The `loopVar` argument is a user-named local variable bound to a dictionary-type object containing per-link properties, used within the action code block. It serves as a more flexible replacement for the older `links()` operator.

**Dictionary Keys**
The operator provides access to numerous keys for each link. Most are editable, while iteration flags are read-only.
*   **Link Identity:** `type` (link type), `anchor` (anchor text within $Text), `source` ($Path), `sourceID`, `sourceIDString`, `dest` ($Path), `destination`, `destID`, `destIDString`.
*   **Metadata:** `comment` (ad hoc info).
*   **HTML Export:** `class`, `title`, `target` (HTML attributes), `url` (Web links only).
*   **Visual Properties (Boolean):** `visible`, `dashed`, `dotted`, `bold`, `broad`, `linear`.
*   **Iteration & State (Read-Only):**
    *   `isFirst`: True for the first link in the list.
    *   `isLast`: True for the last link.
    *   `outbound`: True if the link source is the current note.
    *   `basic`: True for basic links, false for text links.

**Scope and Iteration**
*   **Default Scope:** By default, it acts on the current note.
*   **Optional Scope:** `eachLink(loopVar, scope){...}` allows designating a specific note (via path or designator like `parent` or `original`) to examine.
*   **Order:** It processes links in the order seen in the ""Browse Links"" dialog (text links follow their anchor order in $Text).
*   **Count:** The total iterations equal `$OutboundLinkCount` + `$InboundLinkCount`.

**Detecting Link Types**
*   **Web Links:** Have both an `anchor` and a `url`.
*   **Text Links:** Have an `anchor` but no `url`.
*   **Basic Links:** Have neither `anchor` nor `url`.
One can determine the type by testing these keys (e.g., `if(aLink[""url""]!="""")`).

**Editing Link Properties**
Properties within the dictionary can be modified during iteration.
*   *Example:* Changing 'untitled' links to 'reference'.
    ```
    eachLink(aLink){
        if(aLink[""type""] == ""*untitled""){
            aLink[""type""] = ""reference"";
        }
    };
    ```
*   If a set link type does not exist, it is created.
*   When working with aliases (e.g., inside an agent), using `eachLink(aLink, original){...}` ensures changes apply to the original note.

**Usage Examples**
*   **Filtering Inbound/Outbound:** Compare `$ID` with `aLink[""source""]`. If they match, it is an outbound link.
*   **Counting:** Initialize a variable and increment it within the loop based on specific criteria (e.g., links where the destination prototype is ""Task"").
*   **Styling:** Use `isFirst` or `isLast` to apply specific text or styling at the beginning or end of a link list export.","`eachLink(loopVar){action(s)}` 演算子は、現在のノートの各インバウンドリンクまたはアウトバウンドリンク（プロトタイプリンクを除く）のデータの辞書（Dictionary）を反復処理します。`loopVar` 引数は、各リンクのプロパティを含む辞書型オブジェクトにバインドされた、ユーザーが命名するローカル変数であり、アクションコードブロック内で使用されます。これは、以前の `links()` 演算子に代わる、より柔軟な機能を提供します。

**辞書のキー（Dictionary Keys）**
この演算子は、各リンクの多数のキーへのアクセスを提供します。ほとんどは編集可能ですが、イテレーションフラグは読み取り専用です。
*   **リンクの識別:** `type`（リンクタイプ）、`anchor`（$Text内のアンカーテキスト）、`source`（$Path）、`sourceID`、`sourceIDString`、`dest`（$Path）、`destination`、`destID`、`destIDString`。
*   **メタデータ:** `comment`（任意の情報）。
*   **HTMLエクスポート:** `class`、`title`、`target`（HTML属性）、`url`（ウェブリンクのみ）。
*   **視覚的プロパティ（ブール値）:** `visible`、`dashed`、`dotted`、`bold`、`broad`、`linear`。
*   **イテレーションと状態（読み取り専用）:**
    *   `isFirst`: リストの最初のリンクの場合に真（True）。
    *   `isLast`: 最後のリンクの場合に真（True）。
    *   `outbound`: リンクのソースが現在のノートである場合に真（True）。
    *   `basic`: 基本リンク（basic links）の場合は真（True）、テキストリンクの場合は偽（False）。

**スコープと反復（Scope and Iteration）**
*   **デフォルトのスコープ:** デフォルトでは、現在のノートに対して動作します。
*   **オプションのスコープ:** `eachLink(loopVar, scope){...}` を使用すると、調査する特定のノート（パス、または `parent` や `original` などの指定子経由）を指定できます。
*   **順序:** 「Browse Links」ダイアログに表示される順序でリンクを処理します（テキストリンクは $Text 内のアンカーの順序に従います）。
*   **回数:** 合計反復回数は、`$OutboundLinkCount` + `$InboundLinkCount` に等しくなります。

**リンクタイプの検出**
*   **ウェブリンク:** `anchor` と `url` の両方を持っています。
*   **テキストリンク:** `anchor` は持っていますが、`url` は持っていません。
*   **基本リンク:** `anchor` も `url` も持っていません。
これらのキーをテストすることで（例：`if(aLink[""url""]!="""")`）、タイプを判断できます。

**リンクプロパティの編集**
反復処理中に辞書内のプロパティを修正できます。
*   **例:** 「*untitled」リンクを「reference」に変更する。
    ```
    eachLink(aLink){
        if(aLink[""type""] == ""*untitled""){
            aLink[""type""] = ""reference"";
        }
    };
    ```
*   設定したリンクタイプが存在しない場合は、新しく作成されます。
*   エイリアス（エージェント内など）を扱う場合、`eachLink(aLink, original){...}` を使用することで、変更がオリジナルノートに確実に適用されるようになります。

**使用例**
*   **インバウンド/アウトバウンドのフィルタリング:** `$ID` と `aLink[""source""]` を比較します。一致すれば、それはアウトバウンドリンクです。
*   **カウント:** 変数を初期化し、特定の基準（例：宛先のプロトタイプが「Task」であるリンク）に基づいてループ内でカウントを増やします。
*   **スタイリング:** `isFirst` や `isLast` を使用して、リンク一覧のエクスポートの最初や最後に特定のテキストやスタイルを適用します。"
escapeHTML(dataStr),Function,Item,Formatting,String,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"escapeHTML(dataStr)
escapeHTML converts HTML and XML special characters in string dataStr to HTML/XML entities. For example, '&lt;' is replaced by '&amp;lt;' and '&amp;' is replaced by '&amp;amp;'.
For example, if the source dataStr is ""this & that"":
	$MyString = escapeHTML(""this & that"") outputs ""this &amp;amp; that"".
See also attributeEncode(), especially if working with XML strings.","escapeHTML(dataStr)
escapeHTMLは、文字列dataStr内のHTMLおよびXMLの特殊文字をHTML/XMLエンティティに変換します。例えば、'&lt;' は '&amp;lt;' に、'&amp;' は '&amp;amp;' に置き換えられます。
例えば、ソースのdataStrが ""this & that"" の場合：
	$MyString = escapeHTML(""this & that"") は ""this &amp;amp; that"" を出力します。
特にXML文字列を扱う場合は、attributeEncode() も参照してください。"
"eval([item], expressionStr)",Function,Item,Data manipulation,source context dependent,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"eval([item,] expressionStr)
The item argument must be quoted unless an attribute reference. Ways to define item.
The eval() function takes two quoted evaluated (as string) arguments. The first argument, item, is optional. The second argument , expressionStr, holds string holding an action code expression to be evaluated. Thus, in basic form:
	if($MyBool){$AttribX = ""$Name(parent)+' XYZ'"";}else{$AttribX = ""$Name(grandparent) + 'ABC'"";}; $AttribY = eval($AttribX); 
will set AttribY to the name of the current note's parent's title plus string ""XYZ"" or that of its grandparent plus string ""ABC"", depending on the value of attribute MyBool by evaluating attribute AttribX. Thus eval() gives the action code result of an attribute rather than its literal value. As such eval is normally applied to string-based attributes.
If trying to construct an attribute reference from ""$"" and a literal string or variable, use action() instead.
Further examples
The eval() function can be useful for inserting a local attribute value in an expression that will be evaluated in a different context. Consider this find() in an a rule:
	$ArtistCount = find($ArtistName==$Name & !$IsAlias).size; 
For each note evaluated, the note's $Name is compared to ArtistName. However, what if the intent was to use this in a note with an artist's name where it is necessary to come the calling note's $Name, not that of the in-scope note. There is no designator for that relationship, but eval() offers a way around:
	$ArtistCount = eval('(find($ArtistName==""'+$Name+'"" & !$IsAlias).size)'); 
This first of all makes a string using the correct find code but also inserting the value of the calling note's $Name, and then the whole is evaluated as if it were the original verbatim find() call above. 
The process can be made clearer by splitting it into two steps by first using a placeholder $TempString attribute:
	$TempString = '(find($ArtistName==""'+$Name+'"" & !$IsAlias).size)'; 
The outer parentheses are simply to ensure the .size() call chained on the end of the find is evaluated with the find(). For a note called ""Jacques Brel"", $TempString would be the string: (find($ArtistName==""Jacques Brel"" & !$IsAlias).size). Now, to use eval():
	$ArtistCount = eval($TempString); 
Side note: the actual scenario above can also be solved using the 'that' designator, although the example holds true as an exploration of how eval() works.
A more complex example, using nested eval() calls is described under 'using long sections of code'.
Macros: eval() can be combined with do(macro). As macros take input arguments, an evaluated macro can work a bit like a code function, taking inputs and returning output that once passed through eval() gives an evaluated result. See the do() operator.
The eval() operator also allows access to two Tinderbox properties that are not available via action syntax or attribute value. There are the current TBX document's filename (sans extension) and the app version of the currently used Tinderbox on the user's Mac:
	eval(docTitle) gives a value of """" (note no '.tbx' extension)
	eval(version) gives """" (note that you might want to prefix the return string with 'v' or 'v.' thus: ""v."").
In full syntax form, an additional first argument is added that is an expression string evaluating as a note name, path or note name. Where specified, this indicates the note from which attribute values in the second argument should be drawn.
To create an attribute reference ($-prefixed as in '$Name' not 'Name') use action() instead of eval(). 
Example using both inputs
A different example, using the optional path argument. Take two root-level notes, AA and BB.
	$Text(""AA"") is: 1+1
	$Text(""BB"") is: """"(i.e. nothing)
	$Rule(""BB"") is: $Text=eval(""AA"",$Text) 
…after a brief delay, the text of note BB becomes 2, i.e. the sum of the expression stored in aa's text. The item argument ""AA"" simply indicates that the source of the expressionStr is the note AA.
Now change AA's text:
	$Text(""AA"") is: if(1){42}else{1000}
…after a brief delay, the text of note BB becomes 42. How? Any if(condition) is a Boolean test trying to get a true/false result. If the condition does not result in an actual Boolean value (e.g. testing the value of a Boolean attribute) a Boolean is coerced from the result. Thus an empty string or set or the number zero equate to false, all other values to true. Thus in AA's text above, the condition (1) equates to true so the result is 42.
Again, replace the $Text of note 'AA' with
	$Text(""AA""): $Color==""red""
This is less obvious. When the expression is evaluated, the result will be true if AA is red, and false otherwise. So, $Text(""BB"") will be empty unless AA is red; if AA's $Color is red,
	$Text(""BB""): true","eval([item,] expressionStr)
item 引数は、属性参照でない限り、引用符で囲む必要があります。item を定義する方法については後述します。
eval() 関数は、評価された（文字列としての）2つの引用符付き引数を取ります。第1引数の item はオプションです。第2引数の expressionStr は、評価されるアクションコード式を保持する文字列です。したがって、基本形は以下のようになります：
	if($MyBool){$AttribX = ""$Name(parent)+' XYZ'"";}else{$AttribX = ""$Name(grandparent) + 'ABC'"";}; $AttribY = eval($AttribX); 
これは、属性 MyBool の値に応じて、属性 AttribX を評価することにより、AttribY に現在のノートの親の名前（タイトル）に文字列 ""XYZ"" を加えたもの、または祖父母の名前（タイトル）に文字列 ""ABC"" を加えたものを設定します。このように、eval() は属性のリテラル値ではなく、アクションコードとしての評価結果を返します。そのため、eval() は通常、文字列ベースの属性に適用されます。
「$」とリテラル文字列または変数から属性参照を構築しようとする場合は、eval() ではなく action() を使用してください。

さらなる例
eval() 関数は、別のコンテキストで評価される式の中に、ローカル属性の値を挿入するのに役立ちます。ルール内でのこの find() を考えてみましょう：
	$ArtistCount = find($ArtistName==$Name & !$IsAlias).size; 
評価される各ノートについて、そのノートの $Name が $ArtistName と比較されます。しかし、意図が、アーティスト名を持つノート（呼び出し元のノート）の $Name を使用することであり、検索対象（インスコープ）のノートの $Name と比較することではなかった場合はどうなるでしょうか。その関係を示す指定子はありませんが、eval() が解決策を提供します：
	$ArtistCount = eval('(find($ArtistName==""'+$Name+'"" & !$IsAlias).size)'); 
これはまず、正しい検索コードを使用しつつ呼び出し元のノートの $Name の値を挿入した文字列を作成し、その全体を元の逐次的な find() 呼び出しであるかのように評価します。
このプロセスは、まずプレースホルダーの $TempString 属性を使用して2つのステップに分割することで、より明確にできます：
	$TempString = '(find($ArtistName==""'+$Name+'"" & !$IsAlias).size)'; 
外側の括弧は、find の最後に連結された .size() 呼び出しが find() と共に評価されることを確実にするためのものです。""Jacques Brel"" という名前のノートの場合、$TempString は (find($ArtistName==""Jacques Brel"" & !$IsAlias).size) という文字列になります。ここで eval() を使用します：
	$ArtistCount = eval($TempString); 
補足：上記の実際のシナリオは 'that' 指定子を使用しても解決できますが、この例は eval() がどのように機能するかを探求するものとして有効です。
入れ子になった eval() 呼び出しを使用したより複雑な例は、「コードの長いセクションの使用（using long sections of code）」の下で説明されています。

マクロ：eval() は do(macro) と組み合わせることができます。マクロは入力引数を取るため、評価されたマクロはコード関数のようになり、入力を受け取って出力を返し、それが eval() を通されることで評価された結果が得られます。do() オペレータを参照してください。

eval() オペレータは、アクション構文や属性値を介しては利用できない2つの Tinderbox プロパティへのアクセスも許可します。これらは、現在の TBX ドキュメントのファイル名（拡張子なし）と、ユーザーの Mac で現在使用されている Tinderbox のアプリバージョンです：
	eval(docTitle) は """" という値を返します（'.tbx' 拡張子がないことに注意）。
	eval(version) は """" を返します（戻り値の文字列の前に 'v' や 'v.' を付けて ""v."" としたい場合があるかもしれません）。

完全な構文形式では、ノート名、パス、またはノートとして評価される式文字列である第1引数が追加されます。これが指定された場合、第2引数の属性値を取得する際のソースとなるノートを示します。
（'$Name' のように 'Name' ではなく）$プレフィックスが付いた属性参照を作成するには、eval() の代わりに action() を使用してください。

両方の入力を使用した例
オプションのパス引数を使用した別の例です。2つのルートレベルのノート、AA と BB を用意します。
	$Text(""AA"") は: 1+1
	$Text(""BB"") は: """"（つまり、空）
	$Rule(""BB"") は: $Text=eval(""AA"",$Text) 
…少し遅れて、ノート BB のテキストは 2（つまり、AA のテキストに保存された式の合計）になります。引数 ""AA"" は、単に expressionStr のソースがノート AA であることを示しています。
次に AA のテキストを変更します：
	$Text(""AA"") は: if(1){42}else{1000}
…少し遅れて、ノート BB のテキストは 42 になります。なぜでしょうか？ if(条件) は、真/偽の結果を得ようとするブール値テストです。条件が実際のブール値（ブール属性の値をテストする場合など）にならない場合、結果からブール値が強制変換されます。したがって、空の文字列やセット、または数値のゼロは偽（false）に相当し、それ以外のすべての値は真（true）に相当します。したがって、上記の AA のテキストでは、条件 (1) は真に相当するため、結果は 42 になります。
再び、ノート 'AA' の $Text を次のように置き換えます：
	$Text(""AA""): $Color==""red""
これはそれほど明白ではありません。式が評価されるとき、AA が赤であれば結果は true になり、そうでなければ false になります。したがって、$Text(""BB"") は AA が赤でない限り空になります。AA の $Color が赤であれば、以下のようになります：
	$Text(""BB""): true"
"every(scope, condition)",Function,Group,Non-query Boolean,boolean test,false,4.0.0,Baseline,,,,2,true,false,false,false,true,true,true,false,false,,false,"every(scope, condition)
This Boolean operator examines notes at scope and determines whether any note (i.e. at least one) in the group evaluates condition as true.
scope is the notes to be examined and may be any group designator including a find() query. If group evaluates to contain no items, see the edge case described below.
condition may be any valid expression, but will usually be a reference to an attribute; short form Boolean attribute expressions are acceptable. 
condition must not be enclosed in quotes.
For example:
	every(child,$Status==""Important"") 
	every(children,$Overdue==true) 
	every(children,$Overdue) (using short from test)
	every(children,$Overdue==false) 
	every(children,!$Overdue) (using short from test)
Be aware that a counter-intuitive edge case occurs if the scope is empty. Thus, every() is false if condition is false for any designated note. If there are no designated notes at all, i.e. scope is empty, every() is therefore true, whereas the user might have assumed no outcome and thus no true result. If problematic to the user's intent, this condition can be worked around by first ensuring that scope contains something. In the above example, that uses the scope 'children', a modification can be used, like this:
	$ChildCount>0 & every(children,$Overdue==true) 
See also: any().","every(scope, condition)
このブール演算子は、scope内のノートを検証し、グループ内のすべてのノートがconditionを真と評価するかどうかを判定します。
scopeは調査対象のノートであり、find()クエリを含む任意のグループ指定子を使用できます。グループ内の項目が0個の場合については、後述のエッジケースを参照してください。
conditionは任意の有効な式を指定できますが、通常は属性への参照となります。短縮形式のブール属性式も使用可能です。
conditionを引用符で囲んではいけません。
例：
	every(child,$Status==""Important"")
	every(children,$Overdue==true)
	every(children,$Overdue)（短縮形式のテストを使用）
	every(children,$Overdue==false)
	every(children,!$Overdue)（短縮形式のテストを使用）
スコープが空の場合に、直感に反するエッジケースが発生することに注意してください。every()は、指定されたノートのいずれかでconditionが偽であれば偽となります。指定されたノートが全く存在しない場合（つまりscopeが空の場合）、every()は真となりますが、これはユーザーが「結果なし」つまり真の結果ではないことを想定している場合には、直感に反するかもしれません。これがユーザーの意図にそぐわない場合は、まずscopeに要素が含まれていることを確認することで回避できます。上記の「children」をスコープとした例では、次のように修正を加えることができます。
	$ChildCount>0 & every(children,$Overdue==true)
any() も参照してください。"
exp(powerNum),Function,Item,Mathematical,Number,false,5.10.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"exp(powerNum)
Returns the exponential value of powerNum as e to the power of powerNum.
	$MyNumber = exp(3); 
returns 20.08553692 for an input of 3.","exp(powerNum)
powerNumの指数値を、eのpowerNum乗として返します。
	$MyNumber = exp(3); 
入力が3の場合、20.08553692を返します。"
"expand(scope,methodStr)",Function,Group,Formatting,success boolean,false,9.7.0,Baseline,,,,2,true,false,false,false,false,true,false,false,false,,false,"expand(scope,methodStr)
For Map view, this operator alters notes at scope and alters their $Width and/or $Height to fit the $Name string, according to the method given in methodStr. This operator does not require a left-side recipient, although it does return a true/false value if it is desired to check.
There are three valid choices for methodStr. Given in parentheses below are the equivalent settings from Document Settings ▸ Maps ▸ If note name is too long: see the latter link for an explanation of the resulting change. The options are:
* horizontally (same as Expand horizontally)
* vertically (same as Expand vertically)
* proportionately (same as Expand proportionately)
This function allows scoped resetting of map view note icon sizes. For example, to reset all child map notes using the proportional option, run this code on the maps' parent container:
	expand(children, proportional); 
To do similar but for an ad hoc selection on the current map, use a stamp with code:
	expand(this, proportional); 
recalling that a stamp is run individually on each selected item, so the code only needs a scope of the currently addressed item, i.e. this.","expand(scope,methodStr)
マップビューにおいて、このオペレータは scope で指定された範囲のノートを変更し、methodStr で指定された方法に従って、$Name の文字列が収まるように $Width および/または $Height を調整します。このオペレータは左辺の代入先を必要としませんが、必要に応じて成否を確認できるように true/false の値を返します。

methodStr には3つの有効な選択肢があります。以下の括弧内は、「Document Settings ▸ Maps ▸ If note name is too long」における同等の設定です。変更内容の詳細については、リンク先の説明を参照してください。オプションは以下の通りです：
* horizontally（Expand horizontally と同じ）
* vertically（Expand vertically と同じ）
* proportionately（Expand proportionately と同じ）

この関数を使用すると、マップビューのノートアイコンのサイズを指定したスコープでリセットできます。例えば、proportional オプションを使用してすべての子ノートをリセットするには、マップの親コンテナで次のコードを実行します：
	expand(children, proportional); 

現在のマップで任意に選択した項目に対して同様の操作を行うには、以下のコードをスタンプで使用します：
	expand(this, proportional); 

スタンプは選択された各項目に対して個別に実行されるため、コードのスコープは現在処理中の項目（つまり this）のみを指定すればよい点に注意してください。"
"exportedString(item[, templateStr])",Function,Item,Formatting,String,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"exportedString(item[, templateStr])
The operator exportedString() applies an export template to a note, returning the result as a String. 
item designates the note to be exported; and is a note name, path or item designator. An attribute may not be used as a placeholder for such information. By default, the note used is the current note, i.e. 'this'. exportedString() also binds 'current' designator to 'this' when resolving item.
The second argument, templateStr, has three forms.
* an HTML export template name; this argument is evaluated allowing use of attribute values and expressions. Full template paths should not be quotes, but enclose template names ($Name) in double-quotes.
* the name of an attribute or variable whose value is  a string of actual template code (i.e. what would normally be the contents of a template), which is then applied to the referenced note. The attribute reference cannot use a path extension to refer to a different note, $ExportCode is OK but an offset address like $ExportCode(Another note) will fail.
* a literal string of export code. The most usual use of this is as 'text', i.e. the export encoded $Text of the note. This form is suggested only for very short code strings. For longer code, place it in a discrete template and use it via the two-argument form.
In the short, single argument, usage the template to evaluate is not supplied as the target note's inherited or locally assigned template is used. In long-lived projects, it can be useful to use the two-argument form (assuming the template assignment will not change!). Doing this makes it easier to see in code which template will be used rather than have to go and look up that value. Making such a change has no performance input.
The exportedString() operator is especially useful in conjunction with the runCommand() operator. You can use exportedString() to assemble the input an external program will require, and then pass that input to the external program.
If you simply wish to transform a string or attribute value (e.g. $Name) into a 'safe' value for use as an HTML/XML element 'id' value, a possible alternative is to use idEncode().
Examples
exportedString(item)
Use of exportedString with just the target item. If using only the (unique) note $Name, it should be quote-enclosed.
	$MyString = exportedString(""Some Note""); 
or using a full $Path for the template, do not use quotes:
	$MyString = exportedString(/Projects/X/Some Note); 
exportedString(item, templateStr) 
The first form using templateStr takes a reference to a note and the name of a template note and returns the result of applying the template to the note. If item is a path or title, the value requires quotes:
	$MyString = exportedString(this,""tSome_Template""); 
	$MyString = exportedString(""Some note"",""tSome_Template""); 
or use the unquoted full $Path for the template:
	$MyString = exportedString(this,/Templates/tSome_Template); 
The second form using templateStr requires as its second argument is the template string itself which may be a reference to an attribute or action code variable:
	$MyString = exportedString(this,$MyTemplateCode); 
	$MyString = exportedString(this,vTemplate); 
The third form using templateStr requires as its second argument some literal code:
	$MyString = exportedString(""/Path/To/Some note"",""text""); 
	$MyString = exportedString(""/Path/To/Some note"",""value($Name(parent))"");","exportedString(item[, templateStr])

演算子 exportedString() は、エクスポートテンプレートをノートに適用し、その結果を文字列（String）として返します。

item はエクスポートするノートを指定します。ノートの名前、パス、または項目指定子（item designator）が使用できます。属性をこの情報のプレースホルダーとして使用することはできません。デフォルトでは、使用されるノートは現在のノート、つまり「this」です。exportedString() はまた、item を解決する際に「current」指定子を「this」にバインドします。

第2引数の templateStr には3つの形式があります。
* HTMLエクスポートテンプレートの名前。この引数は評価されるため、属性値や式を使用できます。テンプレートのフルパスは引用符で囲むべきではありませんが、テンプレート名（$Name）はダブルクォーテーションで囲んでください。
* 実際のテンプレートコード（通常はテンプレートの内容となるもの）を値として持つ属性または変数の名前。指定されたコードが参照先のノートに適用されます。属性参照でパス拡張を使用して別のノートを参照することはできません（$ExportCode は有効ですが、$ExportCode(Another note) のようなオフセットアドレスは失敗します）。
* エクスポートコードのリテラル文字列。最も一般的な用途は「text」、つまりノートの HTML エクスポート用にエンコードされた $Text です。この形式は、非常に短いコード文字列の場合にのみ推奨されます。長いコードの場合は、個別のテンプレートに配置し、2引数形式で使用してください。

引数が1つだけの短い形式では、対象のノートに継承またはローカルで割り当てられているテンプレートが使用されるため、評価するテンプレートは指定しません。長期にわたるプロジェクトでは、2引数形式を使用するのが便利です（テンプレートの割り当てが変更されないことを前提としています）。これにより、どのテンプレートが使用されるかをコード内で確認しやすくなり、わざわざ値を確認しに行く必要がなくなります。このような変更によるパフォーマンスへの影響はありません。

exportedString() 演算子は、runCommand() 演算子と組み合わせて使用する場合に特に便利です。exportedString() を使用して外部プログラムが必要とする入力を組み立て、その入力を外部プログラムに渡すことができます。

文字列や属性値（例：$Name）を HTML/XML 要素の「id」値として使用するための「安全な」値に変換したいだけの場合は、代替案として idEncode() の使用を検討してください。

例
exportedString(item)
ターゲットとなる item のみで exportedString を使用する場合。（一意の）ノートの $Name のみを使用する場合は、引用符で囲む必要があります。
	$MyString = exportedString(""Some Note""); 
テンプレートにフルパス（$Path）を使用する場合は、引用符を使用しないでください：
	$MyString = exportedString(/Projects/X/Some Note); 

exportedString(item, templateStr) 
templateStr を使用する最初の形式は、ノートへの参照とテンプレートノートの名前を受け取り、テンプレートをノートに適用した結果を返します。item がパスやタイトルの場合、値には引用符が必要です：
	$MyString = exportedString(this,""tSome_Template""); 
	$MyString = exportedString(""Some note"",""tSome_Template""); 
または、テンプレートに引用符なしのフルパスを使用します：
	$MyString = exportedString(this,/Templates/tSome_Template); 

templateStr を使用する2番目の形式は、第2引数としてテンプレート文字列そのものを必要とします。これは属性やアクションコードの変数への参照でも構いません：
	$MyString = exportedString(this,$MyTemplateCode); 
	$MyString = exportedString(this,vTemplate); 

templateStr を使用する3番目の形式は、第2引数にリテラルコードを必要とします：
	$MyString = exportedString(""/Path/To/Some note"",""text""); 
	$MyString = exportedString(""/Path/To/Some note"",""value($Name(parent))"");"
fail(),Function,Item,Stream parsing,success boolean,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"fail()
fail
The fail operator makes an explicit declaration of a failure, and if invoked only ever returns false.
Often, in stream processing a failure occurs implicitly, for example because the end of the processed string is reached without finding the desired data. However, sometimes, there is a definite need to signal failure; for example, because the parsed data are invalid.
For example:
	$MyString.try{
	   $MyString.skipTo("":"").captureWord(""TheWord"");
	   if($TheWord.contains(""None"")) {
	      fail();
	   }
	}
The above skips through $MyString to the first colon and then captures the next discrete word after the colon into $TheWord. The action fails if:
* if there is no colon
* if there is no word after the colon
* if $TheWord contains ""None"" as a case-sensitive exact full match or substring match.","fail()
fail
failオペレータは、失敗を明示的に宣言し、呼び出された場合は常にfalseを返します。
ストリーム処理では、目的のデータが見つからないまま処理対象の文字列の末尾に達した場合など、失敗が暗黙的に発生することがよくあります。しかし、パースされたデータが無効である場合など、失敗を明確に通知する必要がある場合もあります。
例：
	$MyString.try{
	   $MyString.skipTo("":"").captureWord(""TheWord"");
	   if($TheWord.contains(""None"")) {
	      fail();
	   }
	}
上記は、$MyStringを最初のコロンまでスキップし、コロンの後の次の個別の単語を$TheWordにキャプチャします。このアクションは以下の場合に失敗します：
* コロンが存在しない場合
* コロンの後に単語が存在しない場合
* $TheWordに「None」が（大文字小文字を区別して）完全一致または部分一致で含まれている場合"
"fetch(urlStr,headersDict,attrNameStr,cmdStr[,httpMethod,POSTbody])",Function,Item,Document configuration,String,false,9.6.0,Baseline,,,,4,true,false,false,false,false,false,false,false,false,,false,"The `fetch(urlStr, headersDict, attrNameStr, cmdStr[, httpMethod, POSTbody])` operator in Tinderbox facilitates data collection from servers, offering greater flexibility than AutoFetch. It is designed for advanced use cases, such as interacting with APIs requiring custom headers or immediate result processing.

**Parameters:**
*   **`urlStr`**: The source URL string.
*   **`headersDict`**: A dictionary of HTTP(S) headers. Must be an empty dictionary `{}` if no custom headers are required.
*   **`attrNameStr`**: The *name* (as a literal quoted string) of the attribute or local variable where the fetch output is stored. Unlike AutoFetch, which targets `$Text`, this allows storage in specific attributes.
*   **`cmdStr`**: An action expression (or semi-colon delimited sequence) to execute after the data is successfully fetched.
*   **`httpMethod`** (Optional): The HTTP request method (e.g., GET, POST, PUT, DELETE). Defaults to GET if unspecified.
*   **`POSTbody`** (Optional): The message body to send if the method is POST.

**Operational Behavior:**
*   **Asynchronous Execution**: The operator returns immediately without waiting for the server. Tinderbox attempts to retrieve data for approximately 30 seconds.
*   **Callback Processing**: The `cmdStr` is evaluated only after data arrives. Because of the potential delay, multiple `fetch()` requests are processed on a serial queue to prevent interference.
*   **Concurrency Control**: Users should manage state (e.g., setting an ""In Progress"" boolean flag) to avoid initiating new fetch calls before previous ones complete.

**Usage:**
AutoFetch is preferred for standard tasks. `fetch()` is necessary when specific HTTP methods, authentication headers, or immediate post-processing logic (like handling API pagination tokens) are required.","Tinderboxにおける `fetch(urlStr, headersDict, attrNameStr, cmdStr[, httpMethod, POSTbody])` オペレーターは、サーバーからのデータ収集を容易にし、AutoFetchよりも高い柔軟性を提供します。これは、カスタムヘッダーを必要とするAPIとのやり取りや、結果の即時処理が必要な高度なユースケース向けに設計されています。

**パラメータ:**
*   **`urlStr`**: ソースURL文字列。
*   **`headersDict`**: HTTP(S)ヘッダーのディクショナリ。カスタムヘッダーが不要な場合は、空のディクショナリ `{}` を指定する必要があります。
*   **`attrNameStr`**: フェッチ出力の保存先となる属性またはローカル変数の*名前*（引用符で囲まれたリテラル文字列）。AutoFetchが `$Text` を対象とするのに対し、これは特定の属性への保存を可能にします。
*   **`cmdStr`**: データのフェッチに成功した後に実行されるアクション式（またはセミコロンで区切られた一連の式）。
*   **`httpMethod`** （任意）: HTTPリクエストメソッド（例：GET、POST、PUT、DELETE）。未指定の場合はデフォルトでGETになります。
*   **`POSTbody`** （任意）: メソッドがPOSTの場合に送信されるメッセージボディ。

**動作:**
*   **非同期実行**: オペレーターはサーバーの応答を待たずに即座に復帰します。Tinderboxは約30秒間、データの取得を試みます。
*   **コールバック処理**: `cmdStr` はデータが到着した後にのみ評価されます。遅延が発生する可能性があるため、複数の `fetch()` リクエストは、干渉を防ぐためにシリアルキューで処理されます。
*   **並行制御**: 前のフェッチが完了する前に新しいフェッチが開始されないよう、ユーザーは状態（例：「進行中」を示すブール値フラグの設定など）を管理する必要があります。

**使用法:**
標準的なタスクにはAutoFetchが推奨されます。特定のHTTPメソッド、認証ヘッダー、または即時の後処理ロジック（APIのページネーショントークンの処理など）が必要な場合に `fetch()` が必要になります。"
find(query),Function,Query,"Dictionary, Set & List operations",List,false,5.6.0,Baseline,,,,1,true,false,false,false,false,true,false,false,false,,false,"find(query)
The find() operator returns List-type data of the $Path of all items matching the query argument scope (defining scope). Note that find(), unlike agent queries, does not de-duplicate its matches so any aliases in scope with be matched: to avoid the latter see section 'Filtering out aliases' below. 
To return a list of paths for notes with prototype of 'pRef' and fro which boolean $HasRef is false use:
	find($Prototype==""pRef"" & $HasRef==false) 
Conceptually find() is intended for where no item or group designator exists for use inline in action code (note: such designators were the only scoping terms in early version of Tinderbox). In most cases an agent is the likely and better alternative, noting that agents can also use the results of other agents. find() can also be thought of as a short way of writing:
	$MyList = collect_if(all, expression, $Path); 
where the expression is scope.
The find() operator omits notes for which $Searchable is false.
Filtering out aliases
The find() operator does not de-dupe results in the way an agent does. As find() collects $Path data, aliases both inside and outside agents may also match the query. Adding !$IsAlias as a query term will scrub any aliases from matching a search.
Thus if getting unexpected results via find(), consider whether it is because some de-duping was (incorrectly) assumed and be prepared to sharpen the query terms accordingly.
In the above example, to additionally filter out possible alias matches add an extra query term:
	find($Prototype==""pRef"" & $HasRef==false & $IsAlias==false) 
See also: querying for aliases.","find(query)
find() オペレーターは、クエリ引数のスコープ（定義スコープ）に一致するすべてのアイテムの $Path を、リスト型のデータとして返します。find() は、エージェントのクエリとは異なり、一致した結果の重複除去を行わないため、スコープ内のエイリアスも一致することに注意してください。エイリアスを避ける方法については、後述の「エイリアスの除外」セクションを参照してください。

プロトタイプが 'pRef' で、ブール値の $HasRef が false であるノートのパスのリストを返すには、以下のように記述します：
	find($Prototype==""pRef"" & $HasRef==false) 

概念として、find() は、アクションコード内でインラインで使用できるアイテム指定子やグループ指定子が存在しない場合のために用意されています（注：初期の Tinderbox では、これらの指定子が唯一のスコープ定義用語でした）。ほとんどの場合、エージェントの方がより適切で有力な選択肢となります。エージェントは他のエージェントの結果を利用できることも覚えておいてください。find() は、以下の記述の短縮形と考えることもできます：
	$MyList = collect_if(all, expression, $Path); 
ここで、expression はスコープ（クエリ）です。

find() オペレーターは、$Searchable が false であるノートを除外します。

エイリアスの除外
find() オペレーターは、エージェントが行うような結果の重複除去を行いません。find() は $Path データを収集するため、エージェントの内外にあるエイリアスもクエリに一致する可能性があります。クエリ条件に !$IsAlias を追加することで、検索結果からエイリアスを除外できます。

したがって、find() で予期しない結果が得られた場合は、重複除去が（誤って）行われると想定していないか検討し、クエリ条件をより厳密に設定するようにしてください。

上記の例で、さらにエイリアスの一致を除外するには、以下のようにクエリ条件を追加します：
	find($Prototype==""pRef"" & $HasRef==false & $IsAlias==false) 

参照：エイリアスのクエリ (querying for aliases)"
"first(item[, childrenNum])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"first(item[, childrenNum])
Returns Boolean true if the current note is among the first itemsNum of children of item. If itemsNum is missing, a value of 1 is assumed. The item argument must be quoted unless an attribute reference. Ways to define item.
Both arguments are evaluated and can be a literal string/number, an attribute value or an action code expression evaluating to that same.
If the current note has a $SiblingOrder value of 2, then if first() is run on its parent container:
	first(""Note A"", 5) returns true 
but if 'it has a $SiblingOrder value of 7:
	first(""Note A"", 5) returns false
first() also has a logical opposite in last().
Legacy issues
This operator replaces the legacy #first query operator.","first(item[, childrenNum])
現在のノートが、itemの最初からchildrenNum番目までの子ノートに含まれている場合に、Booleanのtrueを返します。childrenNumが省略された場合、値1が想定されます。item引数は、属性参照でない限り引用符で囲む必要があります。itemを定義する方法。
両方の引数が評価され、リテラルの文字列/数値、属性値、またはそれらと同じ結果を生成するアクションコード式を指定できます。
現在のノートの$SiblingOrderの値が2である場合、その親コンテナでfirst()を実行すると：
	first(""Note A"", 5) はtrueを返します
しかし、$SiblingOrderの値が7である場合：
	first(""Note A"", 5) はfalseを返します
first()には論理的な反対語としてlast()もあります。
レガシーの問題
このオペレータは、レガシーな#firstクエリ・オペレータを置き換えるものです。"
firstWord(dataStr),Function,Item,Data manipulation,String,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"firstWord(dataStr)
The firstWord() operator has one argument, dataStr (a quoted string), and it returns the first word of dataStr (as a String). The delimiter used to define words is one or more spaces (possibly also line break(s)?).
The dataStr argument is evaluated so could be an expression. For example, if the note 'First Line' has the body text ""Winter is coming."", then 
	$MyString = firstWord($Text(""First Line"")); 
should give a result of ""Winter"".","firstWord(dataStr)
firstWord() オペレータは、1 つの引数 dataStr（引用符で囲まれた文字列）を取り、dataStr の最初の単語を（文字列として）返します。単語の区切り文字には、1 つ以上のスペース（おそらく改行も含まれます）が使用されます。
dataStr 引数は評価されるため、式を指定することも可能です。例えば、ノート 'First Line' の本文が ""Winter is coming."" である場合、
	$MyString = firstWord($Text(""First Line""));
の結果は ""Winter"" となります。"
floor(sourceNum),Function,Item,Mathematical,Number,false,6.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"floor(sourceNum)
rounds the number value of sourceNum down to next whole integer.
See also ceil() and round().
If $MyNumber is 3.9 then:
	$MyNumber = ceil($MyNumber); 
sets $MyNumber to 3. Note unlike normal rounding the value is set downwards to the next integer (i.e. whole number).","floor(sourceNum)
sourceNum の数値を、それ以下の直近の整数に切り捨てます。
ceil() および round() も参照してください。
$MyNumber が 3.9 の場合：
	$MyNumber = ceil($MyNumber); 
は $MyNumber を 3 に設定します。注意：通常の丸めとは異なり、値はより小さい整数（すなわち整数）に向けて設定されます。"
"format(dataStr, formatStr[, additionalArguments])",Function,Item,Formatting,String,false,4.0.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"The `format(dataStr, formatStr[, additionalArguments])` operator converts various Tinderbox objects into strings. While the newer per-data-type `.format()` dot-operators are generally preferred, this function remains available.

**General Behavior:**
*   In quoted string arguments, `\""` converts to a double quote, `\n` to a carriage return, and `\t` to a tab.
*   `dataStr` is evaluated (usually an attribute reference or expression).
*   The function's behavior depends on the data type of `dataStr`.

**Data Type Specifics:**

*   **DATE:** `format(dataStr, formatStr)`
    *   Uses standard Tinderbox date export codes for `formatStr`.
    *   Example: `format($Created,""L"")` returns a long local date (e.g., ""Sunday, 23 March, 2007"").
    *   Alternative: `Date.format(""formatString"")`.

*   **SET/LIST:** `format(data, formatStr)`
    *   **Simple Delimiter:** If `formatStr` is a single string, it serves as the delimiter between elements.
        *   Example: `format($DisplayedAttributes, "", "")` returns a comma-separated list.
    *   **Structured Output:** `format(data, list-prefix, item-prefix, item-suffix, list-suffix)`
        *   Accepts four specific arguments to wrap the list and its items (e.g., for HTML).
        *   Example: `format($Classes, ""<ul>"", ""<li>"", ""</li>"", ""</ul>"")` generates an HTML bulleted list.
    *   Alternative: `List.format(""formatString"")` or the 4-argument version.

*   **NUMBER:** `format(dataStr, precisionNum[, widthNum][, padStr])`
    *   *Deprecated:* Prefer `Number.precision()` or `Number.format()`.
    *   `precisionNum`: Controls the number of decimal places.
    *   `widthNum`: (Optional) Sets the width of the returned string, left-padding as needed.
    *   `padStr`: (Optional) Specifies the padding character (default is space).
    *   Example: `format(7, 0, 3, ""0"")` results in ""007"".
    *   **Locale Formatting:** `Number.format(""L"")` returns a string with locale-dependent group and decimal delimiters.

*   **COLOR:** `format(colorStr)`
    *   Ignores format strings.
    *   Always returns the color in hex format (e.g., ""#ff00ff""), even if the stored value is a named color.
    *   Alternative: `Color.format()`.

*   **INTERVAL:**
    *   Uses date-type format strings.
    *   An interval of 00:00 is returned as an empty string.
    *   Alternative: `Interval.format()`.","`format(dataStr, formatStr[, additionalArguments])` オペレータは、さまざまな Tinderbox オブジェクトを文字列に変換します。現在では、より新しいデータ型ごとの `.format()` ドット演算子が一般的に推奨されていますが、この関数も引き続き利用可能です。

**全般的な動作:**
* 引用符で囲まれた文字列引数内では、`\""` は二重引用符、`\n` は改行（キャリッジリターン）、`\t` はタブに変換されます。
* `dataStr` が評価されます（通常は属性の参照または式）。
* この関数の動作は、`dataStr` のデータ型によって異なります。

**データ型ごとの詳細:**

* **DATE（日付）:** `format(dataStr, formatStr)`
    * `formatStr` には標準の Tinderbox 日付エクスポートコードを使用します。
    * 例: `format($Created, ""L"")` はローカル形式の長い日付（例: ""Sunday, 23 March, 2007""）を返します。
    * 代替案: `Date.format(""formatString"")`

* **SET/LIST（セット/リスト）:** `format(data, formatStr)`
    * **単純な区切り文字:** `formatStr` が単一の文字列の場合、それが要素間の区切り文字として機能します。
        * 例: `format($DisplayedAttributes, "", "")` はカンマで区切られたリストを返します。
    * **構造化された出力:** `format(data, list-prefix, item-prefix, item-suffix, list-suffix)`
        * リストとその項目をラップするための 4 つの特定の引数を受け取ります（例: HTML 用）。
        * 例: `format($Classes, ""<ul>"", ""<li>"", ""</li>"", ""</ul>"")` は HTML の箇条書きリストを生成します。
    * 代替案: `List.format(""formatString"")` または 4 引数バージョン。

* **NUMBER（数値）:** `format(dataStr, precisionNum[, widthNum][, padStr])`
    * *非推奨:* `Number.precision()` または `Number.format()` を推奨します。
    * `precisionNum`: 小数点以下の桁数を制御します。
    * `widthNum`: (任意) 返される文字列の幅を設定し、必要に応じて左側にパディングを挿入します。
    * `padStr`: (任意) パディング文字を指定します（デフォルトはスペース）。
    * 例: `format(7, 0, 3, ""0"")` は ""007"" となります。
    * **ロケール形式:** `Number.format(""L"")` は、ロケールに依存したグループ区切り文字と小数点文字を使用した文字列を返します。

* **COLOR（カラー）:** `format(colorStr)`
    * フォーマット文字列は無視されます。
    * 格納されている値が名前付きカラーであっても、常に 16 進数形式（例: ""#ff00ff""）でカラーを返します。
    * 代替案: `Color.format()`

* **INTERVAL（インターバル）:**
    * 日付型のフォーマット文字列を使用します。
    * 00:00 のインターバルは空の文字列として返されます。
    * 代替案: `Interval.format()`"
function,Statement,Document,Data manipulation,declaration,false,9.1.0,Baseline,,,,,false,false,false,true,false,false,false,false,false,,true,"function
The function statement defines a user-defined function. Unusually as an operator function is used as a statement which is then followed by the definition of a user-named function fName. Atypically, trailing empty parentheses must not used by function. Thus:
function fName([argumentsList]){code}
Once defined a function is called in action code using the user-defined function name (here fName), as described here. Any function may several arguments or none at all. These are defined via a comma-delimited argumentsList. All arguments defined in the list are mandatory, unlike some action code operators which define some arguments as optional. In use, all defined arguments must be supplied, even if only as a default value, e.g. 0 for a number, etc.
All input arguments (the argumentsList) are available to use in code within the function. Thus by using the argument name as defined in the argumentsList, each argument's supplied value is retrievable anywhere within the function. Just as with a loop variable, the defined argument name is the code used to retrieve that argument's value.
As functions are more complex than other operators, their complete syntax and use is described in detail in the article on Functions and its sub-articles.
Function declarations may optionally specify the date type of their input arguments, as passed via argumentsList.
Private functions
A private function is a function that can only be called within the note in which it is defined. That note will usually be a library note.
The point of a private function is it allows for the scenario where two (or more) functions might have the same name as might arise if using library notes created by different people. Thus two (or more) library notes can each define private functions with identical names; each library note will use its own version of the private function. As long as functions are labelled private, they will only be callable from their containing note and not from other (library) notes. Be aware that if a note only contains one function it should not be made private—as nothing outside the note can call it. 
A function is designated private by inserting the word private between the function's argument parentheses and the curly brace starting the function's code:
	function fFunctionName(Args) private { ...code... }
White space(s) before/after the private is optional.","functionステートメントは、ユーザー定義関数を定義します。演算子としては珍しく、functionはステートメントとして使用され、その後にユーザーが命名した関数名fNameの定義が続きます。また、functionでは（関数名の後に）空の括弧を付けてはいけないという特異なルールがあります。したがって、構文は以下のようになります：
function fName([argumentsList]){code}

一度定義された関数は、こちらで説明されているように、ユーザー定義の関数名（ここではfName）を使用してアクションコード内で呼び出されます。すべての関数は、複数の引数を持つことも、引数を持たないことも可能です。これらはカンマ区切りのargumentsListを介して定義されます。一部のアクションコード演算子では引数を任意（省略可能）にできますが、関数のリストで定義された引数はすべて「必須」です。使用時には、たとえデフォルト値（数値なら0など）であっても、定義されたすべての引数を提供しなければなりません。

すべての入力引数（argumentsList）は、関数内のコードで利用可能です。argumentsListで定義された引数名を使用することで、渡された引数の値を関数内のどこからでも取得できます。ループ変数と同様に、定義された引数名は、その引数の値を取得するためのコードとして機能します。

関数は他の演算子よりも複雑なため、その完全な構文と使用法については、「関数（Functions）」に関する記事とそのサブ記事で詳しく説明されています。
関数宣言では、argumentsListを介して渡される入力引数のデータ型を任意で指定することもできます。

プライベート関数
プライベート関数とは、その関数が定義されているノート内でのみ呼び出すことができる関数です。そのノートは通常、ライブラリノートになります。
プライベート関数の利点は、異なる作成者によるライブラリノートを併用する場合など、2つ以上の関数が同じ名前を持ってしまう状況に対応できることです。これにより、複数のライブラリノートがそれぞれ同名のプライベート関数を定義でき、各ノートは独自のバージョンのプライベート関数を使用します。関数がprivateと指定されている限り、それらは含まれているノート内からのみ呼び出し可能で、他の（ライブラリ）ノートからは呼び出せません。ただし、ノートに関数が1つしか含まれていない場合、ノート外部から呼び出せなくなるため、プライベートにすべきではない点に注意してください。

関数をプライベートにするには、関数の引数の括弧と、コードを開始する波括弧の間に「private」という単語を挿入します：
	function fFunctionName(Args) private { ...code... }
privateの前後の空白は任意です。"
"hasLocalValue(attributeNameStr[, item])",Function,Item,Data manipulation,success boolean,false,7.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"hasLocalValue(attributeNameStr[,item])
For the current note this tests if an attribute name attributeNameStr has a locally set value (returning a Boolean true), or whether that value is inherited from a prototype or document default (false). The main input is a quote-enclosed system or currently defined user attribute (without a $ prefix):
	$MyBoolean = hasLocalValue(""Rule"") 
The arguments are evaluated, so 
	$MyBoolean = hasLocalValue($MyString) 
returns information about the attribute whose name is currently saved as the current note's value of $MyString.
The note evaluated is the current note. The 'item' input allows for offset addressing. For example:
	$MyBoolean = hasLocalValue(""Rule"",""Some Note"") 
checks the local value status of $Rule not for the current note but for the note called ""Some Note""
As the operator returns a boolean, it can be used in a query in agents or find(), like so:
	$MyBoolean = hasLocalValue(""Edict"") 
in this case matching any note with a locally-set $Edict value.
Note: most users will not have need of this but it is useful in very large document to find the odd note with a local setting, when visual review would take too long. It is also useful where (re-)inheritance of attribute values appears broken or is not reset as expected.","hasLocalValue(attributeNameStr[,item])
現在のノートにおいて、属性名 attributeNameStr がローカルに設定された値を持っているか（真偽値 true を返す）、あるいはその値がプロトタイプやドキュメントのデフォルトから継承されているか（false）を判定します。主な入力は、引用符で囲まれたシステム属性または現在定義されているユーザー属性の名前（$ 接頭辞なし）です：
	$MyBoolean = hasLocalValue(""Rule"") 
引数は評価されるため、
	$MyBoolean = hasLocalValue($MyString) 
は、現在のノートの $MyString の値として現在保存されている名前を持つ属性についての情報を返します。
対象となるノートは現在のノートです。引数 'item' を使用すると、他のノートを指定（オフセット指定）できます。例えば：
	$MyBoolean = hasLocalValue(""Rule"",""Some Note"") 
は、現在のノートではなく、""Some Note"" という名前のノートにおける $Rule のローカル値の状態を確認します。
この演算子は真偽値を返すため、次のようにエージェントや find() のクエリで使用できます：
	$MyBoolean = hasLocalValue(""Edict"") 
この場合、$Edict の値がローカルに設定されているすべてのノートに一致します。
注意：ほとんどのユーザーにとってこれが必要になることは稀ですが、目視での確認が困難な非常に大きなドキュメントで、ローカル設定が残っている特定のノートを探す際に便利です。また、属性値の（再）継承が正しく機能していない、あるいは期待通りにリセットされない場合の調査にも役立ちます。"
"hour(aDate, hoursNum)",Function,Item,Date-time,Date,false,5.7.0,Baseline,,,,2,true,false,true,false,false,false,false,false,false,,false,"hour(theDate, hoursNum)
creates a new Date based on the aDate expression, but in which the hour is hoursNumDate is not changed unless theDate is an attribute and the attribute is re-setting itself:
	$MyDateA = hour($MyDate,14); $MyDate is unaltered
	$MyDate = hour($MyDate,14); $MyDate is changed
Examples. If $MyDate is July 4,2009 09:30, then 
	$MyDate=hour($MyDate,19); 
will change $MyDate to July 4, 2009 19:30.
The single-argument form that reads the hour value is documented separately: see hour(aDate).","hour(theDate, hoursNum)
theDate 式に基づき、新しい日付（Date）を作成しますが、その「時」は hoursNum になります。theDate が属性であり、その属性自体を再設定しない限り、元の Date は変更されません。
	$MyDateA = hour($MyDate,14); $MyDate は変更されません
	$MyDate = hour($MyDate,14); $MyDate は変更されます
例：$MyDate が 2009年7月4日 09:30 の場合、
	$MyDate=hour($MyDate,19); 
は $MyDate を 2009年7月4日 19:30 に変更します。
「時」の値を読み取る引数1つの形式は、別途ドキュメント化されています。hour(aDate) を参照してください。"
hour(aDate),Function,Item,Date-time,Number,false,5.7.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"hour(aDate)
returns the hour element from the aDate date/time expression, which may simply be a date-type attribute value.
Alternatively, use Date.hour.
The two-argument merthod used to set Dates is documented separately: see hour(aDate, hoursNum).","hour(aDate)
aDateの日時式（単に日付型の属性値である場合もあります）から「時」の要素を返します。
あるいは、Date.hourを使用してください。
日付を設定するために使用される2つの引数を持つメソッドは、別途記載されています。hour(aDate, hoursNum)を参照してください。"
"hours(startDate, endDate)",Function,Item,Date-time,Number,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"hours(startDate, endDate) 
returns the Number of whole hours that elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA has time 12:30 and $DateB has time 15:00, then:
	$MyNumber = hours($DateA,$DateB); 
sets $MyNumber to 2.","hours(startDate, endDate)
startDate から endDate までに経過した整数の時間数を返します。endDate が startDate より前の場合は、結果は負の値になります。
$DateA の時刻が 12:30 で $DateB の時刻が 15:00 の場合：
	$MyNumber = hours($DateA,$DateB);
は $MyNumber に 2 をセットします。"
idEncode(dataStr),Function,Item,Formatting,String,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"idEncode(data)
Returns input argument string data in a form suitable for use an id attribute value in HTML and XML. This addresses the problem of using general text strings such as note names as 'id' attributes in output for marked up languages like HTML and XML.
idEncode(""stringValue"")
idEncode($AttributeName)
Using idEncode() ensures the result begins with a letter or underscore, and contains only letters, digits, and the underscore character. Multiple underscores are collapsed to a single character. For example:
	idEncode(string) → result string
	frogs → frogs 
	frogs dogs → frogs_dogs 
	War And Peace → War_And_Peace 
	3 blind mice → _3_blind_mice 
	Wow!!! Look → Wow_Look 
Notice that leading numbers (not legal for 'id' initial characters) are preceded by underscores to maintain legibility vs. the source string.
Note too (see syntax examples at top) that string literal values are ""quoted"" whereas attribute names are not, the latter's status being indicated by their $ prefix.
In code, the last example above can be expressed:
	$MyString = idEncode(""Wow!!! Look"") 
which gives a value ""Wow_Look"".","idEncode(data)
入力引数の文字列 data を、HTML や XML の id 属性値として使用するのに適した形式で返します。これは、HTML や XML などのマークアップ言語の出力において、ノート名などの一般的なテキスト文字列を id 属性として使用する際の問題に対処するものです。

idEncode(""stringValue"")
idEncode($AttributeName)

idEncode() を使用することで、結果が必ず文字またはアンダースコアで始まり、文字、数字、アンダースコアのみが含まれるようになります。複数のアンダースコアは 1 つにまとめられます。

例：
idEncode(string) → 結果の文字列
frogs → frogs
frogs dogs → frogs_dogs
War And Peace → War_And_Peace
3 blind mice → _3_blind_mice
Wow!!! Look → Wow_Look

先頭の数字（id 属性の開始文字として許可されていません）には、元の文字列との可読性を保つためにアンダースコアが前置されることに注意してください。

また（上部の構文例を参照）、文字列リテラルは引用符で囲まれますが、属性名は囲まれません。後者は $ プレフィックスによって属性であることが示されます。

コード内では、上記の最後の例は以下のように記述できます。
$MyString = idEncode(""Wow!!! Look"")
これにより、""Wow_Look"" という値が得られます。"
if(condition){actions}[else{actions}],Function,Conditional Group,Data manipulation,boolean test,false,1.0.0,Baseline,,,,1,true,false,false,false,true,false,true,true,false,,false,"if(condition){actions}[else{actions}]
In rules and (agent) actions, Tinderbox uses this conditional action syntax:
	if(condition){ action(s) }
	if (condition){ action(s) }else{ action(s) }
Where:
* condition is any action code involving an evaluation to a conditional test that resolves to a Boolean true (if the condition is as expected). If the expression is in the form of an $Attribute.[i]contains(regex) query, regex back-references can be used in in the action code of the actions. A conditional expression can also be a query, such as find(), where matching zero results is false and otherwise true is returned.)
* actions is a list of one or more action code expressions, separated by semicolons.
Example:
	if($ChildCount > 5){$Color = ""red"";$Width = 3.5;}else{$Color = ""blue"";} 
A condition can have multiple tests. And (&) or Or (I) joins are allowed as is parenthesised nesting of expressions:
	if($ChildCount > 5 | $Badge = ""ok""){$Color=""red"";$Width=3.5;} 
	if(($ChildCount > 5 & $Badge = ""ok"") | $WordCount >= 450){$Color = ""red"";$Width = 3.5;} 
If the expression is a complex set of condition clauses it may make sense to calculate the conditions, store the value in an attribute and test that in the if(). This form of re-writing the test is a normal part of incremental formalisation such as may occur as a document gets bigger and more complex.
Negative tests
The testing for negatives, the absence of a value (or being in default condition), may be done in several ways. For an attribute value test, the attribute name may simply be prefixed with an exclamation mark, using the short form Boolean test:
	if(!$MyString){…etc. 
Otherwise the != operator is used:
	if($MyString != ""some value""){…etc. 
Closing statements
It is not necessary to close the (last) action code statement in an action list, i.e. put a semi-colon before the closing '}'. However, a semi-colon closure is required after the last closing '}' if other action code follows within the same rule or action:
	if($ChildCount > 5){$Color = ""red"";$Width = 3.5;}else{$Color = ""blue"";}; $Badge = ""ok""; 
	if(!$MyString){
		$Color = ""red"";
	}else{
		$Color = ""blue"";
	};
	$WordCount(parent) = $WordCount(parent)+$WordCount;
Testing multiple conditions
Whilst a single if() test can use a complex expression to form its conditional test, it may be necessary to run a set of linked tests. However, there is no 'else if' construct as found in many programming languages. To handle more than two branches to a condition test, nest an additional if() in either action-list of the first test. Thus:
	if(!$MyString){
		…
	}else{
		if($MyBoolean){
			…
		}else{
			if($MyNumber > 2){
				…
			}else{
				…
			}
		}
	}
In the example above there are two nested if tests within the original if(). Note how nesting is achieved. It is probably more normal that the additional if goes in the 'else' branch of the preceding condition but that is not a requirement. It can be in either branch according to the needs of the scenario. Indeed, both branches of an if could in theory hold another if().
However, this form of coding can quickly get complex and care should be taken with placing appropriate '}' closures. In complex branching, consider using additional queries to hold some initial levels of test, rather than do everything in a complex nested call.
Back-references
Back-references found by regular expression matches in operators like .contains() are available in if() clauses. For example, the rule:
	if($Name.contains(""a(..)"") ){$MyString = $1;}
will set $MyString to ""pp"" if $Name is ""apple"", or to ""rs"" if $Name is ""pears"". Note that the $0 back-reference contains the full matched expression.
Within an overall action, any existing back-references generated by at if() persist until another if(0 statement is met. Note:
* back-references created by an if() statement persist beyond its {}-enclosed code. They last to the end of the action or a new if() statement.
* an if() statement re-sets all previous back-references even if it does not populate them. Thus if the first if() set a $1 and $2, and a second if sets only $1, $2 is now empty—the previous $2 value does not persist.
* even a nested if() resets all back-references for all the rest of the action.
* back-references are not accessible within an ‘else’ branch. An if() nested under the else branch is only evaluated (and thus sets back-references) if the original if() test fails. In other words, if the opening if is true, the code in the else { ... } scope is never evaluated. But if the opening test fails, only the else scope is evaluated.
Inline use of if() statements
Assignment to an inline if() expression is permitted. For example:
	$Color = if($MyBoolean){""red""}else{""blue""}; 
However, when practical, the more conventional and idiomatic style is preferred:
	if($MyBoolean){$Color = ""red"";}else{$Color = ""blue"";}; 
Both the above are functionally equivalent.","if(condition){actions}[else{actions}]

ルールや（エージェントの）アクションにおいて、Tinderboxは以下の条件付きアクション構文を使用します：
	if(condition){ action(s) }
	if(condition){ action(s) }else{ action(s) }

各要素の説明：
* condition（条件）は、評価の結果がブーリアンの真（true）となるアクションコードです。式が $Attribute.[i]contains(regex) クエリの形式である場合、アクションコード内で正規表現の後方参照（back-references）を使用できます。条件式には find() などのクエリを使用することもでき、一致する結果がゼロの場合は偽（false）、それ以外の場合は真（true）が返されます。
* actions（アクション）は、セミコロンで区切られた1つ以上のアクションコード式のリストです。

例：
	if($ChildCount > 5){$Color = ""red"";$Width = 3.5;}else{$Color = ""blue"";} 

条件には複数のテストを含めることができます。「AND (&)」や「OR (|)」による結合が可能であり、括弧による式の入れ子（ネスト）も可能です：
	if($ChildCount > 5 | $Badge = ""ok""){$Color=""red"";$Width=3.5;} 
	if(($ChildCount > 5 & $Badge = ""ok"") | $WordCount >= 450){$Color = ""red"";$Width = 3.5;} 

条件節が複雑な場合は、条件を計算してその値を属性に保存し、それを if() でテストするのが合理的かもしれません。このようなテストの書き換えは、ドキュメントが大きく複雑になるにつれて発生する「漸進的フォーマル化（incremental formalization）」の通常の手法です。

否定のテスト
否定（値がない、またはデフォルト状態であること）のテストは、いくつかの方法で行えます。属性値のテストでは、短縮形式のブーリアンテストを使用して、属性名の前に感嘆符（!）を付けることができます：
	if(!$MyString){…など} 

それ以外の場合は、!= 演算子を使用します：
	if($MyString != ""some value""){…など} 

ステートメントの終了
アクションリストの最後のアクションコード・ステートメントを閉じる（つまり、閉じる「}」の前にセミコロンを置く）必要はありません。ただし、同じルールやアクション内で他のアクションコードが続く場合は、最後の閉じる「}」の後にセミコロンによる終了が必要です：
	if($ChildCount > 5){$Color = ""red"";$Width = 3.5;}else{$Color = ""blue"";}; $Badge = ""ok""; 
	if(!$MyString){
		$Color = ""red"";
	}else{
		$Color = ""blue"";
	};
	$WordCount(parent) = $WordCount(parent)+$WordCount;

複数の条件のテスト
単一の if() テストで複雑な式を使用して条件テストを作成できますが、一連のリンクされたテストを実行する必要がある場合もあります。しかし、多くのプログラミング言語にあるような「else if」構造はありません。条件テストで3つ以上の分岐を処理するには、最初のテストのいずれかのアクションリスト内に追加の if() を入れ子にします。
例：
	if(!$MyString){
		…
	}else{
		if($MyBoolean){
			…
		}else{
			if($MyNumber > 2){
				…
			}else{
				…
			}
		}
	}
上の例では、元の if() の中に2つの入れ子になった if テストがあります。入れ子がどのように実現されているかに注目してください。通常、追加の if は前の条件の「else」分岐に入れられますが、それは必須ではありません。シナリオのニーズに応じて、どちらの分岐にも入れることができます。理論的には、if の両方の分岐に別の if() を含めることも可能です。
ただし、この形式のコーディングはすぐに複雑になる可能性があるため、適切な「}」の配置に注意する必要があります。複雑な分岐では、すべてを複雑な入れ子の呼び出しで行うのではなく、追加のクエリを使用して初期レベルのテストを保持することを検討してください。

後方参照
.contains() などの演算子で正規表現の一致によって見つかった後方参照は、if() 節で使用できます。例えば、以下のルール：
	if($Name.contains(""a(..)"") ){$MyString = $1;}
は、$Name が ""apple"" であれば $MyString を ""pp"" に、$Name が ""pears"" であれば ""rs"" に設定します。$0 後方参照には、一致した式全体が含まれることに注意してください。
アクション全体の中で、if() によって生成された既存の後方参照は、別の if() ステートメントに出会うまで持続します。以下の点に注意してください：
* if() ステートメントによって作成された後方参照は、その {} で囲まれたコードを超えて持続します。これらはアクションの終了、または新しい if() ステートメントまで有効です。
* if() ステートメントは、値を設定しない場合でも、以前のすべての後方参照をリセットします。したがって、最初の if() が $1 と $2 を設定し、2番目の if() が $1 のみを設定した場合、$2 は空になります（以前の $2 の値は持続しません）。
* 入れ子になった if() であっても、アクションの残りの部分のすべての後方参照をリセットします。
* 後方参照は「else」分岐内ではアクセスできません。else 分岐の下に入れ子になった if() は、元の if() テストが失敗した場合にのみ評価されます（したがって後方参照を設定します）。言い換えれば、最初の if が真であれば、else { ... } スコープ内のコードは評価されません。しかし、最初のテストが失敗した場合は、else スコープのみが評価されます。

if() ステートメントのインライン使用
インラインの if() 式への代入が許可されています。例えば：
	$Color = if($MyBoolean){""red""}else{""blue""}; 
しかし、実用的な場合は、より一般的で慣習的なスタイルが好まれます：
	if($MyBoolean){$Color = ""red"";}else{$Color = ""blue"";}; 
上記の2つは機能的に同等です。"
"indented(depthNum[, item])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"indented(depthNum[, item])
Returns Boolean true if the current note is depthNum levels below the root (i.e. target $OutlineDepth minus one). Where item is supplied, depthNum is instead tested against the number of outline levels between the current note and item (as opposed to root). This is essentially a way to test the $OutlineDepth of a note. Query:
	indented(3) 
is true for any notes whose $OutlineDepth value is 4.
The item argument must be quoted unless an attribute reference. Ways to define item.
Legacy issues
This operator replaces the legacy #indented query operator.","indented(depthNum[, item])
現在のノートがルートからdepthNumレベル下（つまり、対象の$OutlineDepthマイナス1）にある場合に、Booleanの真（true）を返します。itemが指定されている場合、depthNumはルートではなく、現在のノートとitemの間のアウトラインレベル数に対してテストされます。これは本質的に、ノートの$OutlineDepthをテストする方法です。クエリ：
	indented(3)
は、$OutlineDepthの値が4であるすべてのノートに対して真となります。
item引数は、属性参照でない限り引用符で囲む必要があります。itemの定義方法。
レガシーに関する事項
このオペレーターは、レガシーな#indentedクエリ・オペレーターを置き換えるものです。"
"inheritsFrom([item, ]prototypeStr)",Function,Item,Query Boolean,boolean test,false,6.6.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"inheritsFrom([item, ]prototypeStr)
inheritsFrom(), is Boolean true if a specific prototypeStr (note) is used by a note, either directly or through other prototypes. For a direct inheritance, the value of $Prototype can be checked but inheritsFrom() allows checking of inheritance via multiple prototypes. Where a note X inherits from a prototype A but the latter itself uses a prototype B, inheritsFrom() allows testing if X inherits indirectly from B. As such inheritance occurs via A, it is otherwise difficult to test such inheritance. This is a specialist operator unlikely to be used except where prototypes themselves use other prototypes.
In a query, or find(), all notes are tested. In an action context (rule, edict, agent action, OnAdd, expression, etc.) only the current note (this) is evaluated. To query the document for notes inheriting from prototype 'pEvent', use the query term:
	inheritsFrom(""pEvent"") 
It is possible to test, via an action, the inheritance of a different note using the optional second scoping argument item. Thus to test if 'Note B' inherits from prototype 'pTask':
	inheritsFrom(""Note B"",""pTask"") 
For example, suppose prototype 'pFlower' has the prototype 'pPlant', and note 'Rose' uses the prototype 'pFlower'. Then
	inheritsFrom(""pPlant"") 
is true for both pFlower and pPlant.
	inheritsFrom(""pFlower"") 
is true for Rose, but false for pPlant.
N.B. note that the stated prototype is also included in the items testing true. This makes sense if actual notes in the document are prototypes, as opposed to using only deliberate 'non-content' prototypes. To filter the latter, and exclude all prototype notes, use a query like:
	inheritsFrom(""pFlower"") & $IsPrototype==false 
You can also write an offset test so note 'Rose' can test if note 'Camelia' uses prototype 'pFlower':
	inheritsFrom(""Camelia"",""pFlower"") 
This returns true if 'Camelia' inherits from that prototype. Or, 'Rose' might want to check if its parent uses that prototype:
	inheritsFrom(""parent,""pFlower"")","inheritsFrom([item, ]prototypeStr)

inheritsFrom()は、特定の prototypeStr（ノート）が、直接または他のプロトタイプを介してノートに使用されている場合に、Booleanの true を返します。直接の継承については $Prototype の値をチェックすることで確認できますが、inheritsFrom() を使用すると、複数のプロトタイプを介した継承をチェックできます。例えば、ノート X がプロトタイプ A を継承しており、その A 自体がプロトタイプ B を使用している場合、inheritsFrom() を使うことで X が間接的に B を継承しているかどうかをテストできます。このような継承は A を介して発生するため、それ以外の方法でテストすることは困難です。これは、プロトタイプ自体が他のプロトタイプを使用している場合にのみ使用される可能性が高い、専門的なオペレータです。

クエリまたは find() 内では、すべてのノートがテストされます。アクションコンテキスト（ルール、エディクト、エージェントアクション、OnAdd、式など）では、現在のノート（this）のみが評価されます。ドキュメント内でプロトタイプ 'pEvent' を継承しているノートを検索するには、以下のクエリ用語を使用します：
	inheritsFrom(""pEvent"") 

アクションを介して、オプションの第2引数 item を使用して別のノートの継承をテストすることも可能です。したがって、'Note B' がプロトタイプ 'pTask' を継承しているかどうかをテストするには、次のように記述します：
	inheritsFrom(""Note B"",""pTask"") 

例えば、プロトタイプ 'pFlower' のプロトタイプが 'pPlant' であり、ノート 'Rose' がプロトタイプ 'pFlower' を使用しているとします。このとき、
	inheritsFrom(""pPlant"") 
は、pFlower と Rose の両方に対して true となります。
	inheritsFrom(""pFlower"") 
は、Rose に対しては true ですが、pPlant に対しては false です。

注意：指定されたプロトタイプ自体も、テストで true となる項目に含まれます。これは、ドキュメント内の実際のノートがプロトタイプである場合（単に「非コンテンツ」としてのプロトタイプを使用するのではない場合）に理にかなっています。後者をフィルタリングし、すべてのプロトタイプノートを除外するには、次のようなクエリを使用します：
	inheritsFrom(""pFlower"") & $IsPrototype==false 

また、オフセットテストを記述することもできます。これにより、ノート 'Rose' は、ノート 'Camelia' がプロトタイプ 'pFlower' を使用しているかどうかをテストできます：
	inheritsFrom(""Camelia"",""pFlower"") 
これは 'Camelia' がそのプロトタイプを継承している場合に true を返します。あるいは、'Rose' は自分の親がそのプロトタイプを使用しているかどうかを確認したいかもしれません：
	inheritsFrom(""parent"",""pFlower"")"
inside(item),Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"inside(item)
Returns Boolean true if the current note is a direct child of item or, put conversely, if item is the parent of the note. Thus it can be thought of as an ""is a child of"" operator and as such a counterpart to the ""is parent of"" operator contains(). Note that aliases can be matched by inside(), which may appear counter-intuitive at first encounter: if only wanting to match original notes, see section 'Filtering out aliases' below.
The item argument must be quoted unless an attribute reference. Ways to define item.
Pertinent to map view, inside() and adornments:
* inside(item) is true for a note that is a child of the map's container item.
* inside(item) is true for a map note that is on top of (within or overlapping) the adornment item.
* inside(item) for a map container item does not match any child adornments.
In a more general context inside(""X"") is true for note A if any of the following are true:
* original A is inside X
* an alias of A is inside X
* A is an alias elsewhere, but its original is inside X
The last of these, if overlooked, can give unexpected results. The more expansive matching above is necessary to do things like looking inside agents. 
If more than one container matching item is present, inside() returns items matching the first such container as listed in $OutlineOrder. If deliberately wanting to match notes inside any of several same-named containers, e.g. ""exploded notes"", then use $Name(parent)==""container name"" instead.
Filtering out aliases 
To match only originals, i.e. just the first of the three conditions in the previous list above, use inside(""X"") & $IsAlias==false.
Legacy issues
This operator replaces the legacy #inside query operator.","inside(item)
現在のノートが item の直接の子である場合、または逆に言えば、item がそのノートの親である場合に、真偽値の true を返します。したがって、これは「〜の子である」演算子と考えることができ、その意味で「〜の親である」演算子である contains() の対になる存在です。inside() はエイリアスにも一致することに注意してください。これは最初、直感に反するように感じられるかもしれません。オリジナルのノートのみを一致させたい場合は、後述の「エイリアスの除外」セクションを参照してください。
item 引数は、属性参照でない限り引用符で囲む必要があります。item を定義する方法。
マップビュー、inside()、およびアドーンメントに関連する事項：
* inside(item) は、マップのコンテナ項目の子であるノートに対して true となります。
* inside(item) は、アドーンメント項目の上にある（内側にある、または重なっている）マップノートに対して true となります。
* マップコンテナ項目に対する inside(item) は、その子のどのアドーンメントにも一致しません。
より一般的な文脈では、以下のいずれかが真である場合、ノート A に対して inside(""X"") は true となります：
* オリジナルの A が X の中にある
* A のエイリアスが X の中にある
* A は他の場所にあるエイリアスだが、そのオリジナルが X の中にある
最後のケースは見落とされると、予期しない結果を招く可能性があります。上記のような広範な一致は、エージェントの内部を調べる際などに必要となります。
item に一致するコンテナが複数存在する場合、inside() は $OutlineOrder で最初に現れるコンテナに一致する項目を返します。意図的に「exploded notes」など、同じ名前を持つ複数のコンテナのいずれかの中にあるノートを一致させたい場合は、代わりに $Name(parent)==""コンテナ名"" を使用してください。
エイリアスの除外
オリジナルのみを一致させる（つまり、上記のリストの3つの条件のうち最初の1つだけを適用する）には、inside(""X"") & $IsAlias==false を使用します。
レガシーの問題
この演算子は、従来の #inside クエリ演算子を置き換えるものです。"
Interval.day(),Property,Item,Date-time,Number,false,6.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Interval.day()
Interval.day
Returns the Interval expressed as a Number of whole days. Thus, if $MyInterval is 1day 12 hours 30 minutes then:
	$MyNumber = $MyInterval.day; 
returns 1.
If the interval is less than 1 day ( i.e. less than 24 hours), the operator returns a zero value.
This operator is read-only and cannot be used to set/edit an Intervals' day part. 
Intervals can also be tested at hour, minute or second scope.","Interval.day()
Interval.day
Interval（期間）を整数の日数（Number型）として返します。したがって、$MyInterval が 1日12時間30分である場合：
	$MyNumber = $MyInterval.day;
は 1 を返します。
期間が1日未満（つまり24時間未満）の場合、このオペレーターは 0 を返します。
このオペレーターは読み取り専用であり、Interval の「日」の部分を設定または編集するために使用することはできません。
期間は、時間（hour）、分（minute）、秒（second）の範囲でも取得できます。"
Interval.format(formatStr),Function,Item,Formatting,String,false,6.6.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Interval.format(formatStr)
For this data type formatStr strings can use date-type format strings. The function returns Interval as a String formatted as per the quoted date/interval format string formatStr.
This supplements the existing format() function. 
When used with Interval-type data, .format() expects the interval to be less than one hour and thus comprising only minutes and seconds data (i.e. 'mm:ss'). Note that the default short Interval form is 'hh:mm' so there is scope for confusion. If passing 'hh:mm' data to .format(), it makes sense to add a blank seconds segment, i.e. 'hh:mm:ss' so the segments of the interval are parsed correctly.
Furthermore, only two date format strings are accepted for formatStr: Interval.format (""l"") and Interval.format (""L""), both of which format the hours and minutes of the Interval date the current locale's style. The lower-case ""l"" format uses the locale's abbreviated form, while ""L"" gives the interval in a phrase customised to local usage.
If $MyInterval is ""12:55:23:""
	$MyString = $MyInterval.format(""l""); gives ""12:55""
	$MyString = $MyInterval.format(""L""); gives ""12 hours, 55 minutes""
An Interval value of ""00:00"" (minutes:seconds)—i.e. that data type's default—always returns an empty string. This if $MyInterval the default 00:00 then:
	$MyString = $MyInterval.format(""l""); 
results in """", i.e. no value is set in $MyString.
Formatting Intervals of over one hour
The expectation of input as being only mm:ss only can cause confusion when using .format(). If the value of $MyInterval is ""12:55:40"" (12 hours, 55 minutes and 14 seconds):
	$MyString = $MyInterval.format(""l"") 
The resulting $MyString value is ""12:56"", i.e. the seconds are rounded (up or down accordingly) and an hours:minutes string is returned.
As Interval maximum scope is days/hours/minutes/seconds, if the aim is to get the entire interval duration, simply pass the Interval data direct to a string. This if $MyInterval is ""1 day 12:55:23"":
	$MyString = $MyInterval; 
sets $MyString to ""1 day 12:55:23"". If only part of the source is needed, a different approach is needed. Thus, if $MyInterval is ""1 day 12:55:23"" and only the number of whole minutes is needed, some string manipulation is required:
	$MyString = $MyInterval.extract(""(\d{2}):\d{2}$""); 
setting $MyString to ""55"". Note that regular expressions are very specific. If the closing '$' is omitted from the regex pattern, this results in a $MyString value of ""12"" instead of ""55"". Why? Because the latter pattern returns the first pair of digits followed explicitly by a colon and two more digits. Adding the '$' tells the regex that the literal sequence must come at the end of the source string, resulting in ""55"" being extracted.","Interval.format(formatStr)
このデータ型では、formatStr 文字列に日付型のフォーマット文字列を使用できます。この関数は、引用符で囲まれた日付/インターバル形式のフォーマット文字列 formatStr に従って、Intervalを文字列として返します。
これは既存の format() 関数を補完するものです。
Interval型のデータで使用する場合、.format() はインターバルが1時間未満であることを想定しており、分と秒のデータ（つまり 'mm:ss'）のみで構成されます。Intervalのデフォルトの短い形式は 'hh:mm' であるため、混乱を招く可能性があることに注意してください。'hh:mm' データを .format() に渡す場合は、インターバルのセグメントが正しく解析されるように、空の秒セグメント（例：'hh:mm:ss'）を追加するのが理にかなっています。
さらに、formatStr には2つの日付フォーマット文字列のみが受け入れられます：Interval.format (""l"") と Interval.format (""L"") です。これらはいずれも、現在のロケールのスタイルに従ってインターバルの時と分をフォーマットします。小文字の ""l"" フォーマットはロケールの短縮形式を使用し、""L"" はロケールの慣習に合わせたフレーズでインターバルを表示します。
$MyInterval が ""12:55:23:"" の場合：
	$MyString = $MyInterval.format(""l""); は ""12:55"" を返します。
	$MyString = $MyInterval.format(""L""); は ""12 hours, 55 minutes"" を返します。
Intervalの値が ""00:00""（分:秒）—つまりそのデータ型のデフォルト値—の場合、常に空の文字列を返します。したがって、$MyInterval がデフォルトの 00:00 であれば：
	$MyString = $MyInterval.format(""l""); 
の結果は """"、すなわち $MyString には値が設定されません。
1時間を超えるインターバルのフォーマット
入力が mm:ss のみであるという想定は、.format() を使用する際に混乱を招くことがあります。$MyInterval の値が ""12:55:40""（12時間55分14秒）の場合：
	$MyString = $MyInterval.format(""l"") 
結果として得られる $MyString の値は ""12:56"" です。つまり、秒が（状況に応じて）丸められ、時:分の文字列が返されます。
Intervalの最大範囲は 日/時/分/秒 であるため、インターバルの全期間を取得することが目的であれば、単にIntervalデータを直接文字列に代入します。$MyInterval が ""1 day 12:55:23"" の場合：
	$MyString = $MyInterval; 
は $MyString を ""1 day 12:55:23"" に設定します。ソースの一部のみが必要な場合は、別のアプローチが必要です。したがって、$MyInterval が ""1 day 12:55:23"" で、整数の分の数だけが必要な場合は、文字列操作が必要になります。
	$MyString = $MyInterval.extract(""(\d{2}):\d{2}$""); 
は $MyString を ""55"" に設定します。正規表現は非常に厳密であることに注意してください。正規表現パターンから末尾の '$' が省略されると、結果として $MyString の値は ""55"" ではなく ""12"" になります。なぜでしょうか？それは、後者のパターンが、コロンとさらに2つの数字が明示的に続く最初の数字のペアを返すからです。'$' を追加することで、そのリテラルシーケンスがソース文字列の最後に来る必要があることを正規表現に伝え、結果として ""55"" が抽出されます。"
Interval.hour(),Property,Item,Date-time,Number,false,6.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Interval.hour()
Interval.hour
Returns the Interval expressed as a Number of whole or partial hours within the current day (ignoring whole days). Thus, if $MyInterval is 12 hours 30 minutes then:
	$MyNumber = $MyInterval.hour; 
returns 12.
This operator is read-only and cannot be used to set/edit an Intervals' hour part. 
Intervals can also be tested at day, minute or second scope.","Interval.hour()
Interval.hour
インターバルを、現在の日の（全日数を無視した）時間数として返します。したがって、もし $MyInterval が12時間30分であれば：
	$MyNumber = $MyInterval.hour; 
は12を返します。
このオペレーターは読み取り専用であり、インターバルの「時」の部分を設定または編集するために使用することはできません。
インターバルは、日、分、秒の単位でも評価できます。"
Interval.minute(),Property,Item,Date-time,Number,false,6.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Interval.minute()
Interval.minute
Returns the Interval expressed as a Number of whole or partial minutes within the current hour (ignoring whole hours). Thus, if $MyInterval is 1 hour, 30 minutes and 15 seconds then:
	$MyNumber = $MyInterval.minute; 
returns 30.
This operator is read-only and cannot be used to set/edit an Intervals' minute part. 
Intervals can also be tested at day, hour or second scope.","Interval.minute()
Interval.minute
インターバルを、現在の時間内（整数の時間を無視した）の、整数または端数を含む分の数値として返します。したがって、$MyInterval が 1時間30分15秒 である場合：
	$MyNumber = $MyInterval.minute; 
は 30 を返します。
このオペレータは読み取り専用であり、インターバルの「分」の部分を設定または編集するために使用することはできません。
インターバルは、日 (day)、時間 (hour)、または秒 (second) のスコープでも評価できます。"
Interval.second(),Property,Item,Date-time,Number,false,7.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Interval.second()
Interval.second
Returns the Interval expressed as a Number of whole seconds within the current minute (ignoring whole minutes). Thus, if $MyInterval is 1 hour, 30 minutes and 15 seconds then:
	$MyNumber = $MyInterval.second; 
returns 15
Although date-time units are stored as milliseconds under the hood, Tinderbox does not return increments smaller than one second.
This operator is read-only and cannot be used to set/edit an Intervals' seconds part. 
Intervals can also be tested at day, hour or minute scope.","Interval.second()
Interval.second
インターバルを、現在の分に含まれる秒数（分単位を切り捨てた整数の秒数）として返します。したがって、$MyInterval が1時間30分15秒であれば、以下のようになります：
	$MyNumber = $MyInterval.second; 
これは15を返します。
内部的には日時の単位はミリ秒で保持されていますが、Tinderboxは1秒未満の単位を返しません。
このオペレータは読み取り専用であり、インターバルの「秒」の部分を設定したり編集したりすることはできません。
インターバルは、日、時間、または分のスコープで評価することも可能です。"
interval(dataStr),Function,Item,Date-time,Interval,false,9.5.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"interval(dataStr)
The operator interval(dataStr) converts a string to an interval. For example:
	$MyInterval = interval(""00:30:00"") 
is an interval of thirty minutes. 
The dataStr can be a literal string, String-type attribute value or a string variable. The string must be in Interval, for which see the 'Alternative syntax' section of the Interval data type.) For instance:
	var:number vHr = 21;
	var:number vMin = 14;
	var:string vInterval = vHr+"":""+vMin;
	$MyInterval = interval(vInterval);
The two Date-type argument version of interval() is documented separately, see interval(start,end): it continues to return the Interval between two Date-type arguments.
If any time element is larger than expected, it is parsed to increment the next larger time element. Thus:
	$MyInterval = interval(""00:90:00"") 
evaluates as if:
	$MyInterval = interval(""01:30:00"") 
This can be helpful, especially if using calculated variables (as above) and where the calculated value may be more than expected if setting values manually.","interval(dataStr)
演算子 interval(dataStr) は、文字列をインターバル（期間）に変換します。例えば：
	$MyInterval = interval(""00:30:00"") 
は30分のインターバルになります。
dataStr には、リテラル文字列、String型の属性値、または文字列変数を使用できます。文字列はインターバル形式である必要があります（これについては、Intervalデータ型の「Alternative syntax」セクションを参照してください）。例えば：
	var:number vHr = 21;
	var:number vMin = 14;
	var:string vInterval = vHr+"":""+vMin;
	$MyInterval = interval(vInterval);
2つのDate型引数を使用するバージョンの interval() は、interval(start,end) として別途ドキュメント化されています。そちらは引き続き、2つのDate型引数の間のインターバルを返します。
時間要素のいずれかが期待される値より大きい場合、上位の時間要素を繰り上げるように解析されます。したがって：
	$MyInterval = interval(""00:90:00"") 
は、以下のように評価されます：
	$MyInterval = interval(""01:30:00"") 
これは、（上記のように）計算された変数を使用する場合や、手動で値を設定する際に計算結果が想定を上回る可能性がある場合に特に便利です。"
"interval(startDate, endDate)",Function,Item,Date-time,Interval,false,6.3.1,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"interval(startDate, endDate)
The function interval(startDate,endDate) returns, in Interval data-type form, the time interval between two Date-type dates. For example, to test the interval between a note's initial creation and its most recent modification and to then store it in an Interval-type attribute:
	$MyInterval = interval($Created,$Modified); 
The interval() function can be used to test the exact equivalence of two Date-type attribute values, using the full Date and time. Thus:
	if(interval($DateA,$DateB)==""00:00""){… 
The latter gets around the fact that == and != operators match Date-type attributes only at day scope rather than the actual date-time values.
If needing the duration expressed in whole time units of a particular time element (or hours, etc.), see days(), hours(), minutes() or seconds().
The single argument method of interval(), used to create Interval-type data is documented separately—see interval(dataStr).","interval(startDate, endDate)
関数 interval(startDate, endDate) は、2つの Date 型の日付の間の時間間隔を Interval 型で返します。例えば、ノートの作成日時と最終更新日時の間隔を調べ、その結果を Interval 型の属性に格納するには、次のように記述します：
	$MyInterval = interval($Created, $Modified); 
interval() 関数は、日付と時刻の両方を使用して、2つの Date 型の属性値が厳密に一致するかどうかをテストするために使用できます。したがって：
	if(interval($DateA, $DateB) == ""00:00"") { ... }
後者の手法は、== および != 演算子が Date 型の属性を実際の日時値ではなく、日単位の範囲でしか照合しないという事実を回避するのに有効です。
特定の時間単位（日、時間など）の整数で期間を表現する必要がある場合は、days()、hours()、minutes()、または seconds() を参照してください。
Interval 型のデータを作成するために使用される、引数が1つの interval() メソッドは、別途ドキュメント化されています。interval(dataStr) を参照してください。"
isbn10(dataStr),Function,Item,Data manipulation,String,false,6.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"isbn10(dataStr)
takes quoted an ISBN-13 format code as the dataStr input and returns is in ISBN-10 format. Any dashes or other punctuation will be ignored. If the argument is not a valid ISBN code, the function returns an empty string. If such characters as in the source string and quotes are omitted, hyphen may be mis-parsed as minus signs giving a wrong result.
Consider a book with the ISBN-10 '1472268997' and the ISBN-13 '978-1472268990':
	$MyString = isbn10(""978-1472268990"") gives the correct '1472268997' but note, without any hyphens.
be aware that if dataStr is not in quotes, the input is treated as an arithmetical expression:
	$MyString = isbn10(""978-1472268990"") gives the incorrect value '1472268012'.","isbn10(dataStr)
引用符で囲まれたISBN-13形式のコードをdataStrとして入力し、ISBN-10形式で返します。ハイフンやその他の記号は無視されます。引数が有効なISBNコードでない場合、この関数は空の文字列を返します。ソース文字列にそのような文字が含まれている際に引用符を省略すると、ハイフンがマイナス記号として誤って解析され、誤った結果を返す可能性があります。
ISBN-10が '1472268997'、ISBN-13が '978-1472268990' の本を例に取ります：
	$MyString = isbn10(""978-1472268990"") は正しい '1472268997' を返しますが、ハイフンは含まれないことに注意してください。
dataStrが引用符で囲まれていない場合、入力は算術式として扱われることに注意してください：
	$MyString = isbn10(""978-1472268990"") は誤った値 '1472268012' を返します。"
isbn13(dataStr),Function,Item,Data manipulation,String,false,6.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"isbn13(data)
takes an ISBN-10 format code as the quoted string dataStr and returns it in ISBN-13 format. Any dashes or other punctuation will be ignored. If the argument is not a valid ISBN code, the function returns an empty string. If such characters as in the source string and quotes are omitted, hyphen may be mis-parsed as minus signs giving a wrong result.
Consider a book with the ISBN-10 '1472268997' and the ISBN-13 '978-1472268990':
	$MyString = isbn13(""1472268997"") gives the correct '9781472268990' but note, without any hyphens.
be aware that if dataStr is not in quotes, result is the same.","isbn13(data)
ISBN-10形式のコードを引用符で囲まれた文字列 dataStr として受け取り、それをISBN-13形式で返します。ハイフンやその他の句読点は無視されます。引数が有効なISBNコードでない場合、この関数は空の文字列を返します。ソース文字列にハイフンなどの文字が含まれている場合に引用符を省略すると、ハイフンがマイナス記号として誤って解析され、誤った結果を招く可能性があります。
ISBN-10が '1472268997'、ISBN-13が '978-1472268990' の書籍を例に挙げます：
$MyString = isbn13(""1472268997"") は正しい '9781472268990' を返しますが、ハイフンは含まれないことに注意してください。
なお、dataStr が引用符で囲まれていない場合でも、結果は同じになります。"
isDuplicateName(),Property,Item,Non-query Boolean,boolean test,false,8.0.0,Baseline,,,,1,false,false,false,false,false,false,false,false,false,,false,"isDuplicateName
isDuplicateName()
This is true if another note in the document has the same $Name as the current note. isDuplicateName() ignores all aliases. The parentheses may be omitted. In an action, the current note might be tested:
	$MyBoolean = isDuplicateName(); 
If the current note has any duplicate-named notes, $MyBoolean is true.
In an agent, all instances of notes with duplicates are listed. Thus, the query:
	isDuplicateName() 
lists all instances of any note with duplicates.
This can be useful if trying to find/resolve notes with duplicate names within a document. If expecting to use action code to work with notes, it helps if a note's title ($Name) is unique.","isDuplicateName
isDuplicateName()
ドキュメント内の別のノートが現在のノートと同じ$Nameを持っている場合、これは真（true）になります。isDuplicateName() はすべてのエイリアスを無視します。括弧は省略可能です。アクションでは、現在のノートを次のようにテストできます：
	$MyBoolean = isDuplicateName(); 
現在のノートに重複した名前のノートがある場合、$MyBoolean は真になります。
エージェントでは、重複があるノートのすべてのインスタンスがリストされます。したがって、クエリ：
	isDuplicateName() 
は、重複があるすべてのノートのインスタンスをリストします。
これは、ドキュメント内の重複した名前のノートを検索または解決しようとする場合に便利です。アクションコードを使用してノートを操作することを想定している場合、ノートのタイトル（$Name）がユニークであると助けになります。"
JSON.each([pathStr]){actions},Function,List,Stream parsing,iterator,false,9.6.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"JSON.each([pathStr]){action(s)}
JSON.each{action(s)}
If the top-level element is an array, rebinds the JSON object in turn to each array element. After calling the action block for each element, the JSON object is restored. 
For example, if the value of $MyString is [{""price"":1}, {""price"":2}], then
	$MyList=[];
	$MyString.json.each{$MyList += json[""price""]*3;}
would set $MyList to ""3;6"".
JSON.each(pathStr){action(s)}
In .json.each(){…}, an optional path argument, pathStr, supplies a path to the array to be iterated. For example, if $Text is:
{  
   ""person"": { ""firstName"": ""Thomas"",  lastName: ""Roe""},
   ""coordinates"" : [-90,41] 
}
then $Text.captureJson().json.each(coordinates){…} would iterate through the array of coordinates.
If String.json.each begins a statement,
	$Text.json.each(coordinates){...} 
.json.each(){} reuses the current JSON object. This can be much faster than repeatedly re-parsing a complex json package.
As a result, the older syntax $Text.json[coordinates].each(x){…}, that chained of JSON.json[keyStr] is no longer supported.
Loading a dictionary of dictionaries from JSON and looking up items
Let $Text be:
{ ""French"":{ ""child"":""enfant""; ""cat"":""chat""}; ""Swedish"":{""child"":""barn"";""cat"":""katt""} } 
Now:
$Text.json[French][cat] is ""chat""
$Text.json[""Swedish""][""cat""] is ""katt""
$Text.json.keys is ""French; Swedish""
$Text.json.keys.each(x){ 
	$MyList=$MyList+$Text.json[x][cat];
};
$MyList is [chat;katt].
Loading a list of dictionaries from JSON a and looking up items
Let $Text be:
[ { ""child"":""enfant""; ""cat"":""chat""} , {""child"":""barn"";""cat"":""katt""} ] 
Now:
$Text.json[0][cat] is chat
$Text.json[0]['cat'] is katt
$Text.json.count is 2
$Text.json.each(x){
	$MyList += x[child];
}
$MyList is now [enfant;barn].","JSON.each([pathStr]){action(s)}
JSON.each{action(s)}
トップレベルの要素が配列の場合、JSONオブジェクトを各配列要素に順番に再バインドします。各要素に対してアクションブロックを呼び出した後、JSONオブジェクトは復元されます。
例えば、$MyStringの値が [{""price"":1}, {""price"":2}] である場合、
	$MyList=[];
	$MyString.json.each{$MyList += json[""price""]*3;}
は、$MyListを ""3;6"" に設定します。
JSON.each(pathStr){action(s)}
.json.each(){…} において、オプションのパス引数 pathStr は、反復処理する配列へのパスを指定します。例えば、$Text が以下の通りである場合：
{  
   ""person"": { ""firstName"": ""Thomas"",  ""lastName"": ""Roe""},
   ""coordinates"" : [-90,41] 
}
このとき、$Text.captureJson().json.each(coordinates){…} は coordinates（座標）の配列を反復処理します。
String.json.each がステートメントを開始する場合、
	$Text.json.each(coordinates){...} 
.json.each(){} は現在のJSONオブジェクトを再利用します。これは、複雑なJSONパッケージを繰り返し再解析するよりもはるかに高速になる可能性があります。
その結果、JSON.json[keyStr] を連鎖させた以前の構文 $Text.json[coordinates].each(x){…} はサポートされなくなりました。
JSONから辞書の辞書を読み込み、項目を検索する
$Text を以下のようにします：
{ ""French"":{ ""child"":""enfant""; ""cat"":""chat""}; ""Swedish"":{""child"":""barn"";""cat"":""katt""} } 
このとき：
$Text.json[French][cat] は ""chat"" です
$Text.json[""Swedish""][""cat""] は ""katt"" です
$Text.json.keys は ""French; Swedish"" です
$Text.json.keys.each(x){ 
	$MyList=$MyList+$Text.json[x][cat];
};
$MyList は [chat;katt] です。
JSONから辞書のリストを読み込み、項目を検索する
$Text を以下のようにします：
[ { ""child"":""enfant""; ""cat"":""chat""} , {""child"":""barn"";""cat"":""katt""} ] 
このとき：
$Text.json[0][cat] は chat です
$Text.json[0]['cat'] は katt です
$Text.json.count は 2 です
$Text.json.each(x){
	$MyList += x[child];
}
$MyList は [enfant;barn] になります。"
JSON.json[itemNum],Function,Item,Stream parsing,source context dependent,false,9.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"JSON.json[itemNum]
If there is no current JSON object, attempts to parse the string as JSON and fails if unsuccessful. If there is a current JSON object, that object will be reused. See JSON.json[keyStr], for more information as to when String.captureJson() might need to be used before applying this operator.
If the top-level element is an array, JSON.json[N] returns the itemNum object. Note that [ ] square brackets, not ( ) parentheses must be used to pass N. If the top-level element is an object, see JSON.json[keyStr].
For example, if the $Text is:
{ [1,4,9,16,25] } 
Then $Text.json[1] is 4.
This usage follows the existing list[N] convention.","JSON.json[itemNum]
現在のJSONオブジェクトがない場合、文字列をJSONとしてパース（解析）しようと試み、解析できない場合は失敗します。現在のJSONオブジェクトがある場合は、そのオブジェクトが再利用されます。この演算子を適用する前に String.captureJson() を使用する必要がある場合についての詳細は、JSON.json[keyStr] を参照してください。
トップレベルの要素が配列の場合、JSON.json[N] は itemNum 番目のオブジェクトを返します。Nを渡すには、丸括弧 ( ) ではなく角括弧 [ ] を使用する必要があることに注意してください。トップレベルの要素がオブジェクトの場合は、JSON.json[keyStr] を参照してください。
例えば、$Text が次の場合：
{ [1,4,9,16,25] } 
このとき、$Text.json[1] は 4 です。
この使用法は、既存の list[N] の慣例に従っています。"
JSON.json[keyStr],Function,Item,Stream parsing,source context dependent,false,9.6.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"JSON.json[keyStr]
If there is no current JSON object, attempts to parse the string as JSON and fails if unsuccessful. If there is a current JSON object, that object will be reused. keyStr is a quoted key name and [ ] square brackets, not ( ) parentheses must be used to pass keyStr. Be aware of possible operator name confusion as described in the Notes section further below.
If the top-level element is an object, Stream.json[key] returns a dictionary for that object. If the top-level element is an array, see JSON.json[itemNum].
For example if $Text is:
{ ""title"":""Becket"", ""price"": 9.95 } 
and $Subtitle is set to ""title"", then:
$Text.json[""title""]; is ""Becket"".
$Text.json[title]; is ""Becket"".
$Text.json[""price""]; is ""9.95"".
$Text.json['$Subtitle']; no such field.
$Text.json[$Subtitle]; is ""Becket"".
Though multiple bracketed arguments can be used to address a JSON path, consider use of .jsonValue(pathStr) instead. For example:
Text:  {
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
MyString: ""person.lastName""
Then:
$Text.json['person']['lastName'] gives 'Roe'
But, easier:
$Text.json.jsonValue(person.lastName) gives 'Roe'
$Text.json.jsonValue($MyString) gives 'Roe'
Again, using the same JSON as above:
$MyString=""coordinates""; 
Now
$Text.json['coordinates'][0] gives -90 
$Text.json[$MyString][1] gives 41 
Notes
Be aware:
* If the source is $Text containing a mix of text and JSON first use .captureJson() to extract only the JSON code: see String.captureJson(). 
* Do not confuse this operator .json[] (note trailing square brackets) with the deprecated/legacy operator .json() (note trailing parentheses).
** The latter was used for export but is now replaced by String.jsonEncode().
** However, .json() does still work (legacy support) but is not the same as .json[] for reading JSON data as is described in this article.","JSON.json[keyStr]
現在のJSONオブジェクトがない場合、文字列をJSONとしてパースしようとし、不可能な場合は失敗します。現在のJSONオブジェクトがある場合は、そのオブジェクトが再利用されます。keyStrは引用符で囲まれたキー名であり、keyStrを渡すには ( ) 丸括弧ではなく [ ] 角括弧を使用する必要があります。後述の「Notes」セクションで説明されている演算子名の混同に注意してください。
トップレベルの要素がオブジェクトの場合、Stream.json[key] はそのオブジェクトの辞書（dictionary）を返します。トップレベルの要素が配列の場合は、JSON.json[itemNum] を参照してください。
例えば、$Textが次のような場合：
{ ""title"":""Becket"", ""price"": 9.95 } 
そして、$Subtitleが ""title"" に設定されているなら：
$Text.json[""title""]; は ""Becket"" です。
$Text.json[title]; は ""Becket"" です。
$Text.json[""price""]; は ""9.95"" です。
$Text.json['$Subtitle']; そのようなフィールドはありません。
$Text.json[$Subtitle]; は ""Becket"" です。
JSONパスを指定するために複数のブラケット引数を使用することもできますが、代わりに .jsonValue(pathStr) の使用を検討してください。例えば：
Text: {
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
MyString: ""person.lastName""
このとき：
$Text.json['person']['lastName'] は 'Roe' を返します。
しかし、より簡単な方法：
$Text.json.jsonValue(person.lastName) は 'Roe' を返します。
$Text.json.jsonValue($MyString) は 'Roe' を返します。
再び、上記と同じJSONを使用する場合：
$MyString=""coordinates""; 
このとき
$Text.json['coordinates'][0] は -90 を返します。
$Text.json[$MyString][1] は 41 を返します。
Notes
以下の点に注意してください：
* ソースである $Text にテキストとJSONが混在している場合は、まず .captureJson() を使用してJSONコードのみを抽出してください：String.captureJson() を参照。
* この演算子 .json[]（末尾が角括弧であることに注意）を、非推奨/レガシー演算子 .json()（末尾が丸括弧であることに注意）と混同しないでください。
** 後者はエクスポート用に使用されていましたが、現在は String.jsonEncode() に置き換えられています。
** ただし、.json() は依然として機能（レガシーサポート）しますが、この記事で説明されているJSONデータを読み取るための .json[] とは異なります。"
JSON.jsonValue(),Function,Item,Stream parsing,source context dependent,false,9.6.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"JSON.jsonValue()
JSON.jsonValue
The .jsonValue() operator returns a json object, from the cursor position to the end of the current code. In an attribute, e.g. $Text, containing only JSON code, the operator returns that whole code segment. If, via stream parsing the input cursor has advanced to the start of a code segment, the complete code segment starting at that point is returned (though other discrete code samples may exist further on the source string—these are ignored)
For example, if $Text is :
Some text.
{
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
Then:
	$MyString = $Text.skipline.captureJson.jsonValue(); 
sets $MyString to the JSON code found at the second paragraph of Text. So, the opening text paragraphs (here paragraph #1, Some text in the above example) are ignored and the first encountered section of JSON, here paragraph #1 is returned.
Important Note: the captured JSON is always, and only, the first discrete section of code in text. 
Thus, if $Text (or other source string) is all JSON code, the use of .captureJson() is moot But, if the $Text (or other source string) contains more than one JSON code section, use stream parsing to detect the desired JSON section and .jsonValue()to capture the desired section of code. For example, if $Text is :
Some text.
{
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
Another paragraph here.
{
  ""person"": { ""firstName"": ""Martin"", ""lastName"": ""Brown"" }, 
  ""coordinates"": [-80,61]
}
Some more text.

In this case the second discrete section of embedded JSON cannot be accessed via .jsonValue().","JSON.jsonValue()
JSON.jsonValue
.jsonValue() オペレータは、カーソル位置から現在のコードの末尾までの JSON オブジェクトを返します。$Text のように JSON コードのみを含む属性では、このオペレータはそのコード セグメント全体を返します。ストリーム解析によって入力カーソルがコード セグメントの開始位置まで進んでいる場合、その地点から始まる完全なコード セグメントが返されます（ソース文字列のさらに先に別の個別のコード サンプルが存在する場合もありますが、それらは無視されます）。

例えば、$Text が次のような場合：
Some text.
{
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
このとき：
	$MyString = $Text.skipline.captureJson.jsonValue(); 
は、$Text の 2 番目の段落にある JSON コードを $MyString に設定します。つまり、冒頭のテキスト段落（この例では第 1 段落の「Some text.」）は無視され、最初に見つかった JSON セクション（ここでは第 1 セクション）が返されます。

重要な注意：キャプチャされる JSON は常に、そして唯一、テキスト内の最初の個別のコード セクションのみです。
したがって、$Text（または他のソース文字列）がすべて JSON コードである場合、.captureJson() を使用する意味はありません。しかし、$Text（または他のソース文字列）に複数の JSON コード セクションが含まれている場合は、ストリーム解析を使用して目的の JSON セクションを検出し、.jsonValue() を使用して目的のコード セクションをキャプチャします。例えば、$Text が次のような場合：
Some text.
{
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
Another paragraph here.
{
  ""person"": { ""firstName"": ""Martin"", ""lastName"": ""Brown"" }, 
  ""coordinates"": [-80,61]
}
Some more text.

この場合、埋め込まれた 2 番目の個別の JSON セクションには .jsonValue() を介してアクセスすることはできません。"
JSON.jsonValue(pathStr),Function,Item,Stream parsing,source context dependent,false,9.6.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"JSON.jsonValue(pathStr)
The .jsonValue() operator allows a json object to be addressed by its JSON path. By comparison .json[keyStr] must use a key name. For example:
Text value:  {
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
MyString value: ""person.lastName""
Then:
$Text.json['person']['lastName'] gives 'Roe'
But, easier:
$Text.json.jsonValue(person.lastName) gives 'Roe'
Or if $MyString holds ""person.lastName"", then:
$Text.json.jsonValue($MyString) gives 'Roe'","JSON.jsonValue(pathStr)
.jsonValue() オペレータを使用すると、JSON オブジェクトを JSON パスで指定できます。一方、.json[keyStr] はキー名を使用する必要があります。例：

Text の値:
{
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}

MyString の値: ""person.lastName""

このとき：
$Text.json['person']['lastName'] は 'Roe' を返します。
しかし、より簡単な方法として：
$Text.json.jsonValue(person.lastName) は 'Roe' を返します。
また、$MyString に ""person.lastName"" が格納されている場合は：
$Text.json.jsonValue($MyString) は 'Roe' を返します。"
jsonEncode(dataStr),Function,Item,Formatting,String,false,5.7.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"jsonEncode(dataStr)
This operator returns a JSON-encoded UTF-8 version of the dataStr string. The straight double quote, solidus (forward slash) and backslash characters are all escaped by a preceding backslash character. The control characters backspace, form feed, new line, carriage return, horizontal tab are encoded as standard JavaScript escapes (\b, \f, \n, \r\, \t ). Unicode addresses are also escaped: \u2345.
Note: the single apostrophe (straight quote) is not escaped as this can cause some Ajax functions to fail.
If dataStr holds the words 'hello	world' separated by a Tab not a space character, then:
	jsonEncode(""hello	world"") 
gives output of 'hello\tworld'.
For string-type data, see also the '.jsonEncode()' operator.","jsonEncode(dataStr)
このオペレーターは、dataStr文字列をJSONエンコードされたUTF-8形式で返します。二重引用符、ソリダス（スラッシュ）、バックスラッシュの各文字は、その前にバックスラッシュを置くことでエスケープされます。バックスペース、フォームフィード、改行、復帰、水平タブの制御文字は、標準的なJavaScriptのエスケープ文字（\b、\f、\n、\r、\t）としてエンコードされます。Unicodeアドレスも「\u2345」のようにエスケープされます。
注意：単一引用符（アポストロフィ）はエスケープされません。これは、エスケープすると一部のAjax関数が失敗する可能性があるためです。
もしdataStrが、スペースではなくタブ文字で区切られた「hello	world」という単語を保持している場合：
	jsonEncode(""hello	world"")
は「hello\tworld」という出力を返します。
文字列型のデータについては、.jsonEncode()オペレーターも参照してください。"
"last(item[, childrenNum])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"last(item[item[, childrenNum])
Returns Boolean true if the current note is among the last childrenNum of children of item. If childrenNum is missing, a value of 1 is assumed.
The item argument must be quoted unless an attribute reference. Ways to define item.
Both arguments are evaluated and can be a literal string/number, an attribute value or an action code expression evaluating to that same.
If the current note has a $SiblingOrder value of 7, then if first() is run on its parent container with 10 children:
	first(""Note A"", 5) returns true 
but if it has a $SiblingOrder value of 2:
	first(""Note A"", 5) returns false 
last() also has a logical opposite in first().
Legacy issues
This operator replaces the legacy #last query operator.","last(item[, childrenNum])
現在のノートが item の子のうち、最後の childrenNum 個の中に含まれる場合、ブール値の真（true）を返します。childrenNum が省略された場合は、1 と見なされます。
item 引数は、属性参照でない限り引用符で囲む必要があります。item の指定方法。
両方の引数が評価され、リテラルの文字列や数値、属性値、またはそれらを評価するアクションコード式を使用できます。
現在のノートの $SiblingOrder の値が 7 で、10 個の子を持つ親コンテナに対して first() を実行した場合：
	first(""Note A"", 5) は真（true）を返します
しかし、$SiblingOrder の値が 2 の場合：
	first(""Note A"", 5) は偽（false）を返します
last() には、論理的に反対の first() も存在します。
旧バージョンの問題
この演算子は、以前の #last クエリ演算子を置き換えます。"
lastWord(dataStr),Function,Item,Data manipulation,String,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"lastword(""data"")
The lastWord() operator has one argument, dataStr (a quoted a string), and it returns the final word of the data string. The delimiter used to define words is one or more spaces (possibly also line break(s)?).
The dataStr argument is evaluated so could be an expression. For example, if the note 'First Line' has the body text ""Winter is coming."", then 
	$MyString = lastWord($Text(""First Line"")); 
should give a result of ""coming"".","lastWord() オペレーターは、1つの引数 dataStr（引用符で囲まれた文字列）を受け取り、そのデータ文字列の最後の単語を返します。単語の区切り文字には、1つ以上のスペース（および場合によっては改行）が使用されます。
引数 dataStr は評価されるため、式を使用することも可能です。例えば、'First Line' という名前のノートの本文が ""Winter is coming."" である場合、
	$MyString = lastWord($Text(""First Line""));
の結果は ""coming"" になります。"
"linkedFrom(scope[, linkTypeStr])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkedFrom(scope[, linkTypeStr])
A test for inbound links. This boolean test at returns true if the current note has a least one link from any of the note(s) defined by scope; this is optionally filtered to only links of type linkTypeStr. Put another way:
* ""Does an inbound link exist to the current note from any of scope's item(s)?"".
or
* ""Do any of scope's item(s) have an outbound link to the current note?"".
As this is effectively only a query term, (with a Boolean result), if trying to collect data about the linked note(s), use links() instead.
scope defines a group of items in a number of ways. An additional option to normal group descriptors is a wildcard designator * that matches all notes in the document and replaces the normal ""all"" group designator.
For linkTypeStr, links of type 'prototype' are ignored. Used in an agent, 'this' note is the alias in the agent and not its original, making this action unsuitable for testing in an agent action. If using linkTypeStr, you must use the value ""*untitled"" to match an 'untitled' type link (rather than an empty string, """", or ""untitled"").
Thus, to test if any note using the 'Event' prototype has an inbound link of the 'untitled' link type the agent query would be:
	$Prototype==""Event"" & linkedFrom(""*"", ""*untitled"") 
The logical opposite of this test is linkedTo().
This function can match a link from an alias as opposed to an original (if the logical choice).
Working with aliases
If testing links using aliases (e.g. those created by an agent query) be aware that, for basic type links only, the original and alias can and may have differing numbers of basic links. Thus if wishing to check, unambiguously, the original's links from the context of one of its aliases, use originalLinkedFrom() instead.
Legacy issues
This replaces the legacy #linkedFrom query operator (deprecated since v4.6).
Counting links (of a type)
To know how many inbound links there are, use links() and .count() the resulting list.","linkedFrom(scope[, linkTypeStr])
インバウンドリンク（被リンク）のテスト。このブール値テストは、現在のノートが scope で定義されたノートのいずれかから少なくとも1つのリンクを持っている場合に真（true）を返します。オプションで、リンクタイプを linkTypeStr に限定してフィルタリングできます。言い換えれば：
* 「scope の項目のいずれかから、現在のノートへのインバウンドリンクが存在するか？」
または
* 「scope の項目のいずれかに、現在のノートへのアウトバウンドリンクがあるか？」
これは事実上クエリ条件（ブール値の結果）に過ぎないため、リンクされたノートに関するデータを収集したい場合は、代わりに links() を使用してください。
scope は、いくつかの方法で項目のグループを定義します。通常のグループ指定子に加えて、ドキュメント内のすべてのノートに一致し、通常の ""all"" グループ指定子に代わるワイルドカード指定子 * が使用可能です。
linkTypeStr について、タイプが 'prototype' のリンクは無視されます。エージェントで使用される場合、 'this' ノートはエージェント内のエイリアスであり、オリジナルではないため、このアクションはエージェントアクション内でのテストには適していません。 linkTypeStr を使用する場合、「untitled（無題）」タイプのリンクに一致させるには、（空の文字列 """" や ""untitled"" ではなく） ""*untitled"" という値を使用する必要があります。
したがって、「Event」プロトタイプを使用しているノートに「untitled」リンクタイプのインバウンドリンクがあるかどうかをテストするエージェントクエリは、次のようになります：
	$Prototype==""Event"" & linkedFrom(""*"", ""*untitled"") 
このテストの論理的な反対は linkedTo() です。
この関数は、（論理的な選択であれば）オリジナルではなくエイリアスからのリンクにも一致させることができます。
エイリアスの扱い
エイリアス（エージェントクエリで作成されたものなど）を使用してリンクをテストする場合、基本タイプのリンクのみ、オリジナルとエイリアスで基本リンクの数が異なる場合があることに注意してください。したがって、エイリアスのコンテキストからオリジナルのリンクを明確にチェックしたい場合は、代わりに originalLinkedFrom() を使用してください。
レガシーに関する事項
これは、レガシーな #linkedFrom クエリ演算子（v4.6 以降非推奨）を置き換えるものです。
リンク（特定のタイプ）のカウント
インバウンドリンクがいくつあるかを知るには、 links() を使用し、結果のリストを .count() してください。"
"linkedTo(scope[, linkTypeStr])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkedTo(scope[, linkTypeStr])
A test for outbound links. This boolean test at returns true if the current note has a least one link to any of the note(s) defined by scope; this is optionally filtered to only links of type linkTypeStr. Put another way:
* ""Does an outbound link exist from the current note to any of scope's item(s)?"".
or
* ""Do any of scope's item(s) have an inbound link from the current note?"".
As this is effectively only a query term, (with a Boolean result), if trying to collect data about the linked note(s), use links() instead.
scope defines a group of items in a number of ways. An additional option to normal group descriptors wildcard designator * that matches all notes in the document and replaces the normal ""all"" group designator.
For linkTypeStr, links of type 'prototype' are ignored. Used in an agent, 'this' note is the alias in the agent and not its original, making this action unsuitable for testing in an agent action. If using linkTypeStr, you must use the value ""*untitled"" to match an 'untitled' type link (rather than an empty string, """", or ""untitled"").
Thus, to test if any note using the 'Event' prototype has an outbound link of the 'untitled' link type the agent query would be:
	$Prototype==""Event"" & linkedTo(""*"", ""*untitled"");  
The logical opposite of this test is linkedFrom().
This function can match a link from an alias as opposed to an original (if the logical choice).
Working with aliases
If testing links using aliases (e.g. those created by an agent query) be aware that, for basic type links only, the original and alias can and may have differing numbers of basic links. Thus if wishing to check, unambiguously, the original's links from the context of one of its aliases, use originalLinkedTo() instead.
Legacy issues
This replaces the legacy #linkedTo query operator (deprecated since v4.6).
Counting links (of a type)
To know how many outbound links there are, use links() and .count() the resulting list.","linkedTo(scope[, linkTypeStr])
アウトバウンドリンク（出力リンク）の有無を判定するテストです。このブール値テストは、現在のノートが scope で定義されたノートのいずれかに対して、少なくとも1つのリンクを持っている場合に真（true）を返します。オプションで linkTypeStr を指定して、特定のリンクタイプのみにフィルタリングすることも可能です。言い換えれば：
* 「現在のノートから scope のアイテムのいずれかに対して、アウトバウンドリンクが存在するか？」
または
* 「scope のアイテムのいずれかが、現在のノートからのインバウンドリンクを持っているか？」
これは実質的にクエリ用語（結果はブール値）であるため、リンク先ノートに関するデータを収集したい場合は、代わりに links() を使用してください。
scope は、いくつかの方法でアイテムのグループを定義します。通常のグループ指定子に加え、ドキュメント内のすべてのノートに一致するワイルドカード指定子「*」も利用でき、これは通常の「all」指定子を置き換えます。
linkTypeStr について、「prototype」タイプのリンクは無視されます。エージェントで使用する場合、「this」ノートはエージェント内のエイリアスを指し、オリジナルではないため、このアクションはエージェントのアクション内でのテストには適していません。linkTypeStr を使用する場合、「untitled」タイプのリンクに一致させるには（空の文字列 """" や ""untitled"" ではなく）「*untitled」という値を使用する必要があります。
したがって、「Event」プロトタイプを使用しているノートが「untitled」リンクタイプのアウトバウンドリンクを持っているかどうかをテストする場合、エージェントのクエリは以下のようになります：
	$Prototype==""Event"" & linkedTo(""*"", ""*untitled""); 
このテストの論理的な反対は linkedFrom() です。
この関数は、（論理的な選択であれば）オリジナルではなくエイリアスからのリンクにも一致させることができます。
エイリアスを扱う場合
エイリアス（エージェントクエリによって作成されたものなど）を使用してリンクをテストする場合、基本タイプ（basic type）のリンクに限り、オリジナルとエイリアスでリンクの数が異なる可能性があることに注意してください。したがって、エイリアスのコンテキストからオリジナルのリンクを曖昧さなくチェックしたい場合は、代わりに originalLinkedTo() を使用してください。
レガシーに関する事項
これは、レガシーな #linkedTo クエリ演算子（v4.6 以降非推奨）を置き換えるものです。
リンク数（特定のタイプ）のカウント
アウトバウンドリンクがいくつあるかを知るには、links() を使用し、結果のリストに対して .count() を使用してください。"
"linkFrom(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkFrom(""item|group""[,""linkType""])
This creates an untitled type basic link from scope to the current note (i.e. an inbound link).
The scope argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString. Ways to define scope.
The scope can be group scoped including use of group designators and operators like find,() collect() and links().
linkTypeStr (string). Optionally, instead of an 'untitled' link the link can be of linkTypeStr type. An untitled type link can be explicitly specified using the string ""*untitled"". Unlike unlinking, this argument may only contain a single link type value.
Both arguments are evaluated. This operator does not require a left-side argument, simply calling effects a result. A new link will not be created if a link of the stated type already exists.
Examples
Linking from a note ""Some note"":
	No link type: linkFrom(""Some note"") 
	Link type 'agree': linkFrom(""Some note"",""agree""); 
Linking from the first child (via a designator):
	linkFrom(child); 
	linkFrom(child,""agree""); 
Relevant similar operators: linkTo, unlinkTo, unlinkFrom.
Use of this action does not shift note focus; in addition if scope contains operators (brackets, plus, minus, etc.) Tinderbox will first look for a match to the literal item string and only if there is no match will the app try evaluating to operators and testing the resulting string. For example:
	linkFrom(""Example 1 (a test)""); 
will link from the note named 'Example 1 (a test)'. If no note matches this string, Tinderbox will attempt to evaluate the string. Thus for:
	linkFrom(""2+2"") 
will link from the note named '2+2' but if no match will look for a note named '4'.
This function can link from an alias as opposed to an original (if the logical choice) and can accept a group scope.
Use in agents
Beware that the action is working on an alias of the current note and note the current note itself. As originals and aliases support discrete basic links this function should not generally be used in an agent. The best way to use the function is by using a prototype and apply a $Rule to it thus running the code in all notes using the prototype.
An alternative linkFromOriginal() code will ensure any link created is between two original notes regardless of whether an alias is the context of execution of the code.","linkFrom(""item|group""[,""linkType""])
この関数は、指定されたスコープ（scope）から現在のノートへの、タイプ指定のない基本リンクを作成します（つまり、内向きのリンクです）。

引数 scope は、$MyString のような属性参照でない限り、""Some note"" のように引用符で囲む必要があります。スコープの定義方法を参照してください。
scope には、グループ指定子や find()、collect()、links() などの演算子を使用したグループスコープを指定できます。

linkTypeStr（文字列）：オプション引数です。「untitled」（タイプなし）リンクの代わりに、linkTypeStr で指定したタイプのリンクを作成できます。タイプなしのリンクは、文字列 ""*untitled"" を使用して明示的に指定することも可能です。リンク解除（unlink）とは異なり、この引数には単一のリンクタイプのみを指定できます。

両方の引数が評価されます。この演算子は左辺（レシーバー）を必要とせず、呼び出すだけで効果を発揮します。指定されたタイプのリンクが既に存在する場合、新しいリンクは作成されません。

例
""Some note"" というノートからリンクする場合：
	リンクタイプなし：linkFrom(""Some note"") 
	リンクタイプ 'agree'：linkFrom(""Some note"",""agree""); 
最初の小ノートからリンクする場合（指定子を使用）：
	linkFrom(child); 
	linkFrom(child,""agree""); 

関連する演算子：linkTo、unlinkTo、unlinkFrom。

このアクションを使用しても、ノートのフォーカスは移動しません。また、スコープに演算子（括弧、プラス、マイナスなど）が含まれている場合、Tinderbox はまずリテラルな文字列として一致する項目を探します。一致するものがない場合にのみ、演算子を評価した結果の文字列で一致を探します。例えば：
	linkFrom(""Example 1 (a test)""); 
は、""Example 1 (a test)"" という名前のノートからリンクします。その名前のノートがない場合にのみ、評価を試みます。したがって：
	linkFrom(""2+2"") 
は、まず ""2+2"" という名前のノートからリンクしようとし、見つからない場合に ""4"" という名前のノートを探します。

この関数は、（論理的に適切な場合）オリジナルの代わりにエイリアスからリンクすることができ、グループスコープも受け入れます。

エージェントでの使用
エージェント内では、アクションは現在のノートのエイリアスに対して動作しており、現在のノート自体に対してではないことに注意してください。オリジナルとエイリアスは個別に基本リンクを保持できるため、この関数をエージェント内で使用することは一般的に避けるべきです。最善の方法は、プロトタイプに $Rule を適用し、そのプロトタイプを使用するすべてのノートでコードを実行させることです。

代替となる linkFromOriginal() を使用すれば、実行コンテキストがエイリアスであっても、常にオリジナルノート間でリンクが作成されるようになります。"
"linkFromOriginal(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,6.4.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkFromOriginal(scope[, linkTypeStr])
This function works exactly as the same as linkFrom(), except for one important difference that the link created is always between two originals even if either/both the evaluated source or destination are an alias.
For more detail of use, see linkFrom().
Examples
Linking from the original note ""Some note"" (and not an alias of it):
	No link type: linkFromOriginal(""Some note"") 
	Link type 'agree': linkFromOriginal(""Some note"",""agree""); 
See also linkToOriginal(), unlinkFromOriginal(), unlinkToOriginal().","linkFromOriginal(scope[, linkTypeStr])
この関数は、linkFrom() と全く同じように動作しますが、1つの重要な違いがあります。それは、評価されたソースまたはデスティネーションのいずれか（または両方）がエイリアスであっても、作成されるリンクは常に2つのオリジナル間のものになるという点です。
使用方法の詳細については、linkFrom() を参照してください。
例
オリジナルのノート ""Some note""（そのエイリアスではない）からのリンク：
	リンクタイプなし: linkFromOriginal(""Some note"") 
	リンクタイプ 'agree': linkFromOriginal(""Some note"",""agree""); 
linkToOriginal()、unlinkFromOriginal()、unlinkToOriginal() も参照してください。"
"linkPath(pathNameStr[, startStr, endStr])",Function,Item,Linking,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,false,false,true,false,,false,"linkPath(pathNameStr)
linkPath(pathNameStr[, startStr, endStr])
These functions return a list of notes that are on a designated path. The pathNameStr input must be supplied but can use a value  ""*"" designates any path, regardless of path name—i.e. all notes that have at least one inbound or outbound link. This operator in many ways mirrors the visual function of the Hyperbolic view.
If startStr is provided, that path starts at the designated note and ends on reaching the endStr note or when all links on the path reachable from start are exhausted. If only the pathName is provided, all notes on the path are listed, whether or not they all form one contiguous network.
For example, to collect all notes on the path ""example"":
	$MyList = linkPath(""example""); 
Or, to return all notes connected by links of any type:
	$MyList = linkPath(""*""); 
To find notes linked by the link type ""Project A"", starting at ""RFC"" :
	$MyList = linkPath(""Project A"", ""RFC""); 
To find notes linked by the link type ""Project A"", starting at ""RFC"" and ending at ""Archive"":
	$MyList = linkPath(""Project A"", ""RFC"", ""Archive""); 
If several possible paths exist from startStr to endStr, Tinderbox will return the shortest path, or at least a path which is not longer than any other path. Bear in mind that in richly interlinked documents, there may be no 'obvious' single path between the specified notes.
 If only endStr is supplied, still include the argument delimiter for the unused startStr:
	$MyList = linkPath(""Project A"", , ""Archive""); 
The underlying graph may contain cycles (i.e. have looping paths).","linkPath(pathNameStr)
linkPath(pathNameStr[, startStr, endStr])
これらの関数は、指定されたパス上にあるノートのリストを返します。pathNameStrの入力は必須ですが、""*""を値として指定することも可能です。""*""はパス名に関わらず任意のパスを指定します。つまり、少なくとも1つのインバウンド（入）またはアウトバウンド（出）リンクを持つすべてのノートを対象とします。この演算子は、多くの点でハイパーボリック・ビューの視覚的機能を反映しています。

startStrが指定された場合、パスは指定されたノートから始まり、endStrノートに到達するか、開始ノートから到達可能なパス上のすべてのリンクを使い果たした時点で終了します。パス名のみが指定された場合は、それらが一つの連続したネットワークを形成しているかどうかにかかわらず、そのパス上のすべてのノートがリストされます。

例えば、パス ""example"" 上のすべてのノートを収集する場合：
	$MyList = linkPath(""example""); 
または、任意のタイプのリンクで接続されたすべてのノートを返す場合：
	$MyList = linkPath(""*""); 
""RFC""から始まり、リンクタイプ ""Project A"" で接続されているノートを探す場合：
	$MyList = linkPath(""Project A"", ""RFC""); 
""RFC""から始まり ""Archive"" で終わる、リンクタイプ ""Project A"" で接続されているノートを探す場合：
	$MyList = linkPath(""Project A"", ""RFC"", ""Archive""); 

startStrからendStrまでの間に複数のパスが存在する場合、Tinderboxは最短のパス、あるいは少なくとも他のどのパスよりも長くないパスを返します。複雑にリンクが張り巡らされたドキュメントでは、指定されたノート間に「明白な」単一のパスが存在しない可能性があることに注意してください。

endStrのみを指定する場合でも、未使用のstartStrのための引数区切り記号（カンマ）を含める必要があります：
	$MyList = linkPath(""Project A"", , ""Archive""); 

背後のグラフ構造にはサイクル（ループするパス）が含まれる場合があります。"
links[(scope)].directionStr.[linkTypeRegex].attributeNameRefStr,Function,Conditional Group,"Dictionary, Set & List operations",List,false,4.0.0,Baseline,,,,4,true,false,false,false,true,true,false,true,false,true,false,"The `links()` operator constructs a List or Set of attribute values from linked notes based on a specified scope, direction, and link type. While powerful, the `eachLink()` operator is often recommended for more complex control over link data.

### Syntax
`links[(scope)].directionStr.[linkTypeRegex].attributeNameStr`

### Arguments
*   **scope (Optional):** Defines the note(s) whose links are inspected (e.g., `this`, `children`, `/config`, or a variable like `$MyList`). It uses simple expressions and never matches aliases. In the context of agent actions, using `original` as the scope is often preferred over `this`. If omitted, it defaults to `this`.
*   **directionStr (Mandatory):** Must be either `inbound` or `outbound`.
*   **linkTypeRegex (Optional):** A literal string or regular expression to filter link types. If left empty, all link types are collected except prototype links, which are always omitted. Multi-word names or strings containing periods or special characters must be enclosed in double quotes.
*   **attributeNameRefStr (Mandatory):** A $-prefixed reference to the attribute whose values should be collected (e.g., `$Name`, `$StartDate`). This must be a literal attribute reference and cannot be a calculated expression.

### Key Behaviors and Constraints
*   **Data Types:** If the result is assigned to a **Set**, duplicate values (such as multiple notes with the same name) are removed. Assigning to a **List** preserves duplicates.
*   **Chaining Operators:** To chain additional dot-operators (like `.size`, `.count`, or `.sort()`), the `links()` expression must be enclosed in parentheses: `(links(this).outbound..$Name).count`.
*   **Comparison with Other Operators:** 
    *   Use `linkedTo()` or `linkedFrom()` for simple Boolean checks of link existence.
    *   Use `eachLink()` for complex tasks involving multiple attributes or advanced logic.
*   **Evaluation:** `links.outbound` is treated as equivalent to `links(this).outbound`.

### Examples
*   `$MyList = links(/config).outbound.supports.$Name;` (Collects names of notes linked from ""/config"" via the ""supports"" link type.)
*   `$MyList = links.inbound.""went to"".$SchoolName;` (Collects `$SchoolName` values for all notes with an inbound ""went to"" link.)
*   `$MyNumber = (links(this).outbound..$Name).count;` (Returns the total count of all outbound links from the current note, excluding prototype and web links.)
*   `$MyList = (links.inbound.""colleague of"".$Name).sort(""$StartDate"");` (Collects names from inbound links and sorts them by their start date.)","`links()`オペレータは、指定されたスコープ、方向、およびリンクタイプに基づいて、リンクされたノートから属性値のリスト（List）またはセット（Set）を構築します。強力な機能ですが、リンクデータをより細かく制御する必要がある場合は、`eachLink()`オペレータの使用が推奨されることがよくあります。

### 構文
`links[(scope)].directionStr.[linkTypeRegex].attributeNameStr`

### 引数
*   **scope（任意）:** リンクを検査する対象のノートを定義します（例：`this`、`children`、`/config`、または`$MyList`のような変数）。単純な式を使用し、エイリアスには決して一致しません。エージェントのアクション内では、スコープとして`this`よりも`original`を使用する方が好ましい場合が多いです。省略した場合、デフォルトは`this`になります。
*   **directionStr（必須）:** `inbound`（入力）または`outbound`（出力）のいずれかである必要があります。
*   **linkTypeRegex（任意）:** リンクタイプをフィルタリングするためのリテラル文字列または正規表現。空のままにすると、プロトタイプリンク（常に除外されます）を除くすべてのリンクタイプが収集されます。複数の単語で構成される名前や、ピリオド、特殊文字を含む文字列は、二重引用符で囲む必要があります。
*   **attributeNameRefStr（必須）:** 値を収集する属性への`$`付きの参照（例：`$Name`、`$StartDate`）。これはリテラルな属性参照である必要があり、計算式にすることはできません。

### 主な動作と制約
*   **データ型:** 結果を**Set**型に代入した場合、重複する値（同じ名前の複数のノートなど）は削除されます。**List**型に代入した場合は、重複が保持されます。
*   **オペレータの連結:** `.size`、`.count`、`.sort()`などの追加のドット演算子を連結するには、`links()`の式全体を括弧で囲む必要があります：`(links(this).outbound..$Name).count`。
*   **他のオペレータとの比較:** 
    *   リンクが存在するかどうかの単純な真偽値（Boolean）チェックには、`linkedTo()`または`linkedFrom()`を使用します。
    *   複数の属性や高度なロジックを伴う複雑なタスクには、`eachLink()`を使用します。
*   **評価:** `links.outbound`は`links(this).outbound`と同等として扱われます。

### 例
*   `$MyList = links(/config).outbound.supports.$Name;` （""/config""から""supports""リンクタイプでリンクされているノートの名前を収集します。）
*   `$MyList = links.inbound.""went to"".$SchoolName;` （""went to""の入力リンクを持つすべてのノートから、`$SchoolName`の値を収集します。）
*   `$MyNumber = (links(this).outbound..$Name).count;` （現在のノートからのすべての出力リンクの総数を返します。ただし、プロトタイプリンクとウェブリンクは除きます。）
*   `$MyList = (links.inbound.""colleague of"".$Name).sort(""$StartDate"");` （入力リンクから名前を収集し、それらをの開始日（`$StartDate`）でソートします。）"
"linkTo(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkTo(scope[, linkTypeStr])
This creates an untitled type basic link to scope from the current note (i.e. an outbound link).
The scope argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString. Ways to define scope.
scope can be group scoped including use of group designators and operators like find,() collect() and links().
linkType (string). Optionally, instead of an 'untitled' link the link can be of linkTypeStr type. An untitled type link can be explicitly specified using the string ""*untitled"". Unlike unlinking, this argument may only contain a single link type value. 
Both arguments are evaluated. This operator does not require a left-side argument, simply calling effects a result. A new link will not be created if a link of the stated type already exists.
Examples
Linking to a note ""Some note"":
	No link type: linkTo(""Some note""); 
	Link type 'agree': linkTo(""Some note"",""agree""); 
Linking to the first child (via a designator):
	linkTo(child); 
	linkTo(child,""agree""); 
Relevant similar operators: linkFrom, unlinkTo, unlinkFrom.
Use of this action does not shift note focus; in addition if scope contains operators (brackets, plus, minus, etc.) Tinderbox will first look for a match to the literal item string and only if there is no match will the app try evaluating to operators and testing the resulting string. For example:
	linkTo(""Example 1 (a test)"") 
will link to the note named 'Example 1 (a test)'. If no note matches this string, Tinderbox will attempt to evaluate the string. Thus for:
	linkTo(""2+2""); 
will link to the note named '2+2' but if no match will look for a note named '4'.
This function can link to an alias as opposed to an original (if the logical choice) and can accept a group scope.
Use in agents
Beware that the action is working on an alias of the current note and note the current note itself. As originals and aliases support discrete basic links this function should not generally be used in an agent. The best way to use the function is by using a prototype and apply a $Rule to it thus running the code in all notes using the prototype.
An alternative linkFromOriginal() code will ensure any link created is between two original notes regardless of whether an alias is the context of execution of the code.","linkTo(scope[, linkTypeStr])
これは、現在のノートから scope への、名前のない（untitled）タイプの基本リンク（アウトバウンドリンク）を作成します。
scope 引数は、属性参照（例：$MyString）でない限り、""Some note"" のように引用符で囲む必要があります（scope の定義方法を参照）。
scope には、グループ指定子や、find()、collect()、links() などの演算子を使用したグループスコープを指定できます。
linkTypeStr（文字列）：オプションで、'untitled' リンクの代わりに linkTypeStr タイプのリンクを作成できます。名前のないリンクを明示的に指定するには、文字列 ""*untitled"" を使用します。unlinkTo とは異なり、この引数には単一のリンクタイプ値のみを指定できます。
両方の引数が評価されます。この演算子は左辺の引数を必要とせず、呼び出すだけで結果が実行されます。指定されたタイプのリンクが既に存在する場合、新しいリンクは作成されません。

例
ノート ""Some note"" へのリンク：
	リンクタイプなし：linkTo(""Some note"");
	リンクタイプ 'agree'：linkTo(""Some note"",""agree"");
最初の子供へのリンク（指定子を使用）：
	linkTo(child);
	linkTo(child,""agree"");

関連する類似演算子：linkFrom, unlinkTo, unlinkFrom

このアクションを使用してもノートのフォーカスは移動しません。さらに、scope に演算子（括弧、プラス、マイナスなど）が含まれている場合、Tinderbox はまずリテラルな項目文字列との一致を探し、一致するものがない場合にのみ演算子を評価して結果の文字列をテストします。例えば：
	linkTo(""Example 1 (a test)"")
は、'Example 1 (a test)' という名前のノートにリンクします。この文字列に一致するノートがない場合、Tinderbox は文字列の評価を試みます。したがって：
	linkTo(""2+2"");
は、まず '2+2' という名前のノートへのリンクを試みますが、一致するものがない場合は '4' という名前のノートを探します。
この関数は、（論理的な選択であれば）オリジナルではなくエイリアスにリンクすることができ、グループスコープも受け入れます。

エージェントでの使用
このアクションは、現在のノート自体ではなく、現在のノートのエイリアスに対して動作することに注意してください。オリジナルとエイリアスは個別の基本リンクをサポートしているため、この関数は通常、エージェントで使用すべきではありません。この関数を使用する最適な方法は、プロトタイプを使用して $Rule を適用し、そのプロトタイプを使用するすべてのノートでコードを実行させることです。
代替となる linkFromOriginal() コードを使用すると、コードの実行コンテキストがエイリアスであるかどうかに関係なく、作成されるリンクが確実に2つのオリジナルノート間のものになります。"
"linkToOriginal(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,6.4.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkToOriginal(scope[, linkType])
This function works exactly as the same as linkTo(), except for one important difference that the link created is always between two originals even if either/both the evaluated source or destination are an alias.
For more detail of use, see linkTo().
Examples
Linking to the original note ""Some note"" (and not an alias of it):
	No link type: linkToOriginal(""Some note""); 
	Link type 'agree': linkToOriginal(""Some note"",""agree""); 
See also linkFromOriginal(), unlinkFromOriginal(), unlinkToOriginal().","linkToOriginal(scope[, linkType])
この関数は linkTo() と全く同じように動作しますが、1つ重要な違いがあります。作成されるリンクは、評価されたソースまたはデスティネーションのいずれか（あるいは両方）がエイリアスであっても、常に2つのオリジナル間のものになります。
使用方法の詳細については、linkTo() を参照してください。
例
元のノート「Some note」に（そのエイリアスではなく）リンクする：
	リンクタイプなし：linkToOriginal(""Some note""); 
	リンクタイプ 'agree'：linkToOriginal(""Some note"",""agree""); 
参照：linkFromOriginal(), unlinkFromOriginal(), unlinkToOriginal()"
"list.any(loopVar, expressionStr)",Function,List,Query Boolean,boolean test,false,8.1.0,Baseline,,,,2,true,true,false,true,false,false,false,false,false,,false,"list.any(loopVar, expressionStr)
This is true if any loopVar in the List- or Set-type list matches the expression.
	$MyBoolean = $MyList.any(x,x>5) 
is true if any loopVar in $MyList is greater than 5. 
The comparison may also be applied to literal lists:
	""apple; pear; plum"".any(x, x==""plum"") 
is true because at least one element has the value ""plum"".
If the target list or set is empty, .any() always returns false, and .every() always returns true.
The loopVar is a user-set case-sensitive string. ""x"", ""anItem"", etc., are equally applicable. Similar to a loop variable in .each(x){}, the point of the loopVar value, is to set a reference variable for each list element. This can then be used in the code provided by the expressionStr argument. Using a number for loopVar, e.g. '1' or '42' is not recommended. Choose a value that makes sense for your own style of work  
The expressionStr is any action code expression that is a test resolving to a Boolean true/false answer.
For example, to test if any item exactly matches the value stored in the $MyString of 'Some note':
	$MyBoolean = $MyList.any(anItem, anItem == $MyString(""Some Note"")); 
Or, any list value that starts with the string 'Large':
	$MyBoolean = $MyList.any(Z, Z.contains(""^Large""));","list.any(loopVar, expressionStr)
List型またはSet型のリスト内のいずれかの要素（loopVar）が式（expressionStr）に一致する場合、真（true）を返します。
	$MyBoolean = $MyList.any(x,x>5) 
は、$MyList内のいずれかの要素が5より大きい場合に真となります。
この比較はリテラルのリストに対しても適用可能です：
	""apple; pear; plum"".any(x, x==""plum"") 
は、少なくとも1つの要素が""plum""という値を持っているため、真となります。
対象のリストまたはセットが空の場合、.any()は常に偽（false）を返し、.every()は常に真（true）を返します。
loopVarは、ユーザーが設定する大文字小文字を区別する文字列です。""x""や""anItem""などが同様に利用できます。.each(x){}におけるループ変数と同様に、loopVarの役割は各リスト要素への参照変数を設定することです。これにより、expressionStr引数で提供されるコード内でその変数を使用できるようになります。loopVarに「1」や「42」などの数値を使用することは推奨されません。自身の作業スタイルに合った分かりやすい名前を選択してください。
expressionStrは、結果が真偽値（true/false）として解決される任意のアクションコードのテスト式です。
例えば、いずれかの項目が「Some note」というノートの$MyStringに格納されている値と正確に一致するかどうかをテストするには：
	$MyBoolean = $MyList.any(anItem, anItem == $MyString(""Some Note"")); 
または、""Large""という文字列で始まるリスト値があるかどうかを確認するには：
	$MyBoolean = $MyList.any(Z, Z.contains(""^Large""));"
list.asString(),Function,Item,Data manipulation,String,false,9.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.asString()
list.asString
The dot-operator .asString(), converts a List- or Set-type list to a String-type representation. This addresses an issue where much-used operators .contains() and .icontains() behave differently for Strings (where it searches for a regular expression match) compared to Lists and Sets (where it tests for set membership). Occasionally, is desirable to perform a regular expression test on a list or set—for example, to ask if any of the members of $MyList begin with the letter ""a"":
	$MyBoolean = $MyList.asString().contains(^a""); 
Note there are no arguments for this operator so the trailing parentheses optionally may be omitted:
 	$MyBoolean = $MyList.asString.contains(^a""); 
The role of .asString() is simple:
     $MyList = [winken;blinken;nod];
     $MyString = $MyList.asString();
The value of MyString is now ""winken;blinken;nod"", still the literal stored value of my list complete with semicolon delimiters, but—importantly—Tinderbox now treats this is a literal String, despite the semicolons, and not as List or Set type data. That allows the .contains() example above to do a regex (String behaviour) match on what is otherwise treated as a 3-item list.","list.asString()
list.asString

ドット演算子 .asString() は、List型またはSet型のリストをString型の表現に変換します。これは、多用される演算子 .contains() や .icontains() が、String（正規表現の一致を検索）と List/Set（セットのメンバーシップをテスト）で動作が異なるという点に対応するためのものです。時として、リストやセットに対して正規表現によるテストを行いたい場合があります。例えば、$MyList のメンバーのいずれかが文字 ""a"" で始まるかどうかを判定する場合などです：
	$MyBoolean = $MyList.asString().contains(""^a""); 

この演算子には引数がないため、末尾の括弧は任意で省略できます：
 	$MyBoolean = $MyList.asString.contains(""^a""); 

.asString() の役割は単純です：
     $MyList = [winken;blinken;nod];
     $MyString = $MyList.asString();
MyString の値は ""winken;blinken;nod"" になります。これはセミコロンの区切り文字を含むリストの格納値そのものですが、重要なのは、Tinderbox がこれを（セミコロンがあるにもかかわらず）List や Set 型のデータではなく、リテラルな String として扱うようになることです。これにより、上記の .contains() の例のように、本来は3項目のリストとして扱われるものに対して、正規表現（String の挙動）によるマッチングを行うことが可能になります。"
list.at(itemNum),Function,Item,Data manipulation,source context dependent,false,5.7.1,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.at(itemNum)
This returns the value of item itemNum of the List- or Set-type list as a string. List can be either Set or List type attributes (or string literal, regex, or expression equivalents thereof). This operator is read-only: list values can be read, but not set.
Note: for accessing look-up tables, use list.lookup().
The operator is zero-based, i.e. an itemNum value of 0 returns the first list item, an itemNum of 1 returns value #2, etc. If the value of N exceeds the number of items in the list an empty string (blank value) is returned. A negative number returns an item numbering in reverse, but one-based not zero-based, so '-1' returns the last item on the list, '-2' the last but one item, etc.
Examples (where $MyList is ""ant;bee;cow""):
	$MyString = $MyList.at(0); returns ""ant""
	$MyString = ""XX;YY;ZZ"".at(2); returns ""ZZ""
	$MyString = $MyList.at(5); returns """" (nothing) 
	$MyString = $MyList.at(-2); returns ""bee""
See also the more recent list[N] usage.
To address particular locations in a list, also see list.first(), list.last() and list.randomItem().

Legacy use (pre-v8)
list.at(""key"")
This usage is deprecated, use list.lookup(""key"") instead. The remainder of this section is for explanation of legacy code use only.
The .at() function is also useful for accessing values from look-up tables by providing the relevant key. Consider a look-up list:
	$RegionList=""AL:South;AK:NorthWest;default:North""; 
This allows actions like:
	$Region=$RegionList.at(""AL""); 
or
	$Region=$RegionList.at($State);","list.at(itemNum)
これは、List型またはSet型のリストのitemNum番目の項目の値を文字列として返します。リスト（list）は、Set型またはList型の属性（または文字列リテラル、正規表現、またはこれらに相当する式）のいずれかです。このオペレータは読み取り専用です。リストの値は読み取ることができますが、設定することはできません。
注：ルックアップテーブルにアクセスする場合は、list.lookup()を使用してください。
このオペレータは0ベースです。つまり、itemNumの値が0の場合はリストの最初の項目を返し、1の場合は2番目の項目を返します。Nの値がリストの項目数を超える場合は、空の文字列（空白値）が返されます。負の数は末尾からの逆順の番号になりますが、0ベースではなく1ベースになります。そのため、「-1」はリストの最後の項目を、「-2」は最後から2番目の項目を返します。
例（$MyListが ""ant;bee;cow"" の場合）：
	$MyString = $MyList.at(0); // ""ant""を返す
	$MyString = ""XX;YY;ZZ"".at(2); // ""ZZ""を返す
	$MyString = $MyList.at(5); // """"（空）を返す
	$MyString = $MyList.at(-2); // ""bee""を返す
より新しい list[N] の使用法も参照してください。
リスト内の特定の場所を指定するには、list.first()、list.last()、およびlist.randomItem()も参照してください。

レガシーな使用法（v8以前）
list.at(""key"")
この使用法は非推奨です。代わりにlist.lookup(""key"")を使用してください。このセクションの残りの部分は、レガシーコードの使用法を説明するためのものです。
.at()関数は、関連するキーを指定することでルックアップテーブルから値にアクセスするのにも役立ちます。次のルックアップリストを考えてみましょう。
	$RegionList=""AL:South;AK:NorthWest;default:North""; 
これにより、以下のようなアクションが可能になります。
	$Region=$RegionList.at(""AL""); 
または
	$Region=$RegionList.at($State);"
list.avg(),Function,List,"Dictionary, Set & List operations",Number,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.avg()
list.avg
Returns the mean value of a List- or Set-type list of numbers. For example, if MyList is a list of numerical values '3;4;8;3;9;2;12':
	$MyNumber = $MyList.avg; returns 5.85714
To get only two decimal places:
	$MyNumber = $MyList.avg.format(""2""); returns 5.86","list.avg()
list.avg
数値の List 型または Set 型リストの平均値を返します。たとえば、MyList が数値 '3;4;8;3;9;2;12' のリストである場合：
	$MyNumber = $MyList.avg; は 5.85714 を返します。
小数点以下2桁のみを取得する場合：
	$MyNumber = $MyList.avg.format(""2""); は 5.86 を返します。"
"list.collect_if(loopVar, condition, expressionStr)",Function,List,"Dictionary, Set & List operations",List,false,9.0.0,Baseline,,,,3,true,true,false,true,false,false,true,false,false,,false,"list.collect_if(loopVar, condition, expressionStr)
The dot-operator .collect_if() collects the members of a List- or Set-type list that satisfy a condition. Each item in the list is bound in turn to loopVar, and then the expressionStr is evaluated.
loopVar is essentially the same as the loop variable used by the List.each() operator. In the examples below, for clarity the loopVar value ""anItem"" is used, but as with any loop variable a shorter less expressive values such a ""x"" can be used (e.g. by more expert users).
The condition argument is a conditional expression for which each tested item must return true or false.
The operator applies the action code expressionStr to only those list items for which condition is  true. For only list items meeting condition, the result of expressionStr on loopVar is returned as List-type data. Unlike list.collect(), the returned list may well contain fewer items than the source list, unless all source items match condition.
If $MyList is ""1;2;3;4;5"", anItem, is 1, then 2, etc. For example:
	$MyListA = $MyList.collect_if(anItem, anItem  returns 1;2 (only 2 of 5 source items match condition)
	$MyListA = $MyList.collect_if(anItem, mod(anItem,2), anItem); returns 1;3;5 (only 3 of 5 source items match condition)
	$MyListA = $MyList.collect_if(anItem, mod(anItem,2), anItem* anItem); returns 1;9;25 (only 3 of 5 source items match condition)
	$MyListA = $MyList.collect_if(anItem, anItem>0, anItem* anItem); returns 1;4;9;16;25 (all 5 source items match condition)
In the first three examples above note how only some of the original 5 source list items are returned as some input items fail the condition test. In the last example, as all 5 items are greater than zero (the condition) to the expressionStr is applied to every one of them and all are returned.
If $MyList is ""Winken;Blinken;Nod"", then:
	$MyListA = $MyList.collect_if(anItem, anItem.contains('i'),anItem.lowercase); returns ""winken;blinken"" (only 2 items are returned)
In the last example note how only 2 of the original 3 source list items are returned as the item  ""Nod"" does not contain the letter 'i' and so fails the condition test.
list.collect_if() vs. collect_if()
Although the two appear similar. This operator works directly on the source list values, whereas collect_if() creates a list of $Path values and returns on an attribute value from each of those paths (where the item at the $Path meets the condition).","list.collect_if(loopVar, condition, expressionStr)
ドット演算子 .collect_if() は、条件を満たすリスト型またはセット型のリストのメンバーを収集します。リスト内の各項目は順番に loopVar にバインドされ、その後に expressionStr が評価されます。

loopVar は、本質的に List.each() オペレータで使用されるループ変数と同じです。以下の例では、わかりやすくするために loopVar の値として ""anItem"" を使用していますが、他のループ変数と同様に、""x"" のような短く表現力の低い値を使用することもできます（例：より熟練したユーザーによる使用）。

condition 引数は、テストされる各項目が true または false を返す条件式です。

このオペレータは、condition が true であるリスト項目に対してのみ、アクションコード expressionStr を適用します。条件を満たすリスト項目に対してのみ、loopVar に対する expressionStr の結果がリスト型のデータとして返されます。list.collect() とは異なり、すべてのソース項目が条件に一致しない限り、返されるリストにはソースリストよりも少ない項目しか含まれない可能性があります。

$MyList が ""1;2;3;4;5"" で、anItem が 1、次に 2 と続く場合。例：
	$MyListA = $MyList.collect_if(anItem, anItem  returns 1;2 （5つのソース項目のうち 2つだけが条件に一致）
	$MyListA = $MyList.collect_if(anItem, mod(anItem,2), anItem); returns 1;3;5 （5つのソース項目のうち 3つだけが条件に一致）
	$MyListA = $MyList.collect_if(anItem, mod(anItem,2), anItem* anItem); returns 1;9;25 （5つのソース項目のうち 3つだけが条件に一致）
	$MyListA = $MyList.collect_if(anItem, anItem>0, anItem* anItem); returns 1;4;9;16;25 （5つのソース項目すべてが条件に一致）

上記の最初の3つの例では、一部の入力項目が条件テストに失敗するため、元の5つのソースリスト項目のうち一部のみが返されていることに注目してください。最後の例では、5つの項目すべてがゼロより大きい（条件）ため、expressionStr がそれらすべてに適用され、すべてが返されます。

$MyList が ""Winken;Blinken;Nod"" の場合：
	$MyListA = $MyList.collect_if(anItem, anItem.contains('i'),anItem.lowercase); returns ""winken;blinken"" （2つの項目のみが返される）

最後の例では、""Nod"" という項目に文字 'i' が含まれておらず、条件テストに失敗するため、元の3つのソースリスト項目のうち2つだけが返されていることに注目してください。

list.collect_if() vs. collect_if()
これら2つは似ているように見えますが、このオペレータはソースリストの値を直接操作するのに対し、collect_if() は $Path 値のリストを作成し、（そのパスにある項目が条件を満たす場合に）それぞれのパスから属性値を返します。"
"list.collect(loopVar, expressionStr)",Function,List,"Dictionary, Set & List operations",List,false,9.0.0,Baseline,,,,2,true,true,false,true,false,false,false,false,false,,false,"list.collect(loopVar, expression)
Each item in the List- or Set-type list is bound in turn to loopVar, and then the expressionStr is evaluated). 
loopVar is essentially the same as the loop variable used by the List.each() operator. In the examples below, for clarity the loopVar value ""anItem"" is used, but as with any loop variable a shorter less expressive values such a ""x"" can be used (e.g. by more expert users). 
The operator applies the action code expressionStr to each list item in turn. The result of expression on loopVar is returned as List-type data. The operator always returns a list of all the results, i.e. the size of the input and output lists are the same. By comparison, this may not be the case with the similar list.collect_if() operator.
If $MyList is ""1;2;3;4;5"", anItem, is 1, then 2, etc. For example:
	 $MyListA = $MyList.collect(anItem,anItem+1); returns 2;3;4;5;6
	 $MyListA = $MyList.collect(anItem, anItem* anItem); returns 1;4;9;16;25
If $MyList is ""Winken;Blinken;Nod"", then:
	$MyListA = $MyList.collect(anItem, anItem.lowercase); returns ""winken;blinken;nod""
list.collect() vs. collect()
Although the two appear similar. This operator works directly on the source list values, whereas collect() creates a list of $Path values and returns on an attribute value from each of those paths.","list.collect(loopVar, expression)
List型またはSet型のリスト内の各項目が順番にloopVarに代入（バインド）され、expression（式）が評価されます。
loopVarは、基本的にはList.each()演算子で使用されるループ変数と同じものです。以下の例では、分かりやすくするためにloopVarに「anItem」という変数名を使用していますが、通常のループ変数と同様に「x」のような短く簡素な名前を使用することも可能です（主に熟練したユーザーなど）。
この演算子は、リストの各項目に対してアクションコードのexpressionを順次適用します。loopVarに対するexpressionの評価結果は、List型のデータとして返されます。この演算子は常にすべての評価結果のリストを返すため、入力リストと出力リストのサイズ（項目数）は常に一致します。これに対し、類似の演算子であるlist.collect_if()では、サイズが一致しない場合があります。
$MyListが""1;2;3;4;5""の場合、anItemはまず1になり、次に2、...となります。例：
	 $MyListA = $MyList.collect(anItem,anItem+1); // 2;3;4;5;6 を返す
	 $MyListA = $MyList.collect(anItem, anItem* anItem); // 1;4;9;16;25 を返す
$MyListが""Winken;Blinken;Nod""の場合：
	$MyListA = $MyList.collect(anItem, anItem.lowercase); // ""winken;blinken;nod"" を返す
list.collect() と collect() の違い
これら2つは似ているように見えますが、list.collect()演算子がソースリストの値を直接操作するのに対し、collect()演算子は$Path値のリストを作成し、それぞれのパスに対応するノートの属性値を返します。"
list.contains(matchStr),Function,Item,Query Boolean,boolean test,false,5.7.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.contains(matchStr)
This operator tests whether the string matchStr matches a whole discrete value string within a the referenced  List- or Set-type list value. Unlike when used with a String, e.g. String.contains, there is no regex functionality. With lists the function behaves as if the chained list were being iterated and an equality (==) test was being run on each list item.
Matches are always case-sensitive, unlike list.icontains() where the matches are always case-sensitive.
Used with a list (List or Set data types), .contains() cannot match to granularity less than a single whole item in the chained list. Importantly, this differs from the operator's use with String data, e.g. String.contains(), where regular expression matching is applied. If regex parsing is needed, e.g. to match a partial list value, coerce the list to a string and use to operator on that string—see below.
A match gives a numerical result which is the 1-based matched list position. That number coerces to the boolean result needed for use in queries: ) to false and 1 or more to true.
matchStr is one of:
* an action code expression (which includes just referencing a single attribute name)
* a quoted literal string (i.e. actual text). Important: do not omit the enclosing quotes. If omitted, Tinderbox will try to evaluate the string as an expression. Doing this may result in the expected result but this is actually a false positive. So, remember to enclose your literals in quotes.
$MyList.contains(matchStr)
The contains operator may also be used with both sets and lists, in which case it tests for set membership, i.e. matching to complete individual values rather than part of values. Thus:
	$MyList.contains(""Tuesday"") 
	$MyList(parent).contains(""Tuesday"") 
are both true if $MyList contains ""Monday;Tuesday;Friday"". A match can use an attribute value as the matchStr. Consider a single-value String-type attribute 'MyDay':
	$MyList.contains($MyDay) 
is true if the value of $MyDay for a given note is any of ""Monday"", ""Tuesday or ""Friday"". Thus in an agent or find query, the regex varies by the source value in the currently-tested note.
The chained list may also be a literal list:
	""Saturday;Sunday"".contains(""Sunday"") 
	""Saturday;Sunday"".contains($MyDay) 
If the matchStr is found the function returns a number which is the 1-based matched list position. In the last example above the returned value will be 2, because 'Sunday' is the second item in the list. 
Testing a negative: ""does not contain""
Use a ! prefix to the query argument:
	!$MyList.contains(""Tuesday"") 
Use of parentheses around the negated query term, can assist Tinderbox's parsing:
	(!$MyList.contains(""Tuesday"")) 
Matching partial list values
As changing to list suppresses the normal string regex parsing, interposing the .asString() operator allows the list to be treats a a string so as to behave like a String.contains() test. See the .asString() operator listing for more detail. This is a more elegant replacement for the old workaround of using List.format(""#"").icontains(""some match) as may be seen in some older code samples.","list.contains(matchStr)
この演算子は、指定された「matchStr」が、参照されているList型またはSet型のリスト値内の個別の離散値全体と一致するかどうかをテストします。String.containsなどの文字列で使用する場合とは異なり、正規表現機能はありません。リストで使用する場合、この関数は、連結されたリストが反復処理され、各リスト項目に対して等価（==）テストが実行されているかのように動作します。

一致は常に大文字と小文字を区別します。一致において大文字と小文字を区別しないlist.icontains()とは対照的です。

リスト（List型またはSet型）で使用する場合、.contains()は、連結されたリスト内の単一の項目全体より小さい単位で一致させることはできません。重要な点として、これはString.contains()などの正規表現マッチングが適用される文字列データでの演算子の使用法とは異なります。部分的なリスト値に一致させるために正規表現の解析が必要な場合は、リストを文字列に強制変換し、その文字列に対して演算子を使用してください（詳細は後述）。

一致した場合、一致したリストの位置を1から始まる数値で返します。その数値は、クエリで使用するために必要なブール結果に強制変換されます。0はfalseに、1以上はtrueになります。

matchStrは以下のいずれかです：
* アクションコード式（単一の属性名の参照を含む）
* 引用符で囲まれたリテラル文字列（実際のテキスト）。重要：囲み引用符を省略しないでください。省略すると、Tinderboxは文字列を式として評価しようとします。これにより期待通りの結果が得られることもありますが、実際には偽陽性です。そのため、リテラルは必ず引用符で囲むようにしてください。

$MyList.contains(matchStr)
contains演算子はSet型とList型の両方で使用でき、その場合はセットのメンバーシップ、つまり値の一部ではなく、完全な個々の値との一致をテストします。したがって：
	$MyList.contains(""Tuesday"")
	$MyList(parent).contains(""Tuesday"")
これらは、$MyListに ""Monday;Tuesday;Friday"" が含まれている場合にtrueとなります。一致には、matchStrとして属性値を使用できます。単一値のString型属性「MyDay」を考えてみましょう：
	$MyList.contains($MyDay)
これは、特定のノートの$MyDayの値が ""Monday""、""Tuesday""、""Friday"" のいずれかである場合にtrueとなります。したがって、エージェントや検索クエリでは、現在テストされているノートのソース値によって正規表現が変化します。

連結されたリストはリテラルリストにすることもできます：
	""Saturday;Sunday"".contains(""Sunday"")
	""Saturday;Sunday"".contains($MyDay)
matchStrが見つかった場合、関数は一致したリストの位置を1から始まる数値で返します。上の最後の例では、'Sunday'はリストの2番目の項目であるため、返される値は2になります。

否定のテスト：「含まない」
クエリ引数に接頭辞 ! を使用します：
	!$MyList.contains(""Tuesday"")
否定されたクエリ語を括弧で囲むと、Tinderboxの解析を助けることができます：
	(!$MyList.contains(""Tuesday""))

部分的なリスト値の一致
リストに変更すると通常の文字列正規表現の解析が抑制されるため、.asString()演算子を介在させることで、リストを文字列として扱い、String.contains()テストのように動作させることができます。詳細については、.asString()演算子のリストを参照してください。これは、古いコードサンプルで見られるようなList.format(""#"").icontains(""some match"")を使用するという古い回避策に代わる、より洗練された方法です。"
list.containsAnyOf(regexList),Function,Item,Query Boolean,boolean test,false,8.8.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"list.containsAnyOf(regexList)
The operator .containsAnyOf(regexList) is true if any of the words in a set of words (i.e. a List- or Set-type list) is contained in the chained-to target string. As shown below, the list may have many or only one entry. The test is case-sensitive (previously it was case-insensitive). For example:
	$MyBoolean = $MyList.containsAnyOf(""emulate""); 
Will be true if the tested note's $Text contains the word ""emulate""; unlike with .contains() or .icontains() a partial value may be matched in the target list. If $MyList holds the values 'emulate', 'mimic' and 'simulate', the list is tested as if a literal string, i.e. with the semi-colon delimiters present:
	$MyBoolean = ""emulate;mimic;simulate"".containsAnyOf(""emulate""); 
A more applied example:
	$MyBoolean = $MyList.containsAnyOf(wordsRelatedTo(""emulate"")); 
Will be true if the tested note's $MyList contains the word ""emulate"".
regexList implies using a list of values (ideally with no dupes). This can be a literal list of 1 or more values—as in the example above, or an attribute reference holding a list of values, for instance:
	$MyBoolean = $MyList.containsAnyOf($MySet); 
It is important to note that .containsAnyOf() is always a case-sensitive test. Thus in the first example above, it will match ""emulate"" but not ""Emulate"" or any other case variant of the word.
Although the examples above use whole words the list in regexList is actually processed assuming they are regular expressions (which may of course be literal strings). Thus in the first example above, it will match both ""emulate"" and ""emulated"" but not ""emulating"". The test value ""emulate\b"", expecting a word break after the final 'e' would this match ""emulate"" but not ""emulated"".
For a case-insensitive version if this operator see list.icontainsAnyOf().
Note the slightly different behaviour from that when chaining a String.","list.containsAnyOf(regexList)
演算子 .containsAnyOf(regexList) は、単語のセット（リスト型またはセット型のリスト）に含まれるいずれかの単語が、チェーンされたターゲット文字列に含まれている場合に true を返します。以下に示すように、リストには多くのエントリが含まれる場合も、1つだけの場合もあります。このテストは大文字と小文字を区別します（以前は区別されませんでした）。例えば：
	$MyBoolean = $MyList.containsAnyOf(""emulate""); 
これは、テスト対象のノートの $Text に ""emulate"" という単語が含まれている場合に true となります。.contains() や .icontains() とは異なり、ターゲットリスト内で部分一致が認められる場合があります。$MyList が 'emulate'、'mimic'、'simulate' という値を保持している場合、リストはセミコロンの区切り文字が含まれた状態のリテラル文字列としてテストされます。
	$MyBoolean = ""emulate;mimic;simulate"".containsAnyOf(""emulate""); 
より応用的な例：
	$MyBoolean = $MyList.containsAnyOf(wordsRelatedTo(""emulate"")); 
テスト対象のノートの $MyList に ""emulate"" という単語が含まれている場合に true となります。
regexList は、値のリスト（重複がないことが理想的）を使用することを意味します。これは、上記の例のような1つ以上の値のリテラルリスト、または属性参照（リスト値を保持するもの）のいずれかになります。例えば：
	$MyBoolean = $MyList.containsAnyOf($MySet); 
.containsAnyOf() は常に大文字と小文字を区別するテストであることに注意が必要です。したがって、最初の例では ""emulate"" には一致しますが、""Emulate"" やその他の大文字小文字のバリエーションには一致しません。
上記の例では完全な単語を使用していますが、regexList のリストは実際には正規表現（もちろんリテラル文字列である場合もあります）として処理されます。したがって、最初の例では ""emulate"" と ""emulated"" の両方に一致しますが、""emulating"" には一致しません。末尾の 'e' の後に単語の区切り（word break）を期待するテスト値 ""emulate\b"" は、""emulate"" には一致しますが、""emulated"" には一致しません。
この演算子の大文字小文字を区別しないバージョンについては、list.icontainsAnyOf() を参照してください。
String（文字列）にチェーンする場合とは動作がわずかに異なることに注意してください。"
"list.count_if(loopVar, condition)",Function,Group,Data manipulation,Number,false,9.5.0,Baseline,,,,,true,false,false,true,false,false,true,false,false,,false,"list.count_if(loopVar, condition)
The dot-operator .count_if() counts the members of a List- or Set-type list that satisfy a condition. Each item in the list is bound in turn to loopVar, and if condition is met, then that item is added to the returned count.
loopVar is essentially the same as the loop variable used by the List.each() operator. In the examples below, for clarity the loopVar value ""anItem"" is used, but as with any loop variable a shorter less expressive values such a ""x"" can be used (e.g. by more expert users).
The condition argument is a conditional expression for which each tested item must return true or false.
For example if $MyList is ""1;2;3;4;5"", then:
	$MyListA =- $MyList.count_if(anItem, anItem>3) 
returns 2, being the number of items in $MyList whose value is greater than 3. If $MyList is ""1;1;2;2;3;3;4;4;5;5"", then:
	$MyListA =- $MyList.count_if(anItem, anItem>3) 
returns 4, being the number of items in $MyList whose value is greater than 3 and values '4' and '5' each occur twice.
list.count_if() vs. .count_if()
Although the two appear similar. This operator works directly on the source list values, whereas count_if() creates a list of $Path values and returns on an attribute value from each of those paths (where the item at the $Path meets the condition).","list.count_if(loopVar, condition)
ドット演算子 .count_if() は、List型またはSet型のリストの中で、条件を満たすメンバーの数をカウントします。リスト内の各項目は順番に loopVar にバインドされ、condition（条件）が満たされた場合、その項目が返されるカウントに加算されます。
loopVar は、本質的に List.each() 演算子で使用されるループ変数と同じです。以下の例では、わかりやすくするために loopVar の値として ""anItem"" を使用していますが、他のループ変数と同様に、""x"" のような短く表現力の低い値を使用することもできます（例：熟練したユーザーなど）。
condition 引数は、テストされる各項目が真 (true) または偽 (false) を返す必要がある条件式です。
例えば、$MyList が ""1;2;3;4;5"" の場合：
	$MyListA = $MyList.count_if(anItem, anItem>3) 
は 2 を返します。これは $MyList 内で値が 3 より大きい項目の数です。$MyList が ""1;1;2;2;3;3;4;4;5;5"" の場合：
	$MyListA = $MyList.count_if(anItem, anItem>3) 
は 4 を返します。これは $MyList 内で値が 3 より大きい項目の数であり、'4' と '5' という値がそれぞれ 2 回ずつ出現するためです。
list.count_if() vs. count_if()
この 2 つは似ているように見えますが、この演算子（.count_if()）はソースリストの値を直接操作するのに対し、count_if() はパス（$Path）値のリストを作成し、（その $Path にある項目が条件を満たす場合に）それらの各パスの属性値に基づいて評価を返します。"
list.count(),Property,List,Data manipulation,Number,false,7.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.count()
list.count
The property .count counts the Number of discrete items in the specified List- or Set-type list.
This is better used instead of count(list) or list.size.
The subject list is evaluated so can use a literal list or $attribute(note). It can also use more complex expressions to get data as long as the result is an attribute of the List or Set data type.
For example if $DisplayedAttributes for the current note is ""Color;AccentColor;NameFont"" then the code
	$MyNumber = $DisplayedAttributes.count; 
is effectively
	$MyNumber = (""Color;AccentColor;NameFont"").count; 
and not surprisingly returns 3. Note that the count is not all unique values for the attribute across the whole TBX; scope is restricted to 'this' note or another nominated note. Specimen usage:
	$MyNumber = $DisplayedAttributes.count; 
	$MyNumber = $DisplayedAttributes(""some other note"").count; 
To use .count with a list of items that are attributes or expressions, use list() to pre-create a list:
	Works: $MyNumber = list(4+2,9+6).count; (output: 2)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Examples
The following is a trivial example (given you could use $ChildCount instead) but shows how count can be used in a more subtle way:
	$MyNumber = collect(children,$Name).count; 
The result of collect() is a List, in this case a number of note titles. List.count will return the number of values in the list (including duplicates). To get a de-duped count, chain the .unique function before the .count:
	$MyNumber = collect(children,$Name).unique.count; 
Similarly, find() returns a List but note that find() does not de-dupe for aliases. Thus test $IsAlias in the query to weed alias results from the returned list:
	$MyNumber = find($Prototype==""pProject""&$IsAlias==false&$ChildCount>1).count;","list.count()
list.count
.countプロパティは、指定されたList型またはSet型のリストに含まれる個別の項目の数をカウントします。
これは、count(list)やlist.sizeの代わりに使用するのが適しています。
対象となるリストは評価されるため、リテラルリストや$attribute(note)を使用できます。また、結果がListまたはSetデータ型の属性である限り、データを取得するためにより複雑な式を使用することもできます。
例えば、現在のノートの$DisplayedAttributesが ""Color;AccentColor;NameFont"" である場合、以下のコード：
	$MyNumber = $DisplayedAttributes.count; 
は実質的に以下のようになり：
	$MyNumber = (""Color;AccentColor;NameFont"").count; 
結果として3を返します。このカウントは、TBX全体における属性の全ユニーク値の数ではないことに注意してください。スコープは「この」ノート、または指定された別のノートに限定されます。
使用例：
	$MyNumber = $DisplayedAttributes.count; 
	$MyNumber = $DisplayedAttributes(""some other note"").count; 
属性や式で構成される項目のリストに対して.countを使用するには、list()を使用してあらかじめリストを作成します：
	動作例: $MyNumber = list(4+2,9+6).count; （出力: 2）
リストの項目がアクションコードの式であるような、より複雑な例では、各リスト項目の式をeval()でラップする必要がある場合があります（例：list(eval(expressionA),eval(expressionB))）。
例
以下は（$ChildCountを代わりに使用できるため）些細な例ですが、countをより高度な方法で使用する方法を示しています：
	$MyNumber = collect(children,$Name).count; 
collect()の結果はListであり、この場合は一連のノートのタイトルになります。List.countはリスト内の値の数（重複を含む）を返します。重複を除いたカウントを取得するには、.countの前に.unique関数をチェインします：
	$MyNumber = collect(children,$Name).unique.count; 
同様に、find()はListを返しますが、find()はエイリアスを自動的に除外しないことに注意してください。そのため、返されたリストからエイリアスの結果を排除するには、クエリで$IsAliasをテストします：
	$MyNumber = find($Prototype==""pProject""&$IsAlias==false&$ChildCount>1).count;"
list.countOccurrencesOf(literalStr),Function,List,Data manipulation,Number,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.countOccurrencesOf(literalStr)
This function returns the Number of times that the literal string literalStr appears in the source List- or Set-type list. A string of the attribute's raw concatenated list values (i.e. with semicolon delimiters) is tested.
If $MyList contains ""ant;bee;ant;cow;ant"", then:
	$MyNumber = $MyList.countOccurrencesOf(""ant""); returns 3
Sets de-duplicate, but partial matches of Sets do not. If $MySet contains ""cat;cut;hat;hit;hut;pat;sat"", then
	$MyNumber = $MySet.countOccurrencesOf(""at""); returns 4
literalStr is literal and must not be a regular expression. If the latter is needed use list.contains() or list.icontains().","list.countOccurrencesOf(literalStr)
この関数は、元の List 型または Set 型のリスト内に、リテラル文字列 literalStr が出現する回数を数値で返します。属性の生の連結されたリスト値（つまり、セミコロンで区切られた文字列）が検索対象となります。
もし $MyList が ""ant;bee;ant;cow;ant"" を含んでいる場合：
	$MyNumber = $MyList.countOccurrencesOf(""ant""); は 3 を返します。
Set 型は重複を排除しますが、Set における部分一致は重複排除の対象にはなりません。もし $MySet が ""cat;cut;hat;hit;hut;pat;sat"" を含んでいる場合：
	$MyNumber = $MySet.countOccurrencesOf(""at""); は 4 を返します。
literalStr はリテラルであり、正規表現を使用することはできません。正規表現が必要な場合は、list.contains() または list.icontains() を使用してください。"
list.each(loopVar){actions},Function,Item,Data manipulation,iterator,false,5.10.0,Baseline,,,,1,true,true,false,true,false,false,false,false,false,,false,"list.each(loopVar){ action(s) }
This allows you to operate in turn on each item in a List- or Set-type list. Put another way you 'iterate;' or loop though, every item in the list evaluating any code inside the { } brackets. The user-defined (i..e. named by the user) loopVar can be used inside the loop to refer to the value of the current list item value being iterated. If the list is a list of path info (or $IDString, $ID, or unique $Name) then in-loop loopVar can be used for offset addressing the note at that path via an attribute offset argument, i.e. $SomeAttribute(loopVar).
What is a loop variable?
For example, for a note with a list of values in $MyList:
	$MyList.each(x){$Result=$Result +x+""\n"" ;} 
will replace the current note's value of $Result with a list of every value from $MyList, but each on its own line. The loopVar, here the in-loop variable 'x', is simply the string defined in .each(), and is case-sensitive and a '$' prefix is not required for in-loop references to the loop variable. For most Tinderbox users, a more readable/understandable version of the above is this:
	$MyList.each(aString){
		$Result=$Result +aString+""\n"" ;
	}
What has changed? Firstly, the loop has been broken out onto speaker lines and in-loop code indented. Tinderbox ignores line breaks and white space between operators and values so both the above seems the same to the parser. Secondly, the obfuscatory 'x' loopVar name has been changed to a more descriptive 'aString' based on the presumption that $Result is a String (it cannot be a Number because Number-type data cannot have line breaks within a single value) and, for the calling note, we are compiling a string the list $Result values. 
Thus .each(loopVar) would iterate using references to loopVar, and thus .each(Y) would iterate using references to 'Y', whilst .each(Abracadabra) would iterate using references to 'Abracadabra', and so forth. Consider making the loop variable something clear to both the user and to Tinderbox. In the trivial example above, 'x' seems pretty clear but might be misread by the users—in a mathematical context—as a multiplication symbol; Tinderbox will not be confused as it uses * for multiplication but consider how something like 'LoopVar' might be clearer. By the same token make sure the loop variable name does not clash with existing attribute names or attribute string values of the same name that might be used as part of the data being processed.
A variable declared using var() may be altered from within the scope of an .each() loop.
If $Total is a numeric attribute and $MyList is a list of numbers:
	$TotalNumber=0;
	$MyList.each(aNumber){
		$TotalNumber += aNumber*aNumber; // parentheses not required but can be useful if calculation is not simple
	} 
computes the sum of the squares of the values in $MyList and stored it in $TotalNumber. As the list is a list of numbers, the user-chosen loopVar name used is 'aNumber'.
Note: remember that you, the user, choose the actual name of loopVar in your own code. It can vary per use, as in the examples on this page.
The loopVar can be a path and this can be used as a variable designator for attribute offset addressing inside the loop:
	$Text="""";
	collect(children,$Path).each(aPath){ 
		$Text += ""\n""+$Text(aPath);
	}
In the above, a list is created on the fly of the current note's children. Then the current note's $Text is appended, for each child, with a line and the child's $Text. As the list is a list of paths, the user-chosen loopVar name used is 'aPath'. Thus for each iteration of the loop aPath's value is being used to provide the offset address in the loop to $Text(loopVar).
If it is desired to iterate a list a particular number of times, another approach to the above is to use the range '...' operator which can be used to provide a numbered loop variable (see).
After each iteration of an each(){} loop, accumulated back-references are cleared. Formerly, back-references from each iteration were retained for the lifetime of the loop, making it very difficult to retrieve the desired reference.
To test for position in a loop, i.e. detecting if processing the first or last items, see list.first() and list.last().
To get a random item from a list without needing to use a loop, see list.randomItem().
A worked example of looping is here.
Examples of using action() within a loop to create attribute references is given here.","list.each(loopVar){ action(s) }
これを使用すると、List型またはSet型のリストの各項目を順番に処理できます。言い換えれば、リスト内のすべての項目を「反復（イテレート）」またはループし、{ } ブラケット内のコードを評価します。ユーザーが定義した（つまりユーザーが名前を付けた）loopVarは、ループ内で現在処理されているリスト項目の値を参照するために使用できます。リストがパス情報（または $IDString、$ID、あるいは一意の $Name）のリストである場合、ループ内の loopVar を属性オフセット引数として使用し、そのパスにあるノートをオフセット指定して参照できます（例：$SomeAttribute(loopVar)）。

ループ変数とは何ですか？
例えば、$MyList に値のリストを持つノートの場合：
	$MyList.each(x){$Result=$Result +x+""\n"" ;}
は、現在のノートの $Result の値を、$MyList のすべての値を各行に分けたリストに置き換えます。ここでのループ内変数 'x' である loopVar は、.each() で定義された単なる文字列であり、大文字と小文字を区別します。また、ループ内でのループ変数の参照に '$' プレフィックスは必要ありません。ほとんどの Tinderbox ユーザーにとって、上記をより読みやすく理解しやすい形にすると次のようになります：
	$MyList.each(aString){
		$Result=$Result +aString+""\n"" ;
	}
何が変わったのでしょうか？まず、ループが複数行に分割され、ループ内のコードがインデントされました。Tinderbox は演算子と値の間の改行や空白を無視するため、パーサーにとっては上記のどちらも同じに見えます。次に、分かりにくい 'x' という loopVar 名が、より説明的な 'aString' に変更されました。これは、$Result が String 型であるという前提に基づいています（Number 型のデータは単一の値の中に改行を含めることができないためです）。そして、呼び出し元のノートに対して、$Result の値のリストを文字列として組み立てています。

したがって、.each(loopVar) は loopVar への参照を使用して反復し、.each(Y) は 'Y' への参照を使用して反復し、.each(Abracadabra) は 'Abracadabra' への参照を使用して反復する、といった具合です。ループ変数は、ユーザーにとっても Tinderbox にとっても明確なものにすることを検討してください。上記の単純な例では 'x' は十分に明確に見えますが、数学的な文脈ではユーザーに「乗算記号」と誤読される可能性があります。Tinderbox は乗算に * を使用するため混乱しませんが、'LoopVar' のような名前の方がより明確になる可能性があることを考慮してください。同様に、ループ変数名が、処理されるデータの一部として使用される可能性のある既存の属性名や同じ名前の属性文字列値と衝突しないように注意してください。

var() を使用して宣言された変数は、.each() ループのスコープ内から変更できます。
$Total が数値属性で、$MyList が数値のリストである場合：
	$TotalNumber=0;
	$MyList.each(aNumber){
		$TotalNumber += aNumber*aNumber; // 計算が単純でない場合は括弧が役立ちますが、必須ではありません
	}
は $MyList 内の数値の平方の和を計算し、それを $TotalNumber に格納します。リストが数値のリストであるため、ユーザーが選択した loopVar 名は 'aNumber' になっています。
注：ループ内の loopVar の実際の名前は、ユーザー自身がコード内で選択することを忘れないでください。このページの例にあるように、使用箇所ごとに変えることができます。

loopVar はパスにすることもでき、これをループ内での属性オフセット指定のための変数指定子として使用できます：
	$Text="""";
	collect(children,$Path).each(aPath){ 
		$Text += ""\n""+$Text(aPath);
	}
上記では、現在のノートの子のリストが動的に作成されます。その後、各子について、現在のノートの $Text に改行とその子の $Text が追加されます。リストがパスのリストであるため、ユーザーが選択した loopVar 名は 'aPath' になっています。このように、ループの各反復において、aPath の値が $Text(loopVar) のオフセットアドレスを指定するために使用されています。

リストを特定の回数だけ反復させたい場合は、上記とは別のアプローチとして、番号付きのループ変数を提供できる範囲演算子 '...' を使用する方法があります（参照）。

each(){} ループの各反復の後、蓄積された後方参照（back-references）はクリアされます。以前は、各反復からの後方参照がループの存続期間中保持されていたため、目的の参照を取得することが非常に困難でした。

ループ内での位置をテストする（最初または最後の項目を処理しているかどうかを検出する）には、list.first() および list.last() を参照してください。
ループを使用せずにリストからランダムな項目を取得するには、list.randomItem() を参照してください。
ループの具体的な実例はこちらにあります。
ループ内で action() を使用して属性参照を作成する例については、こちらで説明しています。"
list.empty(),Property,Item,Non-query Boolean,boolean test,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.empty()
list.empty
This returns a Boolean depending on whether the List- or Set-type list is empty. If empty, the return value is true, if the attribute has content then false is returned.
	$MyList = [hello;world]; $MyBoolean = $MyList.empty; 
$MyBoolean is set to false as content is found. But
	$MyList = []; $MyBoolean = $MyList.empty; 
$MyBoolean is set to true as no content is found.","list.empty()
list.empty
List型またはSet型のリストが空かどうかに応じて、真偽値を返します。リストが空の場合はtrueを返し、属性に内容がある場合はfalseを返します。
	$MyList = [hello;world]; $MyBoolean = $MyList.empty; 
内容があるため、$MyBooleanはfalseに設定されます。しかし、
	$MyList = []; $MyBoolean = $MyList.empty; 
内容がないため、$MyBooleanはtrueに設定されます。"
"list.every(loopVar, expressionStr)",Function,List,Query Boolean,boolean test,false,8.1.0,Baseline,,,,2,true,true,false,true,false,false,false,false,false,,false,"list.every(loopVar, expressionStr)
This is true if every loopVar in the List- or Set-type list meets the query in expressionStr. Thus:
	$MyList.every(x,x>5) 
is true if every loopVar in $MyList is greater than 5.
The comparison may also be applied to literal lists:
	""apple; pear; plum"".every(x, x>""aardvark"") 
is true because every element follows ""aardvark"" in alphabetical (lexical sort) order.
If the target list or set is empty, .any() always returns false, and .every() always returns true.
The loopVar is a user-set case-sensitive string. ""x"", ""anItem"", etc., are equally applicable. Similar to a loop variable in .each(x){}, the point of the loopVar value, is to set a reference variable for each list element. This can then be used in the code provided by the expressionStr argument. Using a number for loopVar, e.g. '1' or '42' is not recommended. Choose a value that makes sense for your own style of work  
The expressionStr is any action code expression that is a test resolving to a Boolean true/false answer (i.e. a query). For example, to test if every item exactly matches the value stored in the $MyString of 'Some note':
	$MyBoolean = $MyList.every(anItem, anItem == $MyString(""Some Note"")); 
Or, every list value starts with the string 'Large':
	$MyBoolean = $MyList.every(Z, Z.contains(""^Large""));","list.every(loopVar, expressionStr)
List型またはSet型のリスト内のすべてのloopVarが、expressionStrのクエリを満たす場合に真（true）となります。したがって：
	$MyList.every(x,x>5)
は、$MyList内のすべてのloopVarが5より大きい場合に真となります。
この比較はリテラルなリストにも適用できます：
	""apple; pear; plum"".every(x, x>""aardvark"")
は、すべての要素がアルファベット順（辞書順）で""aardvark""より後にあるため、真となります。
対象のリストまたはセットが空の場合、.any()は常に偽（false）を返し、.every()は常に真（true）を返します。
loopVarは、ユーザーが設定する大文字小文字を区別する文字列です。""x""や""anItem""などが同様に使用できます。.each(x){}におけるループ変数と同様に、loopVarの値の目的は、各リスト要素の参照変数を設定することです。これはexpressionStr引数で指定されたコード内で使用できます。loopVarに '1' や '42' などの数値を使用することは推奨されません。自身の作業スタイルに合った値を選択してください。
expressionStrは、真/偽（true/false）の論理値（すなわちクエリ）として解決されるテストである任意のアクションコード式です。例えば、すべての項目が 'Some note' というノートの $MyString に格納された値と完全に一致するかどうかをテストする場合：
	$MyBoolean = $MyList.every(anItem, anItem == $MyString(""Some Note""));
あるいは、すべてのリスト値が文字列 'Large' で始まるかどうかをテストする場合：
	$MyBoolean = $MyList.every(Z, Z.contains(""^Large""));"
list.extend(aList),Function,List,Data manipulation,List,false,9.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.extend(aList)
for a List- or Set-type list, a nested list item is inserted as a new item at the end of the returned List. If passed back into a List, the order is maintained. If passed to a Set, the order of values may change.
The += increment operator, if passed a list as an argument, adds the arguments values to the existing list. By comparison, in the same scenario, list.extend() inserts the argument value as a nested list.
Long Tinderbox precedent holds that list addition adds each element of the two lists. For example
	$MyList = [1] + [2;3] 
resulst in the list 1;2;3 and not 1;[2;3]. So, to add a sublist to a list, use the list.extend() operator. Thus:
	$MyList = [1].extend( [2;3])  
results in the list [1;[2;3]].","list.extend(aList)
List型またはSet型のリストにおいて、入れ子になったリスト項目が、返されるリストの末尾に新しい項目として挿入されます。List型に返される場合、順序は維持されます。Set型に渡される場合、値の順序が変わることがあります。
+= 演算子にリストを引数として渡すと、その引数の各値が既存のリストに追加されます。それに対し、同じ状況で list.extend() は引数の値を入れ子になったリストとして挿入します。
Tinderboxの長年の慣例では、リストの加算は2つのリストの各要素を結合します。例えば、
	$MyList = [1] + [2;3] 
の結果はリスト 1;2;3 となり、1;[2;3] にはなりません。そのため、リストにサブリストを追加するには、list.extend() 演算子を使用します。したがって、
	$MyList = [1].extend( [2;3]) 
の結果はリスト [1;[2;3]] となります。"
list.first(),Property,List,"Dictionary, Set & List operations",source context dependent,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.first()
list.first
Returns the first item of a List- or Set-type list. If MyList is a 5-item list ""ant;bee;cow;dog;eel"":
	$MyString = $MyList.first; returns ""ant""
This is also the equivalent of $MyList[0] or $MyList.at(0).
list.first(N)
Returns a list of the first N items of a list. With the same list as above:
	$MyList2 = $MyList.first(2); returns ""ant;bee""
Testing for loop position
This operator can be used to test the current loop state, i.e. whether the currently processed item is the first in the list. Here the code in the commented section is run only when the first list item in $MyList is being processed:
	$MyList.each(anItem){
		if(anItem==$MyList.first){
			// some code here ...
		};
	};
Note that '$MyList.first' is not a test in itself. Rather, it supplies the value of the first list item which can be tested against the currently processed item.
See also list.last.","list.first()
list.first
List型またはSet型リストの最初の項目を返します。MyListが ""ant;bee;cow;dog;eel"" という5つの項目を持つリストの場合：
	$MyString = $MyList.first; は ""ant"" を返します。
これは $MyList[0] または $MyList.at(0) と同等です。

list.first(N)
リストの最初のN個の項目を含むリストを返します。上記のリストの例では：
	$MyList2 = $MyList.first(2); は ""ant;bee"" を返します。

ループ位置の判定
この演算子は、現在のループの状態、つまり現在処理されている項目がリストの最初のものであるかどうかを判定するために使用できます。以下の例では、コメント部分のコードは $MyList の最初の項目が処理されているときのみ実行されます：
	$MyList.each(anItem){
		if(anItem==$MyList.first){
			// ここに何らかのコード ...
		};
	};
「$MyList.first」自体はテスト（条件式）ではないことに注意してください。これはリストの最初の項目の値を返すものであり、その値を現在処理中の項目と比較することで判定を行います。

参照：list.last"
list.format(formatStr),Function,Item,Formatting,String,false,5.8.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.format(formatStr)
For a List- or Set-type list, returns the list as a String, with formatStr inserted between each discrete list element (so not after the last item. The process preserves original data; duplicate values in lists are maintained. For example:
	$MyString = $DisplayedAttributes.format("", ""); 
converts Displayed Attributes to a comma+space-separated list. To put each item on a separate line use this:
	$MyString = $DisplayedAttributes.format(""\n""); 
Doing the same for HTML export, you might want the rendered text to have each value on a new line so use: 
	$MyString = $DisplayedAttributes.format(""&lt;br>""); 
Thus $Text may be created from concatenation of other texts:
	$Text = (collect(children, $Text)).format(""\n""); 
Optionally, you may supply four arguments to format the list or set as an HTML list:
	$MyString = list.format(""listPrefix"",""itemPrefix"",""itemSuffix"",""listSuffix""); 
For example:
	$MyString = $Classes.format(""&lt;ul>"",""&lt;li>"",""&lt;/li>"",""&lt;/ul>""); 
will return HTML code for a bulleted list with each set member marked up as a list item. Note that the tags must be in double quotes. To have each element on a separate line and indent the items add tabs and line breaks:
	$MyString = $Classes.format(""&lt;ul>\n"",""\t&lt;li>"",""&lt;/li>\n"",""&lt;/ul>\n""); 
To make this easier to use in a code export context, you might pass the output of format into another attribute and call the latter within the template with a value() code. By a repeated use of format it is possible to export lists of links.
Other form of list-to-string join
In some data export contexts, tit may be necessary to add a join string while generating a string from an iterated list. See adding joins in loops.
Similar functions
This supplements the existing format() function.","list.format(formatStr)
List型またはSet型のリストに対して、各要素の間に指定した文字列（formatStr）を挿入した単一のStringを返します。この区切り文字は最後の項目の後には挿入されません。この処理では元のデータは保持され、リスト内の重複値も維持されます。例えば：
	$MyString = $DisplayedAttributes.format("", ""); 
これはDisplayedAttributesをカンマとスペースで区切られたリストに変換します。各項目を個別の行に配置するには次のようにします：
	$MyString = $DisplayedAttributes.format(""\n""); 
HTMLエクスポートで同様のことを行い、レンダリングされたテキストの各値を改行したい場合は次のようにします：
	$MyString = $DisplayedAttributes.format(""&lt;br>""); 
また、他のテキストを連結して$Textを作成することもできます：
	$Text = (collect(children, $Text)).format(""\n""); 
オプションとして、リストまたはセットをHTMLリストとしてフォーマットするために4つの引数を指定することもできます：
	$MyString = list.format(""listPrefix"",""itemPrefix"",""itemSuffix"",""listSuffix""); 
例えば：
	$MyString = $Classes.format(""&lt;ul>"",""&lt;li>"",""&lt;/li>"",""&lt;/ul>""); 
は、各セットのメンバーをリストアイテムとしてマークアップした箇条書きのHTMLコードを返します。タグはダブルクォーテーションで囲む必要があることに注意してください。各要素を個別の行にし、項目をインデックス（字下げ）するには、タブと改行を追加します：
	$MyString = $Classes.format(""&lt;ul>\n"",""\t&lt;li>"",""&lt;/li>\n"",""&lt;/ul>\n""); 
コードエクスポートのコンテキストでこれを使いやすくするために、formatの出力を別の属性に渡し、テンプレート内でvalue()コードを使用してその属性を呼び出すことも可能です。formatを繰り返し使用することで、リンクのリストをエクスポートすることもできます。

その他のリストから文字列への結合形式
データエクスポートのコンテキストによっては、反復リストから文字列を生成する際に結合文字列を追加する必要がある場合があります。「ループ内での結合の追加（adding joins in loops）」を参照してください。

類似の関数
これは既存のformat()関数を補完するものです。"
list.icontains(matchStr),Function,Item,Query Boolean,boolean test,false,5.7.1,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"list.icontains(matchStr)
This operator tests whether the string matchStr matches a whole discrete value string within  the referenced List- or Set-type list. Unlike when used with a String, e.g. String.contains, there is no regex functionality. With lists the function behaves as if the chained list were being iterated and an equality (==) test was being run on each list item.
Matches are always case-insensitive, unlike list.contains() where the matches are always case-sensitive.
Used with a list (List or Set data types), .icontains() cannot match to granularity less than a single whole item in the chained list. Importantly, this differs from the operator's use with String data, e.g. String.icontains(), where regular expression matching is applied. If regex parsing is needed, e.g. to match a partial list value, coerce the list to a string and use to operator on that string—see below.
A match gives a numerical result which is the 1-based matched list position. That number coerces to the boolean result needed for use in queries: ) to false and 1 or more to true.
matchStr is one of:
* an action code expression (which includes just referencing a single attribute name')
* a quoted literal string (i.e. actual text). Important: do not omit the enclosing quotes. If omitted, Tinderbox will try to evaluate the string as an expression. Doing this may result in the expected result but this is actually a false positive. So, remember to enclose your literals in quotes.
N.B. Unlike with String-type attributes, regex cannot be used.
$MyList.icontains(matchStr)
The contains operator may also be used with both sets and lists, in which case it tests for set membership, i.e. matching to complete individual values rather than part of values. Thus:
	$MyList.icontains(""Tuesday"") 
	$MyList(parent).icontains(""Tuesday"") 
are both true if $MyList contains ""Monday;Tuesday;Friday"". A match can use an attribute value as the regexStr. Consider a single-value String-type attribute 'MyDay':
	$MyList.icontains($MyDay) 
is true if the value of $MyDay for a given note is any of ""Monday"", ""Tuesday or ""Friday"". Thus in an agent or find query, the regex varies by the source value in the currently-tested note.
The chained list may also be a literal list:
	""Saturday;Sunday"".icontains(""Sunday"") 
	""Saturday;Sunday"".icontains($MyDay) 
If the matchStr is found the function returns a number which is the 1-based matched list position. In the last example above the returned value will be 2, because 'Sunday' is the second item in the list. 
Testing a negative: ""does not contain""
Use a ! prefix to the query argument:
	!$MyList.icontains(""Tuesday"") 
Use of parentheses around the negated query term, can assist Tinderbox's parsing:
	(!$MyList.icontains(""Tuesday"")) 
Matching partial list values
As changing to list suppresses the normal string regex parsing, interposing the .asString() operator allows the list to be treats a a string so as to behave like a String.icontains() test. See the .asString() operator listing for more detail. This is a more elegant replacement for the old workaround of using List.format(""#"").icontains(""some match) as may be seen in some older code samples.","list.icontains(matchStr)
このオペレーターは、参照された List 型または Set 型のリスト内に、文字列 matchStr が 1 つの独立した値として含まれているかどうかをテストします。String 型で使用する場合（例：String.contains）とは異なり、正規表現は機能しません。リストで使用する場合、この関数は連鎖されたリストを反復処理し、各リスト項目に対して等価テスト（==）を実行しているかのように動作します。
一致判定は、常に大文字と小文字を区別しません。これは、常に大文字と小文字を区別する list.contains() とは異なります。
リスト（List または Set データ型）で使用する場合、.icontains() は連鎖されたリスト内の単一の完全な項目より小さい単位で一致させることはできません。重要な点として、これは正規表現マッチングが適用される String データでの使用（例：String.icontains()）とは異なります。部分的なリスト値に一致させるために正規表現の解析が必要な場合は、リストを文字列に変換し、その文字列に対してオペレーターを使用してください（後述）。
一致した場合、結果として 1 から始まる一致したリスト内の位置（数値）を返します。その数値は、クエリで使用される際にブール値の結果に強制変換されます。0 は false、1 以上は true とみなされます。
matchStr は以下のいずれかです：
* アクションコード式（単一の属性名の参照を含む）
* 引用符で囲まれたリテラル文字列（実際のテキスト）。重要：囲み引用符を省略しないでください。省略した場合、Tinderbox はその文字列を式として評価しようとします。これにより期待通りの結果が得られる場合もありますが、それは実際には偽陽性です。そのため、リテラルは必ず引用符で囲むようにしてください。
注意：String 型の属性とは異なり、正規表現は使用できません。
$MyList.icontains(matchStr)
contains オペレーターは Set と List の両方で使用でき、その場合はセットのメンバーシップ（値の一部ではなく、完全な個々の値との一致）をテストします。したがって：
	$MyList.icontains(""Tuesday"") 
	$MyList(parent).icontains(""Tuesday"") 
これらは、$MyList に ""Monday;Tuesday;Friday"" が含まれている場合、どちらも true になります。一致判定には、比較対象として属性値を使用できます。単一値の String 型属性 'MyDay' を例にとると：
	$MyList.icontains($MyDay) 
これは、あるノートの $MyDay の値が ""Monday""、""Tuesday""、""Friday"" のいずれかである場合に true になります。したがって、エージェントまたは検索クエリでは、現在テストされているノートの元の値によって一致対象が変化します。
連鎖されるリストは、リテラルリスト（直接記述されたリスト）でも構いません：
	""Saturday;Sunday"".icontains(""Sunday"") 
	""Saturday;Sunday"".icontains($MyDay) 
matchStr が見つかった場合、関数は 1 から始まる一致したリスト位置の数値を返します。上の最後の例では、'Sunday' はリストの 2 番目の項目であるため、返される値は 2 になります。
否定のテスト：「含まない」場合
クエリ引数の前に ! プレフィックスを使用します：
	!$MyList.icontains(""Tuesday"") 
否定されたクエリ項を括弧で囲むと、Tinderbox の解析を補助できる場合があります：
	(!$MyList.icontains(""Tuesday"")) 
部分的なリスト値との一致
リストに対して使用すると通常の文字列正規表現の解析が抑制されるため、間に .asString() オペレーターを挟むことで、リストを文字列として扱い、String.icontains() テストのように動作させることができます。詳細については .asString() オペレーターの項目を参照してください。これは、古いコードサンプルで見られるような List.format(""#"").icontains(""some match"") を使用する古い回避策に代わる、より洗練された方法です。"
list.icontainsAnyOf(regexList),Function,Item,Query Boolean,boolean test,false,8.9.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"list.icontainsAnyOf(regexList)
The operator .icontainsAnyOf(regexList) is true if any of the words in a List- or Set-type list of words is contained in the chained-to target string. As shown below, the list may have only one entry. The test is case-insensitive. For example:
	$MyBoolean = $MyList.containsAnyOf(""emulate""); 
Will be true if the tested note's $Text contains the word ""emulate""; unlike with .contains() or .icontains() a partial value may be matched in the target list. If $MyList holds the values 'emulate', 'mimic' and 'simulate', the list is tested as if a literal string, i.e. with the semi-colon delimiters present:
	$MyBoolean = ""emulate;mimic;simulate"".icontainsAnyOf(""emulate""); 
A more applied example:
	$MyBoolean = $MyList.icontainsAnyOf(wordsRelatedTo(""emulate"")); 
Will be true if the tested note's $MyList contains the word ""emulate"".
regexList implies using a list of values (ideally with no dupes). This can be a literal list of 1 or more values—as in the example above, or an attribute reference holding a list of values, for instance:
	$MyBoolean = $MyList.containsAnyOf($MySet); 
It is important to note that .containsAnyOf() is always a case-insensitive test. Thus in the first example above, it will match both ""emulate"" and ""Emulate"" or any other case variant of the word.
Although the examples above use whole words the list in regexList is actually processed assuming they are regular expressions (which may of course be literal strings). Thus in the first example above, it will match both ""emulate"" and ""emulated"" but not ""emulating"". The test value ""emulate\b"", expecting a word break after the final 'e' would this match ""emulate"" but not ""emulated"".
For a case-sensitive version of this, see list.containsAnyOf().
Note the slightly different behaviour from that when chaining a String.","list.icontainsAnyOf(regexList)
演算子 .icontainsAnyOf(regexList) は、List型またはSet型のリスト内に、引数リスト（regexList）に含まれる語のいずれかが含まれている場合に true を返します。以下に示すように、リストのエントリは1つだけでも構いません。このテストは大文字小文字を区別しません。例：
	$MyBoolean = $MyList.icontainsAnyOf(""emulate""); 
テスト対象のノートの $Text（訳注：文脈上は $MyList と推測されます）に ""emulate"" という単語が含まれている場合に true となります。 .contains() や .icontains() とは異なり、ターゲットとなるリスト内で部分一致が認められます。 $MyList が 'emulate'、'mimic'、'simulate' という値を保持している場合、リストはセミコロン区切りのリテラル文字列であるかのようにテストされます：
	$MyBoolean = ""emulate;mimic;simulate"".icontainsAnyOf(""emulate""); 
より実用的な例：
	$MyBoolean = $MyList.icontainsAnyOf(wordsRelatedTo(""emulate"")); 
テスト対象のノートの $MyList に ""emulate"" に関連する語が含まれている場合に true となります。
regexList は（理想的には重複のない）値のリストを使用することを意味します。これは上記の例のように1つ以上の値のリテラルリストであることも、次のようにリスト値を保持する属性参照であることもあります：
	$MyBoolean = $MyList.icontainsAnyOf($MySet); 
.icontainsAnyOf() は常に大文字小文字を区別しないテストである点に注意してください。したがって、最初の例では ""emulate"" と ""Emulate""、あるいはその他の大文字小文字のバリエーションのいずれにも一致します。
上記の例では単語全体を使用していますが、regexList 内のリストは実際には正規表現（リテラル文字列の場合もあります）として処理されます。そのため、最初の例では ""emulate"" と ""emulated"" の両方に一致しますが、""emulating"" には一致しません。末尾の 'e' の後に単語の区切りを期待するテスト値 ""emulate\b"" は、 ""emulate"" には一致しますが ""emulated"" には一致しません。
大文字小文字を区別するバージョンについては、list.containsAnyOf() を参照してください。
String型にチェインする場合とは動作がわずかに異なることに注意してください。"
list.intersect(aSet),Function,List,Data manipulation,Set,false,5.10.2,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.intersect(aSet)
This calculates the intersection of two List- or Set-type lists, the chained list and the Set in the aSet argument. The .intersect() test is generally intended for use with Set-type data but will work with Lists, though the output result is always Set-type, even if then passed to be stored in a List:
	$MySet = $MySetA.intersect($MySetB); 
	$MySet = $MyList1.intersect($MyList2); 
The result is a Set of all items in both $MySetA and $MySetB, or in the second example in both $MyList1 and $MyList2. As the result is always a set, any source list items are de-duped in the output.
Non-intersect
No special code is needed to find items in one set but not the other:
	$MySetC = $MySetA - $MySetB; gives items only in $MySetA
	$MySetC = $MySetB - $MySetA; gives items only in $MySetB
Use with Lists
Subtracting a Set from a List results in only one instance of each Set item being removed. Subtracting a List from a List each instance of a value in the second list is removed so multiple source List entries may be removed.","list.intersect(aSet)
これは、チェーンされたリストと引数 aSet に渡されたセットという、2つのリスト型またはセット型リストの積集合を計算します。.intersect() は一般的にセット型データでの使用を目的としていますが、リストでも動作します。ただし、結果をリストに格納する場合であっても、出力結果は常にセット型になります。
	$MySet = $MySetA.intersect($MySetB); 
	$MySet = $MyList1.intersect($MyList2); 
結果は、$MySetA と $MySetB の両方、または2番目の例では $MyList1 と $MyList2 の両方に存在するすべての項目のセットとなります。結果は常にセットであるため、ソースリスト内の重複項目は出力時にデデュープ（重複排除）されます。

非積集合（差集合）
一方のセットには含まれるがもう一方には含まれない項目を見つけるのに、特別なコードは必要ありません。
	$MySetC = $MySetA - $MySetB; （$MySetA にのみ存在する項目を返します）
	$MySetC = $MySetB - $MySetA; （$MySetB にのみ存在する項目を返します）

リストでの使用
リストからセットを減算すると、セットの各項目につき1つのインスタンスのみが削除されます。リストからリストを減算すると、2番目のリストにある値のすべてのインスタンスが削除されるため、ソースリスト内の複数のエントリが削除される可能性があります。"
List.isort([attributeRef]),Function,Item,Data manipulation,List,false,5.0.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"List.isort([attributeRef])
List.isort()
For List-type list data, the basic form
	$MyList = $MyList.isort(); 
re-sorts the referenced list's values in lexical, case-insensitive order. This means sorting letters in alphabetical order ""a,b,c'"" with all upper case instances sorting after any lower case ones as in ""ant;Ant;bee;Bee;cow;Cow"". Lexical sort of numbers means '1,11,2' not 1,2,11' as might be expected.
Alternative sorts are a lexical case-sensitive List.sort(), and a numeric List.nsort() (the latter giving '1,2,11' not '1,11,2'). Or, if using $Name or $Path data, use the optional long from (below) and let the nominated attribute's data type set the form of sort, e.g. for date sorting, sort on a Date-type attribute.
The resulting sort order can be reversed overall by chaining the List.isort() and List.reverse() functions:
	$MyList = $MyList.isort().reverse(); 
List.sort(attributeRef)
Here the referenced List must be a list of note names or paths, i.e. a list of $Name data or $Path data (but not a mix of the two). If note names are not unique within the document, path values must be used to achieve correct sort. This is because the stipulated
The attributeRef argument is a $-prefixed attribute reference and indicates the attribute supplying the sorted value in each list item. As a result, this form of sort cannot be used with any other date type of list and cannot be applied to a literal list of values (as they have no attributes!), unlike the short un-argumented form above.
Thus, the sort order is based on the value of the stipulated attributeRef and that value is derived from the $Name or $Path of the list item being evaluated:	$MyList = $collect(children, $Name).isort($StartDate); 
	$MyList = $collect_if(find($Prototype==""pArticle""), $Fruit!="""",$Path).isort($Fruit); 
So, in the latter case, $MyList is a list of paths, but the paths are sorted in the order of each item's $Year value rather than the default $OutlineOrder of the source objects. Consider notes 'A', 'B', and 'C' in that existing on that $OutlineOrder. Without the sort, $MyList created above is the paths [/A;/B;/C]. If the notes' respective $Fruit values are ""Apple"",""apple"",""Pear"", then a $Year-based sort make the $MyList to be [/C;/A;/B] —whereas a normal .sort($Fruit) would result in [/A;/C;/B]. 
In this argument-based usage, the sort ordering is based on the data type of AttributeRef:
* Number-type: and Interval-type: numerical sort
* Date-type: sort on date (implied numerical)
* All other types lexical
But if attributeRef is Number-type, List.nsort() could be used instead.
With .isort() lexical sorts are always case-insensitive.
Legacy: Use of sorting with Set-type data
This operator does not apply to Set-type lists because, as from v9.0.0, Sets now auto-sort A–Z and cannot be (reliably) user-sorted to a different order. However, is passing the result to a List-type or to some other process—i.e. passing the sorted result, not the source Set—then sorted content is possible.","List.isort([attributeRef])
List.isort()

List型のリストデータに対して、基本的な形式である
	$MyList = $MyList.isort();
は、参照されたリストの値を字句的（レキシカル）かつ大文字小文字を区別しない順序で再ソートします。これは、アルファベット順「a,b,c」でソートされ、「ant;Ant;bee;Bee;cow;Cow」のように、同じ文字のインスタンスではすべての大文字が小文字の後に続くことを意味します。数値の字句ソートは、期待される「1,2,11」ではなく、「1,11,2」となります。

代替のソート方法として、字句的で大文字小文字を区別する List.sort() や、数値ソートの List.nsort()（後者は「1,11,2」ではなく「1,2,11」になります）があります。または、$Name や $Path データを使用している場合は、以下のオプションの長い形式を使用し、指定された属性のデータ型に従ってソート形式（例えば、日付ソートの場合はDate型の属性でソートする）を決めることができます。

結果のソート順序は、List.isort() と List.reverse() 関数を連結することで全体を逆にすることができます。
	$MyList = $MyList.isort().reverse();

List.sort(attributeRef)
ここで参照されるリストは、ノート名またはパスのリスト、つまり $Name データまたは $Path データのリストである必要があります（両方が混在してはいけません）。ドキュメント内でノート名が重複している場合は、正しいソートを実現するためにパスの値を使用する必要があります。

引数 attributeRef は $ が付いた属性参照であり、リストの各項目においてソートされる値を提供する属性を指定します。その結果、この形式のソートは他のデータ型のリストには使用できず、（属性を持っていないため）リテラルの値のリストには適用できません。これは上記の引数なしの短い形式とは異なります。

したがって、ソート順序は規定された attributeRef の値に基づいて決定され、その値は評価対象のリスト項目の $Name または $Path から導出されます。
	$MyList = $collect(children, $Name).isort($StartDate);
	$MyList = $collect_if(find($Prototype==""pArticle""), $Fruit!="""",$Path).isort($Fruit);

後者の例では、$MyList はパスのリストですが、パスは元のオブジェクトのデフォルトの $OutlineOrder ではなく、各項目の $Fruit 値（原文の説明文では $Year となっていますが、文脈上は指定された属性値を指します）の順序でソートされます。既存の $OutlineOrder に「A」、「B」、「C」というノートがあるとします。ソートしない場合、上記で作成された $MyList はパス [/A;/B;/C] になります。もし、それぞれのノートの $Fruit の値が ""Apple""、""apple""、""Pear"" であれば、$Fruit に基づいたソート（ここでは $Year と記されていますが）により $MyList は [/C;/A;/B] になります。一方、通常の .sort($Fruit) では [/A;/C;/B] になります。

この引数を使用した用法では、ソート順序は attributeRef のデータ型に基づきます。
* Number型およびInterval型：数値ソート
* Date型：日付によるソート（暗黙的に数値）
* その他のすべての型：字句ソート

ただし、attributeRef が Number型の場合、代わりに List.nsort() を使用することもできます。
.isort() を使用した字句ソートは、常に大文字小文字を区別しません。

レガシー：Set型のデータでのソートの使用
このオペレーターは Set型のリストには適用されません。v9.0.0 以降、Setは自動的に A–Z でソートされるようになり、ユーザーが別の順序に（確実に）ソートすることはできなくなったためです。ただし、結果を List型や他のプロセスに渡す場合（つまり、元の Set ではなく、ソートされた結果を渡す場合）は、ソートされた内容を得ることが可能です。"
list.last(),Property,List,"Dictionary, Set & List operations",source context dependent,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.last()
list.last
Returns the last item of a List- or Set-type list. If MyList is a 5-item list ""ant;bee;cow;dog;eel"":
	$MyString = $MyList.last; returns ""eel""
This is also the equivalent of $MyList[-1] or $MyList.at(-1).
list.last(N)
Returns a list of the last N items of a list. With the same list as above:
	$MyList2 = $MyList.last(2); returns ""dog;eel""
Testing for loop position
This operator can be used to test the current loop state, i.e. whether the currently processed item is the last in the list. Here the code in the commented section is run only when the last list item in $MyList is being processed:
	$MyList.each(anItem){
		if(anItem==$MyList.last){
			// some code here ...
		};
	};
Note that '$MyList.last' is not a test in itself. Rather, it supplies the value of the last list item which can be tested against the currently processed item.
See also list.first.","list.last()
list.last
List型またはSet型のリストの最後の項目を返します。MyListが5つの項目 ""ant;bee;cow;dog;eel"" からなるリストの場合：
	$MyString = $MyList.last; は ""eel"" を返します。
これは $MyList[-1] または $MyList.at(-1) と同等です。
list.last(N)
リストの最後のN個の項目のリストを返します。上記と同じリストの場合：
	$MyList2 = $MyList.last(2); は ""dog;eel"" を返します。
ループ位置の判定
このオペレータは、現在のループの状態、つまり現在処理されている項目がリストの最後であるかどうかを判定するために使用できます。以下の例では、コメントアウトされたセクションのコードは、$MyListの最後のリスト項目が処理されているときにのみ実行されます：
	$MyList.each(anItem){
		if(anItem==$MyList.last){
			// 何らかのコードをここに記述 ...
		};
	};
「$MyList.last」自体はテスト（条件式）ではないことに注意してください。むしろ、現在処理中の項目と比較するための、リストの最後の項目の値を提供します。
list.first も参照してください。"
list.lookup(keyStr),Function,List,"Dictionary, Set & List operations",source context dependent,false,8.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.lookup(keyStr)
The command .lookup() is intended for look-up tables (i.e. single dimension arrays) using a List- or Set-type list. For the key keyStr value is supplied, the matched key's value is return. We can set up an example listing, using a List-type attribute:
	$MyList = [ant:Wood ant;bee:Carder bee;cow:Jersey;dog:Labrador]; 
This creates a 4 item look-up list. The first list item has two parts - the key 'ant' and its paired value 'Wood ant'. Passing a key via .lookup, returns its key:
	$MyString = $MyList.lookup(""cow""); → ""Jersey"", as list item 3's key is matched.
If a key value with no match is passed, the result is an empty string
	$MyString = $MyList.lookup(""pig""); → """"
But if we add a 'default' key/value pair (anywhere in the list):
	$MyList = [ant:Wood ant;bee:Carder bee;cow:Jersey;dog:Labrador;default:animal]; 
and re-run the last example:
	$MyString = $MyList.lookup(""pig""); → ""animal""
There is still no match but as a default is defined, the default value of ""animal"" is returned.
More complex and nuanced use of .lookup() is described in the discussion of look-up tables.
Dictionary vs. Lookup
The newer Dictionary data-type offers a more efficient and feature rich way of working with lookup lists.
Legacy use (pre v8)
For look-up tables .lookup() is preferred to the older .at() for clarity, and to avoid ambiguity when the argument is numeric. Using the example list as above:
	$MyString = $MyList.at(3); → ""dog:Labrador"", the whole fourth element of the list (do not forget N is counted from zero).
	$MyString = $MyList.lookup(3) → ""animal"", the lookup result for key value 5 which doesn't exist, so we get the default.","list.lookup(keyStr)
.lookup()コマンドは、List型またはSet型のリストを使用したルックアップテーブル（一次元配列）での利用を目的としています。キーkeyStrが指定されると、一致するキーに対応する値が返されます。List型の属性を使用した例を見てみましょう：
	$MyList = [ant:Wood ant;bee:Carder bee;cow:Jersey;dog:Labrador]; 
これにより、4つの項目を持つルックアップリストが作成されます。最初のリスト項目は、キー「ant」とそのペアになる値「Wood ant」の2つの部分で構成されています。.lookupを通じてキーを渡すと、その値が返されます：
	$MyString = $MyList.lookup(""cow""); → ""Jersey""（リストの3番目の項目のキーが一致するため）。
一致するキーがない場合、結果は空の文字列になります：
	$MyString = $MyList.lookup(""pig""); → """"
しかし、（リスト内の任意の場所に）「default」のキー/値ペアを追加すると：
	$MyList = [ant:Wood ant;bee:Carder bee;cow:Jersey;dog:Labrador;default:animal]; 
先ほどの例を再度実行すると：
	$MyString = $MyList.lookup(""pig""); → ""animal""
一致するものは依然としてありませんが、defaultが定義されているため、デフォルト値の「animal」が返されます。
.lookup()のより複雑で詳細な使い方は、ルックアップテーブル（look-up tables）の解説で説明されています。

Dictionary vs. Lookup
新しいDictionaryデータ型は、ルックアップリストを扱うための、より効率的で機能豊富な方法を提供します。

以前の使用法（v8以前）
ルックアップテーブルにおいて、明快さを確保し、引数が数値の場合の曖昧さを避けるために、古い.at()よりも.lookup()が好まれます。上記の例のリストを使用すると：
	$MyString = $MyList.at(3); → ""dog:Labrador""（リストの4番目の要素全体。Nは0から数え始めることに注意してください）。
	$MyString = $MyList.lookup(3) → ""animal""（存在しないキー値5のルックアップ結果であるため、デフォルトが返されます）。"
list.max(),Property,List,Data manipulation,source context dependent,false,6.4.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.max()
list.max
The list.max() operator returns the largest item in a List- or Set-type list.
This is a replacement for/alternative to the max() operator.
Both the operators list.max() and list.min() use lexical comparison in most cases, but numeric comparison if the context is numeric (i.e. the reference is a Number-type attribute) and/or all list items are numbers. Thus:
	$Width=(""1;100;2"").max; 
Since ""Width"" is numeric, max() will be return 100. 
	$Name=(""1;100;2"").max; 
Since the attribute ""Name"" is a string, max() will return 2.
If without a list, create one on the fly:
	$MyMax = collect(all,$MyNumber).max; 
	$MyMax = collect(descendants,$Modified).max; 
This allows export via value:
	value(collect(descendants,$Modified).max) 
To use max() with a list of items that are attributes or expressions, use list():
	Works: $MyNumber = list(4+2,9+6).max; (output: 15)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Using lists of dates
When using Date-type data bear in mind that the defaults for an unset Date attribute is ""never"" and that ""never"" is treated as sorting always before (i.e. less than) any set date. So to use .min with dates, filter out the unset values, whereas with .max it is not needed:
	$MyMax = collect_if(descendants,$Modified).max; 
	$MyMin = collect_if(descendants,($Modified!=""never""),$Modified).min;","list.max()
list.max
list.max() オペレーターは、List型またはSet型のリストの中で最大の項目を返します。
これは max() オペレーターの代替または代わりの手段となります。
list.max() と list.min() の両オペレーターは、ほとんどの場合で辞書順（語彙的）比較を使用しますが、コンテキストが数値である場合（例：参照先が数値型の属性である）、またはリストのすべての項目が数値である場合には数値比較を使用します。したがって：
	$Width=(""1;100;2"").max; 
Width は数値型であるため、max() は 100 を返します。
	$Name=(""1;100;2"").max; 
Name 属性は文字列型であるため、max() は 2 を返します。
リストがない場合は、その場でリストを作成できます：
	$MyMax = collect(all,$MyNumber).max; 
	$MyMax = collect(descendants,$Modified).max; 
これにより、value() を介したエクスポートが可能になります：
	value(collect(descendants,$Modified).max) 
属性や式である項目のリストに対して max() を使用するには、list() を使用します：
	動作例: $MyNumber = list(4+2,9+6).max; (出力: 15)
リスト項目がアクションコードの式であるような、より複雑な例では、各項目の式を eval() で包む必要があるかもしれません。例：list(eval(expressionA),eval(expressionB))。
日付リストの使用について
日付（Date）型のデータを使用する場合、未設定の日付属性のデフォルト値は ""never"" であり、""never"" は常に設定済みのどの本体よりも前（つまり、より小さい）として扱われることに注意してください。そのため、日付で .min を使用する場合は未設定の値をフィルタリングする必要がありますが、.max の場合はその必要はありません：
	$MyMax = collect_if(descendants,$Modified).max; 
	$MyMin = collect_if(descendants,($Modified!=""never""),$Modified).min;"
list.min(),Property,List,Data manipulation,source context dependent,false,6.4.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.min()
list.min
The list.min() operator returns the smallest item in a List- or Set-type list.
This is a replacement for/alternative to the min() operator.
Both the operators list.min() and list.max() use lexical comparison in most cases, but numeric comparison if the context is numeric (i.e. the reference is a Number-type attribute) and/or all list items are numbers. Thus:
	$Width=(""100;2;70"").min; 
Since ""Width"" is numeric, min() will be return 2. 
	$Name=(""100;2;70"").min; 
Since the attribute ""Name"" is a string, .min will return 100.
If without a list, create one on the fly:
	$MyMin = collect_if(all,$MyNum>0,$MyNum).min; 
	$MyMin = collect(descendants,$Modified).min; 
This allows export via value:
	value(collect(descendants,$Modified).min) 
To use count() with a list of items that are attributes or expressions, use list():
	Works: $MyNumber = list(4+2,9+6).min; (output: 6)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Using lists of dates
When using Date-type data bear in mind that the defaults for an unset Date attribute is ""never"" and that ""never"" is treated as sorting always before (i.e. less than) any set date. So to use .min with dates, filter out the unset values, whereas with .max it is not needed:
	$MyMax = collect_if(descendants,$Modified).max; 
	$MyMin = collect_if(descendants,($Modified!=""never""),$Modified).min;","list.min()
list.min
list.min() オペレーターは、List型またはSet型のリストの中で最も小さい項目を返します。
これは min() オペレーターの代替または置き換えとして使用できます。
list.min() および list.max() オペレーターは、ほとんどの場合で辞書順比較を行いますが、コンテキストが数値である場合（例：数値型の属性を参照している場合）や、リストの全項目が数値である場合は数値比較を行います。したがって：
	$Width=(""100;2;70"").min; 
""Width"" は数値型であるため、min() は 2 を返します。
	$Name=(""100;2;70"").min; 
属性 ""Name"" は文字列型であるため、.min は 100 を返します。
リストがない場合は、その場でリストを作成して使用できます：
	$MyMin = collect_if(all,$MyNum>0,$MyNum).min; 
	$MyMin = collect(descendants,$Modified).min; 
これにより、value() を介した値のエクスポートが可能になります：
	value(collect(descendants,$Modified).min) 
属性や式をリスト化して count() を使用するには、list() を使用します：
	動作例：$MyNumber = list(4+2,9+6).min; （出力：6）
リストの項目がアクションコードの式であるような、より複雑な例では、各項目の式を eval() でラップする必要があるかもしれません（例：list(eval(expressionA),eval(expressionB))）。
日付リストの使用
Date型のデータを使用する場合、未設定のDate属性のデフォルトは ""never"" であり、""never"" は常にどの設定済みの日付よりも前（つまり「より小さい」）として扱われることに注意してください。そのため、日付に対して .min を使用する場合は未設定の値をフィルタリングする必要がありますが、.max の場合はその必要はありません：
	$MyMax = collect_if(descendants,$Modified).max; 
	$MyMin = collect_if(descendants,($Modified!=""never""),$Modified).min;"
List.nsort([attributeRef]),Function,Item,Data manipulation,List,false,5.8.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"List.nsort([attributeRefStr])
List.nsort()
For List-type list data, the basic form
	$MyList = $MyList.nsort(); 
	$MyList = $MyList.nsort().reverse(); 
re-sorts the referenced list's values in ascending numerical sort order. This means sorting '1,2,11' not 1,11,2' such as occurs with sort() and a lexical sort. A numerical sort is really only useful for numerical data. This implies:
* Numbers or Interval-type (but not Date-type data)
* Strings that begin with numbers
For most string (text) values and Date-type date, consider List.sort() or List.isort(), both of which give lexical sorts of differing case sensitivity. The resulting sort order can be reversed overall by chaining the List.nsort() and List.reverse() functions:
	$MyList = $MyList.nsort().reverse(); 
List.nsort(attributeRef)
Here the referenced list must be a list of note names or paths, i.e. list $Name data or $Path data (but not a mix of the two). If note names are not unique within the document, path values must be used to achieve correct sort. This form of sort cannot be used with any other sort of value list. This operator cannot be applied to any list of values, unlike the short form above.
In this form, the sort order can be based on the value of the stipulated attributeRef (a $-prefixed attribute name). The attribute's value is derived from the item identified by the $Name or $Path of the list item being evaluated:
	$MyList = $collect(children, $Name).nsort($PageNumber); 
	$MyList = $collect_if(find($Prototype==""pProduct""), $Price>0,$Path).nsort($Price); 
In this argument-based usage, .nsort() assumes the target attribute is Number-type. This the source list must comprise titles of paths but attributeRef must be a Number-type attribute.
Legacy: Use of sorting with Set-type data
This operator does not apply to Set-type lists because, as from v9.0.0, Sets now auto-sort A–Z and cannot be (reliably) user-sorted to a different order. However, is passing the result to a List-type or to some other process—i.e. passing the sorted result, not the source Set—then sorted content is possible.","List.nsort([attributeRefStr])
List.nsort()
List型のリストデータにおいて、基本的な形式は以下の通りです：
	$MyList = $MyList.nsort(); 
	$MyList = $MyList.nsort().reverse(); 
これにより、参照されたリストの値が昇順の数値順で再ソートされます。これは、sort() や辞書順ソートで見られる '1, 11, 2' ではなく、'1, 2, 11' のようにソートされることを意味します。数値順ソートは、実質的に数値データに対してのみ有用です。これには以下が含まれます：
* 数値型またはインターバル（Interval）型（ただし日付（Date）型データは除く）
* 数字で始まる文字列
ほとんどの文字列（テキスト）値や日付（Date）型データについては、List.sort() または List.isort() を検討してください。これらはいずれも辞書順のソートを行いますが、大文字小文字の感度が異なります。List.nsort() と List.reverse() をチェーンさせることで、全体のソート順を反転させることができます：
	$MyList = $MyList.nsort().reverse(); 
List.nsort(attributeRef)
この形式では、参照されるリストはノート名またはパスのリスト、すなわち $Name データまたは $Path データのリストである必要があります（両方の混在は不可）。ドキュメント内でノート名が一意でない場合は、正しいソート結果を得るためにパス値を使用する必要があります。この形式のソートは、他の種類の値リストには使用できません。上記の引数なしの形式とは異なり、この演算子はあらゆる値のリストに適用できるわけではありません。
この形式でのソート順は、指定された attributeRef（$を冠した属性名）の値に基づきます。属性の値は、評価されるリスト項目（$Name または $Path）によって特定されるアイテムから取得されます：
	$MyList = $collect(children, $Name).nsort($PageNumber); 
	$MyList = $collect_if(find($Prototype==""pProduct""), $Price>0,$Path).nsort($Price); 
この引数を用いた使用法では、.nsort() は対象の属性が数値型であることを前提としています。つまり、元のリストは名前またはパスで構成されている必要がありますが、attributeRef は数値型の属性である必要があります。
レガシー：Set型データでのソートの使用
この演算子はSet型のリストには適用されません。なぜなら、v9.0.0以降、SetはAからZへ自動的にソートされるようになり、ユーザーが（確実に）異なる順序にソートすることはできなくなったためです。ただし、結果をList型や他のプロセスに渡す場合（つまり、元のSet自体ではなく、ソートされた結果を渡す場合）は、ソートされた内容を扱うことが可能です。"
list.randomItem(),Function,List,"Dictionary, Set & List operations",source context dependent,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.randomItem()
The .randomItem() returns a randomly-selected item from a List- or Set-type list:
	$MyString = $MyList.randomItem(); 
This replaces the extra coding needed for such a task if using rand().
This operator can be used not only on attributes but also literal lists using list():
	$MyString = list(""ant;bee;cow;dog"").randomItem(); 
list-based variables:
	var:list vList = ""ant;bee;cow;dog""; $MyString = vList.randomItem(); 
and list-creating operators:
	$MyString = collect(find($SomeAttribute==""xyz""),$Path).randomItem();","list.randomItem()
.randomItem()は、List型またはSet型のリストから、ランダムに選択された項目を返します：
	$MyString = $MyList.randomItem(); 
これは、rand()を使用する場合に必要となる追加のコーディングを不要にします。
このオペレーターは属性だけでなく、list()を使用したリテラルリストにも使用できます：
	$MyString = list(""ant;bee;cow;dog"").randomItem(); 
リスト型変数：
	var:list vList = ""ant;bee;cow;dog""; $MyString = vList.randomItem(); 
およびリスト作成オペレーター：
	$MyString = collect(find($SomeAttribute==""xyz""),$Path).randomItem();"
list.remove(matchValue),Function,List,Data manipulation,source context dependent,false,8.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.remove(matchValue)
This removes items from a List- or Set-type list. The argument matchValue may be of the desired data type for matching. For example,
	$MyList = $MyList.remove(0); 
returns a new list from which all elements equal to zero have been removed, and
	$MyList = $MyList.remove(""cat""); 
returns a new list from which call elements equal to ""cat"" have been removed.
	$MyList = $MyList.remove(""cat; dog; badger""); 
removes ""cats"", ""dogs"", and ""badgers"".","list.remove(matchValue)
List型またはSet型のリストから項目を削除します。引数 matchValue には、照合したいデータ型の値を指定できます。
例えば、
	$MyList = $MyList.remove(0); 
は、0に等しいすべての要素が削除された新しいリストを返します。
	$MyList = $MyList.remove(""cat""); 
は、""cat""に等しいすべての要素が削除された新しいリストを返します。
	$MyList = $MyList.remove(""cat; dog; badger""); 
は、""cat""、""dog""、""badger""を削除します。"
"list.replace(regexMatchStr, replacementStr)",Function,Item,Data manipulation,source context dependent,false,5.7.0,Baseline,,,,2,true,true,false,false,true,false,false,false,false,,false,"list.replace(regexMatchStr, replacementStr)
This operator allows simple text transformations of List- or Set-type list data. The result remains a List or Set as per the list of references supplied. Unlike in contains() type operators, some regex are not supported for either argument; regex use is discussed in more detail below.
Very often, a replace output is passed back to the calling list value, updating the source:
	$MyList = $MyList.replace(""Eggs"",""Ham); 
note how the output of the .replace() operator has to explicitly be passed back to the source list to overwrite its data (if this is thew desired intent!).
regexMatchStr and replacement are one of:
* an action code expression (which includes just referencing a single attribute name')
* a quoted string, which may be either:
** a literal string (i.e. actual text)
** a regular expression (regexMatchStr only)
list.replace(regexMatchStr, replacementStr)
List and set type attributes can use replace, though the scope of replacement is more limited than with strings. With listings, the match with and replacement of can only be for a complete list value and not part of a value.
A Replace action does not alter the original source
Using .replace() does not affect the source string unless the replacement output is used to overwrite the original source value. Thus if $MyString holds ""Hello World"" then:
	$MyStringA = $MyString.replace("" World""); 
$MyString remains ""Hello Word"" and $MyStringA has value ""Hello"". The source is unchanged. But, if we set the source to the output
	$MyString = $MyString.replace("" World""); 
Now $MyString becomes ""Hello"" and the original value is lost (overwritten by the new one.
Using regex (regular expressions)
Most basic regex expressions should work but string start () and string end ($) matches work in an unexpected way. When .replace() is run it looks at the internal string value of the Set or List. 
Thus a list of values, like ant/bee/cow/dog/eel, is stored and matched as a single semi-colon delimited string ""ant;bee;cow;dog;eel"". Note Tinderbox does not create a final semi-colon after the last value, but will not complain if the user adds one, e.g. via manual input. Thus a  regex matches only before the 'a' of 'ant' and not the start of other list values. Similarly, $ matches after the 'g' of dog and not the end of other list values. It might be thought of as 'ant;bee;cow;dog;eel$' as opposed to 'ant$;bee$;cow$;dog$;eel$'. 
So, in-list value boundaries still exist for regex matching but only as literal semicolons. Thus to change 'ee' to 'eet' in the above list but only for 'bee' and not 'eel':
	$MyListA = $MyList.replace(""ee;"",""eet;"").replace(""ee$"",""eet""); 
Note how two chained .replace() calls are needed, not one. The first is for inter-value boundaries and the second for the overall string end (had the data had a closing semi-colon the first match catches it so that scenario's still covered. To reverse the scenario and match the 'ee' at the start of a value:
	$MyListA = $MyList.replace("";ee"",""ree;"").replace(""ee"",""ree""); 
That changes 'eel' to 'reel' but leaves 'bee' unaltered.
It is possible to write back to the same attribute:
	$MyList = $MyList.replace(""ee;"",""eet;"").replace(""ee$"",""eet""); 
but, the former is a good idea whilst developing/testing code for this technique, only switching out latter once sure of the result.
Regex and Back-references
Regex can be used to set back-references in the regexMatchStr input string, as in an agent query, that can then be used in the replacementStr string. This is described in more detail here.
Trimming leading/trailing whitespace
	$MyList = $MyList.replace(""^ +"","""").replace("" +$"","""").replace("" *; *"","";""); 
The ' +' means one or more space characters. The first replace finds such a sub-string immediately following the start of the whole string ^), whilst the second does the same for a sub-string immediately before the end of the string ($). The third replace finds zero or more space characters either side of a semi-colon (the per-item list delimiter). The latter also matches a normal ';' delimiter but the test save writing separate regexs for space before and after the delimiter (e.g. "" +;"" and ""; +"") so the zero-or-more test (*) is used here instead of the one-or-more (+) used for the start/end of the overall string. Thus, using the code above, a lists like these with items having undesired leading/trailing space:
	"" ant ; bee ; cow ; dog "" 
	"" ant ;bee ;cow ; dog"" 
…both become…
	""ant;bee;cow;dog"" 
Dealing with inline quote characters
Because regexMatchStr is parsed for regular expressions, it may be possible to use the '\dnn' form described here to work around the lack of escaping from single double quotes within strings.","list.replace(regexMatchStr, replacementStr)
このオペレーターは、リスト型またはセット型のデータに対して簡単なテキスト変換を可能にします。結果は、提供された参照リストに従って、リストまたはセットとして保持されます。contains() 系のオペレーターとは異なり、一部の正規表現はどちらの引数でもサポートされていません。正規表現の使用については、以下で詳しく説明します。

多くの場合、replace の出力は呼び出し元のリスト値に返され、ソースを更新します：
	$MyList = $MyList.replace(""Eggs"",""Ham"");
（これが意図した動作である場合）データを上書きするには、.replace() オペレーターの出力を明示的にソースリストに戻す必要があることに注意してください。

regexMatchStr および replacementStr は、以下のいずれかです：
* アクションコード式（単一の属性名への参照のみを含むものも含む）
* 引用符で囲まれた文字列。以下のいずれか：
** リテラル文字列（実際のテキスト）
** 正規表現（regexMatchStr のみ）

list.replace(regexMatchStr, replacementStr)
リスト型およびセット型の属性で replace を使用できますが、置換の範囲は文字列の場合よりも制限されます。リストの場合、一致と置換はリスト内の完全な値に対してのみ行うことができ、値の一部に対しては行えません。

Replace アクションは元のソースを変更しません
.replace() を使用しても、置換後の出力が元のソース値を上書きするために使用されない限り、ソース文字列には影響しません。したがって、$MyString が ""Hello World"" を保持している場合：
	$MyStringA = $MyString.replace("" World"");
$MyString は ""Hello World"" のままで、$MyStringA の値は ""Hello"" になります。ソースは変更されません。しかし、ソースに出力を設定した場合：
	$MyString = $MyString.replace("" World"");
これで $MyString は ""Hello"" になり、元の値は失われます（新しい値で上書きされます）。

正規表現（regex）の使用
ほとんどの基本的な正規表現は機能しますが、文字列の開始（^）と終了（$）の一致は予想外の動作をします。.replace() が実行されると、セットまたはリストの内部文字列値を調べます。

したがって、ant/bee/cow/dog/eel のような値のリストは、単一のセミコロン区切り文字列 ""ant;bee;cow;dog;eel"" として保存され、一致処理が行われます。Tinderbox は最後の値の後に末尾のセミコロンを作成しませんが、ユーザーが手動入力などで追加しても問題はありません。したがって、正規表現の ^ は ""ant"" の 'a' の前だけに一致し、他のリスト値の開始には一致しません。同様に、$ は ""dog"" の 'g' の後に一致し、他のリスト値の末尾には一致しません。これは ""ant$;bee$;cow$;dog$;eel$"" ではなく、""ant;bee;cow;dog;eel$"" と考えることができます。

そのため、リスト値の境界は正規表現の一致のために依然として存在しますが、リテラルのセミコロンとしてのみ存在します。したがって、上記のリストで ""ee"" を ""eet"" に変更したいが、""bee"" に対してのみ行い、""eel"" には行わないようにするには：
	$MyListA = $MyList.replace(""ee;"",""eet;"").replace(""ee$"",""eet"");
1つではなく、2つの連続した .replace() 呼び出しが必要であることに注意してください。1つ目は値の間の境界用で、2つ目は文字列全体の末尾用です（データに閉じセミコロンがあった場合、1つ目がそれをキャッチするため、そのシナリオもカバーされます）。シナリオを逆にして、値の先頭にある ""ee"" に一致させるには：
	$MyListA = $MyList.replace("";ee"",""ree;"").replace(""ee"",""ree"");
これにより ""eel"" は ""reel"" に変更されますが、""bee"" は変更されません。

同じ属性に書き戻すことも可能です：
	$MyList = $MyList.replace(""ee;"",""eet;"").replace(""ee$"",""eet"");
ただし、コードの開発・テスト中はこの手法を用い、結果が確実になった段階で後者に切り替えるのが良い考えです。

正規表現と後方参照
正規表現は、エージェントクエリのように regexMatchStr 入力文字列で後方参照を設定するために使用でき、それを replacementStr 文字列で使用できます。これについては、こちらで詳しく説明されています。

先頭/末尾の空白のトリミング
	$MyList = $MyList.replace(""^ +"","""").replace("" +$"","""").replace("" *; *"","";"");
"" +"" は1つ以上のスペース文字を意味します。最初の replace は文字列全体の開始（^）直後にあるそのような部分文字列を見つけ、2番目は文字列の末尾（$）直前にあるものに対して同じことを行います。3番目の replace は、セミコロン（項目ごとのリスト区切り文字）の両側にある0個以上のスペース文字を見つけます。後者は通常の "";"" 区切り文字にも一致しますが、このテストでは、区切り文字の前後のスペース（例："" +;"" と ""; +""）に対して別々の正規表現を書く手間を省くために、文字列の開始/終了に使用した 1つ以上（+）の代わりに、0個以上（*）のテストがここで使用されています。したがって、上記のコードを使用すると、次のように項目に不要な先頭/末尾のスペースを持つリストは：
	"" ant ; bee ; cow ; dog ""
	"" ant ;bee ;cow ; dog""
…どちらも次のようになります…
	""ant;bee;cow;dog""

インライン引用符文字の処理
regexMatchStr は正規表現として解析されるため、文字列内の単一の二重引用符のエスケープ不足を回避するために、こちらで説明されている \dnn 形式を使用できる場合があります。"
list.reverse(),Function,Item,Data manipulation,List,false,5.8.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.reverse()
list.reverse
This function reverses the order of the referenced List-type list. The function does not reverse the individual list values, but rather reverses the exact order of the individual values. Trailing parentheses are optional for this function.
	$MyList = $MyList.reverse(); 
	$MyList = [ant;bee;cow].reverse(); 
The function may be chained with the list.sort() and list.isort() functions, noting that sorting can only be used with List-type and not Set-type data:
	$MyList = $MyList.sort().reverse(); 
	$MyList = $MyList.isort().reverse(); 
Reversing Set-type lists
As set-type lists are auto-sorted, this operator only makes sense to use when passing to that function/operator/type other that set data.","list.reverse()
list.reverse
この関数は、参照されたList型のリストの順序を反転させます。この関数は、リスト内の個々の値自体を反転させるのではなく、個々の値の並び順を正確に反転させます。この関数では、末尾の括弧はオプション（省略可能）です。
	$MyList = $MyList.reverse(); 
	$MyList = [ant;bee;cow].reverse(); 
この関数は、list.sort()およびlist.isort()関数と連結させることができます。ただし、ソートはList型でのみ使用可能であり、Set型データには使用できない点に注意してください。
	$MyList = $MyList.sort().reverse(); 
	$MyList = $MyList.isort().reverse(); 
Set型リストの反転
Set型リストは自動的にソートされるため、このオペレータの使用が意味をなすのは、Set型以外のデータを受け取る関数、オペレータ、または型に値を渡す場合のみです。"
list.select(),Function,Group,Data manipulation,source context dependent,false,9.6.0,Baseline,,,,1,true,true,false,false,false,true,false,false,false,,false,"list.select()
The list.select() operator allows the document's current (UI) focus to be shifted, to use the item(s)m defined in a List- or Set-type list. The list may be a literal string, or the value of an attribute or variable.
	[/Note A;/Note B].select(); 
	$MyList.select(); 
	vItems.select(); 
This specialist operator assist in the scenario where, whilst running action code, it is necessary to change the selection such that the locus of 'this' changes. Some action code operators only address the currently selected item(s). The select(scope) operator allows the selection to be changed on the fly without the user having to do so via the UI.
Because using select without arguments has a distinct and different function is it listed separately: select().","list.select()
list.select() 演算子を使用すると、List型またはSet型のリストで定義されたアイテムを使用するために、ドキュメントの現在の（UI上の）フォーカスを移動させることができます。リストはリテラル文字列、あるいは属性や変数の値である場合があります。
	[/Note A;/Note B].select();
	$MyList.select();
	vItems.select();
この特殊な演算子は、アクションコードの実行中に、'this' の指す対象が変わるように選択範囲を変更する必要がある場面で役立ちます。一部のアクションコード演算子は、現在選択されているアイテムのみを対象とします。select(scope) 演算子を使用すると、ユーザーがUIを介して手動で操作することなく、実行中にその場で選択範囲を変更できます。
引数なしの select はこれとは異なる別の機能を持つため、select() として別途記載されています。"
list.size(),Property,Item,Data manipulation,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.size()
list.size
This returns the Number of discrete values in a List- or Set-type list. The returned number can be coerced to a string. Trailing parentheses are optional for this property. Examples:
	$MyList = [hello;world]; $MyStringA = $MyList.size; 
$MyStringA is set to ""2"".
This property is the same evaluation as list.count or count(list).
This operator can also be used on other attribute data types that are string-like, URL, File, etc.","list.size()
list.size
List型またはSet型リスト内の個別の値の数を返します。返される数値は、文字列に強制（coerce）することができます。このプロパティでは、末尾の括弧はオプション（省略可能）です。例：
	$MyList = [hello;world]; $MyStringA = $MyList.size; 
$MyStringA は ""2"" に設定されます。
このプロパティは、list.count または count(list) と同じ評価結果になります。
このオペレータは、String、URL、Fileなど、他の文字列に似た属性データ型でも使用できます。"
List.sort([attributeRef]),Function,Item,Data manipulation,List,false,5.8.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"List.sort([attributeRef])
List.sort()
The basic form
	$MyList = $MyList.sort(); 
This function re-sorts the referenced list's values in lexical, case-sensitive order. This means sorting all upper case letters before any lower case ones as in ""Ant;Bee;Cow;ant;bee;cow"". Users of non-accented languages (for the content of their notes) will likely find the case-insensitive List.isort() of more practical use.
A forced numerical sort (1,2,11 not 1,11,2) can be achieved by using List.nsort(). Or, if using $Name or $Path data, use the optional long from (below) and let the nominated attribute's data type set the form of sort, e.g. for date sorting, sort on a Date-type attribute.
The resulting sort order can be reversed overall by chaining the List.sort() and List.reverse() functions:
	$MyList = $MyList.sort().reverse(); 
Sets can be sorted, on the fly, so a sorted output can be passed to a List. Passing the sorted output of a Set to another Set has an unknown outcome, in terms of stored sort order.
List sorting can be used to process group designators. For example:
	$MyList=$Colors(children); 
finds a list of the colours of each child of the current note, and:
	$MyNumber=$Width(children).max;
will find the maximum width of the current container's children. When applied to the attribute $Text:
	$Text=$Text(children);
the texts of each child are appended, separated by paragraph breaks.
List.sort(attributeRef)
Here the referenced List must be a list of note names or paths, i.e. a list of $Name data or $Path data (but not a mix of the two). If note names are not unique within the document, path values must be used to achieve correct sort. This is because the stipulated
The attributeRef argument is a $-prefixed attribute reference and indicates the attribute supplying the sorted value in each list item. As a result, this form of sort cannot be used with any other date type of list and cannot be applied to a literal list of values (as they have no attributes!), unlike the short un-argumented form above.
Thus, the sort order is based on the value of the stipulated attributeRef and that value is derived from the $Name or $Path of the list item being evaluated:
	$MyList = collect(children, $Name).sort($StartDate); 
	$MyList = collect_if(find($Prototype==""pArticle""), $Year!="""",$Path).sort($Year); 
So, in the latter case, $MyList is a list of paths, but the paths are sorted in the order of each item's $Year value rather than the default $OutlineOrder of the source objects. Consider notes 'A', 'B', and 'C' in that existing on that $OutlineOrder. Without the sort, $MyList created above is the paths [/A;/B;/C]. If the notes' respective $Year values are ""1965"",""2010"",""1980"", then a $Year-based sort make the $MyList to be [/A;/C;/B] (i.e. by increasing year value). 
In this argument-based usage, the sort ordering is based on the data type of attributeRef:
* Number-type: and Interval-type: numerical sort
* Date-type: sort on date (implied numerical)
* All other types lexical
But if attributeRef is Number-type, List.nsort() could be used instead.
With .sort() lexical sorts are always case-insensitive.
Group designators are allowed in attribute references. For example:
	$MyList=$Colors(children); 
finds a list of the colours of each child of this note, and:
	$MyNumber=$Width(children).max; 
will find the maximum width of the container's children. When applied to the attribute $Text:
	$Text=$Text(children); 
the texts of each child are appended, separated by paragraph breaks.
Legacy: Use of sorting with Set-type data
This operator does not apply to Set-type lists because, as from v9.0.0, Sets now auto-sort A–Z and cannot be (reliably) user-sorted to a different order. However, is passing the result to a List-type or to some other process—i.e. passing the sorted result, not the source Set—then sorted content is possible.","List.sort([attributeRef])
List.sort()
基本形式
	$MyList = $MyList.sort(); 
この関数は、参照されたリストの値を辞書順かつ大文字・小文字を区別する（case-sensitive）順序で再ソートします。これは、""Ant;Bee;Cow;ant;bee;cow""のように、すべての大文字を小文字の前にソートすることを意味します。アクセント記号のない言語（ノートの内容）を使用するユーザーにとっては、大文字・小文字を区別しない List.isort() の方が実用的でしょう。
強制的な数値順ソート（1, 2, 11であり、1, 11, 2ではない）は、List.nsort() を使用することで実現できます。または、$Name や $Path のデータを使用している場合は、後述のオプションの長い形式を使用し、指定した属性のデータ型に基づいてソート形式を決定させることができます。例えば、日付順のソートには Date 型の属性でソートします。
ソート結果の順序は、List.sort() と List.reverse() 関数をチェーンさせることで全体を反転させることができます：
	$MyList = $MyList.sort().reverse(); 
Set（セット）は適宜（on the fly）ソートできるため、ソートされた出力を List（リスト）に渡すことができます。ソートされた Set の出力を別の Set に渡した場合、保存されるソート順序の結果は不明です。
リストのソートは、グループ指定子（group designators）の処理に使用できます。例えば：
	$MyList=$Colors(children); 
は、現在のノートの各子ノートの色のリストを取得します。また：
	$MyNumber=$Width(children).max;
は、現在のコンテナの子ノートの最大幅を取得します。属性 $Text に適用した場合：
	$Text=$Text(children);
各子ノートのテキストが、段落区切りで区切られて結合されます。

List.sort(attributeRef)
ここで参照される List は、ノート名またはパスのリスト、つまり $Name データまたは $Path データのリストである必要があります（これら 2 つを混ぜることはできません）。ドキュメント内でノート名が一意でない場合は、正しいソートを実現するためにパス値を使用する必要があります。これは、規定の...
attributeRef 引数は「$」プレフィックスが付いた属性参照であり、リスト内の各項目においてソート後の値を提供する属性を指定します。その結果、この形式のソートは他のデータ型のリストには使用できず、また（属性を持たないため）値のリテラルリストにも適用できません。これは、上記の引数のない短い形式とは異なります。
したがって、ソート順は指定された attributeRef の値に基づいて決定され、その値は評価対象のリスト項目の $Name または $Path から導出されます：
	$MyList = collect(children, $Name).sort($StartDate); 
	$MyList = collect_if(find($Prototype==""pArticle""), $Year!="""",$Path).sort($Year); 
後者の例では、$MyList はパスのリストですが、パスはソースオブジェクトのデフォルトの $OutlineOrder ではなく、各項目の $Year 値の順序でソートされます。既存の $OutlineOrder にノート 'A'、'B'、'C' が存在するとします。ソートを行わない場合、上記で作成される $MyList はパスのリスト [/A;/B;/C] です。各ノートの $Year 値がそれぞれ ""1965""、""2010""、""1980"" である場合、$Year に基づくソートによって $MyList は [/A;/C;/B]（すなわち、年の値が増える順）になります。
この引数ベースの使用法では、ソート順序は attributeRef のデータ型に基づきます：
* Number 型および Interval 型：数値順ソート
* Date 型：日付順ソート（暗黙的に数値順）
* その他のすべての型：辞書順
ただし、attributeRef が Number 型である場合は、代わりに List.nsort() を使用することもできます。
.sort() を使用した場合、辞書順ソートは常に大文字・小文字を区別しません。
属性参照ではグループ指定子が許可されています。例えば：
	$MyList=$Colors(children); 
はこのノートの各子ノートの色のリストを取得します。また：
	$MyNumber=$Width(children).max; 
はコンテナの子ノートの最大幅を取得します。属性 $Text に適用した場合：
	$Text=$Text(children); 
各子ノートのテキストが、段落区切りで区切られて結合されます。

レガシー：Set 型データでのソートの使用
この演算子は Set 型のリストには適用されません。なぜなら、v9.0.0 以降、Set は常に A–Z で自動ソートされ、（確実に）ユーザーが別の順序にソートすることはできなくなったためです。ただし、結果を List 型や他のプロセスに渡す場合（つまり、ソースである Set ではなくソートされた結果を渡す場合）は、ソートされたコンテンツを利用することが可能です。"
"list.sum_if(loopVar, condition[, expressionStr])",Function,Group,Mathematical,Number,false,9.5.0,Baseline,,,,,true,false,false,true,false,false,true,true,false,,false,"list.sum_if(loopVar, condition[, expressionStr])
The dot-operator .sum_if() sums the values of members of a List- or Set-type list that satisfy a condition. Each item in the list is bound in turn to loopVar, and if condition is met, the items value is added to the retuned sum. Optionally, the expressionStr is evaluated, allowing a transform to be carried out on a matched list member's value before it is added to the overall returned sum.
loopVar is essentially the same as the loop variable used by the list.each() operator. In the examples below, for clarity the loopVar value ""anItem"" is used, but as with any loop variable a shorter less expressive values such a ""x"" can be used (e.g. by more expert users).
The condition argument is a conditional expression for which each tested item must return true or false.
The operator applies the action code expressionStr to only those list items for which condition is  true. For only list items meeting condition, the result of expressionStr on loopVar is returned as List-type data.
For example, if $MyList is ""1;2;3;4;5"", then
	$MyListA = $MyList.sum_if(aValue, aValue>3) 
returns the sum of all the members of $MyList that are greater than 3. 
An optional third argument expressionStr allows a matched values to be transformed before they are added to the sum. So:
	$MyListA = $MyList.sum_if(aValue, aValue>3, aValue*aValue)  
returns the sum of the squares of each member that is greater than 3.
list.sum_if() vs. sum_if()
Although the two appear similar. This operator works directly on the source list values, whereas sum_if() creates a list of $Path values and returns on an attribute value from each of those paths (where the item at the $Path meets the condition).","list.sum_if(loopVar, condition[, expressionStr])

ドット演算子 .sum_if() は、List型またはSet型のリストのうち、条件を満たす要素の値を合計します。リストの各項目は順番に loopVar にバインドされ、条件（condition）が満たされると、その項目の値が戻り値となる合計に加算されます。オプションで expressionStr を指定すると、条件に一致したリスト項目の値を変換してから全体の合計に加算することができます。

loopVar は、本質的に list.each() 演算子で使用されるループ変数と同じです。以下の例では、わかりやすくするために loopVar の値として「anItem」を使用していますが、他のループ変数と同様に、「x」のような短く簡潔な値を使用することもできます（熟練したユーザーなど）。

condition 引数は、テストされる各項目が真（true）か偽（false）を返す条件式です。

この演算子は、condition が真であるリスト項目に対してのみ、アクションコード expressionStr を適用します。条件を満たすリスト項目についてのみ、loopVar に対する expressionStr の結果が List型データとして返されます。

例えば、$MyList が ""1;2;3;4;5"" である場合、
	$MyListA = $MyList.sum_if(aValue, aValue>3) 
は、3より大きい $MyList の全要素の合計を返します。

オプションの第3引数 expressionStr を使用すると、一致した値を合計に加算する前に変換することができます。したがって：
	$MyListA = $MyList.sum_if(aValue, aValue>3, aValue*aValue) 
は、3より大きい各要素の2乗の合計を返します。

list.sum_if() と sum_if() の比較
これら2つは似ているように見えますが、この演算子（list.sum_if）がソースリストの値を直接処理するのに対し、sum_if() は $Path 値のリストを作成し、それらのパスにある各項目の属性値を（そのパスの項目が条件を満たす場合に）返します。"
list.sum(),Function,Item,Mathematical,Number,false,8.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.sum()
list.sum
For a list of List- or Set-type data, this adds up lists of numbers. If $MyList is 1;2;3;4, then for:
	$MyNumber = $MyList.sum; 
$MyNumber is 10, i.e. 1+2+3+4.
Non-numerical items
The general expectation is this operator is used for number-only lists. Non-numerical list items are ignored:
	""2; 4; 6; 12"".sum gives 24 
	""2; 8bees; 4; bee; 6; bee5; 12; bee2bee"" also gives 24 
However, be aware of note this edge case;
	2; 8 bees; 4; bee; 6; bee 5; 12; bee 2 bee gives 32 
Here, the original result of 24 is supplemented by the opening 8 from '8 bees' and the trailing 5 from 'bee5' to give 32. But, the 2 entirely within 'bee 2 bee' is not counted.","list.sum()
list.sum
List型またはSet型のデータにおいて、リスト内の数値を合計します。$MyListが「1;2;3;4」である場合、以下のように記述すると：
	$MyNumber = $MyList.sum;
$MyNumberは10（つまり1+2+3+4）となります。

非数値項目
このオペレーターは、通常は数値のみのリストで使用されることを想定しています。非数値のリスト項目は無視されます：
	""2; 4; 6; 12"".sum は 24 を返します。
	""2; 8bees; 4; bee; 6; bee5; 12; bee2bee"" も 24 を返します。

ただし、次のようなエッジケースに注意してください：
	2; 8 bees; 4; bee; 6; bee 5; 12; bee 2 bee は 32 を返します。
この場合、本来の合計値である24に、'8 bees'の先頭にある「8」と、'bee 5'の末尾にある「5」が加算され、32となります。しかし、'bee 2 bee'の中に完全に取り込まれている「2」はカウントされません。"
"list.tr(inStr, outStr)",Function,Item,Data manipulation,source context dependent,false,5.7.0,Baseline,,,,2,true,true,false,false,false,false,false,false,false,,false,"list.tr(inStr, outStr)
This operator allows simple single character string manipulation on a List- or Set-type list. It computes a new list, copying each character of the source list but converting any characters in inStr to the corresponding characters in outStr. For example:
	$MyList = $MyList.tr(""a"",""A""); 
returns a copy of $MyList in which every ""a"" is converted to ""A"".
Backslash characters must be quoted and escaped:
	$MyList = $MyList(""c"",""\\r""); 
converts every ""c"" to a Macintosh newline characters (\r) . Note the need in this context for an extra backslash escape (so Tinderbox knows the intended swap value is ""\r"" and not ""r"").
For further information, see the macOS X man page for the UNIX tr command.","list.tr(inStr, outStr)
このオペレータは、List型またはSet型のリストに対して、単純な1文字単位の文字列操作を可能にします。ソースリストの各文字をコピーしながら、inStrに含まれる文字をoutStrの対応する文字に変換した新しいリストを算出します。
例：
	$MyList = $MyList.tr(""a"",""A""); 
は、すべての ""a"" が ""A"" に変換された $MyList のコピーを返します。
バックスラッシュ文字は引用符で囲み、エスケープする必要があります：
	$MyList = $MyList.tr(""c"",""\\r""); 
は、すべての ""c"" をMacintoshの改行文字（\r）に変換します。このコンテキストでは、追加のバックスラッシュによるエスケープが必要であることに注意してください（これにより、Tinderboxは意図された置換値が ""r"" ではなく ""\r"" であることを認識します）。
詳細については、UNIXのtrコマンドに関するmacOS Xのmanページを参照してください。"
List.unique(),Function,Item,Data manipulation,List,false,5.8.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"List.unique()
List.unique
This returns List-type data of the unique values in the list, as a sorted but de-duped list. Hitherto, de-duping required passing data into a Set-type attribute and back. For the same reason this operator really only makes sense to use on List-type lists as a Set cannot support duplicate items. Trailing parentheses are optional for this function.
Be aware that this function results in a case insensitive A-Z sort, thus not 'bee;ant;cow' as might otherwise be assumed (to get such an outcome see further below). For example, if $MyList is 'bee;ant;cow;bee':
	$MyList = $MyList.unique; 
results in a list value 'ant;bee;cow'. 
The function can be chained with .sort-type actions and .reverse.
	$MyList = $MyList(""Another note"").unique; 
	$SomeList = collect(children, $MyNumberList).unique.nsort; 
	$MyList = collect(children, $MyList).unique.reverse; 
The last above sets $MyList to a list of all the unique, discrete, values to be found in $MyList in every child of the current note. Use with collect() or collect_if() to act on a particular attribute across a group of notes. If a collect() with query scope is the designator 'all' the result will be every discrete value for the referenced list attribute across the whole document.
This function does not apply to Set-type lists because Sets automatically de-duplicate items so are always a list of unique values.
De-duping a list whilst retaining original sort order
The basic method is this:
   $MyList.each(anItem){
      if(!$MyList2.contains(anItem)){
         $MyList2+=anItem;
      }
   };
If is it desired to de-dupe $MyList back to itself, use a list-type variable:
   var:list vList;
   $MyList.each(anItem){
      if(!vList.contains(anItem)){
         vList+=anItem;
      }
   };
   $MyList = vList;
A further consideration is whether the tested list's items are in varying case ('ant' vs. 'Ant' vs. 'ANT' etc.). For instance, to take a mixed case list with duplicates and end up with a de-duped all-lowercase version, use:
   var:list vList;
   $MyList.lowercase.each(anItem){
      if(!vList.contains(anItem)){
         vList+=anItem;
      }
   };
   $MyList = vList;
Resulting order
.unique() preserves the order of elements in a list. Originally, this operator forced an A-Z order, but this was not ideal as one feature of List-type lists is that they allow duplicates do not auto-sort—unlike Set-type lists). Thus now:
	""C:A;A;B"".unique;  
now returns ""C;A;B"" (previously it would have been ""A;B;C"", destroying the original ordering). The output retains the first-occurring item, by list order, of any list value. The underlying assumptions is dupes gat added to the end of the list so the first occurrence is the desired item.","List.unique()
List.unique
リスト内のユニークな（重複しない）値を、重複を除去したリストとして返します。これまで、重複を除去するにはデータを一度Set型のアトリビュートに渡してから戻す必要がありました。Set型はもともと重複をサポートしていないため、このオペレーターはList型のリストに対して使用する場合にのみ意味を持ちます。この関数では、末尾の括弧は省略可能です。

この関数は、大文字小文字を区別しないA-Z順のソート結果を返します。そのため、例えば 'bee;ant;cow' という順序が維持されるとは限りません（順序を維持する方法については後述します）。例えば、$MyList が 'bee;ant;cow;bee' の場合：
	$MyList = $MyList.unique; 
は、'ant;bee;cow' という値を返します。

この関数は、.sort系のアクションや .reverse と連結（チェーン）させることができます。
	$MyList = $MyList(""Another note"").unique; 
	$SomeList = collect(children, $MyNumberList).unique.nsort; 
	$MyList = collect(children, $MyList).unique.reverse; 
上記の最後の例では、$MyList に、現在のノートのすべての子ノートにおける $MyList の全ユニーク値が設定されます。特定のグループのノートにわたって特定のアトリビュートを対象とするには、collect() や collect_if() と組み合わせて使用します。collect() のスコープにデザインキー 'all' を指定すると、ドキュメント全体の指定されたリストアトリビュートに含まれるすべての個別の値が取得されます。

Set型のリストは自動的に重複が除去され、常にユニークな値のリストになるため、この関数はSet型には適用されません。

元のソート順を維持したまま重複を除去する方法
基本的な手法は以下の通りです：
   $MyList.each(anItem){
      if(!$MyList2.contains(anItem)){
         $MyList2+=anItem;
      }
   };
$MyList 自身に対して重複除去を行いたい場合は、list型の変数を使用します：
   var:list vList;
   $MyList.each(anItem){
      if(!vList.contains(anItem)){
         vList+=anItem;
      }
   };
   $MyList = vList;

また、リスト内の項目の大文字小文字が混在している（'ant'、'Ant'、'ANT' など）場合も考慮が必要です。例えば、大文字小文字が混在するリストから重複を除去し、すべて小文字に変換した結果を得るには、以下のように記述します：
   var:list vList;
   $MyList.lowercase.each(anItem){
      if(!vList.contains(anItem)){
         vList+=anItem;
      }
   };
   $MyList = vList;

結果の並び順
現在の仕様では、.unique() はリスト内の要素の順序を維持します。当初、このオペレーターは A-Z 順のソートを強制していましたが、List型のリストの特徴が「重複を許容し、自動ソートされない（Set型とは異なる）」ことであることを踏まえ、仕様が変更されました。したがって現在は：
	""C;A;A;B"".unique; 
は ""C;A;B"" を返します（以前は ""A;B;C"" となり、元の順序が失われていました）。出力は、リスト内で最初に出現した項目の順序を保持します。これは、重複分は通常リストの末尾に追加されるため、最初に出現したものが望ましい項目であるという想定に基づいています。"
list(expressionList),Function,Item,Data manipulation,List,false,5.10.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"list(expressionList)
This function returns a List as the evaluated format of each of its comma-delimited argument list of expressions.
Expression arguments can be:
* Literal values: Fred though there is little point in using these unless the list is subsequently to be concatenated to a String.
* Basic literal operations ""Fred""+"" "" +Smith"".
* Arithmetic operations: 6/2.
* Attributes (values) both system e.g. $Name and user attributes e.g. $MyNumber.
* Action operators sqrt(2).
* Action code expressions, as in whole code expressions ""Date: ""+date(""today"").format(""*"").
The function is also useful as a method of assembling lists of attributes or expressions for action functions using lists such as count(), max() and min():
	FAILS: $MyDate = max($MyDateA,$MyDateB,$MyDateC);
The latter fails as max() interprets the list as 3 literal strings ""$MyDateA"", etc., and does a lexical sort on those values. However:
	WORKS: $MyDate = max(list($MyDateA,$MyDateB,$MyDateC));
Functions creating lists (sum(), links(), collect(), etc.) do not have the same problems with the likes of max as the former output a valid list that can be used directly. For instance:
	WORKS: $MyDate = max(links.outbound.attended.$MyDate);
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression, e.g. list(eval(expressionA),eval(expressionB)).
Examples
This returns a list of numbers resulting from simple evaluations:
	Code: list(4+5,9-3,100/2.5)
	Output value, a list: 
This example, this makes a single evaluated string out of a list of two expressions:
	Code: list(""This note 's $Width is ""+$Width, ""the $Xpos is ""+$Xpos).format("" and "")+""!"")
	Output value, a string:  
This example is not overly complex but points to how list() can be used in constructing output strings/lists that are otherwise difficult to create. The more complex the expressions passed to list() the greater the likelihood of getting no output, or an unexpected one. If complex inputs do not work consider using more parentheses to help TB figure the order of sub-task execution or else put the result of expressions into new attributes and then pass the value of the latter into list() as an argument.","list(expressionList)
この関数は、カンマ区切りの引数リストにある各式を評価した結果をリストとして返します。
式の引数には以下のものが使用できます：
* リテラル値：Fred。ただし、リストを後で文字列に連結する場合を除き、これらを使用する利点はほとんどありません。
* 基本的なリテラル操作：""Fred"" + "" "" + ""Smith""。
* 算術演算：6/2。
* 属性（値）：$Name などのシステム属性、および $MyNumber などのユーザー属性。
* アクション・オペレーター：sqrt(2)。
* アクションコード式：""Date: "" + date(""today"").format(""*"") のような完全なコード式。

この関数は、count()、max()、min() などのリストを使用するアクション関数に、属性や式をリストとしてまとめて渡す方法としても有用です：
	失敗例：$MyDate = max($MyDateA,$MyDateB,$MyDateC);
後者の例が失敗するのは、max() がこの引数リストを ""$MyDateA"" などの3つのリテラル文字列として解釈し、それらの値に対して辞書順のソートを行うためです。しかし、以下の場合は動作します：
	成功例：$MyDate = max(list($MyDateA,$MyDateB,$MyDateC));
リストを作成する関数（sum()、links()、collect() など）は、有効なリストを出力し、それを直接使用できるため、max などで同様の問題は発生しません。例えば、以下のようになります：
	成功例：$MyDate = max(links.outbound.attended.$MyDate);
リスト項目がアクションコード式であるような、より複雑な例では、各項目の式を eval() でラップする必要があるかもしれません（例：list(eval(expressionA), eval(expressionB))）。

例
以下は、単純な評価から得られる数値のリストを返します：
	コード：list(4+5,9-3,100/2.5)
	出力値（リスト）：9;6;40
この例では、2つの式からなるリストから1つの評価済み文字列を作成します：
	コード：list(""This note 's $Width is ""+$Width, ""the $Xpos is ""+$Xpos).format("" and "")+""!""
	出力値（文字列）：This note 's $Width is 3 and the $Xpos is 4!
この例はそれほど複雑ではありませんが、list() を使用して、他の方法では作成が困難な出力文字列やリストを構成する方法を示しています。list() に渡す式が複雑になるほど、出力が得られなかったり、予期しない結果になったりする可能性が高くなります。複雑な入力が機能しない場合は、括弧をさらに使用して Tinderbox がサブタスクの実行順序を判断しやすくするか、あるいは式の結果を新しい属性に入れてから、その属性の値を引数として list() に渡すことを検討してください。"
list[itemNum],Function,List,"Dictionary, Set & List operations",source context dependent,false,9.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"list[itemNum]
sourceNum is the zero-based item number in the referenced List- or Set-type list.
Elements in lists, sets, may be extracted (referenced) with the bracket operator:
	$MyList[1] 
This has the same effect as list.at( ), but may be more convenient. Both 
	$MyList[1] 
	$MyList.at(1) 
Returns the second list item (as list item addresses are zero-based).
This syntax can also assign values to specific elements of lists. For example,
	$MyList=[apple; pear; plum; cherry]; 
	$MyList[1]=""persimmon""; 
Will replace ""pear"" with ""persimmon"".
Nested lists
	MyList = [cow;bee;[fish;whale];ant] 
	$MyList[2][1] gives ""whale""","list[itemNum]
sourceNum は、参照される List 型または Set 型リストにおける 0 から始まる要素番号です。
List 型や Set 型の要素は、ブラケット（角括弧）演算子を使用して抽出（参照）できます：
	$MyList[1]
これは list.at() と同じ効果がありますが、より便利な場合があります。
	$MyList[1]
	$MyList.at(1)
これらはいずれも、リストの 2 番目の項目を返します（リスト項目のアドレスは 0 から始まるため）。
この構文は、リストの特定の要素に値を代入するためにも使用できます。例えば：
	$MyList=[apple; pear; plum; cherry];
	$MyList[1]=""persimmon"";
これは ""pear"" を ""persimmon"" に置き換えます。
入れ子になったリスト（Nested lists）
	MyList = [cow;bee;[fish;whale];ant]
	$MyList[2][1] は ""whale"" を返します。"
locale([localeCodeStr]),Function,Document,Date-time,success boolean,false,6.0.0,Baseline,,,,1,false,false,false,false,false,false,false,false,false,,false,"locale(localeCodeStr)
locale(), allows changing of the locale used to translate dates. The same date can be written in a different format in different parts of the world. For example, in the USA a date is written 12/1/2006 to denote December 1, whereas in UK the same date is written 1/12/2006 and so on for variations around the world.
To read the current host OS' locale, call the operator with no argument:
	$MyString = locale(); 
To set a locale, e.g. here for 'British English', pass the desired locale's code value as localeCodeStr;
	locale(""en_GB"") 
Locale codes begin with a two-letter language code, followed by and underscore and a two-letter region code. These are ISO standards ISO-639 and ISO-3166 respectively. Code combinations are available for any language supported by macOS.
To read, or return to, the user's preferred locale, i.e. is derived from their Mac's OS account, use
	$MyString = locale(); 
You may also save the old locale in an attribute for subsequent use. For example:
	$OldLocale=locale(""en_GB""); 
	…do various things, and then reset the original locale…
	locale($OldLocale); 
	… if simple call locale() with no argument if the host OS locale had remained unchanged.
Note that changing the locale() can be fairly time-consuming, as lots of machinery must be torn down and rebuilt for each change.","locale(localeCodeStr)
locale() は、日付の変換に使用されるロケールを変更することができます。同じ日付でも、世界の地域によって書き方が異なる場合があります。例えば、米国では12月1日を 12/1/2006 と書きますが、英国では同じ日付を 1/12/2006 と書き、世界各地でさまざまなバリエーションが存在します。
現在のホストOSのロケールを読み取るには、引数なしで演算子を呼び出します：
	$MyString = locale();
ロケールを設定するには（例えば「イギリス英語」に設定する場合）、目的のロケールコード値を localeCodeStr として渡します：
	locale(""en_GB"")
ロケールコードは、2文字の言語コードで始まり、アンダースコア、2文字のリージョン（地域）コードが続きます。これらはそれぞれ ISO 規格の ISO-639 および ISO-3166 です。macOS でサポートされているすべての言語でコードの組み合わせが利用可能です。
ユーザーの優先ロケール（Mac の OS アカウントの設定から派生したもの）を読み取る、またはそこに戻すには、次のように使用します：
	$MyString = locale();
また、後で使用するために古いロケールを属性に保存しておくこともできます。例えば：
	$OldLocale=locale(""en_GB"");
	…さまざまな処理を行い、その後に元のロケールにリセットします…
	locale($OldLocale);
	…ホストOSのロケールが変更されていなければ、引数なしで単に locale() を呼び出すこともできます。
locale() の変更は、変更のたびに多くの内部機構を破棄して再構築する必要があるため、かなり時間がかかる可能性があることに注意してください。"
log(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"log(sourceNum)
The operator log() computes the natural logarithm of its sourceNum number, which should be a number, a numeric attribute, or an expression that can be interpreted as a number.
	$MyNumber = log(3); 
returns '1.098612289' for an input of 3.","log(sourceNum)
log() オペレータは、引数 sourceNum の自然対数を計算します。sourceNum は数値、数値属性、または数値として解釈できる式である必要があります。
	$MyNumber = log(3); 
入力が 3 の場合、'1.098612289' を返します。"
lowercase(dataStr),Function,Item,Formatting,String,false,4.6.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"lowercase(dataStr)
The contents of text dataStr are returned entirely in lower case.
If $MyString is ""Hello World"":
	$MyString = lowercase($MyString); 
would set $MyString to ""hello world"".
Functionally equivalent to String.lowercase().","lowercase(dataStr)
テキストdataStrの内容をすべて小文字で返します。
$MyStringが""Hello World""の場合：
	$MyString = lowercase($MyString); 
は$MyStringを""hello world""に設定します。
機能的にはString.lowercase()と同等です。"
max(numberList),Function,List,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"max(numberList)
The max() operator returns the largest item in a list or the values or a List or Set data type attribute. As it operates off a list it may be more convenient to use the newer list.max() chained operator.
Both the operators max() and min() use lexical comparison in most cases, but numeric comparison if the context is numeric (i.e. the reference is a Number-type attribute) and/or all list items are numbers. Thus:
	$Width=max(""1;100;2""); 
Since ""Width"" is numeric, max() will be return 100. 
	$Name=max(""1;100;2""); 
Since the attribute ""Name"" is a string, max() will return 2.
If without a list, create one on the fly using list(), collect() or collect_if():
	$MyMax = max(list($DateA,$DateB,$DateC)); 
	$MyMax = max(collect(descendants,$Modified)); 
	$MyMax = max(collect_if(all,$MyNum>0,$MyNum)); 
This allows export via value:
	value(max(collect(descendants,$Modified))) 
To use max() with a list of expressions, use list():
	Works: $MyNumber = max(list(4+2,9+6)); (output: 15)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Using lists of dates
When using Date-type data bear in mind that the defaults for an unset Date attribute is ""never"" and that ""never"" is treated as sorting always before (i.e. less than) any set date. So to use min() with dates, filter out the unset values, whereas with max() it is not needed:
	$MyMax = max(collect_if(descendants,$Modified)); 
	$MyMin = min(collect_if(descendants,($Modified!=""never""),$Modified));","max(numberList)
max()オペレータは、リスト内の最大の項目、またはList型もしくはSet型の属性の値を返します。リストを対象として動作するため、新しいドット連結形式の list.max() オペレータを使用する方が便利な場合があります。
max()とmin()の両方のオペレータは、ほとんどの場合、辞書式比較を使用しますが、コンテキストが数値である場合（つまり、参照先がNumber型の属性である場合）、および/またはリストのすべての項目が数値である場合は、数値比較を使用します。したがって：
	$Width=max(""1;100;2""); 
$Widthは数値型であるため、max()は100を返します。
	$Name=max(""1;100;2""); 
$Nameは文字列型であるため、max()は2を返します。
リストがない場合は、list()、collect()、またはcollect_if()を使用して、その場でリストを作成します：
	$MyMax = max(list($DateA,$DateB,$DateC)); 
	$MyMax = max(collect(descendants,$Modified)); 
	$MyMax = max(collect_if(all,$MyNum>0,$MyNum)); 
これにより、value()を介したエクスポートが可能になります：
	value(max(collect(descendants,$Modified))) 
式のリストでmax()を使用するには、list()を使用します：
	動作例: $MyNumber = max(list(4+2,9+6)); (出力: 15)
リスト項目がアクションコードの式であるような、より複雑な例では、各リスト項目の式をeval()でラップする必要がある場合があります（例：list(eval(expressionA), eval(expressionB))）。
日付リストの使用
Date型のデータを使用する場合、未設定の日付属性のデフォルト値は ""never"" であり、 ""never"" は常に設定された日付よりも前（つまり、より小さい）として扱われることに注意してください。そのため、日付でmin()を使用する場合は未設定の値を除外する必要がありますが、max()ではその必要はありません：
	$MyMax = max(collect_if(descendants,$Modified)); 
	$MyMin = min(collect_if(descendants,($Modified!=""never""),$Modified));"
min(numberList),Function,List,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"min(numberList)
The min() operator returns the smallest item in a list or the values of a List or Set data type attribute. As it operates off a list it may be more convenient to use the newer list.min() chained operator.
Both the operators max() and min() use lexical comparison in most cases, but numeric comparison if the context is numeric (i.e. the reference is a Number-type attribute) and/or all list items are numbers. Thus:
	$Width=min(""100;2;70""); 
Since ""Width"" is numeric, min() will be return 2. 
	$Name=min(""100;2;70""); 
Since the attribute ""Name"" is a string, min() will return 100.
If without a list, create one on the fly using list(), collect() or collect_if():
	$FistDate = min(list($DateA,$DateB,$DateC)); 
	$MyMin = min(collect(descendants, $Modified)); 
	$MyMin = min(collect_if(all,$MyNum>0,$MyNum)); 
This allows export via value:
	value(min(collect(descendants,$Modified))) 
To use min() with a list of items that are attributes or expressions, use list():
	Works: $MyNumber = min(list(4+2,9+6)); (output: 6)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Using lists of dates
When using Date-type data bear in mind that the defaults for an unset Date attribute is ""never"" and that ""never"" is treated as sorting always before (i.e. less than) any set date. So to use min() with dates, filter out the unset values, whereas with max() it is not needed:
	$MyMax = max(collect_if(descendants,$Modified)); 
	$MyMin = min(collect_if(descendants,($Modified!=""never""),$Modified));","min(numberList)
min()オペレータは、リスト内の最小の項目、またはList型やSet型属性の値を返します。リストに対して動作するため、新しいlist.min()ドット演算子（chained operator）を使用した方が便利な場合もあります。
max()とmin()の両オペレータは、ほとんどの場合で辞書順比較を行いますが、コンテキストが数値である場合（例：参照先がNumber型属性である場合）や、リストの全項目が数値である場合には数値比較を行います。したがって：
	$Width=min(""100;2;70""); 
""Width""は数値型であるため、min()は2を返します。
	$Name=min(""100;2;70""); 
属性""Name""は文字列型であるため、min()は100を返します。
リストが手元にない場合は、list()、collect()、またはcollect_if()を使用して、その場でリストを作成します：
	$FistDate = min(list($DateA,$DateB,$DateC)); 
	$MyMin = min(collect(descendants, $Modified)); 
	$MyMin = min(collect_if(all,$MyNum>0,$MyNum)); 
これにより、value()経由でエクスポートすることも可能です：
	value(min(collect(descendants,$Modified))) 
属性や式を含む項目のリストでmin()を使用するには、list()を使用します：
	動作例: $MyNumber = min(list(4+2,9+6)); (出力: 6)
リストの項目がアクションコードの式であるような、より複雑な例では、各項目の式をeval()でラップする必要がある場合があります（例：list(eval(expressionA),eval(expressionB))）。
日付リストの使用
Date型のデータを使用する場合、未設定の日付属性のデフォルトは""never""であり、""never""は常に任意の日付よりも前（つまり、より小さい）として扱われることに注意してください。そのため、日付でmin()を使用する場合は未設定の値をフィルタリングする必要がありますが、max()ではその必要はありません：
	$MyMax = max(collect_if(descendants,$Modified)); 
	$MyMin = min(collect_if(descendants,($Modified!=""never""),$Modified));"
"minute(aDate, minutesNum)",Function,Item,Date-time,Date,false,5.7.0,Baseline,,,,2,true,false,true,false,false,false,false,false,false,,false,"minute(aDate, minutesNum)
creates a new date based on the aDate expression, but in which the minute is minutesNum. The source Date is not changed unless aDate is an attribute and the attribute is re-setting itself:
	$MyDateA = minute($MyDate,14); $MyDate is not changed
	$MyDate = minute($MyDate,14); $MyDate is changed
Examples. If $MyDate is 4 July 2009 09:30, then 
	$MyDateA=minute($MyDate,5); 
will change $MyDate to 4 July 2009 19:05 whilst leaving $MyDate as 4 July 2009 09:30. However, if the code is self-referring:
	$MyDate=minute($MyDate,5); 
will change $MyDate to 4 July 2009 19:05.
Take care using the later self-referring form in a $Rule or agent as it fires every agent update cycle adding 5 minutes each time! Make sure you use a guard agent or conditional query to make the action out of scope after the first application. Or, consider using a Stamp, which only fires once per (manual) application.
The single-argument method that reads the minutes value is documented separately: see minute(Date).","minute(aDate, minutesNum)
aDate式に基づき、分をminutesNumに設定した新しい日付を作成します。aDateが属性であり、その属性自体に再代入しない限り、元のDateは変更されません。
	$MyDateA = minute($MyDate,14); // $MyDate は変更されません
	$MyDate = minute($MyDate,14); // $MyDate は変更されます
例：$MyDate が 2009年7月4日 09:30 の場合、
	$MyDateA=minute($MyDate,5); 
は、$MyDate を 2009年7月4日 09:30 のまま保ちつつ、$MyDateA を 2009年7月4日 19:05 に変更します。しかし、コードが自己参照している場合：
	$MyDate=minute($MyDate,5); 
は $MyDate を 2009年7月4日 19:05 に変更します。
後者の自己参照形式を $Rule やエージェントで使用する場合は注意してください。エージェントの更新サイクルごとに実行され、そのたびに5分が加算されます！ 初回の適用後にアクションが対象外になるよう、ガード・エージェントや条件付きクエリを必ず使用してください。あるいは、1回（手動）の適用につき1回だけ実行されるスタンプ（Stamp）の使用を検討してください。
分の値を読み取る単一引数のメソッドは別途ドキュメント化されています：minute(Date) を参照してください。"
minute(aDate),Function,Item,Date-time,Number,false,5.7.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"minute(aDate)
returns the hour element from the aDate date/time expression, which may simply be a date-type attribute value.
Alternatively, use Date.minute.
The two-argument method used to set Dates is documented separately: see minute(aDate, minutesNum).","I will translate the text into Japanese as requested, noting the likely typo in the original English (""hour element"" instead of ""minute element"").

minute(aDate)
aDate 日付/時刻式（単に日付型属性値である場合もあります）から分の要素を返します。
あるいは、Date.minute を使用してください。
日付を設定するために使用される2引数の形式については、別にドキュメント化されています。minute(aDate, minutesNum) を参照してください。"
"minutes(startDate, endDate)",Function,Item,Date-time,Number,false,5.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"minutes(startDate, endDate) 
returns the Number of whole minutes that elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA has time 12:30 and $DateB has time 14:00, then:
	$MyNumber = minutes($DateA,$DateB); 
sets $MyNumber to 90.
Also see days(date1,date2).","minutes(startDate, endDate)
startDate と endDate の間に経過した整数の分数を返します。endDate が startDate より前の場合は、結果は負の数になります。
$DateA の時刻が 12:30 で、$DateB の時刻が 14:00 の場合：
	$MyNumber = minutes($DateA,$DateB); 
は $MyNumber を 90 に設定します。
days(date1,date2) も参照してください。"
"mod(sourceNum, modulusNum)",Function,Item,Mathematical,Number,false,4.0.1,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"mod(sourceNum, moduloNum)
mod() returns modulo of a number sourceNum as set by number modulusNum, i.e. the integer remainder of sourceNum divided by modulusNum. Thus:
	$MyNumber = mod(11,3); 
sets $MyNumber to 2.","mod(sourceNum, moduloNum)
mod() は、数値 sourceNum を数値 modulusNum で割った時の剰余（整数としての余り）を返します。
例：
	$MyNumber = mod(11,3); 
は $MyNumber に 2 を設定します。"
modifierKeys,Variable,Item,Data manipulation,List,false,11.5.0,11.5.0,,11.5.0,,,false,false,false,false,false,false,false,false,false,,false,"modifierKeys
When processing a stamp, the local variable modifierKeys is set to a list of strings representing the modifier keys the user was pressing when the stamp is executed. For example, a value of  [control;option] indicates that the control and option keys were pressed, and that neither the shift nor the command keys were pressed.",スタンプを処理する際、ローカル変数 modifierKeys には、スタンプが実行されたときにユーザーが押していた修飾キーを表す文字列のリストが設定されます。例えば、[control;option] という値は、control キーと option キーが押されており、shift キーも command キーも押されていなかったことを示します。
"month(aDate, monthsNum)",Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"month(aDate[, monthsNum])
Alternatively, use Date.month.
month(aDate)
returns the month from the aDate date/time expression, which may simply be a date-type attribute value.
month(aDate,monthsNum) 
creates a new date based on the aDate date/time expression, but in which the month is monthsNum. The source Date is not changed unless theDate is an attribute and the attribute is re-setting itself:
	$MyDateA = month($MyDate,14); 
$MyDate is unaltered
	$MyDate = month($MyDate,14); 
$MyDate is changed
Examples. If $MyDate is July 4,2009, then 
	$MyDate=month($MyDate,5); 
will change $MyDate to May 4, 2009.
The single-argument method that reads the months value is documented separately: see month(aDate).","month(aDate[, monthsNum])
あるいは、Date.month を使用してください。

month(aDate)
日付/時刻式 aDate（単なる日付型属性の値でも可）から「月」の値を返します。

month(aDate, monthsNum) 
aDate の日付/時刻式に基づき、月を monthsNum に指定した値に書き換えた新しい日付を作成します。aDate が属性であり、その属性自体に結果を再代入（自己更新）しない限り、元の aDate は変更されません。

	$MyDateA = month($MyDate,14); 
$MyDate は変更されません。
	$MyDate = month($MyDate,14); 
$MyDate は変更されます。

例：$MyDate が2009年7月4日の場合、
	$MyDate=month($MyDate,5); 
は、$MyDate を2009年5月4日に変更します。

「月」の値を読み取る引数1つのメソッドについては、別途 month(aDate) で解説されています。"
month(aDate),Function,Item,Date-time,Number,false,4.0.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"month(aDate)
returns the month from the aDate date/time expression, which may simply be a date-type attribute value.
Alternatively, use Date.month.
The two-argument form used to set Dates is documented separately: see month(aDate, monthsNum).","month(aDate)
日付/時刻式 aDate（単なる日付型属性の値でも可）から「月」の値を返します。
あるいは、Date.month を使用してください。
日付を設定するための引数2つの形式については、別途 month(aDate, monthsNum) で解説されています。"
"months(startDate, endDate)",Function,Item,Date-time,Number,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"months(startDate, endDate) 
returns the Number of whole months that have elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA is 3 January 2016 and $DateB is 9 April 2016, then:
	$MyNumber = months($DateA,$DateB); 
sets $MyNumber to 4.
Also see days(date1,date2).","months(startDate, endDate)
startDateからendDateまでに経過した整数の月数を返します。endDateがstartDateよりも前の日付の場合、結果は負の値になります。
$DateAが2016年1月3日で、$DateBが2016年4月9日の場合：
	$MyNumber = months($DateA,$DateB); 
は、$MyNumberに4をセットします。
days(date1,date2)も参照してください。"
"neighbors(scope, distanceNum[, linkTypeStr])",Function,Group,Data manipulation,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"neighbors(scope, distanceNum)
Returns a list of the path(s) of all those notes that can be reached by following exactly distanceNum links outward from the designated note or notes. Only the shortest possible path between two notes is considered. The operator will report links from the source node to itself, i.e. self-links. Prototype-type links are ignored. For example:
	$MyList  = neighbors(this, 3); 
Returns the set of notes that are connected from this note by exactly three (outbound) links.
neighbors(scope, distanceNum, linkTypeStr)
Returns the set of notes that are connected by exactly distanceNum links outward from the designated note or notes, but within those links considering only links of the specified link type linkTypeStr to filter on unnamed links use the type ""*untitled"".For example:
	$MyList  = neighbors(children, 2, ""example""); 
Returns the set of notes that are connected from any of this note's children by exactly two (outbound) links of the link type ""example"".
Different variations of 'neighbor' operators
There are essentially two different subtypes within the 4 operators:
* Direction. If the operator name includes a '2' the direction of connecting links are ignored. Otherwise, only outbound links are assessed.
* Distance. If the operator name includes 'Within' then all notes at distances between 1 and distanceNum are considered. Otherwise, only notes at exactly distanceNum are considered.","neighbors(scope, distanceNum)
指定されたノートから、外向きのリンク（外部リンク）を正確に distanceNum 個辿ることで到達可能なすべてのノートのパスのリストを返します。2つのノート間の最短経路のみが考慮されます。このオペレーターは、元のノードから自身へのリンク（セルフリンク）も報告します。プロトタイプ形式のリンクは無視されます。例：
	$MyList = neighbors(this, 3); 
このノートから正確に3つの外向きリンクで接続されているノートのセットを返します。

neighbors(scope, distanceNum, linkTypeStr)
指定されたノートから、外向きのリンクを正確に distanceNum 個辿ることで到達可能なノートのセットを返します。ただし、指定されたリンクタイプ linkTypeStr のリンクのみを考慮します。名前のないリンクをフィルタリングするには、タイプに ""*untitled"" を使用します。例：
	$MyList = neighbors(children, 2, ""example""); 
このノートのいずれかの子ノートから、""example"" というリンクタイプの外向きリンクを正確に2個辿って接続されているノートのセットを返します。

「neighbor」オペレーターのバリエーション
4つのオペレーターには、本質的に2つの異なるサブタイプがあります。
* 方向：オペレーター名に「2」が含まれている場合、接続リンクの方向は無視されます。それ以外の場合は、外向きのリンクのみが評価されます。
* 距離：オペレーター名に「Within」が含まれている場合、距離1から distanceNum までのすべてのノートが考慮されます。それ以外の場合は、正確に distanceNum の距離にあるノートのみが考慮されます。"
"neighbors2(scope, distanceNum[, linkTypeStr])",Function,Group,Data manipulation,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"neighbors2(scope, distanceNum)
Returns a list of the path(s) of all those notes that can be reached by following exactly distanceNum links from the designated note or notes, regardless of the direction of those links (i.e. whether inbound or outbound). Only the shortest possible path between two notes is considered. The operator will report links from the source node to itself, i.e. self-links. Prototype-type links are ignored. For example:
	$MyList  = neighbors2(this, 3); 
Returns the set of notes that are connected from this note by exactly three links of either direction.
neighbors2(scope, distanceNum, linkTypeStr)
Returns the set of notes that are connected by exactly distanceNum links from the designated note or notes, regardless of the direction of a link (i.e. whether inbound or outbound) and within those links considering only links of the specified link type linkTypeStr. Unnamed links are specified as the type ""*untitled"". For example:
	$MyList  = neighbors2(children, 2, ""example""); 
Returns the set of notes that are connected from any of this note's children by exactly two links of any direction but also of the link type ""example"".
Different variations of 'neighbor' operators
There are essentially two different subtypes within the 4 operators:
* Direction. If the operator name includes a '2' the direction of connecting links are ignored. Otherwise, only outbound links are assessed.
* Distance. If the operator name includes 'Within' then all notes at distances between 1 and distanceNum are considered. Otherwise, only notes at exactly distanceNum are considered.","neighbors2(scope, distanceNum)
指定されたノートから、リンクの方向（インバウンドまたはアウトバウンド）に関係なく、正確に distanceNum 個のリンクを辿ることで到達可能なすべてのノートのパスのリストを返します。2つのノート間の最短経路のみが考慮されます。このオペレータは、ソースノードから自身へのリンク（自己リンク）も報告します。プロトタイプ形式のリンクは無視されます。例：
	$MyList = neighbors2(this, 3);
このノートから、方向を問わず正確に3つのリンクで接続されているノートの集合を返します。

neighbors2(scope, distanceNum, linkTypeStr)
指定されたノートから、リンクの方向（インバウンドまたはアウトバウンド）に関係なく、かつ指定されたリンクタイプ linkTypeStr のリンクのみを対象として、正確に distanceNum 個のリンクで接続されているノートの集合を返します。名前のないリンクは、タイプ ""*untitled"" として指定します。例：
	$MyList = neighbors2(children, 2, ""example"");
このノートのいずれかの子から、方向を問わず、かつリンクタイプが ""example"" である正確に2つのリンクで接続されているノートの集合を返します。

'neighbor' オペレータのバリエーション
4つのオペレータには、本質的に2つの異なるサブタイプがあります：
* 方向：オペレータ名に '2' が含まれている場合、リンクの方向は無視されます。含まれていない場合は、アウトバウンド（送信）リンクのみが対象となります。
* 距離：オペレータ名に 'Within' が含まれている場合、距離が 1 から distanceNum までのすべてのノートが考慮されます。含まれていない場合は、正確に distanceNum の距離にあるノートのみが考慮されます。"
"neighbors2Within(scope, distanceNum[, linkTypeStr])",Function,Group,Data manipulation,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"neighbors2Within(scope, distanceNum)
Returns a list of the path(s) of all those notes that can be reached by following between 1 and distanceNum links from the designated note or notes, regardless of the direction of those links (i.e. whether inbound or outbound). Only the shortest possible path between two notes is considered. The operator will report links from the source node to itself, i.e. self-links. Prototype-type links are ignored.
The starting note or notes are considered to be connected to themselves.
For example:
	$MyList  = neighbors2Within(this, 3); 
Returns the set of notes that are connected from this note by between 1–3 (outbound) links.
neighbors2Within(scope, distanceNum, linkType)
Returns the set of notes that are connected by following between 1 and distanceNum links from the designated note or notes, regardless of the direction of those links (i.e. whether inbound or outbound), but within those links considering only links of the specified link type linkTypeStr. 
The starting note or notes are considered to be connected to themselves. To filter on unnamed links use the type ""*untitled"". For example:
	$MyList  = neighbors2Within(children, 2, ""example""); 
Returns the set of notes that are connected from any of this note's children by between 1–2 (outbound) links of the link type ""example"".
Different variations of 'neighbor' operators
There are essentially two different subtypes within the 4 operators:
* Direction. If the operator name includes a '2' the direction of connecting links are ignored. Otherwise, only outbound links are assessed.
* Distance. If the operator name includes 'Within' then all notes at distances between 1 and distanceNum are considered. Otherwise, only notes at exactly distanceNum are considered.","neighbors2Within(scope, distanceNum)
指定されたノート（または複数のノート）から、1からdistanceNum個のリンクを辿って到達できるすべてのノートのパスのリストを返します。その際、リンクの方向（インバウンドかアウトバウンドか）は無視されます。2つのノート間の最短のパスのみが考慮されます。このオペレーターは、ソースノードから自身へのリンク（セルフリンク）も報告します。プロトタイプ形式のリンクは無視されます。
開始ノート（または複数のノート）は、それ自身に接続されていると見なされます。
例：
	$MyList = neighbors2Within(this, 3); 
このノートから1〜3つの（アウトバウンド）リンクで接続されているノートのセットを返します。
neighbors2Within(scope, distanceNum, linkType)
指定されたノート（または複数のノート）から、1からdistanceNum個のリンクを辿って接続されているノートのセットを返します。その際、リンクの方向（インバウンドかアウトバウンドか）は無視されますが、指定されたリンクタイプ linkTypeStr のリンクのみが考慮されます。 
開始ノート（または複数のノート）は、それ自身に接続されていると見なされます。名前のないリンクでフィルタリングするには、タイプ ""*untitled"" を使用します。例：
	$MyList = neighbors2Within(children, 2, ""example""); 
このノートの子のいずれかから、リンクタイプ ""example"" の1〜2つの（アウトバウンド）リンクで接続されているノートのセットを返します。
「neighbor」オペレーターの異なるバリエーション
4つのオペレーターには、実質的に2つの異なるサブタイプがあります：
* 方向：オペレーター名に「2」が含まれている場合、接続するリンクの方向は無視されます。そうでない場合は、アウトバウンドリンクのみが評価されます。
* 距離：オペレーター名に「Within」が含まれている場合、1からdistanceNumまでの距離にあるすべてのノートが考慮されます。そうでない場合は、正確にdistanceNumの距離にあるノートのみが考慮されます。"
"neighborsWithin(scope, distanceNum[, linkTypeStr])",Function,Group,Data manipulation,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"neighborsWithin(scope, distanceNum)
Returns a list of the path(s) of all those notes that can be reached by following between 1 and distanceNum links outward from the designated note or notes. Only the shortest possible path between two notes is considered. The operator will report links from the source node to itself, i.e. self-links. Prototype-type links are ignored.
The starting note or notes are considered to be connected to themselves.
For example:
	$MyList  = neighborsWithin(this, 3); 
Returns the set of notes that are connected from this note by between 1–3 (outbound) links.
neighborsWithin(scope, distanceNum, linkTypeSTr)
Returns the set of notes that are connected by following between 1 and distanceNum links outward from the designated note or notes, but considering only links of the specified link type linkTypeStr. 
The starting note or notes are considered to be connected to themselves. To filter on unnamed links use the type ""*untitled"". For example:
	$MyList  = neighborsWithin(children, 2, ""example""); 
Returns the set of notes that are connected from any of this note's children by between 1–2 (outbound) links of the link type ""example"".
Different variations of 'neighbor' operators
There are essentially two different subtypes within the 4 operators:
* Direction. If the operator name includes a '2' the direction of connecting links are ignored. Otherwise, only outbound links are assessed.
* Distance. If the operator name includes 'Within' then all notes at distances between 1 and distanceNum are considered. Otherwise, only notes at exactly distanceNum are considered.","neighborsWithin(scope, distanceNum)
指定したノートから1回以上、distanceNum回以内のアウトバウンドリンク（外向きのリンク）を辿って到達できるすべてのノートのパスのリストを返します。2つのノート間の最短経路のみが考慮されます。このオペレーターは、ソースノートから自身へのリンク（セルフリンク）も報告します。プロトタイプ型のリンクは無視されます。
開始点となるノートは、自身に接続されているものとみなされます。
例：
	$MyList  = neighborsWithin(this, 3); 
このノートから1〜3回のアウトバウンドリンクで接続されているノートのセットを返します。

neighborsWithin(scope, distanceNum, linkTypeSTr)
指定したノートから1回以上、distanceNum回以内のアウトバウンドリンクを辿って到達できるノートのセットを返しますが、指定されたリンクタイプ linkTypeStr のリンクのみを考慮します。
開始点となるノートは、自身に接続されているものとみなされます。名前のないリンクでフィルタリングするには、タイプに ""*untitled"" を使用します。
例：
	$MyList  = neighborsWithin(children, 2, ""example""); 
このノートのいずれかの子ノートから、""example"" というリンクタイプの1〜2回のアウトバウンドリンクで接続されているノートのセットを返します。

「neighbor」オペレーターの異なるバリエーション
4つのオペレーターには、本質的に2つの異なるサブタイプがあります：
* 方向：オペレーター名に「2」が含まれている場合、接続リンクの方向は無視されます。そうでない場合は、アウトバウンドリンクのみが評価されます。
* 距離：オペレーター名に「Within」が含まれている場合、1から distanceNum の距離にあるすべてのノートが考慮されます。そうでない場合は、ちょうど distanceNum の距離にあるノートのみが考慮されます。"
"notify(headlineStr[, detailsStr, deliveryDateTime ])",Function,Item,Data manipulation,success boolean,false,6.0.0,Baseline,,,,3,true,false,false,false,false,false,false,true,false,,false,"notify(headlineStr[, details, deliveryTime ])
notify() lets notes post notifications to the host Mac's User Notification Center.
headlineStr is a string or string expression, and will be the headline of the notification.
	notify(""Hello world""); 
The optional detailsStr is another string or string expression, and provides an explanation of the notification. 
	notify(""Hello world"", ""Some descriptive text""); 
The optional deliveryDateTime is a date or date expression that represents a delivery time in the future; if this argument is omitted or is already past, the notification is shown immediately.
	notify(""Hello world"", ""Some descriptive text"",date(""now + 1 hour""));","notify(headlineStr[, details, deliveryTime ])
notify() は、ノートからホスト Mac の通知センターに通知を投稿できるようにします。
headlineStr は文字列または文字列式で、通知の見出しになります。
	notify(""Hello world""); 
オプションの detailsStr は別の文字列または文字列式で、通知の説明を提供します。
	notify(""Hello world"", ""Some descriptive text""); 
オプションの deliveryDateTime は、将来の配信日時を表す日付または日付式です。この引数が省略されているか、既に過去である場合、通知は即座に表示されます。
	notify(""Hello world"", ""Some descriptive text"",date(""now + 1 hour""));"
Number.ceil(),Function,Item,Mathematical,Number,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Number.ceil()
Number.ceil() rounds the source number value of sourceNum up to next whole integer.",Number.ceil() は、sourceNum の数値を切り上げて、次の整数にします。
Number.floor(),Function,Item,Mathematical,Number,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Number.floor()
Number.floor() rounds the source number value of sourceNum down to previous whole integer. This is a dot-operator
See also Number.ceil() and Number.round().
If $MyNumber is 3.9 then:
	$MyNumber = $MyNumber.floor(); 
sets $MyNumber to 3. Note unlike normal rounding the value is set downwards to the next integer (i.e. whole number).","Number.floor()
Number.floor() は、sourceNum の数値を直前の整数に切り捨てます。これはドット演算子です。
Number.ceil() および Number.round() も参照してください。
$MyNumber が 3.9 の場合：
	$MyNumber = $MyNumber.floor();
は $MyNumber を 3 に設定します。注意：通常の四捨五入とは異なり、値は下の整数（整数）に切り下げられます。"
"Number.format(decimalsNum[, widthNum, padStr]|formatStr)",Function,Item,Formatting,String,false,5.8.0,Baseline,,,,3,true,true,false,false,false,false,false,true,false,,false,"`Number.format(decimalsNum[, widthNum, padStr])`
`Number.format(formatStr)`

Returns a Number converted to a String, formatted according to the supplied arguments. This function supplements existing precision functions.

### Numeric Configuration
*   **decimalsNum:** Determines the number of decimal places.
*   **widthNum (Optional):** Sets the minimum character width of the returned string.
    *   The result is left-padded so the total length equals `widthNum`.
    *   Total length includes: padding + minus sign (if applicable) + integer digits + decimal point + decimal digits.
    *   Useful for vertically aligning columns of figures.
*   **padStr (Optional):** Specifies the character used for padding (requires `widthNum`). Defaults to a space if omitted.

**Examples:**
*   `$MyNumber.format(2)` (where number is 3.14159) returns `""3.14""`.
*   `$MyNumber.format(2,7)` (where number is 3.14) returns `""   3.14""` (3 spaces + 4 characters).
*   `$MyNumber.format(2,7)` (where number is -3.14) returns `""  -3.14""` (2 spaces + 5 characters).
*   `7.format(0,3,""0"")` returns `""007""`.

**Literal Numbers:**
Can be formatted directly, though enclosing the number in parentheses is recommended for clarity:
*   `(5.14159).format(2)` returns `""5.14""`.

### String Argument Configuration
Alternatively, a specific quoted string code can be passed to apply special formatting based on the OS locale.

*   **""l"" (lowercase L):** Formats using locale-dependent group and decimal delimiters (e.g., US: ""4,562,781.4""; German: ""4.562.781,4"").
*   **""$"":** Formats to local currency with two decimal places and grouping separators (e.g., ""$1,246.88"", ""£1,246.88"").
*   **""$0"":** Formats to local currency rounded to the nearest whole major unit (e.g., ""$1,247"").
*   **""X"":** Converts to Roman numerals (e.g., 3 becomes ""III"").
*   **""o"":** Converts to localized ordinal string (e.g., 3 becomes ""3rd"" in English, ""3e"" in French).","`Number.format(decimalsNum[, widthNum, padStr])`
`Number.format(formatStr)`

数値を文字列に変換し、指定された引数に従って書式設定して返します。この関数は、既存の精度（precision）関数を補完するものです。

### 数値設定
*   **decimalsNum:** 小数点以下の桁数を指定します。
*   **widthNum (オプション):** 返される文字列の最小文字幅を設定します。
    *   結果は、全体の長さが `widthNum` になるように左側にパディングされます。
    *   全体の長さには、パディング、マイナス記号（該当する場合）、整数の桁、小数点、小数の桁が含まれます。
    *   数値の列を垂直方向に揃えるのに便利です。
*   **padStr (オプション):** パディングに使用する文字を指定します（`widthNum` が必要）。省略した場合はスペースがデフォルトとして使用されます。

**例:**
*   `$MyNumber.format(2)` （数値が 3.14159 の場合）は `""3.14""` を返します。
*   `$MyNumber.format(2,7)` （数値が 3.14 の場合）は `""   3.14""` （スペース3つ + 4文字）を返します。
*   `$MyNumber.format(2,7)` （数値が -3.14 の場合）は `""  -3.14""` （スペース2つ + 5文字）を返します。
*   `7.format(0,3,""0"")` は `""007""` を返します。

**数値リテラル:**
数値を直接書式設定することも可能ですが、明確にするために数値を括弧で囲むことが推奨されます。
*   `(5.14159).format(2)` は `""5.14""` を返します。

### 文字列引数設定
あるいは、OS のロケールに基づいた特別な書式を適用するために、特定の引用符で囲まれた文字列コードを渡すことができます。

*   **""l"" (小文字の L):** ロケールに依存したグループ区切り文字および小数点を使用して書式設定します（例：米国: ""4,562,781.4""、ドイツ: ""4.562.781,4""）。
*   **""$"":** 小数点2桁とグループ区切り文字を含む、現地の通貨形式に書式設定します（例: ""$1,246.88""、""£1,246.88""）。
*   **""$0"":** 最も近い主要通貨単位に丸められた、現地の通貨形式に書式設定します（例: ""$1,247""）。
*   **""X"":** ローマ数字に変換します（例: 3 は ""III"" になります）。
*   **""o"":** ロケールに応じた序数文字列に変換します（例: 3 は、英語では ""3rd""、フランス語では ""3e"" になります）。"
Number.precision(decimalsNum),Function,Item,Formatting,Number,false,5.7.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Number.precision(decimalsNum)
This function makes it easier to format numbers. The function returns the associated Number-type attributes value rounded to decimalsNum decimal places as Number-type data.. If $MyNumber is 268.3289 then:
	$MyNumber.precision(2); 
…sets $MyNumber to 268.33, whilst:
	$SomeNumber = $MyNumber.precision(2); 
…sets $OtherNumber to 268.33. The above examples are the equivalent of the older syntax using format():
	format($MyNumber,2); 
Literal numbers, e.g. 3.1415927, can also be worked with:
	$MyNumber = 5.1415927.precision(2); is 5.14
The above works but the following syntax may seem less ambiguous by using parentheses to delimit the literal number:
	$MyNumber =(5.1415927).precision(2); is 5.14
Since Number.precision() was added, format() has been supplemented by a Number.format(). The latter, in single input version equates to Number.precision(). However that Number.format() outputs a String-type, even if that can be coerced back to a number .
The .precision() function can be used to add trailing zeroes to a decimal. If $MyNumber is 214.40, it will display as 214.4 which can be unhelpful if this actually represents £214.40. $MyNumber.precision(2) will return 214.40 but be careful about under-the-hood number/string coercion such as can happen in contexts like $DisplayExpression.
	$MyOtherNumber = $MyNumber.precision(2); gives 214.4
	$MyString = $MyNumber.precision(2); gives ""214.40""
In a $DisplayExpression:
	$MyNumber.precision(2); gives ""214.40""
	 $Name+"" : ""+$MyNumber.precision(2); gives ""214.40""
	$Name+ "" : "" + sum(children,$MyNumber).precision(2); 
It may still be easier to use format() as no extra parentheses are required:
	$Name+ "" : "" + format(sum(children,$MyNumber),2);","Number.precision(decimalsNum)
この関数は、数値のフォーマットを容易にします。関連付けられた数値型（Number-type）属性の値を小数点以下 decimalsNum 桁に四捨五入し、数値型データとして返します。

もし $MyNumber が 268.3289 であれば：
	$MyNumber.precision(2); 
は $MyNumber を 268.33 に設定します。一方：
	$SomeNumber = $MyNumber.precision(2); 
は $SomeNumber（原文の $OtherNumber は誤記と思われます）を 268.33 に設定します。上記の例は、従来の format() を使用した以下の構文と同等です：
	format($MyNumber,2); 

3.1415927 などのリテラルな数値も扱うことができます：
	$MyNumber = 5.1415927.precision(2); は 5.14 になります。
これは動作しますが、次のように括弧を使ってリテラル数値を囲む方が、曖昧さがなく分かりやすいでしょう：
	$MyNumber = (5.1415927).precision(2); は 5.14 になります。

Number.precision() が追加されて以来、format() は Number.format() によって補完されました。後者の単一引数バージョンは Number.precision() と同等です。ただし、Number.format() は（数値に強制変換できる場合であっても）文字列型（String-type）を出力します。

.precision() 関数は、小数の末尾にゼロを追加するために使用できます。$MyNumber が 214.40 の場合、通常は 214.4 と表示されますが、これが金額（例：£214.40）を表す場合には不都合なことがあります。$MyNumber.precision(2) は 214.40 を返しますが、$DisplayExpression のようなコンテキストで発生する可能性のある、内部的な数値と文字列の型変換（coercion）には注意してください。

	$MyOtherNumber = $MyNumber.precision(2); は 214.4 を返します。
	$MyString = $MyNumber.precision(2); は ""214.40"" を返します。

$DisplayExpression 内では：
	$MyNumber.precision(2); は ""214.40"" を返します。
	$Name+"" : ""+$MyNumber.precision(2); は ""214.40"" を返します。
	$Name+ "" : "" + sum(children,$MyNumber).precision(2); 

追加の括弧を必要としない format() を使用する方が、依然として簡単な場合があります：
	$Name+ "" : "" + format(sum(children,$MyNumber),2);"
Number.round(),Function,Item,Mathematical,Number,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Number.round()
Number.round() rounds the value of its chained source number argument to the nearest integer. A partial integer over .50 always round up, everything else rounds down.
See round() for a fuller explanation of the logic and possible usage.
See also Number.ceil() and Number.floor().","Number.round() は、ドット演算子で繋がれた元の数値の値を、最も近い整数に丸めます。小数点以下が .50 を超える場合は常に切り上げられ、それ以外は切り捨てられます。
ロジックと使用方法の詳細については、round() を参照してください。
Number.ceil() および Number.floor() も参照してください。"
"originalLinkedFrom(scope[, linkTypeStr])",Function,Item,Query Boolean,boolean test,false,8.0.0,Baseline,,,,1,true,false,false,false,false,true,false,true,false,true,false,"originalLinkedFrom(scope[,linkTypeStr])
A test for inbound links. This returns true if the current note corresponding to this is linked from the designated scope, i.e. an item or group of items (defining scope); this is optionally filtered to only links of type linkTypeStr. Put another way, ""Does an inbound link exist to the original current note from item(s)?"". This is especially useful in agents, where this is bound to an alias owned by the agent but the user is interested in links to the original note.
This is effectively only a query term, it returns a Boolean. If you are trying to collect data about the linked note(s), use links() instead.
Ways to define item. The item argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString.
Ways to define group. In group scope, a wildcard ""*"" designator matches all notes and replaces the normal ""all"" group designator.
Links of type 'prototype' are ignored. If using linkType, you must use the value ""*untitled"" to match an 'untitled' type link (rather than """" or ""untitled"").
Thus, to test if any original note using the 'Event' prototype has an inbound link of the 'untitled' link type the agent query would be:
	$Prototype==""Event"" & originalLinkedFrom(""*"", ""*untitled"");  
The logical opposite of this test is originalLinkedTo().","originalLinkedFrom(scope[,linkTypeStr])

受信リンクを判定するテストです。this に対応する現在のノートが、指定されたスコープ（アイテムまたはアイテムのグループ）からリンクされている場合に true を返します。オプションとして、リンクタイプ（linkTypeStr）でフィルタリングすることも可能です。言い換えれば、「指定されたアイテムから現在のノートのオリジナルへの受信リンクが存在するか？」を確認します。これは特にエージェントで有用です。エージェント内では this はエージェントが生成したエイリアスを指しますが、ユーザーはオリジナルノートへのリンクを調べたい場合が多いからです。

これは実質的にクエリ専用の関数であり、真偽値（Boolean）を返します。リンクされたノートに関するデータを収集したい場合は、代わりに links() を使用してください。

アイテム（item）の指定方法。item 引数は、属性参照（例：$MyString）でない限り、引用符で囲む必要があります（例：""Some note""）。
グループ（group）の指定方法。グループスコープでは、ワイルドカード ""*"" 指定子がすべてのノートに一致し、通常の ""all"" グループ指定子に代わって使用されます。

リンクタイプが 'prototype' のものは無視されます。linkType を使用する場合、'untitled' タイプのリンクに一致させるには（"""" や ""untitled"" ではなく）""*untitled"" という値を使用する必要があります。

したがって、'Event' プロトタイプを使用しているオリジナルノートに 'untitled' リンクタイプの受信リンクがあるかどうかを判定するエージェントクエリは次のようになります：
	$Prototype==""Event"" & originalLinkedFrom(""*"", ""*untitled"");  

このテストの論理的な反対は originalLinkedTo() です。"
"originalLinkedTo(scope[, linkTypeStr])",Function,Item,Query Boolean,boolean test,false,8.0.0,Baseline,,,,1,true,false,false,false,false,true,false,true,false,true,false,"originalLinkedTo(scope[,linkTypeStr])
A test for outbound links. This returns true if the current note corresponding to this is linked from the designated scope, i.e. an item or group of items (defining scope); this is optionally filtered to only links of type linkTypeStr. Put another way, ""Does an outbound link exist from the original current note to item(s)?"". This is especially useful in agents, where this is bound to an alias owned by the agent but the user is interested in links to the original note.
This is effectively only a query term, it returns a Boolean. If you are trying to collect data about the linked note(s), use links() instead.
Ways to define item. The item argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString.
Ways to define group. In group scope, a wildcard ""*"" designator matches all notes and replaces the normal ""all"" group designator.
Links of type 'prototype' are ignored. If using linkType, you must use the value ""*untitled"" to match an 'untitled' type link (rather than """" or ""untitled"").
Thus, to test if any original note using the 'Event' prototype has an outbound link of the 'untitled' link type the agent query would be:
	$Prototype==""Event"" & originalLinkedTo(""*"", ""*untitled"");  
The logical opposite of this test is originalLinkedFrom().","originalLinkedTo(scope[,linkTypeStr])
アウトバウンドリンクのテスト。指定されたスコープ、すなわち項目または項目のグループ（スコープの定義）から、これに対応する現在のノートがリンクされている場合に true を返します。これはオプションで、linkTypeStr 型のリンクのみにフィルタリングすることもできます。別の言い方をすれば、「元の現在のノートから項目（群）へのアウトバウンドリンクが存在するか？」ということです。
これは特にエージェントにおいて有用です。エージェント内では this はエージェントが所有するエイリアスにバインドされますが、ユーザーは元のノートへのリンクに関心があるからです。
これは実質的にクエリ条件としてのみ機能し、真偽値（Boolean）を返します。リンク先のノートに関するデータを収集したい場合は、代わりに links() を使用してください。
項目の指定方法。項目の引数は、属性参照（例：$MyString）でない限り、引用符で囲む必要があります（例：""Some note""）。
グループの指定方法。グループスコープでは、ワイルドカード ""*"" 指定子はすべてのノートに一致し、通常の ""all"" グループ指定子に代わって機能します。
タイプが 'prototype' のリンクは無視されます。linkType を使用する場合、'untitled' タイプのリンクに一致させるには、（"""" や ""untitled"" ではなく） ""*untitled"" という値を使用する必要があります。
したがって、'Event' プロトタイプを使用している元のノートに 'untitled' リンクタイプのアウトバウンドリンクがあるかどうかをテストする場合、エージェントクエリは次のようになります：
	$Prototype==""Event"" & originalLinkedTo(""*"", ""*untitled""); 
このテストの論理的な逆は originalLinkedFrom() です。"
paste(),Function,Document,Data manipulation,String,false,11.5.0,11.5.0,,11.5.0,,,false,false,false,false,false,false,false,false,false,,false,"paste()
The operator paste() returns the String contents of the OS' clipboard.
For example:
	$MyString = paste();","paste() オペレーターは、OSのクリップボードの文字列の内容を返します。
例：
	$MyString = paste();"
play(soundNameStr),Function,Item,Data manipulation,success boolean,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"play(soundNameStr)
This causes the stated OS alert sound to be played, the sound name being supplied as soundNameStr. To play the default error sound:
	play(""Basso""); 
The soundNameStr name is case-sensitive.","play(soundNameStr)
指定した名前（soundNameStr）のOSアラート音を再生します。デフォルトのエラー音を再生するには、以下のように記述します。
	play(""Basso""); 
soundNameStrの名前は、大文字と小文字を区別します。"
"pow(sourceNum, powerNum)",Function,Item,Mathematical,Number,false,5.10.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"pow(sourceNum, powerNum)
pow() returns the sourceNum raised to the powerNum.
	$MyNumber = pow(3,4); 
returns 81.","pow(sourceNum, powerNum)
pow()は、sourceNumをpowerNum乗した値を返します。
	$MyNumber = pow(3,4); 
は81を返します。"
radians(degreesNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"radians(degreesNum)
radians() converts its degreesNum, in degrees, to radians.
See also degrees() which converts an angle in radians to degrees.
	$MyNumber = radians(90); 
returns '1.570796327' for an input of 90.","radians(degreesNum)
radians() は、度単位の degreesNum をラジアンに変換します。
ラジアンを度に変換する degrees() も参照してください。
	$MyNumber = radians(90); 
90 を入力すると '1.570796327' を返します。"
rand([maxNumber]),Function,Item,Mathematical,Number,false,4.0.0,Baseline,9.5.2,,,1,false,false,false,false,false,false,false,true,false,,false,"rand([maxNumber])
rand()
rand
rand() returns a pseudo-random number between 0 and 1. No argument is required.
rand([maxNumber])
Supplying an optional parameter maxNumber, which must be an integer, returns a random integer between 0 and maxNumber-1. This can be useful when wanting random list items, noting that list items are addressed using zero-based integers.
N.B. if working with list-based items, consider the list.randomItem() operator, which abstracts away the need to know the size of the list. Essentially it encapsulates calling list.at(rand(list.count)), so much easier to write/use
Getting 1-based ranges vs. zero-based ranges of values
Consider the original round() method:
	$MyNumber=round(rand()*10); 
$MyNumber will be set to one of eleven integers in the range 0 through to 10. But, what if the '10' argument about is actually a child count:
	$MyNumber=round(rand()*$ChildCount); 
If the $ChildCount was 10 and $MyNumber were used to fetch a random child using $SiblingOrder($MyNum) the process would fail if $MyNumber were zero as $SiblingOrder numbers from 1. Indeed, in this case the need is for ten integers, one through to ten.
Previously, 1-based range can be achieved:
	$MyNumber=round(rand()*(10-1))+1; 
	$MyNumber=round(rand()*($ChildCount-1))+1; 
If the main input is 10, by subtracting 1 the process returns a randomised integer in in the range 0-9 (ten numbers) and then adding back 1 shifts the value range to 1-10.
Using the newer rand(maxNumber) method the above becomes:
	$MyNumber=round(rand($ChildCount-1))+1; 
This is why the list.randomItem() may be an easier clear approach.","rand([maxNumber])
rand()
rand
rand() は0から1の間の擬似乱数を返します。引数は必要ありません。
rand([maxNumber])
オプションのパラメータ maxNumber（整数である必要があります）を指定すると、0から maxNumber-1 の間のランダムな整数を返します。リスト項目は0ベースの整数で参照されるため、リストからランダムに項目を取得したい場合に便利です。
注意：リスト形式の項目を扱う場合は、list.randomItem() オペレータの使用を検討してください。これによりリストのサイズを意識する必要がなくなります。本質的には list.at(rand(list.count)) の呼び出しをカプセル化したものであり、より簡単に記述・使用できます。

1ベースの範囲 vs 0ベースの範囲の値の取得
従来の round() を用いた手法を考えてみましょう：
	$MyNumber=round(rand()*10); 
$MyNumber は0から10までの11個の整数のいずれかに設定されます。しかし、引数の「10」が実際には子要素の数（$ChildCount）だった場合はどうでしょうか：
	$MyNumber=round(rand()*$ChildCount); 
もし $ChildCount が10で、$MyNumber を使って $SiblingOrder($MyNum) でランダムな子要素を取得しようとした場合、$SiblingOrder は1から数え始めるため、$MyNumber が0になると処理は失敗します。この場合に必要とされるのは、1から10までの10個の整数です。
以前は、1ベースの範囲は以下のようにして実現されていました：
	$MyNumber=round(rand()*(10-1))+1; 
	$MyNumber=round(rand()*($ChildCount-1))+1; 
メインの入力が10の場合、1を引くことで0-9の範囲（10個の数値）のランダムな整数を発生させ、そこに1を加えることで値の範囲を1-10にシフトさせます。
新しい rand(maxNumber) メソッドを使用すると、上記は以下のようになります：
	$MyNumber=round(rand($ChildCount-1))+1; 
これが、list.randomItem() を使う方がより簡単で明快なアプローチとなる理由です。"
require(featureName),Function,Document,Document configuration,success boolean,false,9.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"require(featureName)
The require() operator adds the /Hints container and its subsidiary containers. It is equivalent to selecting Built In Hints from the File menu. If any of the containers already exists, that container is left unchanged. For example:
	require(""Hints""); 
featureName is a mandatory argument. It is a literal string and case-sensitive.
""Hints"" is currently the only featureName value recognised by require(). But, this method allows for other values to be added in the future as need arises.
require() accepts four case-sensitive arguments:
* require(""Templates"") adds the built-in configuration /Templates container. It is equivalent to the container created when first adding a built-in template from the File menu.
* require(""Prototypes"") adds the /Prototypes container. It is equivalent to the container created when first adding a built-in prototype from the File menu.
* require(""Preview"") displays the text pane sub-tab selector above the text pane (the new document default is to hide the selector).
* require(""NoPreview"") hides the text pane selector, i.e. the reverse of the above and the default for a new TBX document.","require(featureName)
require() オペレーターは、/Hints コンテナとその子コンテナを追加します。これは、[File] メニューから [Built In Hints] を選択する操作と同等です。対象のコンテナが既に存在する場合、そのコンテナは変更されません。例：
	require(""Hints""); 
featureName は必須の引数です。これはリテラル文字列であり、大文字と小文字を区別します。
現在、require() で認識される featureName の値は ""Hints"" のみです。しかし、このメソッドは将来的に必要に応じて他の値を追加できるようになっています。
require() は、大文字と小文字を区別する4つの引数を受け入れます：
* require(""Templates"") は、組み込みの設定用 /Templates コンテナを追加します。これは、[File] メニューから初めて組み込みテンプレートを追加した際に作成されるコンテナと同等です。
* require(""Prototypes"") は、/Prototypes コンテナを追加します。これは、[File] メニューから初めて組み込みプロトタイプを追加した際に作成されるコンテナと同等です。
* require(""Preview"") は、テキスト・ペインの上にテキスト・ペイン・サブタブ・セレクターを表示します（新規ドキュメントのデフォルトではセレクターは非表示です）。
* require(""NoPreview"") は、テキスト・ペイン・セレクターを非表示にします。つまり、上記の逆であり、新しい TBX ドキュメントのデフォルト設定です。"
return,Statement,Document,Data manipulation,declaration,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,true,"return
return() never use trailing parentheses with this operator!
The return statement is only used inside a function, and indicates the value to be passed back to the code calling the function at which point the function stops. Atypically, trailing empty parentheses must not used with return. The value passed by return is defined by the rest of code line following the return statement
See further explanation of the use of return within functions, including how the returned value is coded.","return
return() このオペレーターには決して末尾に括弧を使用しないでください！
return ステートメントは関数内でのみ使用され、関数を呼び出したコードに返される値を示します。その時点で関数の実行は停止します。異例なことに、return には末尾に空の括弧を使用してはいけません。return によって渡される値は、return ステートメントに続く行の残りの部分によって定義されます。
返される値の記述方法など、関数内での return の使用に関する詳細な説明を参照してください。"
"rgb(redNum, greenNum, blueNum)",Function,Item,Color,String,false,4.0.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"rgb(redNum, greenNum, blueNum)
Creates a Color type: its arguments are integers ranging from 0 to 255 or an expression or attribute reference resolving to a number in this range. The value set is in hex form. For example:
	$MyColor = rgb(255,0,0); sets a value of ""#ff0000""
The individual channels of an RGB colour can be set or read using the '.red', '.green' and '.blue' Color-type data operators.","rgb(redNum, greenNum, blueNum)
Color型を作成します。引数は0から255までの整数、またはこの範囲の数値に解決される式や属性参照です。設定される値は16進数形式（16進カラーコード）です。例：
	$MyColor = rgb(255,0,0); は ""#ff0000"" を設定します。
RGBカラーの各チャンネルは、Color型のデータオペレータである「.red」、「.green」、「.blue」を使用して設定または取得できます。"
round(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,,true,false,true,false,false,false,false,false,false,,false,"round(sourceNum)
round() rounds the value of its sourceNum argument to the nearest integer. Note that there is now a dot-operator version (with the same behaviour) Number.round().
The Number.format, Number.precision and format() functions all round numbers in this manner when shortening numbers during formatting. A partial integer over .50 always round up, everything else rounds down. Thus:
	$MyNumber = round(4.0); gives 4
	$MyNumber = round(4.2); gives 4
	$MyNumber = round(4.5); gives 5
	$MyNumber = round(4.7); gives 5
The round function with work on string literal or String attribute values that are just numbers:
	$MyNumber = round(""4.2""); gives 4
	$MyNumber = round(""4.7""); gives 5
	$MyString = round(4.2); gives ""4""
	$MyString = round(4.7); gives ""5""
	$MyString = round(""4.2""); gives ""4""
	$MyString = round(""4.7""); gives ""5""
There are also functions to always force rounding upwards (ceiling)—see ceil(), or to force rounding downwards (floor)—see floor().
For a practical example, assume you would like to round you calculation (upward) to the nearest 100, so if the calculation output is 167 it should be 200, for a result of 540 a result of 600, and so on. This can be done like so:
	$MyNumber = 100*ceil($MyNumber/100); 
whereas if you used round(), as in:
	$MyNumber = 100*round($MyNumber/100); 
the result would vary depending on whether $MyNumber started above or below the nearest 50. An opposite of the first example, i.e. where everything rounds downwards to the nearest 100 can be done using floor():
	$MyNumber = 100*floor($MyNumber/100);","round(sourceNum)
round() は、引数 sourceNum の値を最も近い整数に丸めます。現在では、同じ動作をするドット演算子バージョンの Number.round() も利用できる点に注意してください。
Number.format、Number.precision、および format() 関数はすべて、書式設定で数値を短縮する際に、この方法で数値を丸めます。小数点以下が .50 を超える場合は常に切り上げられ、それ以外は切り捨てられます。したがって、以下のようになります。
	$MyNumber = round(4.0); // 4
	$MyNumber = round(4.2); // 4
	$MyNumber = round(4.5); // 5
	$MyNumber = round(4.7); // 5
round 関数は、数値のみの文字列リテラルや String 型の属性値に対しても動作します。
	$MyNumber = round(""4.2""); // 4
	$MyNumber = round(""4.7""); // 5
	$MyString = round(4.2); // ""4""
	$MyString = round(4.7); // ""5""
	$MyString = round(""4.2""); // ""4""
	$MyString = round(""4.7""); // ""5""
また、常に強制的に切り上げる（天井関数）ceil() や、強制的に切り捨てる（床関数）floor() もあります。
実用的な例として、計算結果を最も近い100単位に（上向きに）丸めたい場合を考えます。たとえば、計算結果が167なら200に、540なら600にしたい場合です。これは以下のように記述できます。
	$MyNumber = 100*ceil($MyNumber/100); 
一方で、次のように round() を使用した場合：
	$MyNumber = 100*round($MyNumber/100); 
結果は、$MyNumber が最も近い50より大きいか小さいかによって変動します。最初の例の逆、つまり最も近い100単位にすべて切り捨てる場合は、floor() を使用して以下のように行えます。
	$MyNumber = 100*floor($MyNumber/100);"
"runCommand(commandStr[, inputsStr, dirStr])",Function,Item,Data manipulation,source context dependent,false,4.0.0,Baseline,,,,3,true,false,false,false,true,false,false,true,false,,false,"The `runCommand()` operator enables Tinderbox rules and actions to execute OS command line scripts. It returns the process's standard output (stdout) and assumes the user's OS home folder as the default working directory unless specified otherwise.

**Syntax and Variants**

1.  **`runCommand(commandStr)`**
    *   Passes `commandStr` to the Unix shell.
    *   Returns stdout (e.g., `$Text = runCommand(""ls -a"")` captures a file listing).
    *   Assignment is optional if the output is not needed.

2.  **`runCommand(commandStr, inputStr)`**
    *   Passes `commandStr` to the shell and uses `inputStr` as standard input (stdin).
    *   Example: `$MyNumber = runCommand(""wc -w"", ""hello world"")` counts words in the input string.
    *   **Important:** To pass command arguments via `inputStr` instead of `commandStr`, prefix the command with `xargs` (e.g., `runCommand(""xargs mv"", ...)`).

3.  **`runCommand(commandStr, inputStr, dirStr)`**
    *   Executes the command in the directory specified by `dirStr`.
    *   `dirStr` accepts full POSIX paths or tilde (`~`) notation (e.g., `""~/test""`). It should not end with a forward slash.
    *   When using `dirStr`, an `inputStr` argument is required, even if empty (`""""`).

**Data Handling and Best Practices**

*   **Variables:** Attributes and variables can be used dynamically in place of literal strings for all parameters.
*   **Quoting & Escaping:**
    *   Paths or strings containing spaces must be explicitly quoted so the shell parses them as single arguments.
    *   Use `urlEncode()` to safely escape special characters (spaces, quotes, apostrophes) in attribute values before passing them to the shell.
    *   `exportedString()` or dedicated ""quoting notes"" can help manage complex escaping needs.
*   **Testing:** It is recommended to verify commands in the OS Terminal first and use fixed strings before substituting dynamic attributes to aid troubleshooting.

**Performance and Limitations**

*   The operator is optimized for rapid call-and-response actions.
*   There is an implicit timeout of approximately 30 seconds.
*   Processes that take longer to complete should be configured to write results to disk, which can be read by a separate action, rather than blocking execution.","`runCommand()` オペレータは、Tinderbox のルールやアクションから OS のコマンドラインスクリプトを実行することを可能にします。プロセスの標準出力（stdout）を返し、特に指定がない限り、ユーザーの OS ホームフォルダをデフォルトの作業ディレクトリとして使用します。

**構文とバリエーション**

1.  **`runCommand(commandStr)`**
    *   `commandStr` を Unix シェルに渡します。
    *   標準出力（stdout）を返します（例：`$Text = runCommand(""ls -a"")` はファイルリストを取得します）。
    *   出力が不要な場合、代入は任意です。

2.  **`runCommand(commandStr, inputStr)`**
    *   `commandStr` をシェルに渡し、`inputStr` を標準入力（stdin）として使用します。
    *   例：`$MyNumber = runCommand(""wc -w"", ""hello world"")` は入力文字列の単語数をカウントします。
    *   **重要:** `commandStr` ではなく `inputStr` 経由でコマンド引数を渡すには、コマンドの前に `xargs` を付けます（例：`runCommand(""xargs mv"", ...)`）。

3.  **`runCommand(commandStr, inputStr, dirStr)`**
    *   `dirStr` で指定されたディレクトリでコマンドを実行します。
    *   `dirStr` はフル POSIX パスまたはチルダ（`~`）記法（例：`""~/test""`）を受け入れます。末尾にスラッシュを付けてはいけません。
    *   `dirStr` を使用する場合、`inputStr` 引数は（空の `""""` であっても）必須です。

**データ処理とベストプラクティス**

*   **変数:** すべてのパラメータにおいて、リテラル文字列の代わりに属性や変数を動的に使用できます。
*   **引用符とエスケープ:**
    *   スペースを含むパスや文字列は、シェルがそれらを単一の引数として解析できるように、明示的に引用符で囲む必要があります。
    *   `urlEncode()` を使用して、シェルに渡す前に属性値に含まれる特殊文字（スペース、引用符、アポストロフィ）を安全にエスケープしてください。
    *   `exportedString()` や専用の「引用ノート」は、複雑なエスケープの管理に役立ちます。
*   **テスト:** トラブルシューティングを容易にするため、動的な属性に置き換える前に、まず OS のターミナルでコマンドを確認し、固定文字列を使用することをお勧めします。

**パフォーマンスと制限**

*   このオペレータは、迅速なコール・アンド・レスポンスのアクションに最適化されています。
*   約 30 秒の暗黙のタイムアウトがあります。
*   完了に時間がかかるプロセスは、実行をブロックするのではなく、結果をディスクに書き込み、それを別のアクションで読み取るように構成する必要があります。"
"seconds(startDate, endDate)",Function,Item,Date-time,Number,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"seconds(startDate, endDate) 
returns the Number of whole seconds that elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA has time 12:30:00 and $DateB has time 12:31:30, then:
	$MyNumber = seconds($DateA,$DateB); 
sets $MyNumber to 90.","seconds(startDate, endDate) 
startDate から endDate までの間に経過した整数の秒数を返します。endDate が startDate より前の場合は、結果は負になります。
$DateA の時刻が 12:30:00 で $DateB の時刻が 12:31:30 の場合：
	$MyNumber = seconds($DateA,$DateB); 
は $MyNumber に 90 を設定します。"
select(),Function,Group,Data manipulation,n/a - no return,false,9.6.0,Baseline,,,,1,true,false,false,false,false,true,false,false,false,,false,"select()
The select() operator de-selects all items currently selected in the document. The usage is simple:
	select(); 
Because using select with arguments has a distinct and different function is it listed separately: select(scope).","I will translate the text for the `select()` operator into Japanese, maintaining its technical context.

select()
select() オペレータは、現在ドキュメントで選択されているすべての項目の選択を解除します。使い方は簡単です：
	select(); 
引数を伴う select の使用は、これとは全く異なる機能を持つため、select(scope) として個別に記載されています。"
select(scope),Function,Group,Data manipulation,List,false,9.6.0,Baseline,,,,1,true,false,true,false,false,true,false,false,false,,false,"select(scope)
The select(scope) operator allows the document's current (UI) focus to be shifted. The scope argument defines a list of one or more notes. The argument may be a literal string, or the value of an attribute or variable.
	select([/Note A;/Note B]); 
	select($MyList); 
	select(vItems); 
This specialist operator assist in the scenario where, whilst running action code, it is necessary to change the selection such that the locus of 'this' changes. Some action code operators only address the currently selected item(s). The select(scope) operator allows the selection to be changed on the fly without the user having to do so via the UI.
Because using select without arguments has a distinct and different function is it listed separately: select().","select(scope)
select(scope)オペレータは、ドキュメントの現在の（UI）フォーカスを移動させることができます。scope引数は、1つ以上のノートのリストを定義します。この引数は、リテラル文字列、または属性や変数の値にすることができます。
	select([/Note A;/Note B]); 
	select($MyList); 
	select(vItems); 
この専門的なオペレータは、アクションコードの実行中に、'this'の対象を変更するために選択範囲を変更する必要があるシナリオで役立ちます。一部のアクションコードオペレータは、現在選択されているアイテムのみを対象とします。select(scope)オペレータを使用すると、ユーザーがUIを介して操作することなく、実行中に選択範囲を動的に変更できます。
引数なしのselectは、明確に異なる機能を持つため、別個の項目として記載されています：select()。"
"show(msgString[, backgroundColor[, colorString, [durationNum]]])",Function,Item,Data manipulation,success boolean,false,9.5.2,Baseline,,,,3,true,false,true,false,false,false,false,false,false,,false,"show(msgString)
show(msgString, backgroundColor)
show(msgString, backgroundColor, colorString)
show(message[ foreground, background, duration)
The show(msgString) function allows a plain-text message to be shown in the front window's message placard. The source text, msgString, may be a literal string, variable or a String-type attribute value.
show() allows 3 further optional arguments.
The optional backgroundColor argument may be used on its own with or without the optional third colorString argument. But if the colorString argument is used, then the backgroundColor argument must be given as well. The same holds for the optional durationNum argument. If passed, durationNum specifies the number of seconds for which to display the message. Setting a duration can be useful if wanted to show a series of short messages, each in a discrete manner.
The full features and limitations of messages sent to the placard are described separately under the Message placards article.
The String.show() operator offers a dot-operator alternative.","show(msgString)
show(msgString, backgroundColor)
show(msgString, backgroundColor, colorString)
show(message, foreground, background, duration)

show(msgString) 関数を使用すると、最前面のウィンドウのメッセージ・プラカードにプレーンテキストのメッセージを表示できます。ソーステキストである msgString は、リテラル文字列、変数、または String 型の属性値のいずれかです。

show() には、さらに 3 つのオプションの引数を指定できます。

オプションの backgroundColor 引数は、オプションの 3 番目の引数である colorString の有無にかかわらず、単独で使用できます。ただし、colorString 引数を使用する場合は、backgroundColor 引数もあわせて指定する必要があります。オプションの durationNum 引数についても同様です。durationNum を渡すと、メッセージを表示する秒数を指定できます。期間を設定することは、一連の短いメッセージをそれぞれ個別に表示したい場合に便利です。

プラカードに送信されるメッセージの全機能と制限については、別記事の「Message placards（メッセージ・プラカード）」で詳しく説明されています。

String.show() オペレーターは、ドット演算子による代替手段を提供します。"
"similarTo(item[, notesNum])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,true,"similarTo(item,notesNum)
Returns Boolean true if item is amongst the (optionally notesNum notes) most similar to the current note.
The item argument must be quoted unless an attribute reference. Ways to define item.
Similarity is based on several factors, including:
* the text of the note
* the note title
* any text contained in user attributes
In addition, weighting is applied for:
* notes having the same prototype
* notes having roughly similar amounts of text
This data replicates that seen in the similar tab of Get Info and in the export code similarTo().
Legacy issues
This operator replaces the legacy #similarTo query operator and what in old version's agent query creation pop-ups and Find dialogs was listed as ""is similar to"".","similarTo(item,notesNum)
itemが現在のノートに（オプションのnotesNum個の範囲内で）最も類似しているノートの1つである場合に、真（true）を返します。
item引数は、属性参照でない限り引用符で囲む必要があります。itemの指定方法。
類似性は、以下のようないくつかの要因に基づいています：
* ノートの本文（text）
* ノートのタイトル
* ユーザー属性に含まれるすべてのテキスト
さらに、以下の要素に対して重み付けが適用されます：
* 同じプロトタイプを持つノート
* テキストの量がほぼ同程度のノート
このデータは、情報取得（Get Info）の「類似（similar）」タブや、エクスポートコードのsimilarTo()で表示されるものと同じです。
レガシーな問題
このオペレーターは、従来の#similarToクエリ・オペレーター、および旧バージョンのエージェントクエリ作成ポップアップや検索ダイアログで「is similar to」として表示されていたものに代わるものです。"
sin(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"sin(sourceNum)
sin() converts its sourceNum, in radians, to the sine of that value.
	$MyNumber = sin(3) 
returns '0.1411200081' for an input of 3 radians.","sin(sourceNum)
sin() は、ラジアン単位の sourceNum をその値の正弦（サイン）に変換します。
	$MyNumber = sin(3) 
3ラジアンの入力に対して '0.1411200081' を返します。"
"speak(MessageStr[, voiceNameStr])",Function,Item,Data manipulation,success boolean,false,9.5.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"speak(MessageStr[, voiceNameStr])
speaks a MessageStr string using Mac text-to-speech. If another string is being spoken, the new phrase is spoken after the current phrase is complete:
	speak(""Hello""); 
MessageStr can be a variable or attribute reference:
	speak($Text); 
An optional second argument voiceNameStr identifies the voice the speech synthesiser should use. If the nominated voiceNameStr is not present no sound is played. The closing parentheses are only needed if the extra argument is being passed:
	speak($Text.,""Tessa""); 
See also String.speak().","speak(MessageStr[, voiceNameStr])
Macのテキスト読み上げ機能を使用して、文字列MessageStrを読み上げます。別の文字列が読み上げられている最中の場合、新しいフレーズは現在のフレーズの終了後に読み上げられます。
	speak(""Hello""); 
MessageStrには変数や属性の参照を使用できます。
	speak($Text); 
オプションの第2引数voiceNameStrは、音声合成に使用する音声を指定します。指定したvoiceNameStrが存在しない場合、音声は再生されません。閉じ括弧が必要なのは、追加の引数を渡す場合のみです。
	speak($Text, ""Tessa""); 
String.speak() も参照してください。"
sqrt(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"sqrt(sourceNum)
sqrt() computes the square root of its sourceNum.
	$MyNumber = sqrt(9); 
sets $MyNumber to 3.","sqrt(sourceNum)
sqrt() は、sourceNum の平方根を計算します。
	$MyNumber = sqrt(9); 
は、$MyNumber を 3 に設定します。"
"stamp([scope, ]stampName)",Function,Group,Data manipulation,success boolean,false,8.1.0,Baseline,9.0.0,,,2,true,false,false,false,false,false,false,true,false,,false,"stamp([scope, ]stampName)
stamp(stampName)
This operator applies the stamp stampName is applied to the this note, i.e. the current note. So:
	stamp(""Do Stuff""); 
runs the stamp called ""Do Stuff"" on the current note.
stamp(scope, stampName)
scope is an optional argument that can be a single note or a group or designator defined in any of the normal methods (literal, designator, expression).
If a scope argument is supplied the stamp named stampName is applied discretely to each of scope items (defining scope). So:
	stamp(""SomeNote"",""Do Stuff""); 
runs the stamp called ""Do Stuff"" on the note with the unique $Name ""Some Note"". Or:
 	stamp($MyList,""Do Stuff""); 
runs the stamp called ""Do Stuff"" on every note described by an item in the list stored in the value of $MyList for this note.","stamp([scope, ]stampName)
stamp(stampName)
このオペレータは、現在のノート（this note）に stampName というスタンプを適用します。つまり：
	stamp(""Do Stuff""); 
は、現在のノートで ""Do Stuff"" という名前のスタンプを実行します。

stamp(scope, stampName)
scope はオプションの引数で、単一のノート、グループ、または任意の方法（リテラル、指定子、式）で定義された指定子を指定できます。
scope 引数が指定された場合、stampName という名前のスタンプが scope 内の各項目（scope で定義されたもの）に個別に適用されます。つまり：
	stamp(""SomeNote"",""Do Stuff""); 
は、一意の $Name が ""Some Note"" であるノートに対して ""Do Stuff"" というスタンプを実行します。
または：
 	stamp($MyList,""Do Stuff""); 
は、このノートの $MyList の値に格納されているリストの各項目によって示されるすべてのノートに対して、""Do Stuff"" というスタンプを実行します。"
String.beginsWith(matchStr),Function,Item,Data manipulation,boolean test,false,6.4.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.beginsWith(matchStr)
String.beginsWith() returns Boolean true if the chained string begins with the literal string matchStr. Note that matchStr cannot be a regular expression, only literal string values are allowed.
For example, if $MyString is ""I do not like green eggs and ham"":
	$MyString.beginsWith(""I do"")  returns true 
	$MyString.beginsWith(""Hello"")  returns false 
Also, with string literals:
	(""There are gentlemen now abed."").beginsWith(""There are"")  returns true 
	(""There are gentlemen now abed."").beginsWith(""Hello"")  returns false 
This operator searches for literal strings, not regular expressions. Matches are case sensitive
	(""There are gentlemen now abed."").beginsWith(""there are"")  returns false 
See also String.endsWith(). If you need to search a String for a regular expression, use String.contains().","String.beginsWith(matchStr)
String.beginsWith() は、チェインされた文字列がリテラル文字列 matchStr で始まる場合、ブール値の true を返します。matchStr には正規表現を使用できず、リテラル文字列のみが使用可能であることに注意してください。
例えば、$MyString が ""I do not like green eggs and ham"" の場合：
	$MyString.beginsWith(""I do"") は true を返します。
	$MyString.beginsWith(""Hello"") は false を返します。
また、文字列リテラルの場合：
	(""There are gentlemen now abed."").beginsWith(""There are"") は true を返します。
	(""There are gentlemen now abed."").beginsWith(""Hello"") は false を返します。
この演算子は正規表現ではなくリテラル文字列を検索します。一致は大文字と小文字を区別します。
	(""There are gentlemen now abed."").beginsWith(""there are"") は false を返します。
String.endsWith() も参照してください。正規表現を使用して文字列内を検索する必要がある場合は、String.contains() を使用してください。"
String.capitalize(),Function,Item,Formatting,String,false,5.9.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.capitalize()
String.capitalize
Returns the referenced string, transforming the initial letter of each word to a capital letter and leaving all other characters unchanged.
The function can be chained both to string data and to string literals:
	$MyString.capitalize() 
	""my new title"".capitalize() 
The latter gives ""My New Title"".
The trailing parentheses may be omitted:
	$MyString.capitalize 
If 'title case' is required from a mixed case string, chain with .lowercase():
	$MyString = ""my nEW title"".lowercase.capitalize; 
sets $MyString to ""My New Title"".
Bear in mind the latter will not deal with all capital acronyms (UPS, UNHCR) or CamelCase words (AstroTurf, FedEx).
Functionally equivalent to capitalize().
The .capitalize() method may also be used on Lists or Sets. Consider the list [Ant;BEE;Cow] when stored in $MyList:
	$MyList = $MyList.capitalize; 
… giving [Ant;Bee;Cow].","String.capitalize()
String.capitalize
参照された文字列を返し、各単語の最初の文字を大文字に変換し、他のすべての文字は変更せずに残します。
この関数は、文字列データと文字列リテラルの両方に連結（チェーン）できます。
	$MyString.capitalize() 
	""my new title"".capitalize() 
後者は ""My New Title"" を返します。
末尾の括弧は省略可能です。
	$MyString.capitalize 
大文字小文字が混在する文字列から「タイトルケース」が必要な場合は、.lowercase() を連結します。
	$MyString = ""my nEW title"".lowercase.capitalize; 
$MyString を ""My New Title"" に設定します。
後者の方法は、すべて大文字の略語（UPS、UNHCR）やキャメルケース（CamelCase）の単語（AstroTurf、FedEx）を処理しないことに注意してください。
capitalize() と機能的に同等です。
.capitalize() メソッドは、リスト（List）やセット（Set）でも使用できます。$MyList にリスト [Ant;BEE;Cow] が格納されている場合を考えてみましょう。
	$MyList = $MyList.capitalize; 
… [Ant;Bee;Cow] が得られます。"
String.captureJson(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,11.5.0,11.5.0,,,false,true,false,false,false,false,false,false,false,,false,"String.captureJson()
String.captureJson
From v11.5.0, the .captureJson() operator is deprecated. That proved to be a wrong step; embedding json in $Text (or within other text) is not useful and better solutions are available.

Attempts to parse the string as fully/partially JSON and fails if unsuccessful. The parsed JSON is saved as the current JSON (stream) object. 
Essentially, this re-scopes the current stream so that it contains only the contents of the first section of JSON detected within the original stream. The focus of the stream parsing is set to the beginning of the extracted JSON code.
Only one JSON object may be current at any time. If the source stream contains multiple discrete JSON code sections, only the first is detected/used.
To actually work with the JSON data's values, use JSON.json[] and its sibling operators.
In the most likely scenario, working on $Text, .captureJson() is needed only if $Text contains both JSON and other text:
	$MyResult = $Text.captureJson().json[""somekey""]; 
But, if the whole of $Text is a single block of (complete) JSON, use .json[] directly. So:
	$MyResult = $Text.json[""somekey""]; 
Legacy usage
Prior to v10.0.2, the operator used the casing .captureJSON(). This version is still silently supported (and is coloured in supported input boxes). However, .captureJson() is not the approved casing and existing code should be updated to this as legacy support may stop at any time.","String.captureJson()
String.captureJson

v11.5.0以降、.captureJson()オペレータは非推奨となりました。これは誤ったステップであったことが判明しました。$Text内（または他のテキスト内）にJSONを埋め込むことは有用ではなく、より優れた解決策が利用可能です。

文字列を完全または部分的なJSONとして解析（パース）することを試み、失敗した場合は動作しません。解析されたJSONは、現在のJSON（ストリーム）オブジェクトとして保存されます。
本質的に、これは現在のストリームのスコープを再設定し、元のストリーム内で最初に検出されたJSONセクションの内容のみが含まれるようにします。ストリーム解析のフォーカスは、抽出されたJSONコードの開始位置に設定されます。
一度に保持できるJSONオブジェクトは1つだけです。ソースストリームに複数の個別のJSONコードセクションが含まれている場合、最初のセクションのみが検出・使用されます。
実際にJSONデータの値を操作するには、JSON.json[]およびその関連オペレータを使用してください。
最も一般的なシナリオである$Textを処理する場合、.captureJson()が必要になるのは、$TextにJSONとその他のテキストの両方が含まれている場合のみです：
	$MyResult = $Text.captureJson().json[""somekey""]; 
しかし、$Text全体が単一の（完全な）JSONブロックである場合は、直接.json[]を使用してください。すなわち：
	$MyResult = $Text.json[""somekey""]; 

以前の用法（レガシー）
v10.0.2より前、このオペレータは .captureJSON() という大文字小文字の表記を使用していました。このバージョンは現在も暗黙的にサポートされています（サポートされている入力ボックスでは色付けされます）。しかし、.captureJson() は承認された表記ではなく、レガシーサポートはいつでも終了する可能性があるため、既存のコードはこれに更新されるべきです。"
String.captureLine([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureLine(targetAttributeStr)
String.captureLine()
String.captureLine
Optionally stores the rest of the line (paragraph) in the specified targetAttributeStr, a quoted name of an attribute, and returns the string that follows this line and the String moves forwards to the end of the current line.
If the targetAttributeStr is omitted the String is advanced to the next line without any data being saved.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the stream is three paragraphs ""Goodbye cruel world.\nHello again.\nFinal text."" (the \n is a line break):
	$MyString = $Text.captureLine(""SomeAttribute"").captureLine(vString); 
results in attribute $SomeAttribute holding the value ""Goodbye cruel world."" and the variable vString holding the value ""Hello again."". $MyString holds ""Final text."", it being the remainder of the unconsumed stream.","String.captureLine(targetAttributeStr)
String.captureLine()
String.captureLine
オプションで、行（段落）の残りの部分を、引用符で囲まれた属性名である指定の targetAttributeStr に格納します。この行に続く文字列を返し、String は現在の行の末尾まで進みます。
targetAttributeStr が省略された場合、データは保存されずに String は次の行に進みます。
targetAttributeStr に指定できる値は以下の通りです：
* 引用符で囲まれたリテラル文字列。例：$Text の場合は (""Text"")。
* 引用符で囲まれていない変数やループ変数。例：変数 'vString' の場合は (vString)。
例えば、ストリームが ""Goodbye cruel world.\nHello again.\nFinal text."" という3つの段落（\n は改行）である場合：
	$MyString = $Text.captureLine(""SomeAttribute"").captureLine(vString); 
の結果、属性 $SomeAttribute には ""Goodbye cruel world."" が、変数 vString には ""Hello again."" が保持されます。$MyString には消費されなかったストリームの残りである ""Final text."" が保持されます。"
String.captureNumber([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureNumber(""targetAttribute"")
String.captureNumber()
String.captureNumber
Searches forward from the start of String and matches the a detected number up to the first non-number character, optionally storing that number in the attribute specified targetAttributeStr, a quoted name of an attribute. It then returns the string that follows that number (to any left side recipient) whilst the String is advanced to a position after the number. The operator fails if the match is empty or entirely white space, with no result. 
A number is assumed to be any character continuous sequence of one or more number characters between 0–9 (zero through nine). Formatted numbers will not be fully matched. Any further text after the number is ignored, both for the capture and advancing the String.
If the targetAttributeStr is omitted the String is advanced to after the number without any data being saved.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the string is ""1234 items"":
$Result = $Result=$Text.captureNumber(""SomeAttribute""); 
The value of $SomeAttribute is ""1234"" $Result holds "" items"". But if the stream is ""1,234 items"", $Result holds ""1"" and $SomeAttribute holds "",234 items"" as the comma means the first detected number stops at '1'.","String.captureNumber(""targetAttribute"")
String.captureNumber()
String.captureNumber
Stringの先頭から前方に向かって検索し、最初に検出された数字を、最初の非数字文字の直前まで照合します。オプションで、その数字を targetAttributeStr（引用符で囲まれた属性名）で指定された属性に保存します。その後、その数字に続く文字列を（左側の受信者に）返し、Stringは数字の後の位置まで進められます。一致するものが空であるか、完全に空白である場合、このオペレータは失敗し、結果は返されません。
数字は、0〜9（0から9）の1つ以上の数字文字の連続したシーケンスであると見なされます。書式設定された数字は、完全には照合されません。数字の後のテキストは、キャプチャおよびStringの進行の両方において無視されます。
targetAttributeStr が省略された場合、データは保存されずにStringは数字の後の位置まで進められます。
targetAttributeStr に指定できる値は以下の通りです：
* 引用符で囲まれたリテラル文字列。例：$Text の場合は (""Text"")。
* 引用符で囲まれていない変数/ループ変数。例：変数 'vString' の場合は (vString)。
例えば、文字列が ""1234 items"" の場合：
$Result = $Text.captureNumber(""SomeAttribute""); 
$SomeAttribute の値は ""1234"" となり、$Result は "" items"" を保持します。しかし、ストリームが ""1,234 items"" の場合、カンマによって最初に検出された数字が '1' で止まるため、$Result は ""1"" を保持し、$SomeAttribute は "",234 items"" を保持します。"
String.captureRest([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureRest(targetAttributeStr)
String.captureRest()
String.captureRest
Stores all of the String from the current position to its end into the specified targetAttributeStr, which is a quoted name of an attribute, and returns an empty string.
If the targetAttributeStr is omitted the String is advanced to the end so processing ceases.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the stream is ""Goodbye cruel world.\nHello again."":
	vString = $Text.captureWord(""SomeAttribute"").captureRest(vRest); 
results in attribute $SomeAttribute holding the value ""Goodbye"" and the variable vRest holding the value "" cruel world.\nHello again"".","String.captureRest(targetAttributeStr)
String.captureRest()
String.captureRest
現在の位置から文字列の末尾までを、指定された targetAttributeStr（引用符で囲まれた属性名）に格納し、空の文字列を返します。
targetAttributeStr が省略された場合、文字列は末尾まで進められ、処理が終了します。
targetAttributeStr に指定できる値は以下の通りです：
* 引用符で囲まれたリテラル文字列。例：$Text の場合は (""Text"")
* 引用符のない変数またはループ変数。例：変数 'vString' の場合は (vString)
例えば、ストリームが ""Goodbye cruel world.\nHello again."" の場合：
	vString = $Text.captureWord(""SomeAttribute"").captureRest(vRest); 
この結果、属性 $SomeAttribute には ""Goodbye"" が格納され、変数 vRest には "" cruel world.\nHello again"" が格納されます。"
"String.captureTo(matchStr[, targetAttributeStr])",Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,2,true,true,false,false,true,false,false,true,false,,false,"String.captureTo(matchStr, targetAttributeStr)
String.captureTo(matchStr)
Stores the source text string up to, but not including, the designated literal matchStr into the specified targetAttributeStr, a quoted name of an attribute,  and returns the string that follows matchStr. Note that matchStr is not a regular expression and can only be a literal string.
If the targetAttributeStr is omitted the String is advanced to the end so processing ceases.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the stream is ""Piglet, a friend of Pooh"" and if wishing to capture only the name 'Piglet' into $SomeAttribute:
	$Result = $Text.captureTo("", "",""SomeAttribute""); 
Now, the value of $Result is ""a friend of Pooh"" and that of $SomeAttribute is ""Piglet"".","String.captureTo(matchStr, targetAttributeStr)
String.captureTo(matchStr)
元のテキスト文字列のうち、指定されたリテラル matchStr の直前までの部分を、指定された targetAttributeStr（引用符で囲まれた属性名）に格納し、matchStr に続く文字列を返します。matchStr は正規表現ではなく、リテラル文字列である必要があることに注意してください。
targetAttributeStr が省略された場合、String は最後まで進められるため、処理は終了します。
targetAttributeStr に指定できる値は以下の通りです：
* 引用符で囲まれたリテラル文字列。例：$Text を指定する場合は (""Text"")。
* 引用符で囲まれていない変数またはループ変数。例：変数 'vString' を指定する場合は (vString)。
例えば、ストリームが ""Piglet, a friend of Pooh"" で、名前の 'Piglet' だけを $SomeAttribute に抽出したい場合：
	$Result = $Text.captureTo("", "",""SomeAttribute""); 
このとき、$Result の値は ""a friend of Pooh"" になり、$SomeAttribute の値は ""Piglet"" になります。"
String.captureToken([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureToken(targetAttributeStr)
String.captureToken()
String.captureToken
Captures a sequence of non-whitespace characters ('tokens'), the matched token string is passed to the specified targetAttributeStr, a quoted name of an attribute. The String stream is not advanced and any chained parsing continues from the same point. Punctuation (notably @) is part of a token but *not* part of a word.
If the targetAttributeStr is omitted the String is advanced to the end so processing ceases.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, with a source a stream of ""5. Hello world"":
	vString = $Text.captureToken(""SomeAttribute""); 
results in attribute $SomeAttribute holding ""5."" and the variable vText hosing the value "" Hello world""—note the space after the full stop is passed to the text stream as it is not a captured 'token'.
Iif the source stream is ""John Doe&lt;johndoe@example.com>"":
	vText = $Text.captureToken(vString) 
results in variable vText holding "" Doe&lt;johndoe@example.com>"" whilst variable vString holds ""John"".
Thus .captureToken() might be considered akin to a more permissive form of String.captureWord() where the first 'word' in the stream contains non-normal word characters (as long as not a space).","String.captureToken(targetAttributeStr)
String.captureToken()
String.captureToken
空白文字以外の文字の並び（「トークン」）を抽出します。抽出されたトークン文字列は、指定された属性名の引数 `targetAttributeStr`（引用符で囲まれた属性名）に渡されます。文字列ストリームは進まず、後続のチェーン化された解析は同じ位置から継続されます。記号（特に @）はトークンの一部として扱われますが、「単語（word）」の一部とはみなされません。
`targetAttributeStr` が省略された場合、文字列は最後まで進められ、処理が終了します。
`targetAttributeStr` に指定できる値は以下の通りです：
* 引用符で囲まれたリテラル文字列。例：$Text の場合は `(""Text"")`。
* 引用符で囲まれていない変数またはループ変数。例：変数 'vString' の場合は `(vString)`。
例えば、ソースストリームが ""5. Hello world"" の場合：
	vString = $Text.captureToken(""SomeAttribute""); 
この結果、属性 `$SomeAttribute` には ""5."" が保持され、変数 `vString` には "" Hello world"" が保持されます。ピリオドの後のスペースは「トークン」として抽出されないため、テキストストリームに残されている点に注意してください。
ソースストリームが ""John Doe&lt;johndoe @example.com>"" の場合：
	vText = $Text.captureToken(vString) 
この結果、変数 `vText` には "" Doe&lt;johndoe @example.com>"" が保持され、変数 `vString` には ""John"" が保持されます。
このように、`.captureToken()` は、ストリーム内の最初の「単語」に（スペースでない限り）通常の単語文字以外の文字が含まれている場合に使用できる、`String.captureWord()` のより許容範囲の広い形式と考えることができます。"
String.captureWord([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureWord(targetAttributeStr)
String.captureWord()
String.captureWord
Matches a word character at the start of String up to the first non-word character and stores the word in the specified targetAttributeStr, a quoted name of an attribute, and returns the string that follows this word. Fails if the string is empty or entirely white space.
What constitutes a word? This operator captures text from the current position up to (but not including) the next character that is a digit, whitespace, or punctuation.
If the targetAttributeStr is omitted the String is advanced to the end so processing ceases.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the stream is ""Hello world"":
	vString = $Text.captureWord(""SomeAttribute""); 
results in attribute $SomeAttribute holding the value ""Hello"" and the variable vText holding the value "" world"". If the stream does not start with a word, the operator fails. So, for a stream of ""5. Hello world"":
	vString = $Text.captureWord(""SomeAttribute""); 
results in attribute $SomeAttribute holding no value and the variable vString hosing the value ""5. Hello world"".","String.captureWord(targetAttributeStr)
String.captureWord()
String.captureWord

Stringの先頭にある単語構成文字から、最初の非単語文字までの間に一致させ、その単語を引用符で囲まれた属性名である指定されたtargetAttributeStrに格納し、その単語に続く文字列を返します。文字列が空、または完全に空白である場合は失敗します。
何をもって単語とするか？このオペレーターは、現在の位置から、次の文字が数字、空白、または句読点のいずれかになる直前までのテキストをキャプチャします。
targetAttributeStrが省略された場合、Stringは最後まで進められ、処理が終了します。
targetAttributeStrに指定できる値は以下の通りです：
* 引用符で囲まれたリテラル文字列（例：$Textを指すなら(""Text"")）
* 引用符で囲まれていない変数／ループ変数（例：変数'vString'なら(vString)）
例えば、ストリームが ""Hello world"" の場合：
	vString = $Text.captureWord(""SomeAttribute""); 
の結果、属性 $SomeAttribute には ""Hello"" という値が保持され、変数 vText（原文ママ）には "" world"" という値が保持されます。ストリームが単語で始まらない場合、オペレーターは失敗します。したがって、ストリームが ""5. Hello world"" の場合：
	vString = $Text.captureWord(""SomeAttribute""); 
の結果、属性 $SomeAttribute には値が保持されず、変数 vString には ""5. Hello world"" という値が保持されます。"
String.captureXML(),Operator,Item,Stream parsing,,false,9.1.0,,,,,,false,true,false,false,false,false,false,false,false,,false,"String.captureXML()
String.captureXML
Attempts to parse the string as fully/partially XML and fails if unsuccessful. The parsed XML is saved as the current XML (stream) object. 
Essentially, this re-scopes the current stream so that it contains only the contents of the first section of XML detected within the original stream. The focus of the stream parsing is set to the beginning of the extracted XML code.
Only one XML object may be current at any time. If the source stream contains multiple discrete XML code sections, only the first is detected/used.","String.captureXML()
String.captureXML
文字列を完全または部分的なXMLとして解析しようと試み、失敗した場合はエラーとなります。解析されたXMLは、現在のXML（ストリーム）オブジェクトとして保存されます。
本質的には、これにより現在のストリームのスコープが再設定され、元のストリーム内で最初に検出されたXMLセクションの内容のみが含まれるようになります。ストリーム解析のフォーカスは、抽出されたXMLコードの先頭に設定されます。
一度にカレント（現在対象）にできるXMLオブジェクトは1つだけです。ソースストリームに複数の独立したXMLコードセクションが含まれている場合、最初のセクションのみが検出・使用されます。"
String.contains(regexStr),Function,Item,Query Boolean,boolean test,false,5.7.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.contains(regexStr)
This operator tests whether regular expression pattern regexStr matches the referenced string attribute's value in whole or part. Matches are always case-sensitive, unlike String.icontains(). The match gives a coerced boolean result: if regexStr is matched (literally or via regex) the function returns the match offset+1 in the source string, where offset is the distance from the start of the string to the start of the matched regex. No match, coerces to false. The +1 works around the fact the match is zero-based, so a match at position 0 (the start of the string), returns as 1 (0+1) and a value of 1 or more coerces to a boolean true. The boolean allows queries' normal true/false to evaluate as normal.
If concerned over unwanted case-sensitivity, use String.icontains() which is always case-insensitive.
regexStr is one of:
* an unquoted action code expression, which includes just referencing a single attribute name e.g. MyString
* a quoted string; quoted strings may be either:
** a literal string (i.e. actual text)
** a regular expression.
Important: do not omit the enclosing quotes for literal strings or regex. If omitted, Tinderbox will try to evaluate the string as an expression. Doing this may result in the expected result but this is actually a false positive. So, remember to enclose your regex or literals in quotes.
For example:
	$MyString.contains(""regex"") 
is true if $MyString matches regexStr's pattern. Other more complex usage:
	$MyString.contains($MyMatchText) 
	$MyString.contains($MyString(agent)) 
	$MyString(parent).contains(""Tuesday"") 
	""Any day like Saturday is good"".contains($MyDay) 
	""Any day like Saturday is good"".contains(""Saturday"") 
Note that regex/literal strings are quoted whilst action expressions are not.
Getting the offset of the (first) regex match
If the regular expression regexStr is found the function returns the match offset+1, where offset is the distance from the start of the string to the start of the matched regex. If there is more than one match, the offset of the first match is returned. Formerly, .contains() returned true if the regex was found. The '+1' modifier ensures that a match at position zero return a number higher than zero which would otherwise coerce tofalse. Since 1+offset is always true, no changes are required in existing documents but the function also gives usable offset information. Thus, if $MyString is ""abcdefgehEi"":
	$MyNumber = $MyString.contains(""e""); returns 5.
	$MyNumber = $MyString.contains(""E""); returns 10.
	$MyNumber = $MyString.contains(""eh""); returns 8.
Testing ""does not contain""
Use a ! prefix to the query argument:
	!$MyString.contains(""Tuesday"") 
Use of parentheses around the negated query term, can assist Tinderbox's parsing:
	(!$MyString.contains(""Tuesday"")) 
Using back-references
In an agent query or if() conditions the function can return back-references to matches of (sub-)strings.
String.contains() clears the list of back references from previous processes, so $0 and $1 correspond to its own results, not those from prior expressions.
Dealing with inline quote characters
Because regex is parsed for regular expressions, it may be possible to use the '\xNN' form described here to work around the lack of escaping from single double quotes within strings.
Legacy format
This operator is the replacement of the older form of AttributeName(regex) which is deprecated and should not be used in new work (legacy support may fall away). Apart from anything else, the current syntax should remove the confusion over whether/when to use the $ prefix with attribute names in queries.","String.contains(regexStr)
このオペレータは、正規表現パターン regexStr が、参照された文字列属性の値の全部または一部に一致するかどうかをテストします。String.icontains() とは異なり、一致は常に大文字と小文字を区別します。一致の結果は強制的なブール値（真偽値）として評価されます。regexStr が（リテラルまたは正規表現を介して）一致した場合、関数はソース文字列内の一致オフセット+1を返します。ここでオフセットとは、文字列の先頭から一致した正規表現の開始位置までの距離です。一致しない場合は false に変換されます。+1 という処理は、一致が0ベースである（つまり、文字列の先頭である位置0での一致が 1 (0+1) として返される）という事実に対処するためのもので、1以上の値はブール値の true に変換されます。このブール値としての性質により、クエリの通常の真偽評価が正常に行われます。
大文字・小文字の区別を避けたい場合は、常に大文字・小文字を区別しない String.icontains() を使用してください。
regexStr は以下のいずれかです：
* 引用符で囲まれていないアクションコード式（単一の属性名 MyString の参照など）
* 引用符で囲まれた文字列。引用符で囲まれた文字列は以下のいずれかになります：
** リテラル文字列（すなわち、実際のテキスト）
** 正規表現
重要：リテラル文字列や正規表現の場合、それらを囲む引用符を省略しないでください。省略すると、Tinderbox はその文字列を式として評価しようとします。その結果、期待通りの結果が得られることもありますが、それは実際には誤検知です。したがって、正規表現やリテラルは必ず引用符で囲むようにしてください。
例：
	$MyString.contains(""regex"") 
は、$MyString が regexStr のパターンに一致する場合に true となります。その他のより複雑な使用例：
	$MyString.contains($MyMatchText) 
	$MyString.contains($MyString(agent)) 
	$MyString(parent).contains(""Tuesday"") 
	""Any day like Saturday is good"".contains($MyDay) 
	""Any day like Saturday is good"".contains(""Saturday"") 
正規表現やリテラル文字列は引用符で囲まれますが、アクション式は囲まれないことに注意してください。
（最初の）正規表現一致のオフセットの取得
正規表現 regexStr が見つかった場合、関数は一致したオフセット+1を返します。ここでオフセットとは、文字列の先頭から一致した正規表現の開始位置までの距離です。複数の一致がある場合は、最初の一致のオフセットが返されます。以前は、.contains() は正規表現が見つかった場合に true を返していました。「+1」の修飾により、位置0での一致が0より大きい数値を返すことが保証されます。そうでないと false に変換されてしまうためです。1+オフセットは常に true であるため、既存のドキュメントに変更を加える必要はありませんが、この関数は利用可能なオフセット情報も提供するようになりました。したがって、$MyString が ""abcdefgehEi"" の場合：
	$MyNumber = $MyString.contains(""e""); は 5 を返します。
	$MyNumber = $MyString.contains(""E""); は 10 を返します。
	$MyNumber = $MyString.contains(""eh""); は 8 を返します。
「含まない」のテスト
クエリ引数の前に ! プレフィックスを使用します：
	!$MyString.contains(""Tuesday"") 
否定されたクエリ項を括弧で囲むことで、Tinderbox の解析を助けることができます：
	(!$MyString.contains(""Tuesday"")) 
後方参照の使用
エージェントクエリや if() 条件内では、関数は（サブ）文字列の一致に対する後方参照を返すことができます。
String.contains() は以前のプロセスからの後方参照のリストをクリアするため、$0 や $1 は以前の式の結果ではなく、それ自体の結果に対応します。
インライン引用符文字の扱い
正規表現は正規表現として解析されるため、文字列内での単一の二重引用符のエスケープ不足を回避するために、ここで説明されている '\xNN' 形式を使用できる場合があります。
レガシー形式
このオペレータは、非推奨であり新しい作業では使用すべきではない古い形式の AttributeName(regex) に代わるものです（レガシーサポートは将来的に廃止される可能性があります）。とりわけ、現在の構文では、クエリ内で属性名に $ プレフィックスを使用すべきかどうか、またいつ使用すべきかという混乱が解消されるはずです。"
String.containsAnyOf(regexList),Function,List,Query Boolean,boolean test,false,8.9.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.containsAnyOf(regexList)
The operator .containsAnyOf(regexList) is true if any of the words in a set of words (i.e. list) is contained in the chained-to target string. As shown below, the list may have only one entry. The test is case-sensitive (previously it was case-insensitive). For example:
	$MyBoolean = $Text.containsAnyOf(""emulate""); 
Will be true if the tested note's $Text contains the word ""emulate"". A more applied example:
	$MyBoolean = $Text.containsAnyOf(wordsRelatedTo(""emulate"")); 
Will be true if the tested note's $Text contains the word ""aspire"".
regexList implies using a list of values (ideally with no dupes). This can be a literal list of 1 or more values—as in the example above, or an attribute reference holding a list of values, for instance:
	$MyBoolean = $Text.containsAnyOf($MySet); 
It is important to note that .containsAnyOf() is always a case-insensitive test. Thus in the first example above, it will match ""emulate"" but not ""Emulate"" or any other case variant of the word.
Although the examples above use whole words the list in regexList is actually processed assuming they are regular expressions (which may of course be literal strings). Thus in the first example above, it will match both ""emulate"" and ""emulated"" but not ""emulating"". The test value ""emulate\b"", expecting a word break after the final 'e' would this match ""emulate"" but not ""emulated"".
For a case-insensitive version of this operator see String.icontainsAnyOf().
If wishing to test a List or Set, chain to list.asString():
	$MyBoolean = $MyList.asString.containsAnyOf(wordsRelatedTo(""emulate""));","String.containsAnyOf(regexList)
演算子 .containsAnyOf(regexList) は、一連の単語（すなわちリスト）内のいずれかの単語が、適用対象のターゲット文字列に含まれている場合に true を返します。以下に示すように、リストのエントリは1つだけでも構いません。このテストは大文字と小文字を区別します（以前は大文字と小文字を区別しませんでした）。例えば：
	$MyBoolean = $Text.containsAnyOf(""emulate""); 
テスト対象のノートの $Text に ""emulate"" という単語が含まれている場合に true となります。より応用的な例：
	$MyBoolean = $Text.containsAnyOf(wordsRelatedTo(""emulate"")); 
テスト対象のノートの $Text に ""aspire"" という単語が含まれている場合に true となります。
regexList は、値のリスト（理想的には重複のないもの）を使用することを意味します。これは上記の例のように1つ以上の値のリテラルリストにすることも、以下のように値のリストを保持する属性参照にすることもできます：
	$MyBoolean = $Text.containsAnyOf($MySet); 
.containsAnyOf() は常に大文字と小文字を区別するテストであることに注意してください。したがって、最初の例では ""emulate"" には一致しますが、""Emulate"" やその他の大文字小文字のバリエーションには一致しません。
上記の例では単語全体を使用していますが、regexList 内のリストは実際には正規表現（もちろんリテラル文字列の場合もあります）として処理されます。したがって、最初の例では ""emulate"" と ""emulated"" の両方に一致しますが、""emulating"" には一致しません。末尾の 'e' の後に単語の区切りを期待するテスト値 ""emulate\b"" を使用すれば、""emulate"" には一致しますが ""emulated"" には一致しなくなります。
この演算子の大文字小文字を区別しないバージョンについては、String.icontainsAnyOf() を参照してください。
List または Set をテストしたい場合は、list.asString() に繋げます：
	$MyBoolean = $MyList.asString.containsAnyOf(wordsRelatedTo(""emulate""));"
String.countOccurrencesOf(literalStr),Function,Item,Data manipulation,Number,false,6.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.countOccurrencesOf(literalStr)
This function returns the Number of times that the literal argument 'literalStr' appears in the String. If $MyString contains the word ""aardvark"", then:
	$MyNumber = $MyString.countOccurrencesOf(""a""); returns 3
	$MyNumber = $MyString.countOccurrencesOf(""aa""); returns 1
	$MyNumber = $MyString.countOccurrencesOf(""r""); returns 2
literalStr is literal and must not be a regular expression. If the latter is needed use String.contains() or String.icontains().","String.countOccurrencesOf(literalStr)
この関数は、引数 'literalStr' で指定されたリテラル文字列が、対象の文字列内に出現する回数を数値で返します。$MyString の内容が ""aardvark"" である場合、以下のようになります。
	$MyNumber = $MyString.countOccurrencesOf(""a""); // 3を返します
	$MyNumber = $MyString.countOccurrencesOf(""aa""); // 1を返します
	$MyNumber = $MyString.countOccurrencesOf(""r""); // 2を返します
literalStr はリテラル文字列として扱われ、正規表現として指定することはできません。正規表現が必要な場合は、String.contains() または String.icontains() を使用してください。"
String.deleteCharacters(characterSet),Function,Item,Data manipulation,String,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.deleteCharacters(characterSet)
Returns a copy of the string from which all instances of every discrete character in the quoted literal string-based set characterSet have been removed. For example:, if $MyString is ""1Hello1 2world3"";
	$MyStringA = $MyString.deleteCharacters(""1234567890""); 
would remove any digits from the target string, thus $MyStringA will be ""Hello world"", having removed two instances of '1', and a single instance of '2' and of '3'.
But were $MyString ""Hello world: 45"";
	$MyStringA = $MyString.deleteCharacters(""1234567890""); 
the result would be ""Hello world: "". Importantly, note the trailing space as only the digits (i.e. characters in characterSet) have been removed.","String.deleteCharacters(characterSet)
引用符で囲まれたリテラル文字列ベースのセット characterSet に含まれるすべての個別の文字が削除された、元の文字列のコピーを返します。例えば、$MyString が ""1Hello1 2world3"" の場合：
	$MyStringA = $MyString.deleteCharacters(""1234567890""); 
は対象の文字列からすべての数字を削除し、その結果 $MyStringA は ""Hello world"" になります（2つの '1'、1つの '2'、および 1つの '3' が削除されます）。
しかし、$MyString が ""Hello world: 45"" の場合：
	$MyStringA = $MyString.deleteCharacters(""1234567890""); 
の結果は ""Hello world: "" になります。重要な点として、characterSet に含まれる文字（つまり数字）のみが削除されるため、末尾にスペースが残ることに注意してください。"
String.eachLine(loopVar[:condition]){actions},Function,List,Stream parsing,iterator,false,9.1.0,Baseline,,,,2,true,true,false,true,false,false,true,true,false,,false,"String.eachLine(loopVar[:condition]){ action(s) }
The .eachLine() operator, iterates through each line of a steam, where a line is one or more characters ending in a carriage return, line feed, unicode paragraph separator, or the end of the string (so in $Text, it means discrete paragraphs).
Each line, in turn, is bound to a temporary variable loopVar, and the action is then performed. The name of the variable is set by the user when writing the code, i.e. it is whatever string is entered where loopVar is shown above. Something like 'aLine' might be a more useful variable name.
If the optional condition is specified, only lines that satisfy the condition are processed using the action.
For example:
$MyNumber=0;
$Text.eachLine(aLine){
   $MyNumber=$MyNumber+1;
};
will set $MyNumber to the number of lines (paragraphs!) in the $Text of this note.
$MyNumber=0;
$Text.eachLine(aLine:aLine.contains(""@"")){
   $MyNumber=$MyNumber+1;
};
will set $MyNumber to the number of lines in the $Text that contain the ""@"" symbol.
When parsing text paragraphs, this operator can substitute for the older method of chaining .paragraphList.each(){}.","String.eachLine(loopVar[:condition]){ action(s) }
.eachLine() オペレーターは、ストリーム（文字列）の各行を反復処理します。ここで「行」とは、キャリッジリターン、ラインフィード、Unicode の段落区切り文字、または文字列の終端で終わる 1 文字以上の文字列を指します（つまり $Text においては、個別の段落を意味します）。
各行は順番に一時変数 loopVar にバインドされ、その後にアクションが実行されます。変数名はコードを書くときにユーザーが自由に設定できます。つまり、上記の loopVar の位置に入力した任意の文字列が変数名になります。例えば 'aLine' といった名前が使いやすいでしょう。
オプションの条件（condition）が指定された場合、その条件を満たす行のみがアクションの処理対象となります。
例：
$MyNumber=0;
$Text.eachLine(aLine){
   $MyNumber=$MyNumber+1;
};
これにより、$MyNumber にはこのノートの $Text に含まれる行数（段落数！）がセットされます。
$MyNumber=0;
$Text.eachLine(aLine:aLine.contains("" @"")){
   $MyNumber=$MyNumber+1;
};
これにより、$MyNumber には $Text の中で「 @」という記号を含む行の数がセットされます。
テキストの段落を解析する際、このオペレーターは従来の .paragraphList.each(){} をつなげる手法の代わりとして利用できます。"
String.empty(),Property,Item,Non-query Boolean,boolean test,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.empty()
String.empty
This returns a Boolean depending on whether the string is empty. If empty, the return value is true, if the attribute has content then false is returned.
	$MyString = """"; $MyBoolean = $MyString.empty; $MyBoolean is set to true.
	$MyString = ""hello""; $MyBoolean = $MyString.empty; $MyBoolean is set to true.
This operator can also be used on other attribute data types that are string-like, URL, File, Action, Color, etc., and which have no value at all by default. However, for a Number or Date, the default values of 0 or never, coerce to a literal string of ""0"" or ""never"" so the .empty() test does not work the same way. For the latter types, use the short Boolean test form, !AttributeName.","String.empty()
String.empty
これは、文字列が空かどうかに応じてブール値を返します。空であれば戻り値は true となり、属性に内容があれば false が返されます。
	$MyString = """"; $MyBoolean = $MyString.empty; $MyBoolean は true に設定されます。
	$MyString = ""hello""; $MyBoolean = $MyString.empty; $MyBoolean は true に設定されます。
この演算子は、URL、File、Action、Color など、デフォルトで値を持たない文字列に似た他の属性データ型にも使用できます。しかし、Number や Date の場合、デフォルト値の 0 や never はリテラル文字列の ""0"" や ""never"" に強制変換されるため、.empty() テストは同様には機能しません。後者の型については、短縮されたブール値テスト形式である !AttributeName を使用してください。"
String.endsWith(matchStr),Function,Item,Data manipulation,boolean test,false,6.4.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.endsWith(matchStr)
String.endsWith() returns Boolean true if the chained string ends with the literal string matchStr. Note that matchStr cannot be a regular expression, only literal string values are allowed.
For example, if $MyString is ""I do not like green eggs and ham"":
	$MyString.endsWith(""ham"")  returns true
	$MyString.endsWith(""eggs"")  returns false
Also, with string literals:
	(""There are gentlemen now abed."").endsWith(""abed"")  returns true 
	(""There are gentlemen now abed."").endsWith(""night"")  returns false 
This operator searches for literal strings, not regular expressions. Matches are case sensitive:
	(""There are gentlemen now abed."").endsWith(""Abed"")  returns false 
See also String.beginsWith(). If you need to search a String for a regular expression, use String.contains().","String.endsWith(matchStr)
String.endsWith() は、チェインされた文字列がリテラル文字列 matchStr で終わる場合に、真 (true) を返します。matchStr には正規表現を使用できず、リテラル文字列のみが許可されることに注意してください。
例えば、$MyString が ""I do not like green eggs and ham"" の場合：
	$MyString.endsWith(""ham"") は true を返します
	$MyString.endsWith(""eggs"") は false を返します
また、文字列リテラルにおいても：
	(""There are gentlemen now abed."").endsWith(""abed"") は true を返します
	(""There are gentlemen now abed."").endsWith(""night"") は false を返します
このオペレーターはリテラル文字列を検索し、正規表現は検索しません。また、大文字と小文字を区別します：
	(""There are gentlemen now abed."").endsWith(""Abed"") は false を返します
String.beginsWith() も参照してください。正規表現を使用して文字列を検索する必要がある場合は、String.contains() を使用してください。"
String.expect(matchStr),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.expect(matchStr)
The operator tests if the String begins with the matchStr string with the following results:
* success: operator returns the rest of string that follows matchStr.
* failure: nothing is returned
Note that matchStr is not a regular expression and can only be a literal string.
For example:
	vText = $Text.expect(""abc""); 
Tests that the next characters in the stream read from $Text is the sequence abc, and advances the stream beyond ""abc"". Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .expect() unless a failure occurs in which case chained operators are not processed.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.expect(matchStr)
このオペレーターは、文字列が matchStr で始まっているかどうかを判定し、以下の結果を返します。
* 成功：matchStr に続く残りの文字列を返します。
* 失敗：何も返されません。
matchStr は正規表現ではなく、リテラル文字列である必要があることに注意してください。

例：
	vText = $Text.expect(""abc""); 
$Text から読み取られるストリームの次の文字がシーケンス「abc」であるかを確認し、ストリームを「abc」の先へと進めます。一致しない場合は失敗となり、カーソルは進みません。いずれの場合も（失敗して後続のオペレーターが処理されない場合を除き）、.expect() にチェーンされた他のオペレーターと同様に、変数 vText は結果のテキストストリームを受け取ります。

このオペレーターは、抽出対象のコンテンツが正しく検出されていることを保証するための補助として使用することを想定しています。本質的には「if」スタイルのテストであり、テストが成功すれば処理を進め、失敗すればカーソルはその位置に留まり、後続のストリーム解析オペレーターに備えます。"
String.expectNumber(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.expectNumber()
String.expectNumber
If the string begins with one or more contiguous character(s) that could be interpreted as a number, the String stream cursor skips to the end of that number sequence and parsing continues.
For example:
	vText = $Text.expectNumber(); 
Tests that the next characters in the stream read from $Text is a sequence of digits, and advances the stream past a continuous runs of digits. Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .expectNumber() unless a failure occurs in which case chained operators are not processed.
If the input stream passes in ""1234 items"" the cursor advances past '1234' such that the remaining stream is "" items"".
If the input stream passes in ""1,234 items"" the cursor advances past '1' such that the remaining stream is ""234 items"". Notice how number formatting delimiters like a comma (or other locale-specific delimiters) used in string representations of  numbers may confuse this operator is used without care.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.expectNumber()
String.expectNumber
文字列が、数値として解釈可能な1つ以上の連続した文字で始まっている場合、文字列ストリームのカーソルはその数値シーケンスの末尾までスキップし、解析（パース）を続行します。
例：
	vText = $Text.expectNumber(); 
$Textから読み取られたストリームの次の文字が数字のシーケンスであるかどうかをテストし、連続する数字の連なりを越えてストリームを進めます。そうでない場合は失敗し、カーソルは進みません。どちらの場合も、失敗が発生して後続のオペレータが処理されない場合を除き、.expectNumber()に連結された他のオペレータと同様に、変数vTextは結果のテキストストリームを受け取ります。
入力ストリームとして ""1234 items"" が渡された場合、カーソルは '1234' を越えて進み、残りのストリームは "" items"" になります。
入力ストリームとして ""1,234 items"" が渡された場合、カーソルは '1' を越えて進み、残りのストリームは ""234 items"" になります。数値の文字列表現で使用されるカンマ（またはその他のロケール固有の区切り文字）のような数値形式の区切り文字は、注意して使用しないとこのオペレータを混乱させる可能性があることに注意してください。
このオペレータの使用目的は、キャプチャ対象のコンテンツが正しく検出されるようにするための補助です。本質的には、これは「if」スタイルのテストです。テストが正しい場合は続行し、そうでない場合は、後続のストリーム解析オペレータのためにカーソルはその位置に留まります。"
String.expectWhitespace(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.expectWhitespace()
String.expectWhitespace
If the string begins the whitespace, skips the whitespace and succeeds. Otherwise, it fails.
For example:
	vText = $Text.expectWhitespace(); 
Tests that the next characters in the stream are non-word, and advances the stream beyond the detected  whitespaces characters. Otherwise, it fails and the cursor does not advance. Either way, the variable vText receives the resulting text stream as would any operator chained to .expectWhitespace() unless a failure occurs in which case chained operators are not processed. 
If the stream passed in is ""  Hello world"" (note the leading spaces) then the spaces are detected and the cursor returns ""Hello world"". But if the stream passed in is ""Hello world"" a word is detected and the cursor does not advance.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.expectWhitespace()
String.expectWhitespace
文字列が空白で始まる場合、その空白をスキップして成功します。それ以外の場合は失敗します。
例：
	vText = $Text.expectWhitespace(); 
ストリームの次の文字が非単語（non-word）であることをテストし、検出された空白文字を越えてストリームを進めます。それ以外の場合は失敗し、カーソルは進みません。いずれにせよ、失敗が発生してチェーンされたオペレーターが処理されない場合を除き、変数 vText は .expectWhitespace() にチェーンされた他のオペレーターと同様に、結果のテキストストリームを受け取ります。
渡されたストリームが ""  Hello world""（先頭の空白に注意）の場合、空白が検出され、カーソルは ""Hello world"" を返します。しかし、渡されたストリームが ""Hello world"" の場合、単語が検出され、カーソルは進みません。
このオペレーターは、キャプチャされるべきコンテンツが正しく検出されるのを確実にするための補助として使用されることが想定されています。本質的には「if」形式のテストであり、テストが正しければ進行し、そうでなければカーソルは、後に続く可能性のあるストリーム解析オペレーターのために現在の位置に留まります。"
String.expectWord(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.expectWord()
String.expectWord
If the string begins with one or more contiguous character(s) that could be interpreted as a word the String stream cursor skips to the end of that sequence and parsing continues.
What constitutes a word? This operator captures text from the current position up to (but not including) the next character that is a digit, whitespace, or punctuation.
For example:
	vText = $Text.expectWord(); 
Tests that the next characters in the stream are not non-word, and advances the stream beyond the detected word. Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .expectWord() unless a failure occurs in which case chained operators are not processed. 
If the stream passed in is ""Hello world"" then 'Hello' is detected and the cursor returns "" world"" (note the leading space). But if the stream passed in is "" Hello world"" (note the leading space), no word is detected and the cursor does not advance.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.expectWord()
String.expectWord
文字列が、単語として解釈可能な1つ以上の連続する文字で始まっている場合、Stringストリームのカーソルはそのシーケンスの末尾までスキップし、解析が継続されます。
何をもって単語と見なすのか？このオペレーターは、現在の位置から、数字、空白、または句読点である次の文字（それ自体は含まない）までのテキストを抽出します。
例：
	vText = $Text.expectWord(); 
ストリームの次の文字が単語構成文字であることを確認し、検出された単語を越えてストリームを進めます。単語でない場合は失敗し、カーソルは進みません。いずれの場合も、失敗が発生して連結されたオペレーターが処理されない場合を除き、.expectWord() に連結された他のオペレーターと同様に、変数 vText は結果のテキストストリームを受け取ります。
渡されたストリームが ""Hello world"" であれば、""Hello"" が抽出され、カーソルは "" world""（先頭の空白に注意）を返します。しかし、渡されたストリームが "" Hello world""（先頭の空白に注意）であれば、単語は検出されず、カーソルは進みません。
このオペレーターは、抽出したいコンテンツが正しく検出されることを保証するための補助として使用されることを想定しています。本質的には、これは「if」形式のテストです。テストが成功すれば処理を続行し、失敗すれば、後続のストリーム解析オペレーターのためにカーソルを元の位置に留めます。"
"String.extract(regexStr[, caseInsensitiveBln])",Function,Item,Data manipulation,String,false,9.1.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.extract(regexStr)
The operator returns the first matched subexpression of a quote-enclosed regular expression regexStr in the source String. If the regular expression has no subexpressions, the entire match is returned up to the end of the current line/paragraph, i.e. the first line break character encountered.
For example, take a String which is the $Text ""We are very tired, Harrison! #things #Memes #August"":
	$MyString = $Text.extract(""[A-Z][A-Za-z+]""); 
this returns ""We"" as that is the first match (although there are others). This sort of use is the presumed most likely used of this operator.
If we amend the regex
	$MyString = $Text.extract(""#([A-Z][A-Za-z+])""); 
it now returns ""Memes"" (the first hash tag starts with a lowercase letter does not match). 
If multiple matches are expected/wanted, see String.extractAll().
String.extract(regex[, caseInsensitiveBln]) 
String.extract() now accepts an optional boolean second argument caseInsensitiveBln. If that argument is true, the regex argument's regular expression search is case-insensitive. The default value is false respecting the pre-existing behaviour.
String.extract() recognises  and $ regex codes as applying to the start and end of a line within a multiline string. Therefore,  and $ can apply to line boundaries within a multiline string.","String.extract(regexStr)
このオペレータは、ソースとなる文字列（String）から、引用符で囲まれた正規表現 regexStr に最初に一致したサブエクスプレッション（部分式）を返します。正規表現にサブエクスプレッションが含まれていない場合は、最初に一致した箇所から現在の行または段落の終わり（つまり、最初に現れる改行文字）までの全体を返します。

例えば、$Text が ""We are very tired, Harrison! #things #Memes #August"" という文字列であるとします：
	$MyString = $Text.extract(""[A-Z][A-Za-z+]""); 
これは、他にも一致する箇所はありますが、最初の一致である ""We"" を返します。このような使い方が、このオペレータの最も一般的な用途と考えられます。

正規表現を次のように修正した場合：
	$MyString = $Text.extract(""#([A-Z][A-Za-z+])""); 
これは ""Memes"" を返します（最初のハッシュタグは小文字で始まっているため一致しません）。

複数の一致を期待または必要とする場合は、String.extractAll() を参照してください。

String.extract(regex[, caseInsensitiveBln]) 
String.extract() は、オプションの第2引数として論理値 caseInsensitiveBln を受け付けるようになりました。この引数が true の場合、正規表現の検索は大文字小文字を区別しません。デフォルト値は false で、これまでの動作を維持します。

String.extract() は、正規表現コードの ^ と $ を、複数行文字列内の行の先頭と末尾に適用されるものとして認識します。したがって、^ と $ は複数行文字列内の行の境界に適用できます。"
"String.extractAll(regexStr[, caseInsensitiveBln])",Function,Item,Data manipulation,List,false,9.1.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.extractAll(regexStr)
The operator returns a (semi-colon delimited) list of all matches for a quote-enclosed regexStr found in the source String.
For example:
	$MyList = $Text.extractAll(""#[A-Za-z]+""); 
would return a list of all discrete tag instances in the source String such as: ""#Tinderbox;#Stuff;#Thing;#tinderbox;#Tinderbox;#Cars"".
To get a de-duped list, without the hashes we can chain other operators:
	$MyList = $Text.extractAll(""#[A-Za-z]+"").unique.replace(""#"",""""); 
That refines the returned list: ""Cars;Stuff;Thing;Tinderbox;tinderbox"". Note the extra operators also sort the list too.
String.extractAll(regexStr[, caseInsensitiveBln])
String.extractAll() now accepts an optional boolean second argument caseInsensitiveBln. If that argument is true, the regex argument's regular expression search is case-insensitive. The default value is false respecting the pre-existing behaviour.","String.extractAll(regexStr)
このオペレータは、ソースの文字列（String）の中から、引用符で囲まれた正規表現（regexStr）に一致するすべての箇所の（セミコロン区切りの）リストを返します。
例：
	$MyList = $Text.extractAll(""#[A-Za-z]+""); 
これは、ソース文字列に含まれる ""#Tinderbox;#Stuff;#Thing;#tinderbox;#Tinderbox;#Cars"" のような個別のタグ・インスタンスのリストを返します。
重複を排除し、ハッシュ記号を除去したリストを取得するには、他のオペレータを繋げることができます：
	$MyList = $Text.extractAll(""#[A-Za-z]+"").unique.replace(""#"",""""); 
これにより、リストは ""Cars;Stuff;Thing;Tinderbox;tinderbox"" のように整理されます。追加されたオペレータによって、リストがソートもされることに注意してください。
String.extractAll(regexStr[, caseInsensitiveBln])
String.extractAll() は、オプションとして2番目の引数に真偽値 caseInsensitiveBln を取ることができるようになりました。この引数が true の場合、正規表現による検索は大文字と小文字を区別しません。デフォルト値は false で、従来の動作を継承します。"
String.failed(),Function,Item,Stream parsing,boolean test,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,true,"String.failed()
String.failed
.failed tests for a failed Stream processing action String.try{}, including an explicit fail() call. It returns true if the current operation has failed, and false otherwise.
When processing a string, it may be that the string is not what was expected. Thus the .failed operator raises a flag to say this process did not work.
A .failed flag is reset to false when the current try{} expires, or when the current action is complete.
For example, to test if a 'try' sequence has failed:
	if ( $MyString.try{ … }.failed() ) {
		$Color=""bright red"";
	}","String.failed()
String.failed
.failed は、明示的な fail() 呼び出しを含む、失敗したストリーム処理アクション String.try{} をテストします。現在の操作が失敗した場合は true を返し、それ以外の場合は false を返します。
文字列を処理する際、その文字列が期待通りでない場合があります。そのため、.failed オペレータは、このプロセスが機能しなかったことを示すフラグを立てます。
.failed フラグは、現在の try{} が終了するか、現在のアクションが完了したときに false にリセットされます。
例えば、'try' シーケンスが失敗したかどうかをテストするには：
	if ( $MyString.try{ … }.failed() ) {
		$Color=""bright red"";
	}"
String.find(matchStr),Function,Item,Data manipulation,Number,false,6.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.find(matchStr)
This operator returns a Number with the location of the first occurrence of a literal (not regex) substring matchStr within the source string. Thus, the operator searches for literal strings, not regular expressions. Matches are case sensitive. The offset is zero-based (position 1 is zero). If the string is not found, String.find(matchStr) returns -1.
For example, if $MyString is ""I do not like green eggs and ham"":
	$MyNumber = $MyString.find(""not""); returns 5
	$MyNumber = $MyString.find(""blue""); returns -1 (not found in match string)
	$MyNumber = $MyString.find(""Not""); returns -1 (not found, due to case-sensitive matching)","String.find(matchStr)
このオペレータは、ソース文字列内でリテラル（正規表現ではない）の部分文字列 matchStr が最初に現れる位置を数値（Number）で返します。したがって、このオペレータは正規表現ではなくリテラル文字列を検索します。一致は大文字と小文字を区別します。オフセットは0ベース（1番目の位置が0）です。文字列が見つからない場合、String.find(matchStr) は -1 を返します。
例えば、$MyString が ""I do not like green eggs and ham"" の場合：
	$MyNumber = $MyString.find(""not""); は 5 を返します
	$MyNumber = $MyString.find(""blue""); は -1 を返します（一致する文字列が見つからないため）
	$MyNumber = $MyString.find(""Not""); は -1 を返します（大文字と小文字を区別して一致しないため）"
String.following(matchStr),Function,Item,Data manipulation,String,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.following(matchStr)
The .following( ) operator extracts information from one or more paragraphs of a string using a literal quoted string as the match (i.e. no regex support). If matchStr appears in a line, then whatever follows after the matchStr is the result. If matchStr appears in more than one line, the return value is a list of results.
For example, if the text of a note is:
	From: Mark
	To: Clotilde
	Subject: Mignardise
Then:
	$MyString = $Text.following(""To:""); 
 would return ""Clotilde"".
	$MyString = $Text.following("":""); 
would return ""Mark;Clotilde:Mignardise"".
In addition, the .following() operator binds any text that precedes the matchStr string to $0. If the matchStr appears several times, the first prefix is bound to $0, the second to $1, and so forth.
The .following() operator's argument is interpreted as a sequence of characters, not a regular expression. If the flexibility of regular expressions is needed, use .find() instead.
The .following() operator is useful for extracting formal and semi-formal data from free text and simple interchange formats like email and RIS.
The .following() operator does not skip Tinderbox action code comments starting with // as this confounds working with URLs.","String.following(matchStr)
.following() 演算子は、引用符で囲まれたリテラル文字列を照合に使用し、文字列の1つ以上の段落から情報を抽出します（つまり、正規表現はサポートされていません）。matchStr が行内に出現した場合、matchStr の直後に続く内容が結果となります。matchStr が複数の行に出現する場合、戻り値は結果のリストになります。
例えば、ノートのテキストが以下の場合：
	From: Mark
	To: Clotilde
	Subject: Mignardise
このとき：
	$MyString = $Text.following(""To:""); 
は ""Clotilde"" を返します。
	$MyString = $Text.following("":""); 
は ""Mark;Clotilde:Mignardise"" を返します。
さらに、.following() 演算子は matchStr 文字列の前にくる任意のテキストを $0 にバインドします。matchStr が複数回出現する場合、最初の前置テキストは $0 に、2番目は $1 に、というようにバインドされます。
.following() 演算子の引数は、正規表現ではなく一連の文字列として解釈されます。正規表現の柔軟性が必要な場合は、代わりに .find() を使用してください。
.following() 演算子は、自由形式のテキストや Eメール、RIS のような単純なデータ交換形式から、定型および準定型データを抽出するのに便利です。
.following() 演算子は、URL の操作との混同を避けるため、// で始まる Tinderbox アクションコードのコメントをスキップしません。"
String.highlights([aColor]),Property,Item,Data manipulation,List,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.highlights(aColor)
String.highlights
The expression returns a list of strings that have been highlighted in the $Text using Format ▸ Highlight. 
	$MyList = $Text.highlights; 
Note: aColor can only be the value of a named colour as listing in the menu Format ▸ Style ▸ Highlight.
String.highlights(aColor)
The result may be limited to strings highlighted in a specific colour by supplying aColor as an argument. aColor may be any of the currently supported highlight colours: ""red"", ""green"", ""blue"", ""yellow"", or ""magenta"". Thus:
	$MyList = $Text.highlights(""red"");
would return only those highlighted $Text portions using a red highlight colour.","String.highlights(aColor)
String.highlights
この式は、[フォーマット] ▸ [ハイライト]（Format ▸ Highlight）を使用して $Text 内でハイライトされた文字列のリストを返します。
	$MyList = $Text.highlights; 
注意：aColor には、[フォーマット] ▸ [スタイル] ▸ [ハイライト] メニューにリストされている名前付きカラーの値のみを指定できます。

String.highlights(aColor)
引数として aColor を渡すことで、特定の色でハイライトされた文字列のみに結果を制限できます。aColor には、現在サポートされているハイライトカラーである ""red""（赤）、""green""（緑）、""blue""（青）、""yellow""（黄）、または ""magenta""（マゼンタ）のいずれかを指定できます。したがって：
	$MyList = $Text.highlights(""red"");
は、赤色のハイライトが使用されている $Text の部分のみを返します。"
String.icontains(regexStr),Function,Item,Query Boolean,boolean test,false,5.7.1,Baseline,9.0.0,,,1,true,true,false,false,true,false,false,false,false,,false,"String.icontains(regexStr)
This operator tests whether regular expression pattern regexStr matches the referenced string attribute's value in whole or part. Matches are always case-insensitive, unlike String.contains(). The match gives a coerced boolean result: if regexStr is matched (literally or via regex) the function returns the match offset+1 in the source string, where offset is the distance from the start of the string to the start of the matched regex. No match, coerces to false. The +1 works around the fact the match is zero-based, so a match at position 0 (the start of the string), returns as 1 (0+1) and a value of 1 or more coerces to a boolean true. The boolean allows queries' normal true/false to evaluate as normal.
If needing case-sensitivity, use String.contains() which is always case-sensitive
regexStr is one of:
* an unquoted action code expression, which includes just referencing a single attribute name e.g. MyString
* a quoted string; quoted strings may be either:
** a literal string (i.e. actual text)
** a regular expression.
Important: do not omit the enclosing quotes for literal strings or regex. If omitted, Tinderbox will try to evaluate the string as an expression. Doing this may result in the expected result but this is actually a false positive. So, remember to enclose your regex or literals in quotes.
For example:
	$MyString.icontains(""regex"") 
is true if $MyString matches regexStr's pattern. Other more complex usage:
	$MyString.icontains($MyMatchText) 
	$MyString.icontains($MyString(agent)) 
	$MyString(parent).icontains(""Tuesday"") 
	""Any day like Saturday is good"".icontains($MyDay) 
	""Any day like Saturday is good"".icontains(""Saturday"") 
Note that regex/literal strings are quoted whilst action expressions are not.
Getting the offset of the (first) regex match
If the regular expression regexStr is found the function returns the match offset+1, where offset is the distance from the start of the string to the start of the matched regex. If there is more than one match, the offset of the first match is returned. Formerly, .contains() returned true if the regex was found. The '+1' modifier ensures that a match at position zero return a number higher than zero which would otherwise coerce to false. Since 1+offset is always true, no changes are required in existing documents but the function also gives usable offset information. Thus, if $MyString is ""abcdefgehEi"":
	$MyNumber = $MyString.icontains(""e""); returns 5.
	$MyNumber = $MyString.icontains(""E""); returns 5.
	$MyNumber = $MyString.icontains(""eh""); returns 8.
Testing ""does not contain""
Use a ! prefix to the query argument:
	!$MyString.icontains(""Tuesday"") 
Use of parentheses around the negated query term, can assist Tinderbox's parsing:
	(!$MyString.icontains(""Tuesday"")) 
Using back-references
In an agent query or if() conditions the function can return back-references to matches of (sub-)strings.
String.icontains() clears the list of back references from previous processes, so $0 and $1 correspond to its own results, not those from prior expressions.
Dealing with inline quote characters
Because regex is parsed for regular expressions, it may be possible to use the '\xNN' form described here to work around the lack of escaping from single double quotes within strings.
Legacy format
This operator is the replacement of the older form of AttributeName(regex) which is deprecated and should not be used in new work (legacy support may fall away). Apart from anything else, the current syntax should remove the confusion over whether/when to use the $ prefix with attribute names in queries.","String.icontains(regexStr)
このオペレータは、正規表現パターン regexStr が、参照された文字列属性の値の全部または一部と一致するかどうかをテストします。String.contains() とは異なり、一致の判定は常に大文字と小文字を区別しません。

一致判定の結果は、ブール値として評価可能な数値（強制的なブール値の結果）となります。regexStr が（リテラルまたは正規表現として）一致した場合、関数はソース文字列内の一致オフセット+1を返します。ここでオフセットとは、文字列の先頭から一致した正規表現の開始位置までの距離です。一致しない場合は、false（0）を返します。

「+1」という処理は、一致判定が0ベースであること（文字列の先頭、つまり位置0で一致した場合に0を返すと、ブール値のfalseと誤認されてしまうこと）を回避するためのものです。位置0での一致は 1 (0+1) として返され、1以上の値はブール値の true として評価されます。この仕組みにより、クエリの通常の true/false 判定が期待通りに機能します。

大文字と小文字を区別する必要がある場合は、常に大文字と小文字を区別する String.contains() を使用してください。

regexStr は以下のいずれかです：
* 引用符で囲まれていないアクションコード式。これには、MyString のような単一の属性名の参照も含まれます。
* 引用符で囲まれた文字列。引用符で囲まれた文字列は以下のいずれかとして扱われます：
  * リテラル文字列（実際のテキスト）
  * 正規表現
重要：リテラル文字列や正規表現を囲む引用符を省略しないでください。省略すると、Tinderbox はその文字列を式として評価しようとします。これにより期待通りの結果が得られることもありますが、それは実際には「偽陽性」です。したがって、正規表現やリテラルを引用符で囲むことを忘れないでください。

例：
	$MyString.icontains(""regex"") 
$MyString が regexStr のパターンに一致する場合に true となります。その他のより複雑な使用例：
	$MyString.icontains($MyMatchText) 
	$MyString.icontains($MyString(agent)) 
	$MyString(parent).icontains(""Tuesday"") 
	""Any day like Saturday is good"".icontains($MyDay) 
	""Any day like Saturday is good"".icontains(""Saturday"") 
正規表現やリテラル文字列は引用符で囲まれますが、アクション式は囲まれないことに注意してください。

（最初の一致の）正規表現一致のオフセットの取得
正規表現 regexStr が見つかった場合、関数は一致オフセット+1を返します。ここで、オフセットは文字列の開始位置から一致した正規表現の開始位置までの距離です。複数の一致がある場合は、最初の一致のオフセットが返されます。
以前の .contains() は正規表現が見つかった場合に true を返していました。「+1」という修飾は、位置ゼロでの一致がゼロより大きい数値を返すことを保証し、そうでなければ false に強制されてしまう状況を防ぎます。「1+オフセット」は常に true と評価されるため、既存のドキュメントを変更する必要はありませんが、同時にこの関数は利用可能なオフセット情報も提供するようになっています。

例えば、$MyString が ""abcdefgehEi"" の場合：
	$MyNumber = $MyString.icontains(""e""); は 5 を返します。
	$MyNumber = $MyString.icontains(""E""); は 5 を返します。
	$MyNumber = $MyString.icontains(""eh""); は 8 を返します。

「含まない」ことのテスト
クエリ引数に ! プレフィックスを使用します：
	!$MyString.icontains(""Tuesday"") 
否定されたクエリ項を括弧で囲むと、Tinderbox の解析を補助できます：
	(!$MyString.icontains(""Tuesday"")) 

後方参照の使用
エージェントクエリまたは if() 条件において、この関数は（サブ）文字列の一致への後方参照を返すことができます。
String.icontains() は以前のプロセスからの後方参照のリストをクリアするため、$0 や $1 は前の式の結果ではなく、その関数自体の結果に対応します。

インライン引用符文字の扱い
正規表現は正規表現として解析されるため、文字列内にある二重引用符のエスケープ不足を回避するために、ここで説明されている '\xNN' 形式を使用して回避できる場合があります。

レガシー形式
このオペレータは、古い形式の AttributeName(regex) の代替です。古い形式は非推奨であり、新しい作業では使用すべきではありません（レガシーサポートは将来的に廃止される可能性があります）。また、現在の構文により、クエリで属性名に $ プレフィックスを使用するかどうか、またいつ使用するかについての混乱が解消されます。"
String.icontainsAnyOf(regexList),Function,List,Query Boolean,boolean test,false,8.9.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.icontainsAnyOf(regexList"")
The operator .icontainsAnyOf(""regexList) is true if any of the words in a set of words (i.e. list) is contained in the chained-to target string. As shown below, the list may have only one entry. The test is case-insensitive. For example:
	$MyBoolean = $Text.icontainsAnyOf(""emulate""); 
Will be true if the tested note's $Text contains the word ""emulate"". A more applied example:
	$MyBoolean = $Text.icontainsAnyOf(wordsRelatedTo(""emulate"")); 
Will be true if the tested note's $Text contains the word ""aspire"".
regexList implies using a list of values (ideally with no dupes). This can be a literal list of 1 or more values—as in the example above, or an attribute reference holding a list of values, for instance:
	$MyBoolean = $Text.icontainsAnyOf($MySet); 
It is important to note that .containsAnyOf() is always a case-insensitive test. Thus in the first example above, it will match both ""emulate"" and ""Emulate"" or any other case variant of the word.
Use of regular expressions
Although the examples above use whole words the list in regexList is actually processed assuming they are regular expressions (which may of course be literal strings). Thus in the first example above, it will match both ""emulate"" and ""emulated"" but not ""emulating"". The test value ""emulate\b"", expecting a word break after the final 'e' would this match ""emulate"" but not ""emulated"".
For a case-sensitive version of this operator see String.containsAnyOf().
If wishing to test a List or Set, chain to list.asString():
	$MyBoolean = $MyList.asString.icontainsAnyOf(wordsRelatedTo(""emulate""));","String.icontainsAnyOf(""regexList"")
オペレーター `.icontainsAnyOf(""regexList"")` は、一連の単語（すなわちリスト）に含まれるいずれかの単語が、ドットで繋がれたターゲット文字列に含まれている場合に真（true）となります。以下に示すように、リストのエントリは1つだけでも構いません。このテストは大文字・小文字を区別しません。例えば：
	$MyBoolean = $Text.icontainsAnyOf(""emulate""); 
これは、テスト対象のノートの `$Text` に ""emulate"" という単語が含まれている場合に真となります。より応用的な例：
	$MyBoolean = $Text.icontainsAnyOf(wordsRelatedTo(""emulate"")); 
これは、テスト対象のノートの `$Text` に ""aspire"" という単語が含まれている場合に真となります。
regexList は、値のリスト（理想的には重複のないもの）を使用することを意味します。これは、上記の例のような1つ以上の値のリテラルなリスト、またはリスト値を保持する属性参照のいずれかです。例えば：
	$MyBoolean = $Text.icontainsAnyOf($MySet); 
重要な点として、.icontainsAnyOf() は常に大文字・小文字を区別しないテストです。したがって、最初の例では、""emulate"" と ""Emulate""、あるいはその単語の他の大文字・小文字のバリエーションの両方に一致します。
正規表現の使用
上記の例では完全な単語を使用していますが、regexList 内のリストは実際には正規表現（もちろんリテラル文字列でも可）として処理されます。したがって、最初の例では、""emulate"" と ""emulated"" の両方に一致しますが、""emulating"" には一致しません。末尾の 'e' の後にワード境界（word break）を期待するテスト値 ""emulate\b"" は、""emulate"" には一致しますが、""emulated"" には一致しません。
このオペレーターの大文字・小文字を区別するバージョンについては、String.containsAnyOf() を参照してください。
List型やSet型をテストしたい場合は、list.asString() にチェーンしてください：
	$MyBoolean = $MyList.asString.icontainsAnyOf(wordsRelatedTo(""emulate""));"
String.json(),Function,Item,Formatting,String,false,5.7.0,Baseline,v9.1.0,,,,false,true,false,false,false,false,false,false,false,,true,"IMPORTANT: if looking for reading JSON see JSON.json[] and associated operators


LEGACY ONLY
Operator Deprecated in v9.1.0+ - use String.jsonEncode() instead
String.json()
String.json
This operator returns a JSON-encoded UTF-8 version of a string attribute's value. The apostrophe (straight single quote), straight double quote, solidus (forward slash) and backslash characters are all escaped by a preceding backslash character.
Now, use jsonEncode().","重要：JSONの読み取りについては、JSON.json[]および関連するオペレータを参照してください。

レガシー専用
v9.1.0以降で非推奨のオペレータ - 代わりに String.jsonEncode() を使用してください。
String.json()
String.json
このオペレータは、文字列属性の値をJSONエンコードされたUTF-8形式で返します。アポストロフィ（直線のシングルクォート）、直線のダブルクォート、ソリダス（スラッシュ）、およびバックスラッシュ文字はすべて、直前のバックスラッシュ文字によってエスケープされます。
現在は、jsonEncode() を使用してください。"
String.jsonEncode(),Function,Item,Formatting,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.jsonEncode()
String.jsonEncode
The .jsonEncode() operator returns a JSON-encoded UTF-8 version of the chained source String's value. Forbidden characters such as the apostrophe (straight single quote), straight double quote, solidus (forward slash) and backslash characters are all escaped by a preceding backslash character.
The general expectation is String will be a quoted literal string or a String-type attribute or variable, e.g. $Text:
	var:string vEncoded = $Text.jsonEncode() 
	value(""Apostrophe's are often wrongly used"".jsonEncode()) 
This operator was formerly know as .json, and is effectively a replacement for that operator. The naming also better reflects the non dot-operator jsonEncode().
Using the latter, the same outcome can be encoded as:
	var:string vEncoded = jsonEncode($Text) 
	value(jsonEncode(""Apostrophe's are often wrongly used"")) 
For attributes, variables and very long literal string, the chained dot-operator seems more helpful when coding, whereas the older form may be more intuitive with short literal strings (as shown in the last example above.)","String.jsonEncode()
String.jsonEncode
.jsonEncode() 演算子は、連結されたソース String の値を JSON エンコードされた UTF-8 バージョンで返します。アポストロフィ（垂直の一重引用符）、垂直の二重引用符、ソリダス（スラッシュ）、およびバックスラッシュなどの禁止文字は、すべて直前にバックスラッシュを置くことでエスケープされます。
一般的に、String は引用符で囲まれたリテラル文字列、または String 型の属性や変数であることが想定されます（例：$Text）。
	var:string vEncoded = $Text.jsonEncode() 
	value(""Apostrophe's are often wrongly used"".jsonEncode()) 
この演算子は以前は .json として知られており、事実上その演算子の代替となります。また、この名称はドット演算子ではない形式の jsonEncode() をより適切に反映しています。
後者を使用すると、同じ結果を次のようにエンコードできます。
	var:string vEncoded = jsonEncode($Text) 
	value(jsonEncode(""Apostrophe's are often wrongly used"")) 
属性、変数、および非常に長いリテラル文字列の場合、コーディング時には連結されたドット演算子の方が便利に感じられますが、短いリテラル文字列の場合は（上の最後の例のように）以前の形式の方が直感的かもしれません。"
String.lowercase(),Function,Item,Formatting,String,false,5.9.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.lowercase()
String.lowercase
Returns the referenced string, transforming all uppercase letters to lowercase.
The function can be chained to both string data and to string literals:
	$MyString.lowercase() 
	""My NEW Title"".lowercase() 
The latter results in ""my new title"".
The trailing parentheses may be omitted:
	$MyString.lowercase 
Functionally equivalent to lowercase().
If $MyString is ""Hello World"":
	$MyString = $MyString.lowercase; 
$MyString is set to ""hello world"".
The .lowercase() method may also be used on Lists or Sets. Consider [Ant;BEE;Cow] stored in $MyList:
	$MyList = $MyList.lowercase; 
… giving [ant;bee;cow].","String.lowercase()
String.lowercase
参照された文字列内のすべての大文字を小文字に変換して返します。
この関数は、文字列データと文字列リテラルの両方に連結（チェーン）させることができます：
	$MyString.lowercase() 
	""My NEW Title"".lowercase() 
後者は ""my new title"" という結果になります。
末尾の括弧は省略可能です：
	$MyString.lowercase 
これは lowercase() と機能的に等価です。
$MyString が ""Hello World"" の場合：
	$MyString = $MyString.lowercase; 
$MyString は ""hello world"" に設定されます。
.lowercase() メソッドは、リスト（List）型やセット（Set）型のデータに対しても使用できます。$MyList に [Ant;BEE;Cow] が格納されている場合：
	$MyList = $MyList.lowercase; 
…結果は [ant;bee;cow] となります。"
String.next(),Function,Item,Data manipulation,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.next()
String.next
The operator .next generates convenient note names and other strings in a sequence. For example:
	$MyString = ""footnote"".next ; → ""footnote 1""
	$MyString = ""footnote 1"".next; → ""footnote 2""
Specifically, .next searches a string for its last run of digits. If no digits are found, .next returns the string followed by "" 1"". Otherwise, the number is increments and placed in the same position in the string.
	$MyString = ""Agent 007 (active)"".next; → ""Agent 008 (active)""","String.next()
String.next
演算子 .next は、シーケンス内の便利なノート名やその他の文字列を生成します。例：
	$MyString = ""footnote"".next ; → ""footnote 1""
	$MyString = ""footnote 1"".next; → ""footnote 2""
具体的には、.next は文字列の中から最後の数字の並びを検索します。数字が見つからない場合、.next は文字列の末尾に「 1」を追加して返します。数字が見つかった場合は、その数字をインクリメント（1増加）し、文字列内の同じ位置に配置します。
	$MyString = ""Agent 007 (active)"".next; → ""Agent 008 (active)"""
String.nounList(),Property,Item,Data manipulation,List,false,9.0.0,Baseline,,,10.14,,false,true,false,false,false,false,false,false,false,,false,"String.nounList()
String.nounList
This returns a list of each noun in the supplied string, excepting those recognised as pronouns and proper names. Note that the output list is all lowercase, regardless of source case. This operator requires running on macOS 10.14 and later.
	$MyList = ""I am the very model of a modern Major-General."".nounList; 
then MyList holds ""model;major;general"".","String.nounList()
String.nounList
指定された文字列に含まれる各名詞のリストを返します。ただし、代名詞や固有名詞として認識されるものは除外されます。出力されるリストは、元の格（大文字・小文字）に関わらず、すべて小文字になることに注意してください。この演算子は macOS 10.14 以降で実行する必要があります。
	$MyList = ""I am the very model of a modern Major-General."".nounList; 
この場合、MyList には ""model;major;general"" が格納されます。"
String.paragraph(paraNum),Function,Item,Data manipulation,String,false,7.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.paragraph(paraNum)
returns the text of the paraNum paragraph in the source string. paraNum is zero-based, i.e. the first paragraph is .paragraph(0); empty paragraphs are ignored. If the string does not contain paraNum paragraphs, the result is an empty string. 
If paraNum is negative, Tinderbox counts from the last paragraph. Thus, $Text.paragraph(-1) is the last paragraph in the text.
For example:
	$MyString = $Text.paragraph(2); 
sets $MyString the the contents of the third paragraph of $Text—recall at N is zero-based, so counting 0/1/2 means 2 is #3 in the sequence.","String.paragraph(paraNum)
ソース文字列内の paraNum 番目の段落のテキストを返します。paraNum は 0 基点です。つまり、最初の段落は .paragraph(0) です。空の段落は無視されます。文字列に paraNum 番目の段落が含まれていない場合、結果は空の文字列になります。
paraNum が負の値の場合、Tinderbox は最後の段落から数えます。したがって、$Text.paragraph(-1) はテキストの最後の段落になります。
例：
    $MyString = $Text.paragraph(2); 
は $MyString に $Text の 3 番目の段落の内容を設定します。N は 0 基点であるため、0/1/2 と数えると 2 はシーケンスの 3 番目になります。"
String.paragraphCount(),Property,Item,Data manipulation,Number,false,7.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.paragraphCount()
String.paragraphCount
returns the Number of paragraphs in a string; empty paragraphs are ignored. Thus, $Text.paragraphCount is the number of paragraphs in the text of the currently selected note.
	$MyNumber = $Text.paragraphCount; 
sets $MyNumber to the number of discrete paragraphs within $Text.","String.paragraphCount()
String.paragraphCount
文字列内の段落数を返します。空の段落は無視されます。したがって、$Text.paragraphCount は、現在選択されているノートのテキストに含まれる段落の数となります。
	$MyNumber = $Text.paragraphCount; 
$MyNumber に $Text 内の個別の段落数を設定します。"
String.paragraphList(),Property,Item,Data manipulation,List,false,9.0.0,Baseline,,,10.14,,false,true,false,false,false,false,false,false,false,,false,"String.paragraphList()
String.paragraphList
The .paragraphList operator returns a list of paragraphs contained in a string. This operator requires running on macOS 10.14 and later. For example, to get a list of the discrete paragraphs in $Text:
		$MyList = $Text.paragraphList; 
To set a string to the third paragraph of $Text (recall the .at(N) operator is zero-based):
		$MyString = $Text.paragraphList.at(2); 
If wanting to iterate and test paragraphs, rather than chain $Text.paragraphList.each(){}, use the newer stream parsing method $Text.eachLine(){}. In both instance a line—or paragraph—is a substring—delimited by one of more successive line breaks.
Source paragraphs containing semicolons
As .paragraphList returns a List, if any source paragraph containing a semicolon it will create more than one item in the returned list. In such circumstances, in may be better to use .eachLine() instead. Or, if encountered, a technique is to first sanitise the source by changing semicolons to another string and then back:
    var:string vSource = $Text.replace("";"",""@@@"");
    $MyList = vSource.paragraphList;
    $MyString = $MyList.at(4)replace(""@@@"","";"");","String.paragraphList()
String.paragraphList
.paragraphList 演算子は、文字列に含まれる段落のリストを返します。この演算子は macOS 10.14 以降で動作します。例えば、$Text 内の個別の段落のリストを取得するには以下のようにします：
		$MyList = $Text.paragraphList; 
$Text の3番目の段落を文字列に設定するには（.at(N) 演算子はゼロベースであることに留意してください）：
		$MyString = $Text.paragraphList.at(2); 
段落を反復処理して検証したい場合は、$Text.paragraphList.each(){} をつなげるのではなく、より新しいストリーム解析メソッドである $Text.eachLine(){} を使用してください。どちらの場合も、行（または段落）は、1つ以上の連続した改行で区切られた部分文字列となります。
セミコロンを含む元の段落について
.paragraphList はリスト（List）を返すため、元の段落のいずれかにセミコロンが含まれていると、返されるリストではその段落が複数の項目になってしまいます。そのような状況では、代わりに .eachLine() を使用する方が良いかもしれません。あるいは、直面した場合の対処法として、まずソース内のセミコロンを別の文字列に置換して無害化し、後で元に戻すという手法があります：
    var:string vSource = $Text.replace("";"","" @@@"");
    $MyList = vSource.paragraphList;
    $MyString = $MyList.at(4)replace("" @@@"","";"");"
String.paragraphs(parasNum),Function,Item,Data manipulation,String,false,5.8.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.paragraphs(parasNum)
This function extracts the first parasNum paragraphs of the referenced string or String-type attribute. Examples:
	$MyString = ""Paragraph 1\nParagraph 2"".paragraphs(1); 
In the example the ""\n"" simulates a line break. The code would set $MyString to the string ""Paragraph 1"". A more real example:
	$Text = $Text(""Some note"").paragraphs(2); 
In the second example the current note's $Text would be set to the first 2 paragraphs of note ""Some note"".
To get a single given paragraph of a multi line/paragraph string, such as $Text, see String.split() (beware of semicolons in the source string being misinterpreted as list item delimiters, as discussed in that article).
This function respects existing rich text styling.
To get all paragraphs as a list, e.g. in order to iterate against them using list.each(), then use string.split(), e.g.:
	$MyList = $Text.split(""\n+""); 
Or from a different note, e.g. 'another note':
	$MyList = $Text(""another note"").split(""\n+""); 
The \n+ implies to split on and remove sub-strings of one or more consecutive line breaks, thus avoiding the creation of unwanted creating blank list items in the output where there are several line breaks between paragraphs.
Working with styled text
This operator is capable of worthing with StyledString operators: StyledString.bold, StyledString.fontSize(), StyledString.italic and StyledString.strike.","String.paragraphs(parasNum)
この関数は、参照された文字列またはString型の属性の最初の parasNum 個の段落を抽出します。例：
	$MyString = ""Paragraph 1\nParagraph 2"".paragraphs(1); 
この例の ""\n"" は改行をシミュレートしています。このコードにより、$MyString には ""Paragraph 1"" という文字列が設定されます。より現実的な例：
	$Text = $Text(""Some note"").paragraphs(2); 
2番目の例では、現在のノートの $Text に ""Some note"" というノートの最初の2つの段落が設定されます。
複数行/複数段落の文字列（$Text など）から特定の1つの段落を取得するには、String.split() を参照してください（その記事で説明されているように、元の文字列内のセミコロンがリスト項目の区切り文字として誤解される可能性があることに注意してください）。
この関数は、既存のリッチテキストのスタイリングを保持します。
すべての段落をリストとして取得し、例えば list.each() を使用してそれらを反復処理するには、string.split() を使用します。例：
	$MyList = $Text.split(""\n+""); 
または、別のノート（例：'another note'）から取得する場合：
	$MyList = $Text(""another note"").split(""\n+""); 
\n+ は、1つ以上の連続する改行で分割して削除することを意味し、これにより段落間に複数の改行がある場合に出力に不要な空のリスト項目が作成されるのを防ぎます。
スタイル付きテキストの処理
このオペレータは、StyledString オペレータである StyledString.bold、StyledString.fontSize()、StyledString.italic、StyledString.strike と共に使用することが可能です。"
"String.replace(regexMatchStr, replacementStr)",Function,Item,Data manipulation,String,false,5.7.0,Baseline,,,,2,true,true,false,false,true,false,false,false,false,,false,"**String/List.replace(regexMatchStr, replacementStr)**

This operator performs simple text transformations on strings or lists. It returns a new string with replacements made; it does not modify the source attribute unless explicitly assigned back to it.

**Syntax & Parameters**
`$MyString.replace(regexMatchStr, replacementStr)`

*   **regexMatchStr**: The pattern to find. Can be:
    *   A literal string.
    *   A regular expression (e.g., `.` for any character, `*` for 0+ occurrences).
    *   An action code expression.
*   **replacementStr**: The string to insert. Can be:
    *   A literal string.
    *   An action code expression.
    *   Back-references (`$1`, `$2`, ... `$9`) to captured groups from `regexMatchStr` (`$0` is the entire match).

**Key Functionality**
*   **Global Replacement**: Replaces *all* occurrences of the pattern.
*   **Immutability**: `$MyString.replace(...)` returns a modified copy. To update the attribute, use assignment: `$MyString = $MyString.replace(...)`.
*   **Deletions**: If `replacementStr` is omitted (`$MyString.replace(regexMatchStr)`), matches are removed.

**Advanced Usage**
*   **Regex & Back-references**: Supports standard regex.
    *   Example: `$Text = $Text.replace(""From: (.+) @(.*)"", ""——$1——\n$2"");` formats email headers.
*   **Chaining**: Use multiple `.replace()` calls for different replacements.
    *   Example: `$MyNumber.replace(""regex1"", ""replace1"").replace(""regex2"", ""replace2"")`.
*   **Styling**:
    *   Preserves existing rich text styles in the source.
    *   Allows applying style operators (like `.bold`, `.italic`, `.strike`) to the replacement, particularly useful with `$Text`.
    *   Example: `replace(""^From: .*"", $0.bold)` bolds lines starting with ""From: "".
*   **Link Anchors**: When used on `$Text`, it preserves and updates the positions of existing text link anchors.
*   **Trimming**:
    *   Whitespace: Can trim leading/trailing spaces using regex anchors (`^` and `$`). Note that on multi-line text (like `$Text`), this applies to every paragraph.
    *   Quotes: Tinderbox cannot escape quotes (e.g., `\""`). Use `String.substr()` for removing enclosing quotes or hex codes (`\xNN`) for inline quotes in regex.

**Examples**
*   `$MyString.replace(""Spenser"", ""Spencer"")`: Corrects spelling.
*   `$MyString.replace(""(a|e|i|o|u)"", """")`: Removes all vowels.
*   `$Text = ""$Text.replace(""(green) (eggs)"", $2.bold + "" "" + $1.strike)`: Swaps words and applies styling.","**String/List.replace(regexMatchStr, replacementStr)**

このオペレータは、文字列またはリストに対して単純なテキスト置換を実行します。置換が行われた新しい文字列を返します。明示的に代入しない限り、元の属性自体は変更されません。

**構文とパラメータ**
`$MyString.replace(regexMatchStr, replacementStr)`

*   **regexMatchStr**: 検索するパターン。以下のいずれかです：
    *   リテラル文字列。
    *   正規表現（例：任意の文字を表す `.`、0回以上の繰り返しを表す `*` など）。
    *   アクションコードの式。
*   **replacementStr**: 挿入する文字列。以下のいずれかです：
    *   リテラル文字列。
    *   アクションコードの式。
    *   `regexMatchStr` でキャプチャされたグループへの後方参照（`$1`、`$2`、... `$9`。`$0` はマッチ全体）。

**主な機能**
*   **グローバル置換**: パターンのすべての出現箇所を置換します。
*   **不変性**: `$MyString.replace(...)` は変更されたコピーを返します。属性を更新するには、代入を使用します：`$MyString = $MyString.replace(...)`。
*   **削除**: `replacementStr` が省略された場合（`$MyString.replace(regexMatchStr)`）、マッチした箇所が削除されます。

**高度な使用法**
*   **正規表現と後方参照**: 標準的な正規表現をサポートします。
    *   例：`$Text = $Text.replace(""From: (.+) @(.*)"", ""——$1——\n$2"");` はメールのヘッダーを整形します。
*   **チェイニング（連結）**: 異なる置換を行うために、複数の `.replace()` 呼び出しを連結できます。
    *   例：`$MyNumber.replace(""regex1"", ""replace1"").replace(""regex2"", ""replace2"")`
*   **スタイリング**:
    *   元のソースにある既存のリッチテキストスタイルを保持します。
    *   置換後のテキストにスタイルオペレータ（`.bold`、`.italic`、`.strike` など）を適用できます。これは特に `$Text` で便利です。
    *   例：`replace(""^From: .*"", $0.bold)` は、""From: "" で始まる行を太字にします。
*   **リンクアンカー**: `$Text` に使用した場合、既存のテキストリンクアンカーの位置を保持し、更新します。
*   **トリミング**:
    *   空白文字：正規表現のアンカー（`^` と `$`）を使用して、先頭や末尾のスペースをトリミングできます。マルチラインテキスト（`$Text` など）の場合、これはすべての段落に適用されることに注意してください。
    *   引用符：Tinderbox では引用符をエスケープ（`\""` など）できません。囲んでいる引用符を削除するには `String.substr()` を使用するか、正規表現内のインライン引用符には 16 進コード（`\xNN`）を使用してください。

**例**
*   `$MyString.replace(""Spenser"", ""Spencer"")`: スペルを修正します。
*   `$MyString.replace(""(a|e|i|o|u)"", """")`: すべての母音を削除します。
*   `$Text = $Text.replace(""(green) (eggs)"", $2.bold + "" "" + $1.strike)`: 単語を入れ替え、スタイルを適用します。"
String.reverse(),Function,Item,Data manipulation,String,false,5.8.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.reverse()
String.reverse
This function reverses the order of the referenced string or string literal. Trailing parentheses are optional for this function.
	$MyString = $MyString.reverse(); 
	$MyString = $MyString.reverse; 
	$MyString = ""man bites dog"".reverse(); 
The latter gives ""god setib nam"" not ""dog bites man"". It is the order of characters that is reversed, not words within it.","String.reverse()
String.reverse
この関数は、対象の文字列または文字列リテラルの文字の順序を反転させます。この関数では、末尾の括弧（）は省略可能です。
	$MyString = $MyString.reverse(); 
	$MyString = $MyString.reverse; 
	$MyString = ""man bites dog"".reverse(); 
最後の例の結果は ""dog bites man"" ではなく ""god setib nam"" となります。反転されるのは文字列内の単語ではなく、文字の順序です。"
String.sentence([sentenceNum]),Function,Item,Data manipulation,String,false,9.5.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.sentence([sentenceNum])
String.sentence()
String.sentence
The dot-operator .sentence(sentenceNum) extracts the sentenceNumth sentence from the source String, which most likely will be $Text. For example, if $Text contains the passage ""Mr. Smith went to Washington. He shook hands. He kissed babies."", then""
	$MyString = $Text.sentence(0); 
returns 'Mr. Smith went to Washington.' and
	$Text.sentence(2) 
returns ""He kissed babies.""
If the sentenceNum argument is omitted, the initial sentence is returned. This is sentence 0 (zero) as sentenceNum is a zero-based index.
The definition of a 'sentence' is heuristic, and varies depending on the locale. In the example above, notice Tinderbox (in en-US locale) recognises that the period following ""Mr."" ends an abbreviation, not a sentence. The locale is derived from the users macOS settings but can also be set contextually using locale().","String.sentence([sentenceNum])
String.sentence()
String.sentence
ドット演算子 .sentence(sentenceNum) は、元の String（通常は $Text）から sentenceNum 番目の文章を抽出します。たとえば、$Text に ""Mr. Smith went to Washington. He shook hands. He kissed babies."" という一節が含まれている場合、
	$MyString = $Text.sentence(0);
は 'Mr. Smith went to Washington.' を返し、
	$Text.sentence(2)
は ""He kissed babies."" を返します。
引数 sentenceNum が省略された場合は、最初の文章が返されます。sentenceNum は 0 から始まるインデックス（ゼロベース）であるため、これは文章 0 に相当します。
「文章（sentence）」の定義はヒューリスティック（経験則的）であり、ロケールによって異なります。上記の例では、Tinderbox（en-US ロケールの場合）が、""Mr."" の後のピリオドを文章の終わりではなく略語の終わりとして認識していることに注目してください。ロケールはユーザーの macOS 設定から派生しますが、locale() を使用して文脈に応じて設定することも可能です。"
String.sentences(),Operator,Item,Data manipulation,List,false,9.7.3,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.sentences()
String.sentences() returns a list of sentences in the source String. Sentences are formed by natural language analysis of the text, which reduces the likelihood of errors cause by abbreviations, decimals, and quoted interjections. 
The operator takes no arguments so the trailing parentheses may be omitted if desired.
Note: 
* any/every semicolon in the sentences are replaced by an underscore character (_). This is because list-based Tinderbox attributes use semicolons to delimit the list's items.
* any leading/trailing whitespace (including tabs, line breaks, etc.) is trimmed from the sentence.
Example:
	$MyList = $Text.sentences(); -","String.sentences()
String.sentences() は、元の文字列（String）に含まれる文のリストを返します。文はテキストの自然言語解析によって識別されるため、略語、小数、引用された挿入句などによる誤判定の可能性が低く抑えられています。
このオペレーターは引数を取らないため、必要に応じて末尾の括弧を省略できます。
注意：
* 文中のすべてのセミコロンはアンダースコア（_）に置き換えられます。これは、リスト型の Tinderbox 属性が項目の区切り文字としてセミコロンを使用するためです。
* 文の前後にある空白（タブ、改行などを含む）は取り除かれます。
例：
	$MyList = $Text.sentences(); -"
"String.show([backgroundColor[, colorString, [durationNum]]])",Function,Item,Data manipulation,success boolean,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.show([backgroundColor[,colorString]])
String.show()
String.show
The String.show() function allows a plain-text message to be shown in the front window's message placard. The source text may be a literal string, variable or a String-type attribute value. The trailing parentheses are optional.
String.show() allows a further three optional arguments.
The optional backgroundColor argument may be used on its own with or without the optional third colorString argument. But if the colorString argument is used, then the backgroundColor argument must be given as well. The same holds for the optional durationNum argument. If passed, durationNum specifies the number of seconds for which to display the message. Setting a duration can be useful if wanted to show a series of short messages, each in a discrete manner.
The features and limitations of messages sent to the placard are described separately under the Message placards article.
The show(MsgString) operator offers a non-dot-operator alternative.
From v10.1.1, .show() takes an additional optional Number argument duration:
	String.show(foreground, background, duration])
If passed, duration specifies the number of seconds for which to display the message. If not specified, the display duration is 3 seconds. Setting a duration can be useful if wanted to show a series of short messages, each in a discrete manner.","String.show([backgroundColor[,colorString]])
String.show()
String.show
String.show() 関数を使用すると、前面のウィンドウのメッセージプラカードにプレーンテキストのメッセージを表示できます。ソーステキストは、リテラル文字列、変数、または String 型の属性値を使用できます。末尾の括弧は省略可能です。
String.show() では、さらに 3 つのオプション引数を使用できます。
オプションの backgroundColor 引数は、それ単体で、あるいは 3 番目のオプション引数 colorString と併用して使用できます。ただし、colorString 引数を使用する場合は、backgroundColor 引数も指定しなければなりません。これはオプションの durationNum 引数についても同様です。durationNum が渡された場合、メッセージを表示する秒数を指定します。表示時間を設定することは、一連の短いメッセージをそれぞれ個別に表示させたい場合に便利です。
プラカードに送信されるメッセージの機能と制限については、別記事の「Message placards」で説明されています。
show(MsgString) 演算子は、ドット演算子を使用しない代替手段を提供します。
v10.1.1 より、.show() は追加のオプションの数値（Number）引数 duration を受け取るようになりました：
	String.show(foreground, background, duration])
duration が渡された場合、メッセージを表示する秒数を指定します。指定されない場合、表示時間は 3 秒です。表示時間を設定することは、一連の短いメッセージを個別に表示させたい場合に便利です。"
String.size(),Property,Item,Data manipulation,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.size()
String.size
This returns the Number of characters in a string value. The returned number can be coerced to a string. Examples:
	$MyString = ""hello world""; $MyNumber = $MyString.size; $MyStringA = $MyString.size; 
The value of $MyNumber will be the number 11, $MyStringA will be the string ""11"".
This operator can also be used on other attribute data types that are string-like, URL, File, etc.
The 'size' of $Text is pre-computed and accessed via the read-only system attribute $TextLength. 
More detail on how character counts are made.","String.size()
String.size
文字列値の文字数を返します。返された数値は文字列に変換可能です。例：
	$MyString = ""hello world""; $MyNumber = $MyString.size; $MyStringA = $MyString.size; 
$MyNumber の値は数値の 11 になり、$MyStringA は文字列の ""11"" になります。
このオペレータは、URL や File など、他の文字列に類する属性データ型にも使用できます。
$Text の「size」は事前に計算されており、読み取り専用のシステム属性 $TextLength を通じてアクセスします。
文字数のカウント方法についての詳細。"
String.skip(charsNum),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.skip(charsNum)
Moves the current stream position charsNum characters forward (right). A failure occurs if charsNum reaches past the end of the String stream.
For example, for stream ""It was the best of times, it was the worst of times"":
	vText = $Text.skip(20); 
Advances the cursor forward 20 characters, returning the stream ""imes, it was the worst of times"". Otherwise, if the end of the string is detected, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .expect() unless a failure occurs in which case chained operators are not processed.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.skip(charsNum)
現在のストリーム位置をcharsNum文字分、前方（右）に移動させます。charsNumがStringストリームの末尾を超えた場合、失敗となります。
例えば、ストリームが「It was the best of times, it was the worst of times」の場合：
	vText = $Text.skip(20); 
カーソルを20文字進め、ストリーム「imes, it was the worst of times」を返します。それ以外の場合（文字列の末尾が検出された場合）、失敗となり、カーソルは進みません。いずれの場合も、失敗が発生して後続の演算子が処理されない場合を除き、変数vTextは、.expect()に連結された他の演算子と同様に、結果のテキストストリームを受け取ります。
この演算子の使用は、キャプチャ対象の内容が正しく検出されるのを助けるための補助を想定しています。本質的には、これは「if」形式のテストです。テストが成功すれば続行し、そうでなければカーソルはその場に留まり、後続のストリーム解析演算子は処理されません。"
String.skipLine(),Function,Item,Stream parsing,String,false,9.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.skipLine()
String.skipLine
The dot-operator String.skipLine skips forward to the next carriage return or to the end of the String stream. String.skipLine fails if the string is exhausted, i.e. the stream cursor remains where it was before the call.
The sort of scenario with which this helps is where the desired line(s) has no identifiable label but is preceded by a separate area of the stream that can be found. Thus in a raw email transcript the content includes labels like 'To:' and 'Subject:' but has nothing for the main body copy, which simply forms all content after the Subject line.
Most stream operators work up to the end of the current line but exclude the line break characters (\n) that separates each line. In the above scenario, where the needed line cannot be detected but the preceding line can be, .skipLine allows code like this:
	$Source.captureTo(""Subject:"").skipLine.captureRest(""Text"")","String.skipLine()
String.skipLine
ドット演算子 String.skipLine は、次の復行（キャリッジリターン）または String ストリームの末尾まで進みます。文字列が終了している場合、String.skipLine は失敗します。つまり、ストリームカーソルは呼び出し前の位置から移動しません。
この機能が役立つのは、目的の行に特定のラベルがないものの、その前に見つけることが可能な別のセクションがあるような場合です。例えば、電子メールの生データには 'To:' や 'Subject:' といったラベルがありますが、本文にはラベルがなく、単に Subject 行以降のすべての内容として存在しています。
ほとんどのストリーム演算子は現在の行の末尾までを対象としますが、各行を区切る改行文字（\n）は含みません。前述のように、必要な行自体は特定できないが、その直前の行が特定できる場合、.skipLine を使うことで以下のようなコードが記述できます。
	$Source.captureTo(""Subject:"").skipLine.captureRest(""Text"")"
String.skipTo(matchStr),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.skipTo(matchStr)
Looks for the matchStr (N.B. this is not a regular expression) in the source String stream. If not found, it returns nothing. If found, it returns the string that follows matchStr.
For example:
	vText = $Text.skipTo(""abc""); 
Tests that the next characters in the stream read from $Text is the sequence abc, and advances the stream beyond ""abc"". Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .skipTo() unless a failure occurs in which case chained operators are not processed.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.skipTo(matchStr)
ソースのStringストリームから matchStr（注意：正規表現ではありません）を検索します。見つからない場合は、何も返しません。見つかった場合は、matchStr に続く文字列を返します。
例：
	vText = $Text.skipTo(""abc""); 
$Text から読み込まれたストリームの次の文字列がシーケンス ""abc"" であるかをテストし、ストリームを ""abc"" の直後まで進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合も、失敗して後続のオペレータが処理されない場合を除き、変数 vText は .skipTo() に連結された他のオペレータと同様に、結果のテキストストリームを受け取ります。
このオペレータは、キャプチャするコンテンツが正しく検出されるのを補助することを目的としています。本質的には「if」形式のテストです。テストが成功すれば続行し、そうでなければ、後続のストリーム解析オペレータのためにカーソルを現在の位置に保持します。"
String.skipToNumber(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.skipToNumber()
String.skipToNumber
Advances the String stream to the next number (i.e. one of more continuous number characters). A failure occurs if the stream is exhausted.
For example:
	vText = $Text.skipToNumber(); 
Tests that the next characters in the stream read from $Text is a sequence of digits, and advances the stream past a continuous runs of digits. Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream (as would any operator chained to .skipToNumber() unless a failure occurs in which case chained operators are not processed.
If the input stream passes in ""1234 items"" the cursor advances past '1234' such that the remaining stream is "" items"".
If the input stream passes in ""1,234 items"" the cursor advances past '1' such that the remaining stream is ""234 items"". Notice how number formatting delimiters like a comma (or other locale-specific delimiters) used in string representations of  numbers may confuse this operator is used without care.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.skipToNumber()
String.skipToNumber
文字列ストリームを次の数値（すなわち、1つ以上の連続する数字文字）まで進めます。ストリームが終端に達している場合は失敗します。
例：
	vText = $Text.skipToNumber(); 
$Textから読み取られたストリームの次の文字が数字のシーケンスであることをテストし、連続する数字の並びを越えてストリームを進めます。そうでない場合は失敗し、カーソルは進みません。いずれの場合も、変数vTextは結果のテキストストリームを受け取ります（失敗が発生した場合は連結された演算子が処理されませんが、そうでない限り.skipToNumber()に連結されたどの演算子も同様です）。
入力ストリームに ""1234 items"" が渡された場合、カーソルは '1234' を通過して進み、残りのストリームは "" items"" になります。
入力ストリームに ""1,234 items"" が渡された場合、カーソルは '1' を通過して進み、残りのストリームは ""234 items"" になります。数値の文字列表現で使用されるカンマ（または他のロケール固有の区切り文字）のような数値形式の区切り文字は、注意して使用しないとこの演算子を混乱させる可能性があることに注意してください。
この演算子の使用は、キャプチャ対象のコンテンツが正しく検出されるのを助けるための補助として想定されています。本質的には、これは 'if' スタイルのテストです。テストが正しい場合は続行し、そうでなければカーソルはそのままの位置に留まり、後続のストリーム解析演算子に備えます。"
String.skipWhitespace(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.skipWhitespace()
String.skipWhitespace
Advances the String stream to the first character that is not whitespace. A failure occurs if the stream is exhausted.
For example:
	vText = $Text.skipWhitespace(); 
Tests that the next characters in the stream are non-word, and advances the stream beyond the detected  whitespaces characters. Otherwise, it fails and the cursor does not advance. Either way, the variable vText receives the resulting text stream as would any operator chained to .skipWhitespace() unless a failure occurs in which case chained operators are not processed. 
If the stream passed in is ""  Hello world"" (note the leading spaces) then the spaces are detected and the cursor returns ""Hello world"". But if the stream passed in is ""Hello world"" a word is detected and the cursor does not advance.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.skipWhitespace()
String.skipWhitespace
文字列ストリームを、空白文字ではない最初の文字まで進めます。ストリームが終端に達した場合は失敗となります。
例：
	vText = $Text.skipWhitespace(); 
ストリームの次の文字が非単語文字であることをテストし、検出された空白文字を越えてストリームを進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合も、失敗が発生して連結されたオペレータが処理されない場合を除き、変数vTextは .skipWhitespace() に連結された他のオペレータと同様に、結果のテキストストリームを受け取ります。
渡されたストリームが ""  Hello world""（先頭に空白がある）の場合、空白が検出され、カーソルは ""Hello world"" を返します。しかし、渡されたストリームが ""Hello world"" の場合、単語が検出されるため、カーソルは進みません。
このオペレータは、抽出（キャプチャ）対象のコンテンツが正しく検出されるのを助けるための支援機能として想定されています。本質的にはこれは「if」スタイルのテストです。テストが正しければ処理を進め、そうでなければ、後続のストリーム解析オペレータのためにカーソルを現在の位置に留めます。"
String.speak([voiceNameStr]),Function,Item,Data manipulation,success boolean,false,6.0.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.speak([voiceNameStr])
speaks a string using Mac text-to-speech. If another string is being spoken, the new phrase is spoken after the current phrase is complete.
	$Text.speak(); 
An optional second argument voiceNameStr identifies the voice the speech synthesiser should use. If the nominated voiceNameStr is not present no sound is played. The closing parentheses are only needed if the extra argument is being passed:
	$Text.speak(""Tessa""); 
Quoted literal strings can be chained to .speak():
	""Look on my Works, ye Mighty, and despair"".speak(); 
	'Look on my Works, ye Mighty, and despair'.speak(); 
See also speak().","String.speak([voiceNameStr])
Macのテキスト読み上げ機能を使用して文字列を読み上げます。別の文字列が読み上げられている最中の場合は、現在の読み上げが完了した後に新しいフレーズが読み上げられます。
	$Text.speak(); 
オプションの第2引数 voiceNameStr は、音声合成に使用する音声を指定します。指定された voiceNameStr が存在しない場合、音は再生されません。括弧が必要になるのは、追加の引数を渡す場合のみです。
	$Text.speak(""Tessa""); 
引用符で囲まれたリテラル文字列に .speak() を連結することもできます。
	""Look on my Works, ye Mighty, and despair"".speak(); 
	'Look on my Works, ye Mighty, and despair'.speak(); 
speak() も参照してください。"
String.split(regexStr),Function,Item,Data manipulation,List,false,5.7.1,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.split(regexStr)
This operator splits a string into a List, as divided by instances of regular expression pattern regexStr in the original string. Source characters matched by regexStr are not passed to the list. The source string itself is not affected.
regexStr is one of:
* an action code expression (which includes just referencing a single attribute name')
* a quoted string; quoted strings may be either:
** a literal string (i.e. actual text)
** a regular expression
Useful regex values are:
* ""\W+"". This splits the source at word boundaries removing spaces and punctuation.
* ""\n"". This divides the string into discrete paragraphs, ignoring blank lines and/or lines/paragraphs with only spaces but no textual content.
* ""\."". This divides on sentences ending with a period. It will strip the terminating punctuation.
* ""[\.\?\!]"". As above but the sentence may end with any of full stop, question mark or exclamation mark.
The result of the operator is a List-type attribute value, i.e. the data should be passed to a list. Passing the output to a Set-type attribute will de-dupe any list values in the output with the first instance of any duplicates forming its set entry.
For example:
	$MyList = ""ant bee ant cow"".split("" ""); gives list [ant;bee;ant;cow]
	$MySet = ""ant bee ant cow"".split("" ""); gives list [ant;bee;cow]
	$MyList = ""ant, bee, cow"".split(""\W+ ""); gives  list [ant;bee;cow]
	$MyList = ""ant, bee, cow"".split("" ""); gives list [ant,;bee,;cow]
	$MyList = $MyString.split($MyString(agent)); 
	$MyList = $MyString(parent).split(""and""); 
If the string, stored in $MyString, is multi-line:
ant
bee
cow
…then: 
	$MyList = $MyString.split(""\n""); 
gives list [ant;bee;cow]. 
This approach can be useful if trying to retrieve a specific paragraph of $Text, perhaps from notes exploded from a larger consistently formatted text source. To get a string holding just paragraph #3 of the source $Text (or other multi-line string data):
	$MyString = $Text.split(""\n"").at(2); 
Do not overlook the fact that that List.at() is zero-based. That means the first list item is .at(0) and so the third list item is '2' and not '3' as might otherwise be assumed the last item is '-1':
	$MyString = $Text.split(""\n"").at(-1); 
There is one limitation of this approach to working with $Text or multi-line strings. The issue is that blank lines or lines with only spaces, are ignored; lists do not hold 'empty' items. So if the string $MyString is multi-line and contains blank lines, like so:
ant
  
bee
cow
…then:
	$MyList = $MyString.split(""\n""); 
still gives [ant;bee;cow]. 
It does not matter if the blank is just two successive line returns or actually contains some white space, no list item is created for it.
Luckily there is a simple workaround is to seed empty lines with a single hyphen (or whatever placeholder you prefer, e.g. ""N/A"" or such). Thus:
	$MyList = $Text.replace(""\n\n"",""\n-\n"").split(""\n""); 
…now gives $MyList [ant;-;bee;cow] such that ""bee"" is still paragraph #3 of the new list, as in the original text. If you wanted to make a deliberate review of such data you might use a more distinctive marker string:
	$MyList = $Text.replace(""\n\n"",""\n#####\n"").split(""\n""); 
You could then query for $MyList.contains(""#####"").
Dealing with inline quote characters
Because regex is parsed for regular expressions, it may be possible to use the '\dnn' form described here to work around the lack of escaping from single double quotes within strings.
Dealing with inline semi-colons
As this function outputs a list, where values are semi-colon delimited, if the source string—such as $Text—has semicolons in it they act as extra (unexpected!) splits when viewing the outcome. To get around this, escape the semicolons on the fly:
	$MyList = $Text.replace("";"",""\\;"").split(""\n""); 
However, the surviving inline semicolons in the resulting List items will get misread, when interrogating the List, as item delimiters. In such cases, first replace inline semicolons with another character(s) before using the split-generated list and then reverse the replacement before actual use of the text. For example:
    var:string vSource = $Text.replace("";"",""@@@"");
    $MyList = vSource.paragraphList;
    $MyString = $MyList.at(4)replace(""@@@"","";"");","I will translate the text describing the `String.split(regexStr)` operator into Japanese, maintaining its technical context and formatting.

String.split(regexStr)
このオペレータは、元の文字列内の正規表現パターン regexStr が一致する箇所で分割し、リスト（List）を作成します。regexStr に一致した文字自体はリストには含まれません。元の文字列自体は変更されません。
regexStr は以下のいずれかです：
* アクションコードの式（単一の属性名を参照する場合も含みます）
* 引用符で囲まれた文字列。引用符で囲まれた文字列は以下のいずれかです：
** リテラル文字列（実際のテキスト）
** 正規表現
便利な正規表現の値：
* ""\W+""：単語の境界で分割し、スペースや句読点を取り除きます。
* ""\n""：文字列を各段落に分割します。空行や、スペースのみでテキスト内容のない行／段落は無視されます。
* ""\.""：ピリオドで終わる文ごとに分割します。末尾の句読点は削除されます。
* ""[\.\?\!]""：上記と同様ですが、文の終わりがピリオド、疑問符、感嘆符のいずれかである場合に分割します。
このオペレータの結果はリスト（List）型の属性値となります。つまり、データはリストに渡される必要があります。出力をセット（Set）型の属性に渡すと、重複する値が排除され、重複する値のうち最初のインスタンスがセットのエントリとして保持されます。
例：
	$MyList = ""ant bee ant cow"".split("" ""); // リスト [ant;bee;ant;cow] になります
	$MySet = ""ant bee ant cow"".split("" ""); // リスト [ant;bee;cow] になります
	$MyList = ""ant, bee, cow"".split(""\W+ ""); // リスト [ant;bee;cow] になります
	$MyList = ""ant, bee, cow"".split("" ""); // リスト [ant,;bee,;cow] になります
	$MyList = $MyString.split($MyString(agent)); 
	$MyList = $MyString(parent).split(""and""); 
$MyString に格納された文字列が複数行の場合：
ant
bee
cow
…この場合：
	$MyList = $MyString.split(""\n""); 
リスト [ant;bee;cow] を返します。
この手法は、$Text の特定の段落を取得したい場合に便利です。たとえば、一貫したフォーマットの大きなテキストソースから分解（explode）されたノートなどから取得する場合です。ソースの $Text（または他の複数行文字列データ）の3番目の段落だけを保持する文字列を取得するには：
	$MyString = $Text.split(""\n"").at(2); 
List.at() が「0ベース（0から始まる）」であることを忘れないでください。つまり、最初のリスト項目は .at(0) であり、3番目のリスト項目は「3」ではなく「2」となります。最後の項目は「-1」です：
	$MyString = $Text.split(""\n"").at(-1); 
複数行の文字列や $Text を扱うこの手法には、1つの制限があります。空行やスペースのみの行は無視されるという点です。リストは「空の」項目を保持しません。したがって、$MyString が複数行で、以下のように空行を含んでいる場合：
ant
  
bee
cow
…この場合でも：
	$MyList = $MyString.split(""\n""); 
依然として [ant;bee;cow] を返します。
空行が単なる連続した改行であっても、実際にホワイトスペースが含まれていても関係なく、それに対するリスト項目は作成されません。
幸いなことに、簡単な回避策があります。空行にハイフン（または ""N/A"" などお好みのプレースホルダー）を一時的に挿入することです。
	$MyList = $Text.replace(""\n\n"",""\n-\n"").split(""\n""); 
…これにより $MyList は [ant;-;bee;cow] となり、元のテキストと同様に ""bee"" は新しいリストの3番目の段落として保持されます。このようなデータを意図的に確認したい場合は、より特徴的なマーカー文字列を使用することもできます：
	$MyList = $Text.replace(""\n\n"",""\n#####\n"").split(""\n""); 
その後、$MyList.contains(""#####"") で問い合わせることができます。
インラインの引用符（""）の取り扱い
正規表現は正規表現として解析されるため、文字列内でエスケープできない二重引用符を回避するために、こちらで説明されている '\dnn' 形式を使用できる場合があります。
インラインのセミコロン（;）の取り扱い
この関数は、値がセミコロンで区切られたリストを出力するため、ソース文字列（$Text など）にセミコロンが含まれていると、結果を表示する際に予期せぬ分割が発生します。これを回避するには、実行時にセミコロンをエスケープします：
	$MyList = $Text.replace("";"",""\\;"").split(""\n""); 
ただし、結果として得られたリスト項目内に残っているインラインのセミコロンは、リストを照会する際に項目の区切り文字として誤読されます。そのような場合は、まず split でリストを生成する前にインラインのセミコロンを別の文字に置換し、テキストを実際に使用する前に置換を元に戻してください。例：
    var:string vSource = $Text.replace("";"","" @@@"");
    $MyList = vSource.paragraphList;
    $MyString = $MyList.at(4).replace("" @@@"","";"");"
"String.substr(startNum[, lengthNum])",Function,Item,Data manipulation,String,false,5.7.0,Baseline,,,,2,true,true,false,false,false,false,false,true,false,,false,"String.substr(startNum[, lengthNum])
This operator allows extraction of a substring from a string attribute. The source string is not affected.
	$MyString.substr(startN) 
returns the substring of $MyString beginning startNum characters from the beginning. The numbers for startN and lengthN are 0-based, i.e. zero is character position #1. A negative startNum value counts back from the end of the string .Negative values are 1-based, i.e. the -1 represents the last character in the string.
In the examples below assume $MyString's value is ""Hello World"". Examples:
	$MyString = ""abcde"".substr(2); returns ""cde""
	$MyString = ""abcde"".substr(-2); returns ""de""
	$MyString = $MyString.substr(6); returns ""World""
If the string does not contain at least startNum characters, the empty string is returned.
A second argument lengthNum specifies the length of the returned string. If unspecified, the entire remaining string is returned.
	$MyString = ""abcde"".substr(2,2); returns ""cd""
	$MyString = ""abcde"".substr(-3,2); returns ""cd""
	$MyString = $MyString.substr(0,5); returns ""Hello""
If the length of the substring is negative, it is treated as an offset from the end of the string.
	$MyString = ""Hello"".substr(1,-1); → ""ell""
Besides strings and string literals, this operator can also be used on other attribute data types that are string-like, URL, File, etc. Although the operator also works on lists/sets, the source data is all the values as a single semi-colon-joined string literal so there is less point in its use in this context.
This function respects existing rich text styling.
Incorrect argument values
If .substr() is asked to address parts of the string before its start or after its end, .substr() returns the empty string. This can arise through poor selection of input argument values. For instance, if $MyString is 5 characters long, $MyString.substr(0-7) is impossible, so this returns an empty string.
Trimming leading/trailing quotes
See String.trim().
Working with styled text
This operator is capable of worthing with StyledString operators: StyledString.bold, StyledString.fontSize(), StyledString.italic and StyledString.strike.","String.substr(startNum[, lengthNum])
このオペレーターを使用すると、文字列属性から部分文字列を抽出できます。元の文字列は影響を受けません。
	$MyString.substr(startN) 
$MyStringの先頭からstartNum文字目以降の部分文字列を返します。startNおよびlengthNの数値は0ベース（0から始まる）です。つまり、0は1番目の文字位置を表します。負のstartNum値は文字列の末尾から逆方向にカウントします。負の値は1ベース（1から始まる）です。つまり、-1は文字列の最後の文字を表します。
以下の例では、$MyStringの値が ""Hello World"" であると仮定します。
例：
	$MyString = ""abcde"".substr(2); // ""cde"" を返す
	$MyString = ""abcde"".substr(-2); // ""de"" を返す
	$MyString = $MyString.substr(6); // ""World"" を返す
文字列に少なくともstartNum文字が含まれていない場合、空の文字列が返されます。
第2引数のlengthNumは、返される文字列の長さを指定します。指定されない場合は、残りの文字列全体が返されます。
	$MyString = ""abcde"".substr(2,2); // ""cd"" を返す
	$MyString = ""abcde"".substr(-3,2); // ""cd"" を返す
	$MyString = $MyString.substr(0,5); // ""Hello"" を返す
部分文字列の長さが負の場合、文字列の末尾からのオフセットとして扱われます。
	$MyString = ""Hello"".substr(1,-1); → ""ell""
文字列や文字列リテラルの他に、URLやFile型など、文字列に類似した他の属性データ型でもこのオペレーターを使用できます。リストやセットでも動作しますが、ソースデータはすべての値をセミコロンで連結した単一の文字列リテラルとして扱われるため、これらのコンテキストで使用する意味はほとんどありません。
この関数は、既存のリッチテキストのスタイルを保持します。
不適切な引数の値
.substr() が文字列の開始前または終了後の範囲を参照するように指定された場合、.substr() は空の文字列を返します。これは、入力引数の値の選択が不適切な場合に発生する可能性があります。例えば、$MyString が5文字の長さである場合、$MyString.substr(0-7) は不可能であるため、空の文字列を返します。
前後の引用符の除去（トリミング）
String.trim() を参照してください。
スタイル付きテキストの操作
このオペレーターは、StyledString オペレーター（StyledString.bold、StyledString.fontSize()、StyledString.italic、StyledString.strike）と連携して動作させることが可能です。"
String.toNumber(),Function,Item,Data manipulation,Number,false,5.8.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.toNumber()
String.toNumber
Used for explicit coercion of numbers in strings to Number type data. Examples:
	$MyNumber = $MyString.toNumber; 
	$MyNumberA = ""40"".toNumber; 
This can be useful if default type coercion is not working as expected.","String.toNumber()
String.toNumber
文字列内の数値を数値型（Number）データに明示的に変換するために使用されます。例：
	$MyNumber = $MyString.toNumber; 
	$MyNumberA = ""40"".toNumber; 
これは、デフォルトの型変換が期待通りに動作しない場合に便利です。"
"String.tr(inStr[, outStr])",Function,Item,Data manipulation,String,false,5.7.0,Baseline,,,,2,true,true,false,false,false,false,false,true,false,,false,"String.tr(inStr[, outStr])
$MyString.tr(inStr, outStr)
This operator allows simple single character string manipulation. It computes a new string, copying each character of $MyString but converting any characters in inStr to the corresponding characters in dataOut. For example:
	$MyString = $MyString.tr(""a"",""A""); 
returns a copy of MyString in which every ""a"" is converted to ""A"".
Backslash characters must be quoted and escaped:
	$MyString = $MyString.tr(""c"",""\\r""); 
converts every ""c"" to a Macintosh newline characters (\r). Note the need in this context for an extra backslash escape (so Tinderbox knows the intended swap value is ""\r"" and not ""r"").
Multiple characters can be replaced:
	$MyString = ""Hello, world"".tr(""aeiou"",""AEIOU""); gives ""HEllO, wOrld""
Note that in the later example the number of characters in inStr and outStr must match and pairs must list in order, otherwise unmatched characters will act as for the syntax below.
$MyString.tr(inStr)
If outStr is omitted or left empty, any matches to inStr are deleted from the referenced string.
	$MyString = ""Hello, world"".tr(""aeiou""); 
gives ""Hll, wrld""
For further information, see the macOS man page for the UNIX tr command.
Performance
If using actions with a lot of .tr() calls, based on some testing in large complex docs, it may—counter-intuitively—be faster using .replace() instead.","String.tr(inStr[, outStr])
$MyString.tr(inStr, outStr)
このオペレータは、単純な1文字単位の文字列操作を可能にします。$MyStringの各文字をコピーしながら、inStrに含まれる各文字をoutStrの対応する文字に変換して、新しい文字列を生成します。例えば：
	$MyString = $MyString.tr(""a"",""A""); 
は、すべての「a」が「A」に変換された$MyStringのコピーを返します。
バックスラッシュ文字は引用符で囲み、エスケープする必要があります：
	$MyString = $MyString.tr(""c"",""\\r""); 
は、すべての「c」をMacintoshの改行文字（\r）に変換します。この文脈では、バックスラッシュによるエスケープがさらにもう一つ必要であることに注意してください（これにより、Tinderboxは意図した置換値が「r」ではなく「\r」であることを認識します）。
複数の文字を置換することも可能です：
	$MyString = ""Hello, world"".tr(""aeiou"",""AEIOU""); は ""HEllO, wOrld"" になります。
なお、上記の例ではinStrとoutStrの文字数が一致し、ペアが順番に並んでいる必要があります。そうでない場合、一致しない文字は以下の構文のように扱われます。
$MyString.tr(inStr)
outStrが省略されたか空の場合、inStrに一致する文字は元の文字列から削除されます。
	$MyString = ""Hello, world"".tr(""aeiou""); 
は ""Hll, wrld"" になります。
詳細については、UNIXのtrコマンドに関するmacOSのmanページを参照してください。
パフォーマンス
大規模で複雑なドキュメントでのテストによると、多数の .tr() 呼び出しを行うアクションの場合、直感に反して .replace() を使用した方が高速になる可能性があります。"
String.trim([filterStr]),Function,Item,Data manipulation,String,false,9.0.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.trim([filterStr])
String.trim()
String.trim
The .trim operator removes unwanted characters from the start and end of a string. With no arguments, .trim() removes whitespace and end of line characters.
	""Hello world     "".trim; → ""Hello world""
It may also be used with a literal string argument filterStr. The only accepted value for filterStr is ""punctuation"", in which case the operator also removes punctuation marks.
	""[tab] Hello world?!     "".trim(""punctuation"") → ""Hello world""
The resulting string retains any stying in the source string.","String.trim([filterStr])
String.trim()
String.trim
.trim オペレータは、文字列の前後から不要な文字を削除します。引数がない場合、.trim() は空白文字と改行文字を削除します。
	""Hello world     "".trim; → ""Hello world""
また、リテラル文字列の引数 filterStr を指定して使用することもできます。filterStr に指定できる唯一の値は ""punctuation"" で、この場合、オペレータは句読点も削除します。
	""[tab] Hello world?!     "".trim(""punctuation"") → ""Hello world""
結果の文字列は、元の文字列のスタイルを保持します。"
String.try{actions}[.thenTry{actions}],Function,Item,Stream parsing,boolean test,false,9.1.0,Baseline,,,,,true,true,false,false,false,false,false,true,false,,false,"String.try{ action(s) }[.thenTry{ action(s) }]
If the first test action fails, they restore the string and allow you to process it a different way. The current success/failure state can be tested using the .failed() operator.
Saves the value of an attribute (the steam source) and attempts an action. If the action fails because one of its operators fails or the fail() operator is performed, the original value of String stream source is restored.
A .try{} may be followed by one or more .thenTry{} clauses. If the original .try{} succeeds, all subsequent .thenTry{} clauses are ignored. If the original .try{} fails, then each .thenTry{} is attempted in turn. Once a .thenTry{} clause succeeds, subsequent .thenTry{} clauses are ignored.
For example:
$MyString.try{
   $MyString=$MyString.skipToWord(""To:"").captureWord;
}.thenTry{
   fail(); //signal an explicit failure and return a 'false' value to an enclosing expression
};

looks for strings such as ""To:John Doe""
If the string ""To:"" is not found, $MyString will be unchanged. If found, $MyString's value is set to the word that follows, up to the next whitespace character or the end of the string, i.e. ""John"".","String.try{ action(s) }[.thenTry{ action(s) }]
最初のテストアクションが失敗した場合、文字列を復元し、別の方法で処理できるようにします。現在の成功/失敗の状態は、.failed() オペレーターを使用してテストできます。
属性の値（ストリーム・ソース）を保存し、アクションを試行します。オペレーターの1つが失敗したか、fail() オペレーターが実行されたためにアクションが失敗した場合、String ストリーム・ソースの元の値が復元されます。
.try{} の後には、1つ以上の .thenTry{} 句を続けることができます。最初の .try{} が成功した場合、それ以降のすべての .thenTry{} 句は無視されます。最初の .try{} が失敗した場合、各 .thenTry{} が順番に試行されます。ひとたび .thenTry{} 句が成功すると、それ以降の .thenTry{} 句は無視されます。
例：
$MyString.try{
   $MyString=$MyString.skipToWord(""To:"").captureWord;
}.thenTry{
   fail(); // 明示的な失敗を通知し、囲んでいる式に 'false' 値を返す
};

""To:John Doe"" のような文字列を探します。
文字列 ""To:"" が見つからない場合、$MyString は変更されません。見つかった場合、$MyString の値は、次に来る単語（次の空白文字または文字列の末尾まで）、つまり ""John"" に設定されます。"
String.uppercase(),Function,Item,Formatting,String,false,5.9.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.uppercase()
String.uppercase
Returns the referenced String, transforming all uppercase letters to lowercase.
The function can be chained to both string data and to string literals:
	$MyString.uppercase() 
	""my new title"".uppercase() 
The latter gives ""MY NEW TITLE"".
The trailing parentheses may be omitted:
	$MyString.uppercase 
Functionally equivalent to uppercase().
If $MyString is ""hello world"":
	$MyString = $MyString.uppercase; 
$MyString is set to ""HELLO WORLD"".
The .uppercase() method may also be used on Lists or Sets. Consider [Ant;BEE;Cow] stored in $MyList:
	$MyList = $MyList.uppercase; 
… giving [ANT;BEE;COW].","String.uppercase()
String.uppercase
参照された文字列のすべての文字を大文字に変換して返します。
この関数は、文字列データと文字列リテラルの両方に連結（チェーン）させることができます。
	$MyString.uppercase() 
	""my new title"".uppercase() 
後者は ""MY NEW TITLE"" になります。
末尾の括弧は省略可能です。
	$MyString.uppercase 
uppercase() と機能的に同等です。
$MyString が ""hello world"" の場合：
	$MyString = $MyString.uppercase; 
$MyString は ""HELLO WORLD"" に設定されます。
.uppercase() メソッドは、リスト（List）やセット（Set）に対しても使用できます。$MyList に [Ant;BEE;Cow] が格納されているとします。
	$MyList = $MyList.uppercase; 
… 結果は [ANT;BEE;COW] になります。"
String.wordCount(),Property,Item,Data manipulation,Number,false,9.5.2,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"String.wordCount()
String.wordCount
String.wordCount returns the number of words in a string. The string is first scanned to determine its dominant language, and the word count is based on the conventions of that language (q.v. $WordCount). If the language cannot be determined or if it is not known to macOS, the conventions of English are used.","String.wordCount()
String.wordCount
String.wordCountは、文字列内の単語数を返します。まず文字列がスキャンされて主要な言語が特定され、その言語の規則に基づいて単語数がカウントされます（$WordCountを参照）。言語を特定できない場合、またはmacOSで認識されない言語の場合は、英語の規則が使用されます。"
String.wordList(),Property,Item,Data manipulation,List,false,9.0.0,Baseline,,,10.14,,false,true,false,false,false,false,false,false,false,,false,"String.wordList()
String.wordList
This returns a list of each noun in the supplied string, excepting those recognised as pronouns and proper names. Note that the output list is all lowercase, regardless of source case. This operator requires running on macOS 10.14 and later.
	$MyList = ""I am the very model of a modern Major-General."".wordList; 
then MyList holds ""i;am;the;very;model;of;a;modern;major;general"".","String.wordList()
String.wordList
これは、指定された文字列内の各単語のリストを返しますが、代名詞や固有名詞として認識されるものは除外されます。ソースの大小文字に関わらず、出力されるリストはすべて小文字になることに注意してください。このオペレータは macOS 10.14 以降で動作させる必要があります。
	$MyList = ""I am the very model of a modern Major-General."".wordList;
この場合、MyList は ""i;am;the;very;model;of;a;modern;major;general"" を保持します。"
String.words(wordsNum),Function,Item,Data manipulation,String,false,6.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.words(wordsNum)
returns the first number words of a string. If the string has fewer than wordsNum words, returns the entire string. If wordsNum is negative, it returns a negative -wordsNum words from the end of the string. If $MyString is ""Romans, they go house?"".
	$MyString = $MyString.words(2); 
returns ""Romans, they"". 
	$MyString = $MyString.words(-1); 
returns ""house?"". Note that punctuation contiguous to words gets passed through as part of the returned word(s).","String.words(wordsNum)
文字列の最初のwordsNum個の単語を返します。文字列の単語数がwordsNumより少ない場合は、文字列全体を返します。wordsNumが負の値の場合、文字列の末尾から-wordsNum個の単語を返します。$MyStringが ""Romans, they go house?"" の場合：
	$MyString = $MyString.words(2); 
は ""Romans, they"" を返します。
	$MyString = $MyString.words(-1); 
は ""house?"" を返します。単語に隣接する句読点は、返される単語の一部としてそのまま保持されることに注意してください。"
string(argStr),String,Item,Data manipulation,,false,11.5.0,11.5.0,,11.5.0,,1,true,false,false,false,false,false,false,false,false,,false,"string(argStr)
The operator string(argStr) returns its argument as explicitly String-type data. This is useful when neither single nor double quotes will achieve the desired result. The string result must not contain a closing parenthesis, i.e. a ')' character.","string(argStr)
string(argStr) 演算子は、その引数を明示的な文字列（String）型のデータとして返します。これは、一重引用符や二重引用符のどちらを使用しても望ましい結果が得られない場合に便利です。結果の文字列には、閉じ括弧、つまり「)」文字を含めることはできません。"
StyledString.bold(),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,true,,false,"StyledString.bold()
StyledString.bold
The function sets the referenced string's styled text to bold text.
	$Text = $Text + ""This is "" + ""some"".bold + "" text"".plain; 
adds ""this is some text"" to the end of $Text. The '.plain' command reasserts no style is to be applied.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.bold()
StyledString.bold
この関数は、参照された文字列のスタイル付きテキストを太字に設定します。
	$Text = $Text + ""This is "" + ""some"".bold + "" text"".plain; 
は、$Text の末尾に ""this is some text"" を追加します。`.plain` コマンドは、スタイルを適用しないことを再指定します。
注意：現在、スタイル付きテキストを保持できる属性は $Text のみです。文字列属性やアクションコード変数（var など）は、スタイル付きテキストを格納できません。スタイル付きテキストが渡された場合、後者は渡されたテキストのスタイルなしのバージョンを格納します。詳細な説明を参照してください。
StyledString オペレーターを尊重する文字列オペレーター
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.fontSize(pointSizeNum),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,true,,false,"StyledString.fontSize(pointSizeNum)
The function sets the referenced string's styled text to font size pointSizeNum, where pointSizeNum is the desired font size in points.
	$Text = $Text + ""some bigger text"".fontSize(N); 
adds test ""some bigger text"" in 24pt to the end of $Text.
It is also a good automatic way to reset $Text containing old (or accidental) size-based auto-headings. Code like this can be used as a stamp or other action to reset multiple selected notes:
	$Text = $Text.fontSize($TextFontSize); 
This will make each (selected) note use it's own $TextFontSize (which might differ) to reset the size of the entire $Text of the note.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.fontSize(pointSizeNum)
この関数は、対象となる文字列のスタイル付きテキストのフォントサイズをpointSizeNumに設定します。ここでpointSizeNumは、ポイント単位での希望のフォントサイズです。
	$Text = $Text + ""some bigger text"".fontSize(N); 
は、$Textの末尾に24ptの「some bigger text」というテキストを追加します。
これは、古い（あるいは意図しない）サイズベースの自動見出しが含まれる$Textをリセットする自動的な手法としても有効です。以下のようなコードをスタンプやその他のアクションとして使用することで、選択した複数のノートをリセットできます。
	$Text = $Text.fontSize($TextFontSize); 
これにより、（選択された）各ノートは自身の$TextFontSize（ノートごとに異なる場合があります）を使用して、そのノートの$Text全体のサイズをリセットします。
現在、$Textはスタイル付きテキストを保持できる唯一の属性であることに注意してください。文字列属性やアクションコードの変数（varなど）は、スタイル付きテキストを保持できません。これらにスタイル付きテキストが渡された場合、スタイルのないバージョンのテキストが保存されます。詳細は「詳細な説明」を参照してください。
StyledStringオペレータを維持する文字列オペレータ：
String.paragraphs()、String.replace()、およびString.substr()。"
StyledString.italic(),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,true,,false,"StyledString.italic()
StyledString.italic
The function sets the referenced string's styled text to italic.
	$Text = $Text + ""This is "" + ""some"".italic + "" text"".plain; 
adds ""this is some text"" to the end of $Text. The '.plain' command reasserts no style is to be applied.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.italic()
StyledString.italic
この関数は、参照される文字列のスタイル付きテキストをイタリック（斜体）に設定します。
	$Text = $Text + ""This is "" + ""some"".italic + "" text"".plain; 
は、$Text の末尾に ""this is some text"" を追加します。`.plain` コマンドは、スタイルを適用しないことを再指定します。
現在、スタイル付きテキストを保持できる属性は $Text のみであることに注意してください。文字列属性やアクションコード変数（var など）は、スタイル付きテキストを保存できません。これらにスタイル付きテキストが渡された場合、スタイル情報のないテキストが保存されます。詳細な説明を参照してください。
StyledString オペレータを維持する文字列オペレータ
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.plain(),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,true,,false,"StyledString.plain()
StyledString.plain
The function (re-)sets the referenced string's styled text to the default face.
	$Text = $Text + ""This is "" + ""some"".italic + "" text"".plain; 
adds ""this is some text"" to the end of $Text. The '.plain' command reasserts no style is to be applied.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
Re-setting a note's $Text styling to defaults via code or stamp
The Format ▸ Style menu allows the user to reset the default $TextFont/$TextSize and (ruler) styles. To replicate all those defaults for all the existing $Text, use:
	$Text = $Text.plain;
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.plain()
StyledString.plain
この関数は、参照された文字列のスタイル付きテキストをデフォルトの書体（face）に（再）設定します。
	$Text = $Text + ""This is "" + ""some"".italic + "" text"".plain; 
は、$Text の末尾に ""this is some text"" を追加します。`.plain` コマンドは、スタイルを適用しないことを明示的に指定します。
現在、スタイル付きテキストを保持できる属性は $Text のみであることに注意してください。String 属性やアクションコードの変数（var など）は、スタイル付きテキストを保持できません。スタイル付きテキストが渡された場合、それらはスタイル情報を取り除いたテキストのみを保存します。詳細な説明を参照してください。
コードまたはスタンプを使用してノートの $Text スタイリングをデフォルトにリセットする
[フォーマット] ▸ [スタイル] メニューを使用すると、デフォルトの $TextFont/$TextSize および（ルーラー）スタイルをリセットできます。既存のすべての $Text に対してこれらのデフォルト設定を適用するには、次のように記述します。
	$Text = $Text.plain;
StyledString オペレータに対応している String オペレータ
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.strike(),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,true,,false,"StyledString.strike()
StyledString.strike
The function sets the referenced string's styled text to stuck-through text.
	$Text = $Text + ""This is "" + ""some"".strike + "" text"".plain; 
adds ""this is some text"" to the end of $Text. The '.plain' command reasserts no style is to be applied.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.strike()
StyledString.strike
この関数は、参照された文字列のスタイル付きテキストを打ち消し線付きに設定します。
	$Text = $Text + ""This is "" + ""some"".strike + "" text"".plain; 
は、$Text の末尾に ""this is some text"" を追加します。`.plain` コマンドは、スタイルが適用されない状態を再指定します。
注意：現在、スタイル付きテキストを保持できる属性は $Text のみです。String 属性やアクションコードの変数（var）は、スタイル付きテキストを保存できません。スタイル付きテキストが渡された場合、変数は渡されたテキストのスタイルなしバージョンを保存します。詳細については、より詳細な説明を参照してください。
StyledString オペレーターを維持する String オペレーター
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.textColor(aColor),Function,Item,Data manipulation,String,false,9.0.0,Baseline,,,,,true,true,false,false,false,false,false,false,true,,false,"StyledString.textColor(aColor)
The operator .textColor(aColor), when applied to styled text, sets the foreground colour of the text. The color argument can be either a named colour or a hexadecimal string. For example, both of these examples add 'example' in bright red text to the current note's $Text.
	$Text = $Text + ""example"".textColor(""#FF0000"") 
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
.textColor() respects the current text font, e.g. if set to a non-default colour.","StyledString.textColor(aColor)
演算子 .textColor(aColor) は、スタイル付きテキストに適用されると、テキストの前景色を設定します。引数 aColor には、カラー名または16進数文字列を指定できます。例えば、次の例では、現在のノートの $Text に「example」というテキストを鮮やかな赤色で追加します。
	$Text = $Text + ""example"".textColor(""#FF0000"") 
現在、スタイル付きテキストを保持できる属性は $Text のみである点に注意してください。文字列属性やアクションコード変数（var など）は、スタイル付きテキストを保存できません。これらにスタイル付きテキストが渡された場合、スタイル情報のないテキストのみが保存されます。詳細な説明を参照してください。
.textColor() は、現在のテキストフォント（デフォルト以外のフォントが設定されている場合など）の設定を維持します。"
"substr(dataStr, startNum[, lengthNum])",Function,Item,Data manipulation,String,false,5.0.0,Baseline,,,,3,true,false,true,false,false,false,false,true,false,,false,"substr(dataStr, startNum, lengthNum)
Where dataStr is a string literal, string attribute or expression evaluating to a string.
Where startNum is the zero-based position to start the substring. Negative startNum values are not supported, though String.substring() does so and may be used instead.
Where lengthNum is the length of the returned string. If not specified, the entire string from (or back from) startNum is returned.
Extracts a substring of data. For example:
	$MyString = substr(""test"",0,1); 
returns ""t"", while
	$MyString = substr(""test"",1,2); 
returns ""es"". All arguments are evaluated; if the designated characters do not exist, an empty string is returned.
If the length of the substring is negative, it is treated as an offset from the end of the string.
	$MyString = substr(""Hello"",1,-1); → ""ell""
Note that in expressions like
	$Initial=substr($Name,0,1); 
the value of $Name is not changed.","substr(dataStr, startNum, lengthNum)
dataStr は、文字列リテラル、文字列属性、または文字列として評価される式です。
startNum は、部分文字列の開始位置を 0 から数えた数値です。負の startNum 値はサポートされていませんが、String.substring() はサポートしており、代わりにそちらを使用できます。
lengthNum は、返される文字列の長さです。指定されない場合、startNum から（またはそこから後ろの）文字列全体が返されます。
データから部分文字列を抽出します。例：
	$MyString = substr(""test"",0,1); 
は ""t"" を返し、
	$MyString = substr(""test"",1,2); 
は ""es"" を返します。すべての引数が評価されます。指定された文字が存在しない場合は、空の文字列が返されます。
部分文字列の長さが負の場合、それは文字列の末尾からのオフセットとして扱われます。
	$MyString = substr(""Hello"",1,-1); → ""ell""
次のような式において、
	$Initial=substr($Name,0,1); 
$Name の値は変更されないことに注意してください。"
"sum_if(scope, condition, expressionStr)",Function,Conditional Group,Mathematical,Number,false,4.0.0,Baseline,,,,3,true,false,true,false,true,true,true,false,false,,false,"sum_if(scope, condition, expressionStr)
This computes the Number sum of every expressionStr value in each scope item (defining scope), as filtered by a condition expression. See sum() for a related non-conditional operator.
scope describes the notes to be examined and may be any group designator including a find() query. sum_if() omits notes for which $Searchable is false.
In addition, where may be argument that designates a particular (single) note other than this.
condition is action code forming a valid conditional query test, i.e. it equates to true when matched. Some query-style operators terms may allow use of regular expressions.
expressionStr can be an expression, but is typically a Number-attribute value or a List or Set holding a list of numbers. It can also be a literal number 1, i.e. if the test is true from that item then add one to the retuned value of sum_if().
For example,
	$MyNumber = sum_if(children,$Prototype==""p_Problem"",1); 
sums the number of children of the current note whose prototype is 'p_Prototype'. If tested value is a string with spaces, e.g. ""p Prototype"" vs. ""p_Prototype"" then use double quotes around the value.
The newer count_if() offers a more intuitive method of counting matches rather than the value of matched items.","sum_if(scope, condition, expressionStr)
この関数は、条件式（condition）でフィルタリングされた、各スコープ（scope）項目のすべての expressionStr 値の数値合計を計算します。関連する非条件演算子については sum() を参照してください。
scope は調査対象のノートを記述し、find() クエリを含む任意のグループ指定子を使用できます。sum_if() は $Searchable が false のノートを除外します。
さらに、where は、現在のノート以外の特定の（単一の）ノートを指定する引数となる場合があります。
condition は、有効な条件付きクエリテストを形成するアクションコードです。つまり、一致したときに true と評価されます。一部のクエリスタイル演算子では、正規表現を使用できる場合があります。
expressionStr は式にすることもできますが、通常は数値属性の値、または数値のリストを保持する List や Set です。また、リテラル数値の 1 にすることもできます。つまり、その項目でテストが true であれば、sum_if() の返り値に 1 を加算します。
例えば、
	$MyNumber = sum_if(children,$Prototype==""p_Problem"",1); 
は、プロトタイプが 'p_Problem' である現在のノートの子の数を合計します。テストされる値が ""p Prototype"" のようにスペースを含む文字列の場合は、値を二重引用符で囲みます。
新しい count_if() は、一致した項目の値ではなく、一致した数をカウントする、より直感的な方法を提供します。"
"sum(scope, expressionStr)",Function,Group,Mathematical,Number,false,4.0.0,Baseline,,,,2,true,false,true,false,false,true,false,false,false,,false,"sum(scope, expressionStr)
This computes the arithmetic Number of every expressionStr value in each in-scope item (defining scope). See sum_if() for a related conditional operator.
The sum() operator omits notes for which $Searchable is false.
expressionStr can be an expression, but is typically a Number-attribute value or a List or Set holding a list of numbers. It can also be a literal number 1, i.e. if the test is true from that item then add one to the retuned value of sum(). The latter is less likely than with the sibling operator sum_if().
For example,
	$MyNumber = sum(children,$WordCount); 
constructs the current word count of the children of the note.
See also list.sum().","sum(scope, expressionStr)
指定された scope 内の各アイテム（scope の定義を参照）における、すべての expressionStr の値の算術合計（数値）を算出します。関連する条件付き演算子については sum_if() を参照してください。
sum() 演算子は、$Searchable が false であるノートを除外します。
expressionStr は式にすることもできますが、通常は数値型の属性値、または数値を保持する List 型や Set 型の属性です。また、数値リテラルの 1 を指定することもできます。つまり、そのアイテムにおいて評価が真であれば、sum() が返す値に 1 を加算します。後者の使い方は、兄弟演算子である sum_if() ほど一般的ではありません。
例：
	$MyNumber = sum(children,$WordCount); 
ノートの子の現在のワード数の合計を算出します。
list.sum() も参照してください。"
tan(radiansNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"tan(radiansNum)
tan() converts its radiansNum, in radians, to the tangent of that value.
	$MyNumber = tan(3) 
returns '-0.1425465431' for an input of 3 radians.","tan(radiansNum)
tan() は、ラジアン単位の radiansNum をその値の正接（タンジェント）に変換します。
	$MyNumber = tan(3)
3 ラジアンの入力に対して '-0.1425465431' を返します。"
"time(aDate, hoursNum, minutesNum[, secondsNum])",Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,4,true,false,false,false,false,false,false,false,false,,false,"time(aDate, hoursNum, minutesNum[, secondsNum])
creates a new Date based on the aDate expression, but in which the time is set by hoursNum, minutesNum, and secondsNumDate is not changed. Only positive values are allowed. If needing to alter a Date's time towards or backwards by a certain amount, consider using interval(dataStr).
time() accepts an optional fourth argument secondsNum, representing the seconds component of the time.
For example, to make a stamp or rule that sets the time element of all event start/end dates in a timeline to 12:00:00 AM (midday) use this code:
   $StartDate=time($StartDate,12,0,0);
   if($EndDate){
      $EndDate=time($EndDate,12,0,0)
   };

Parsing of time inputs
When any/all of hoursNum, minutesNum, and secondsNumDate are provided in a value larger then their normal limit, Tinderbox adjusts the containing limit accordingly. Thus > 60 seconds adds minute to aDate, > 60 minutes adds an hour, >24 hours adds a day. Therefore:
	$StartDate=time($StartDate,12,30,0); 
results in a time of 12:30:00, but:
	$StartDate=time($StartDate,12,90,0); 
results in a time of 13:30:00, as 90 minutes is parsed as being 1 hour + 30 minutes and as if this code were being used:
	$StartDate=time($StartDate,13,30,0);","time(aDate, hoursNum, minutesNum[, secondsNum])
aDate 式に基づき、時刻を hoursNum、minutesNum、および secondsNum で指定した値に設定した新しい Date を作成します。元の Date は変更されません。正の値のみが許可されます。Date の時刻を一定量進めたり戻したりする必要がある場合は、interval(dataStr) の使用を検討してください。
time() は、時刻の秒要素を表すオプションの第4引数 secondsNum を受け取ります。
例えば、タイムライン内のすべてのイベントの開始日/終了日の時刻要素を 12:00:00 AM (正午) に設定するスタンプやルールを作成するには、次のコードを使用します：
   $StartDate=time($StartDate,12,0,0);
   if($EndDate){
      $EndDate=time($EndDate,12,0,0)
   };

時刻入力の解析
hoursNum、minutesNum、または secondsNum のいずれか（あるいはすべて）に通常の上限を超える値が指定された場合、Tinderbox はそれに応じて上位の単位を調整します。したがって、60秒を超えると aDate に1分加算され、60分を超えると1時間加算され、24時間を超えると1日加算されます。
その結果：
	$StartDate=time($StartDate,12,30,0); 
は 12:30:00 という時刻になりますが、
	$StartDate=time($StartDate,12,90,0); 
は 13:30:00 という時刻になります。これは、90分が 1時間 + 30分として解析され、次のようなコードが使用された場合と同じ結果になるためです：
	$StartDate=time($StartDate,13,30,0);"
time(aDate),Function,Item,Date-time,String,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"time(aDate) 
returns a string of the hours/minutes/seconds time part the aDate date/time expression, which may simply be a date-type attribute value. For instance:
	$MyString = time($StartDate); 
If the time of $StartTime is 14:20:30 then $MyString will be ""14:20:30"". Passing to a string will elide leading zeroes, so a time of 05:08 will return ""5:08"".","time(aDate) 
日付/時刻式（単なる日付型属性値でも可）である aDate から、時/分/秒の部分を文字列として返します。
例：
	$MyString = time($StartDate); 
$StartTime の時刻が 14:20:30 であれば、$MyString は ""14:20:30"" となります。文字列に渡される際、先頭のゼロは省略されるため、時刻が 05:08 であれば ""5:08"" が返されます。"
"twitter(usernameStr, statusStr)",n/a - success boolean,Item,Data manipulation,source context dependent,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"twitter(usernameStr,statusStr)
NOW DEPRECATED and no longer working - for info only
allows posting to the user's twitter account (usernameStr) of a tweet (statusStr).
Tinderbox will request permission to use your Twitter account, and will send the tweet to that account.
	twitter(""myusername"",""my test tweet"") 
The twitter() action is no longer supported (reflecting changes to Twitter API).","twitter(usernameStr,statusStr)
現在は非推奨であり、動作しません（情報提供のみ）。
ユーザーのTwitterアカウント（usernameStr）からツイート（statusStr）を投稿できるようにします。
TinderboxはTwitterアカウントの使用許可を求め、そのアカウントにツイートを送信します。
	twitter(""myusername"",""my test tweet"") 
twitter() アクションは、Twitter APIの変更を反映して現在サポートされていません。"
type(attributeNameStr),Function,Document,Document configuration,String,false,9.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"type(attributeNameStr)
This operator may be replaced by the more flexible attribute() operator.
The operator type(attributeNameStr) returns a string representing the type of the designated attribute. The attribute may simply be the attribute name (without quotes or a preceding ""$"") or an expression that, when evaluated, yields an attribute name.
	$MyString = type(Width); → ""number""
	$MyString = type(""AccentColor""); → ""color""
	$MyString=""Modified""; type($MyString); → ""date""
Note that type($MyString) returns the type of the attribute who name is stored in $MyString, while type(""MyString"") or  type(MyString) returns the type of the attribute MyString.
If no such attribute exists in the document, the operator returns the empty string.","type(attributeNameStr)
このオペレーターは、より柔軟な attribute() オペレーターに置き換えられる可能性があります。
オペレーター type(attributeNameStr) は、指定された属性の型を表す文字列を返します。属性は、単に属性名（引用符や先頭の「$」なし）か、評価されたときに属性名を生成する式を指定できます。
	$MyString = type(Width); → ""number""
	$MyString = type(""AccentColor""); → ""color""
	$MyString=""Modified""; type($MyString); → ""date""
type($MyString) は $MyString に格納されている名前を持つ属性の型を返し、type(""MyString"") または type(MyString) は属性 MyString の型を返すことに注意してください。
ドキュメント内にそのような属性が存在しない場合、このオペレーターは空の文字列を返します。"
"unlink(source,destination[,linkType])",Function,Group,Linking,success boolean,false,10.2.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"unlink(source,destination[,linkType])
unlink(source,destination[,linkType]) removes all links between an explicit source and destination note. If linkType is omitted, the linkType is assumed to be *untitled. If linkType is *, all links are deleted regardless of their linkType.
No expression left side is needed (the operator returns a true/false success boolean value. This removes a link from note ""A note"" to ""Some note"" that uses the ""agree"" link type.
	$MyBoolean = unlink(""A note"", ""Some note"",""agree""); 
The same but removing all links from ""A note"" to ""Some note"" (here with no left-side to the expression:
	unlink(""A note"", ""Some note"",""*""); 
The asterisk is functioning as a wildcard.","unlink(source,destination[,linkType])
unlink(source,destination[,linkType]) は、指定されたソース・ノートとデスティネーション・ノートの間のすべてのリンクを削除します。linkType が省略された場合、linkType は *untitled とみなされます。linkType が * の場合、リンクタイプに関係なくすべてのリンクが削除されます。
式の左辺（代入先）は必須ではありません（この演算子は成否を true/false の論理値で返します）。以下は、""A note"" から ""Some note"" への ""agree"" リンクタイプのリンクを削除する例です。
	$MyBoolean = unlink(""A note"", ""Some note"",""agree""); 
同様に ""A note"" から ""Some note"" へのすべてのリンクを削除する例（ここでは式の左辺を記述していません）：
	unlink(""A note"", ""Some note"",""*""); 
アスタリスクはワイルドカードとして機能します。"
"unlinkFrom(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"unlinkFrom(scope[, linkTypeStr])
This removes all basic links from scope to the current note (i.e. inbound links). unlinkFrom() does not delete prototype links.
Both arguments are evaluated. This operator does not require a left-side argument, simply calling effects a result. No change occurs if the described link does not exist.
scope argument
The scope argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString. Ways to define scope. Note that here, unlike other scope uses, $Path can not be used.
scope may be group scoped including use of group designators and operators like find,() collect and links().
linkTypeStr argument
linkTypeStr (string). Optionally, link deletion can be constrained to one type supplied as literal string value for linkTypeStr:
* If no linkTypeStr argument is supplied, only untitled (i.e. no link type) links are deleted. 
* If a valid link type name, e.g. ""agree"", is supplied only links of the specified type are deleted.
* To delete all links of any type or none use the wildcard value ""*"" (an asterisk). Also note:
** This method does not affect prototype links.
** This wildcard linkTypeStr option only applies to unlinking, and not to linking).
linkTypeStr is evaluated as a literal string (previously a pattern match was undertaken).
Examples
Unlinking from a note ""Some note"":
	all link types: unlinkFrom(""Some note""); 
	only link type 'agree': unlinkFrom(""Some note"",""agree""); 
	either of 2 link types: unlinkFrom(""Some note"", ""example|disagree""); 
Unlinking the first child (via a designator):
	unlinkFrom(child); 
	unlinkFrom(child,""agree""); 
See further below for group-scope references.
Relevant similar operators: linkTo, linkFrom, unlinkTo.
Use of this action does not shift note focus; in addition if scope contains operators (brackets, plus, minus, etc.) Tinderbox will first look for a match to the literal scope string and only if there is no match will the app try evaluating to operators and testing the resulting string. For example:
	unlinkFrom(""Example 1 (a test)""); 
will unlink the note named 'Example 1 (a test)'. If no note matches this string, Tinderbox will attempt to evaluate the string. Thus for:
	unlinkFrom(""2+2""); 
will unlink the note named '2+2' but if there is no match Tinderbox will look for a note named '4'.
This function can unlink an alias as opposed to an original (if the logical choice) and can also accept a group scope. An example of group scope is the following code that could be used in a rule or stamp to remove in/bound footnote links from one or more selected notes. Use of the 'all' designator removes the need to know the name of the notes for which the selection are footnotes:
	unlinkFrom(all,""note"");unlinkTo(all,""note+""); 
Use in agents
Beware that the action is working on an alias of the current note and note the current note itself. As originals and aliases support discrete basic links this function should not generally be used in an agent. The best way to use the function is by using a prototype and apply a $Rule to it thus running the code in all notes using the prototype.
An alternative unlinkFromOriginal() code will ensure any link deleted is between two original notes regardless of whether an alias is the context of execution of the code.","unlinkFrom(scope[, linkTypeStr])
この関数は、scopeから現在のノートへのすべての基本リンク（すなわち、内向きのリンク）を削除します。unlinkFrom() はプロトタイプ・リンクを削除しません。
両方の引数は評価されます。このオペレータは左辺の引数を必要とせず、呼び出すだけで結果が得られます。指定されたリンクが存在しない場合、変更は行われません。

scope引数
scope引数は、属性参照（例：$MyString）でない限り、引用符で囲む必要があります（例：""Some note""）。スコープの定義方法。なお、ここでは他のスコープの使用とは異なり、$Pathは使用できないことに注意してください。
scopeは、find()、collect()、links()などのグループ・デジグネータやオペレータの使用を含むグループ・スコープを指定できます。

linkTypeStr引数
linkTypeStr（文字列）。オプションで、linkTypeStrにリテラル文字列を指定することで、リンクの削除を特定のタイプに制限できます：
* linkTypeStr引数が指定されない場合、タイトルのない（リンク・タイプがない）リンクのみが削除されます。
* 有効なリンク・タイプ名（例：""agree""）が指定された場合、その指定されたタイプのリンクのみが削除されます。
* タイプに関わらず、またはタイプがないものも含め、すべてのリンクを削除するには、ワイルドカード値""*""（アスタリスク）を使用します。また、以下の点に注意してください：
** このメソッドはプロトタイプ・リンクには影響しません。
** このワイルドカード（linkTypeStr）オプションはアンリンク（リンク解除）にのみ適用され、リンク作成には適用されません。
linkTypeStrはリテラル文字列として評価されます（以前はパターンマッチングが行われていました）。

例
""Some note""というノートからのリンク解除：
	すべてのリンク・タイプ：unlinkFrom(""Some note""); 
	リンク・タイプ 'agree' のみ：unlinkFrom(""Some note"",""agree""); 
	2つのリンク・タイプのいずれか：unlinkFrom(""Some note"", ""example|disagree""); 
最初の子供からのリンク解除（デジグネータを使用）：
	unlinkFrom(child); 
	unlinkFrom(child,""agree""); 
グループ・スコープの参照については、以下を参照してください。
関連する類似のオペレータ：linkTo, linkFrom, unlinkTo。

このアクションを使用してもノートのフォーカスは移動しません。さらに、scopeに演算子（括弧、プラス、マイナスなど）が含まれている場合、Tinderboxはまずリテラルなscope文字列との一致を探し、一致するものがない場合にのみ、アプリは演算子を評価して結果の文字列をテストしようとします。例えば：
	unlinkFrom(""Example 1 (a test)""); 
は、'Example 1 (a test)'という名前のノートをアンリンクします。この文字列に一致するノートがない場合、Tinderboxは文字列の評価を試みます。したがって：
	unlinkFrom(""2+2""); 
は、'2+2'という名前のノートをアンリンクしようとしますが、一致するものがない場合、Tinderboxは'4'という名前のノートを探します。

この関数は、オリジナルの代わりにエイリアスをアンリンクすることもでき（それが論理的な選択である場合）、グループ・スコープを受け入れることもできます。グループ・スコープの例として、ルールやスタンプで使用して、選択された1つ以上のノートから内向きの脚注（footnote）リンクを削除する次のコードがあります。'all'デジグネータを使用することで、選択対象が脚注となっているノートの名前を知る必要がなくなります：
	unlinkFrom(all,""note"");unlinkTo(all,""note+""); 

エージェントでの使用
アクションが現在のノートそのものではなく、現在のノートのエイリアスに対して動作していることに注意してください。オリジナルとエイリアスは個別の基本リンクをサポートしているため、この関数は通常エージェント内では使用すべきではありません。この関数を使用する最適な方法は、プロトタイプを使用し、それに$Ruleを適用することで、そのプロトタイプを使用しているすべてのノートでコードを実行することです。
代替の unlinkFromOriginal() コードを使用すると、コードの実行コンテキストがエイリアスであるかどうかにかかわらず、削除されるリンクが確実に2つのオリジナル・ノート間のものになります。"
"unlinkFromOriginal(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,6.4.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"unlinkFromOriginal(scope[, linkTypeStr])
This function works exactly as the same as unlinkFrom(), except for one important difference that the link deleted is always between two originals even if either/both the evaluated source or destination are an alias. unlinkFromOriginal() does not delete prototype links.
For more detail of use, see unlinkFrom().
Unlinking from an original note ""Some note"" (and not an alias of it):
	all link types: unlinkFromOriginal(""Some note""); 
	only link type 'agree': unlinkFromOriginal(""Some note"",""agree""); 
	either of 2 link types: unlinkFromOriginal(""Some note"", ""example|disagree""); 
See also linkFromOriginal(), linkToOriginal(), unlinkToOriginal().","unlinkFromOriginal(scope[, linkTypeStr])
この関数はunlinkFrom()とまったく同じように動作しますが、1つ重要な違いがあります。それは、評価されたソースまたはデスティネーションのいずれか（あるいは両方）がエイリアスであっても、削除されるリンクは常に2つのオリジナル（本体）間のものになるということです。unlinkFromOriginal()はプロトタイプリンクを削除しません。
使い方の詳細については、unlinkFrom()を参照してください。

オリジナル・ノート「Some note」（そのエイリアスではないもの）からのリンク解除：
すべてのリンクタイプ：unlinkFromOriginal(""Some note"");
リンクタイプ「agree」のみ：unlinkFromOriginal(""Some note"",""agree"");
2つのリンクタイプのいずれか：unlinkFromOriginal(""Some note"", ""example|disagree"");

参照：linkFromOriginal(), linkToOriginal(), unlinkToOriginal()。"
"unlinkTo(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"unlinkTo(scope[, linkTypeStr])
This removes all basic links to scope from the current note (i.e. outbound links). unlinkTo() does not delete prototype links.
Both arguments are evaluated. This operator does not require a left-side argument, simply calling effects a result. No change occurs if the described link does not exist.
scope argument
The scope argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString. Ways to define scope. Note that here, unlike other scope uses, $Path may not be used.
The scope may be group scoped including use of group designators and operators like find,() collect() and links().
linkTypeStr argument
linkTypeStr (string). Optionally, link deletion can be constrained to one type supplied as literal string value for linkTypeStr:
* If no linkTypeStr argument is supplied, only untitled (i.e. no link type) links are deleted. 
* If a valid link type name, e.g. ""agree"", is supplied only links of the specified type are deleted.
* To delete all links of any type or none use the wildcard value ""*"" (an asterisk). Also note:
** This method does not affect prototype links.
linkTypeStr is evaluated as a literal string (previously a pattern match was undertaken).
Examples
Unlinking to a note ""Some note"":
	all link types: unlinkTo(""Some note""); 
	only link type 'agree': unlinkTo(""Some note"",""agree""); 
	either of 2 link types: unlinkTo(""Some note"", ""agree|disagree""); 
Matching the first child (via a designator):
	unlinkTo(child); 
	unlinkTo(child,""agree""); 
See further below for group-scope references.
Relevant similar operators: linkTo, linkFrom, unlinkFrom.
Use of this action does not shift note focus; in addition if scope contains operators (brackets, plus, minus, etc.) Tinderbox will first look for a match to the literal scope string and only if there is no match will the app try evaluating to operators and testing the resulting string. For example:
	unlinkTo(""Example 1 (a test)""); 
will unlink the note named 'Example 1 (a test)'. If no note matches this string, Tinderbox will attempt to evaluate the string. Thus for:
	unlinkTo(""2+2""); 
will unlink the note named '2+2' but if there is no match Tinderbox will look for a note named '4'.
This function can unlink an alias as opposed to an original (if the logical choice) and can also accept a group scope. An example of group scope is the following code that could be used in a rule or stamp to remove in/bound footnote links from one or more selected notes. Use of the 'all' designator removes the need to know the name of the notes for which the selection are footnotes:
	unlinkFrom(all,""note"");unlinkTo(all,""note+""); 
Use in agents
Beware that the action is working on an alias of the current note and note the current note itself. As originals and aliases support discrete basic links this function should not generally be used in an agent. The best way to use the function is by using a prototype and apply a $Rule to it thus running the code in all notes using the prototype.
An alternative unlinkToOriginal() code will ensure any link deleted is between two original notes regardless of whether an alias is the context of execution of the code.","unlinkTo(scope[, linkTypeStr])
この関数は、現在のノートから scope（スコープ）で指定されたノートへのすべての基本リンク（つまり、アウトバウンドリンク）を削除します。unlinkTo() はプロトタイプリンクは削除しません。
両方の引数が評価されます。この演算子は左辺の引数を必要とせず、呼び出すだけで結果が得られます。指定されたリンクが存在しない場合は、何も変更されません。
scope 引数
scope 引数は、属性参照（例：$MyString）でない限り、引用符で囲む必要があります（例：""Some note""）。スコープの定義方法を参照してください。なお、ここでは他のスコープの使用法とは異なり、$Path は使用できない場合があります。
スコープは、グループ指示子や find()、collect()、links() などの演算子を含むグループスコープとして定義することもできます。
linkTypeStr 引数
linkTypeStr（文字列）。オプションとして、linkTypeStr にリテラル文字列を指定することで、リンクの削除を特定のタイプに限定できます。
* linkTypeStr 引数が指定されない場合、タイトルのない（つまりリンクタイプがない）リンクのみが削除されます。
* 有効なリンクタイプ名（例：""agree""）が指定された場合、その指定されたタイプのリンクのみが削除されます。
* 任意のタイプ、またはタイプのないすべてのリンクを削除するには、ワイルドカード ""*""（アスタリスク）を使用します。また、以下の点に注意してください。
** このメソッドはプロトタイプリンクには影響しません。
linkTypeStr はリテラル文字列として評価されます（以前はパターンマッチングが行われていました）。
例
""Some note"" というノートへのリンクを解除する場合：
	すべてのリンクタイプ：unlinkTo(""Some note""); 
	リンクタイプ 'agree' のみ：unlinkTo(""Some note"",""agree""); 
	2つのリンクタイプのいずれか：unlinkTo(""Some note"", ""agree|disagree""); 
（指示子を使用して）最初の子ノートにマッチさせる場合：
	unlinkTo(child); 
	unlinkTo(child,""agree""); 
グループスコープの参照については、後述の内容を参照してください。
関連する類似の演算子：linkTo, linkFrom, unlinkFrom。
このアクションを使用してもノートのフォーカスは移動しません。さらに、scope に演算子（括弧、プラス、マイナスなど）が含まれている場合、Tinderbox はまずリテラルな scope 文字列との一致を探し、一致するものがない場合にのみ、文字列を演算子として評価し、その結果の文字列をテストします。例えば：
	unlinkTo(""Example 1 (a test)""); 
は、'Example 1 (a test)' という名前のノートのリンクを解除します。この文字列に一致するノートがない場合、Tinderbox は文字列の評価を試みます。したがって：
	unlinkTo(""2+2""); 
は '2+2' という名前のノートのリンクを解除しようとしますが、一致するものがない場合、Tinderbox は '4' という名前のノートを探します。
この関数は、論理的な選択であればオリジナルではなくエイリアスのリンクを解除でき、グループスコープも受け入れることができます。グループスコープの例として、以下のコードは、選択された1つまたは複数のノートから、インバウンドまたはアウトバウンドの脚注（footnote）リンクを削除するためにルールやスタンプで使用できます。'all' 指示子を使用することで、選択対象がどのノートの脚注であるかを知る必要がなくなります。
	unlinkFrom(all,""note"");unlinkTo(all,""note+""); 
エージェントでの使用
このアクションは、現在のノートそのものではなく、現在のノートのエイリアスに対して動作していることに注意してください。オリジナルとエイリアスは個別の基本リンクを保持するため、通常、この関数はエージェント内で使用すべきではありません。この関数を使用する最適な方法は、プロトタイプを使用し、それに $Rule を適用して、そのプロトタイプを使用するすべてのノートでコードを実行することです。
代替の unlinkToOriginal() コードを使用すると、コードが実行されているコンテキストがエイリアスであっても、削除されるリンクが2つのオリジナルノート間のリンクであることを保証できます。"
"unlinkToOriginal(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,6.4.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"unlinkToOriginal(scope[, linkTypeStr])
This function works exactly as the same as unlinkTo(), except for one important important difference that the link deleted is always between two originals even if either/both the evaluated source or destination are an alias. unlinkToOriginal() does not delete prototype links.
For more detail of use, see unlinkTo().
Unlinking to an original note ""Some note"" (and not an alias of it):
	all link types: unlinkToOriginal(""Some note""); 
	only link type 'agree': unlinkToOriginal(""Some note"",""agree""); 
	either of 2 link types: unlinkToOriginal(""Some note"", ""agree|disagree""); 
See also linkFromOriginal(), linkToOriginal(), unlinkFromOriginal().","unlinkToOriginal(scope[, linkTypeStr])
この関数は、1つの重要な違いを除いて、unlinkTo()と全く同じように動作します。その違いとは、評価されたソースまたはデスティネーションの一方または両方がエイリアスであっても、削除されるリンクは常に2つのオリジナル（本体）間のリンクであるということです。unlinkToOriginal()はプロトタイプリンクを削除しません。
使用方法の詳細については、unlinkTo()を参照してください。
オリジナルノート ""Some note""（エイリアスではない）へのリンク解除：
	すべてのリンクタイプ: unlinkToOriginal(""Some note""); 
	リンクタイプ 'agree' のみ: unlinkToOriginal(""Some note"",""agree""); 
	2つのリンクタイプのいずれか: unlinkToOriginal(""Some note"", ""agree|disagree""); 
関連項目: linkFromOriginal(), linkToOriginal(), unlinkFromOriginal()。"
update(),Function,List,Data manipulation,List,false,9.1.0,Baseline,11.0.0,11.0.0,,,false,false,false,false,false,false,false,false,false,,false,"update() 
This returns a list of updated notes. This allow the user, to check, if necessary, which notes have actually been updated.
Note also that we can use update() at the start of an action to be sure we are ready to work, and we can also use update() after an action if we know some other note will want to respond to our new values.
On the whole, update() is envisaged an esoteric command for unusual cases, but may prove popular for some users with demanding applications. For light/occasional use, a need to use update() is likely an indication that some review of current code use is needed.
The method of update() using an argument is documented separately: see update(scope).
From v11.0.0 update() updates smart adornments as well as agents.","update()
これは、更新されたノートのリストを返します。これにより、ユーザーは必要に応じて、どのノートが実際に更新されたかを確認することができます。
また、作業の準備が整っていることを確実にするためにアクションの開始時にupdate()を使用したり、他のノートが新しい値に反応することがわかっている場合にアクションの終了後にupdate()を使用したりすることもできます。
全体として、update()は特殊なケース向けの高度なコマンドとして想定されていますが、要求の厳しいアプリケーションを扱う一部のユーザーには普及するかもしれません。軽度または時折の使用においてupdate()が必要になる場合は、現在のコードの使用方法を見直す必要があるという兆候である可能性が高いです。
引数を使用するupdate()の方法については、別途ドキュメント化されています（update(scope)を参照）。
v11.0.0より、update()はエージェントだけでなくスマート・アドーンメントも更新するようになりました。"
update(scope),Function,List,Data manipulation,success boolean,false,9.1.0,Baseline,11.0.0,11.0.0,,1,true,false,false,false,false,true,false,false,false,,false,"update(scope)
The action update(scope) asks Tinderbox to update one or more notes defined in the list scope by evaluating both their rule and edict of each listed note (defining scope). If the note has been evaluated recently, Tinderbox will not evaluate it again. 
For example, suppose there is a note 'INSTALL DISHWASHER', which has a rule saying that the dishwasher cannot start to be installed until the task of note 'FLOOR' is finished.
if($StartDate 
This rule works best if the 'FLOOR' note is up to date. So, before doing anything else, the 'FLOOR' note is updated:
update(""FLOOR"");
if($StartDate 
Note that, if note 'FLOOR' has been updated recently (a duration as decided by the app), it will not be updated again; the prevents Tinderbox from doing lots of unwanted and unnecessary work.
On the whole, update(scope) is envisaged an esoteric command for unusual cases, but may prove popular for some users with demanding applications. For light/occasional use, a need to use update() is likely an indication that some review of current code use is needed.
The non-argument form of update() is documented separately: see update().
If update() is called on a note inside /Hints/Library, any functions in the text of that note will be recompiled and the actions in the text of the note will be performed.
When applied to an agent, update() updates the agent as well as performing its rule and edict.
From v11.0.0 update() updates smart adornments as well as agents.","update(scope)
update(scope)アクションは、リストscopeで定義された1つ以上のノートについて、それぞれのルールとエディクト（edict）の両方を評価することで更新するようTinderboxに要求します。ノートが最近評価されたばかりであれば、Tinderboxは再評価を行いません。

例えば、「INSTALL DISHWASHER（食洗機の設置）」というノートがあり、それに「『FLOOR（床）』ノートのタスクが完了するまで食洗機の設置を開始できない」というルールが設定されているとします。
if($StartDate 
このルールは、「FLOOR」ノートが最新の状態である場合に最も効果的に機能します。そのため、他の処理を行う前に「FLOOR」ノートを更新します：
update(""FLOOR"");
if($StartDate 
なお、「FLOOR」ノートが最近更新された場合（アプリによって決定される一定期間内）、再び更新されることはありません。これにより、Tinderboxが不要な作業を大量に行うのを防ぎます。

全体として、update(scope)は特殊なケースのための難解なコマンドとして想定されていますが、要求の厳しいアプリケーションを使用する一部のユーザーには重宝されるかもしれません。軽い用途やたまにしか使わない場合、update()を使用する必要があるということは、現在のコードの使用方法を見直す必要があることを示唆している可能性があります。

引数のない形式のupdate()については、別途ドキュメント化されています（update()を参照）。

/Hints/Library内のノートに対してupdate()が呼び出された場合、そのノートのテキスト内にあるすべての関数が再コンパイルされ、テキスト内のアクションが実行されます。

エージェントに適用された場合、update()はエージェントを更新するとともに、そのルールとエディクトを実行します。

v11.0.0以降、update()はエージェントに加えてスマートアドーンメント（smart adornments）も更新します。"
uppercase(dataStr),Function,Item,Formatting,String,false,4.6.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"uppercase(dataStr)
The contents of dataStr are returned entirely in upper case.
If $MyString is ""hello world"":
	$MyString = uppercase($MyString); 
$MyString is set to ""HELLO WORLD"".
Functionally equivalent to String.uppercase().","uppercase(dataStr)
dataStrの内容をすべて大文字にして返します。
$MyString が ""hello world"" の場合：
	$MyString = uppercase($MyString); 
$MyString は ""HELLO WORLD"" に設定されます。
機能的には String.uppercase() と同等です。"
urlEncode(dataStr),Function,Item,Formatting,String,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"urlEncode(dataStr)
urlEncode() converts a dataStr string to 'urlEncoded' form for the web, in accordance with RFC1738. URLs should not contain spaces, control characters, or non-ASCII characters. Characters that are illegal in URLs are encoded as '%' followed by the corresponding hexadecimal character code, e.g. space = %20.
Thus:
	$MyString = urlEncode(""Hello world""); 
sets $MyString to 'Hello%20world'.
dataStr should be a quoted literal string or a reference to a string value.
The characters ? and / are percent-encoded by urlEncode(), e.g. as %3F and %2F. Even though these are now permitted in the query portion of URLs, the Apple NSURL used by Tinderbox balks at their presence.","urlEncode(dataStr)
urlEncode() は、RFC 1738 に準拠して、文字列 dataStr をウェブ用の「URLエンコード」形式に変換します。URL にはスペース、制御文字、または非 ASCII 文字を含めることはできません。URL で使用できない文字は、「%」の後に対応する16進文字コードが続く形式（例：スペース = %20）でエンコードされます。
したがって：
	$MyString = urlEncode(""Hello world"");
は、$MyString を 'Hello%20world' に設定します。
dataStr は、引用符で囲まれたリテラル文字列、または文字列値への参照である必要があります。
文字 ? と / は、urlEncode() によってパーセントエンコードされます（例：%3F および %2F）。これらは現在、URL のクエリ部分では許可されていますが、Tinderbox が使用している Apple の NSURL がそれらの存在によってエラーを起こす（または正しく処理できない）ためです。"
"values([scope, ]attributeNameStr)",Function,Group,"Dictionary, Set & List operations",List,false,5.10.1,Baseline,,,,2,true,false,false,false,false,true,false,true,false,,false,"values([scope, ]attributeNameStr)
values(attributeNameStr)
This returns a Set of unique values for the attribute attributeNameStr. As the output is a of Set data type, the list of possible values is de-duped thus giving a list of unique values, and should be sorted. Any suggested values not actually used by at least one note are omitted from the list return by values().
If the named attributeNameStr is a set or list, values() returns a list of all the unique discrete list item values that occur. If the named attribute is a string, values() returns all the unique strings.
attributeNameStr is evaluated in case it is something like a variable holding the desired target attribute name. The change is that, if the argument is not an attribute name, and if the argument trimmed of its $ is still not an attribute name, we now see if the evaluated expression turns out to be an attribute name.
Important: unlike other operators, be aware that values($MyString) returns a list of values found for $MyString, not a list of the values of the attribute whose name is stored in $MyString. This is unique to values(), and arises because writing values($MyString) instead of values(""MyString"") was a very common mistake. If needing to pass a value holding an attribute name, use an action code variable and not as a value stored in another attribute.
The returned set is sorted in lexical order.
If a document has a user List-Type attribute $SomeList, then to get a a list of all the unique values for $SomeList in the whole document:
	$MyList = values(""SomeList""); 
The attributeNameStr argument is evaluated so may be:
* A quoted attribute name without $-prefix: values(""MyList"").
* A string attribute name, whose current value is the name of an attribute (without a dollar prefix). If $MyString has the value ""MyList"", then values($MyString) will evaluate the unique values for $MyList (and output the same result as values(""MyList"") above).
* An expression resolving to an attribute name.
Thus if the document has a user List-Type attribute $SomeList and $MyString has the value ""SomeList"", then these are functionally equivalent:
	$MyList = values(""SomeList""); 
	$MyList = values($MyString); 
It is envisaged that the first method (the quoted, un-prefixed, attribute name) will be the most usual method of using values().
Sorting. The data is returned in case-sensitive lexical sort order (i.e. all capitals sort before lower case letters, and numbers sorting textually not numerically) so chaining .isort() may often be the desired 'default', or use .nsort() if the list is entirely composed of numbers. Assume, the intention is to get a note whose $Text has one value per line. It could be coded thus:
	$Text=values(""MyList"").format(""\n""); 
This is a very useful way of making a set of per-value notes. Use values() to collect the values, pass them to a note's $Text as a one-value-per-line string and then explode the $Text.
However, a value list of [aardvark;amber;Ant] would actually list in this order: [Ant;aardvark;amber]. That is due to the Set's auto-sort using case-sensitive lexical sorting, whereas a case-insensitive sort would be more appropriate. Thus:
	$Text=values(""MyList"").isort.format(""\n""); 
Similarly the default sort would order 1/2/10 and 1/10/2, so a numerical sort would be more sensible:
	$Text=values(""MyList"").isort.format(""\n""); 
De-duplication. values() differs from collect() in that values() returns Set-type data and collect() returns List-type data. For a list $MyList, the following are functionally equivalent in output:
	$MyList = collect(all,$SomeList).unique; 
	$MyList = values(""SomeList""); 
	$MyList = values($MyString); (where $MyString has the value ""SomeList"")
values(scope, attributeNameStr)
If an optional first scope argument is provided, the value(s) returned are drawn only from notes in that scope (defining scope). If no first argument is supplied, as in the short form above, the default scope-defined group is assumed as 'all' and thus at whole document scope.The reference point for groups like 'children' or 'siblings' is this note. Thus:
	$MyList = values(children,""Subtitle""); 
will return all the discrete subtitles (i.e. values of $Subtitle) for children of this note, i.e. the note in which context the action is being evaluated.","values([scope, ]attributeNameStr)
values(attributeNameStr)
この関数は、属性 attributeNameStr の一意な値のセット（Set）を返します。出力は Set データ型であるため、リストは重複が取り除かれた一意な値のリストとなり、ソートされます。少なくとも1つのノートで実際に使用されていない「推奨値（suggested values）」は、values() が返すリストからは除外されます。
指定された attributeNameStr が Set 型または List 型の場合、values() は出現するすべての重複しない個別のリスト項目のリストを返します。指定された属性が String 型の場合、values() はすべての一意な文字列を返します。
attributeNameStr は、目的のターゲット属性名を保持する変数の場合などに備えて評価されます。変更点として、引数が属性名ではなく、かつ引数から $ を取り除いても属性名でない場合、評価された式の結果が属性名になるかどうかが確認されるようになりました。
重要：他のオペレーターとは異なり、values($MyString) は $MyString 自体で見つかった値のリストを返すのであり、$MyString に格納されている名前を持つ属性の値のリストを返すのではないことに注意してください。これは values() 特有の挙動であり、values(""MyString"") と書くべきところを values($MyString) と書いてしまうミスが非常に多かったために生じました。属性名を保持する値を渡す必要がある場合は、別の属性に格納された値ではなく、アクションコードの変数を使用してください。
返されるセットは辞書順（lexical order）でソートされます。
ドキュメントにユーザー定義の List 型属性 $SomeList がある場合、ドキュメント全体における $SomeList のすべての一意な値のリストを取得するには次のように記述します。
	$MyList = values(""SomeList""); 
引数 attributeNameStr は評価されるため、以下のいずれかになります。
* $ プレフィックスのない、引用符で囲まれた属性名： values(""MyList"")。
* 文字列属性の名前。その属性の現在の値が別の属性の名前（ドル記号なし）である場合。例えば $MyString の値が ""MyList"" である場合、values($MyString) は $MyList の一意な値を評価します（これは上記の values(""MyList"") と同じ結果を出力します）。
* 属性名へと解決される式。
したがって、ドキュメントにユーザー定義の List 型属性 $SomeList があり、$MyString の値が ""SomeList"" である場合、以下の2つは機能的に等価です。
	$MyList = values(""SomeList""); 
	$MyList = values($MyString); 
values() を使用する際は、最初の方法（引用符で囲まれ、$ プレフィックスのない属性名）がもっとも一般的になると想定されています。
ソートについて。データは大文字小文字を区別する辞書順（つまり、すべての大文字が小文字より前にソートされ、数字は数値ではなくテキストとしてソートされる）で返されます。そのため、.isort() を連結するのが望ましい「デフォルト」となることが多いでしょう。また、リストが完全に数字で構成されている場合は .nsort() を使用してください。例えば、1行に1つの値を保持する $Text を持つノートを作成したい場合は、次のように記述できます。
	$Text=values(""MyList"").format(""\n""); 
これは、値ごとのノートのセットを作成する際に非常に便利な方法です。values() を使用して値を収集し、それを1行に1つの値を含む文字列としてノートの $Text に渡し、その $Text を Explode（展開）します。
ただし、値のリストが [aardvark;amber;Ant] の場合、実際には [Ant;aardvark;amber] という順序でリスト化されます。これは Set 型の自動ソートが大文字小文字を区別する辞書順を使用するためですが、大文字小文字を区別しないソートの方が適切な場合が多いでしょう。その場合は次のように記述します。
	$Text=values(""MyList"").isort.format(""\n""); 
同様に、デフォルトのソートでは 1/2/10 が 1/10/2 という順序になるため、数値ソート（nsort）の方が合理的です。
	$Text=values(""MyList"").isort.format(""\n""); 
重複排除について。values() が collect() と異なるのは、values() が Set 型のデータを返し、collect() が List 型のデータを返す点です。リスト $MyList について、以下の出力は機能的に等価です。
	$MyList = collect(all,$SomeList).unique; 
	$MyList = values(""SomeList""); 
	$MyList = values($MyString); （$MyString の値が ""SomeList"" である場合）
values(scope, attributeNameStr)
オプションの第1引数 scope が指定された場合、返される値はそのスコープ（定義された範囲）内のノートからのみ抽出されます。第1引数が指定されない場合、上記の短縮形のようにデフォルトのスコープは 'all' とみなされ、ドキュメント全体の範囲となります。children（子）や siblings（兄弟）といったグループの参照点は「このノート」になります。したがって：
	$MyList = values(children,""Subtitle""); 
は、このノート（アクションが評価されているコンテキストのノート）の子要素における、重複しないすべてのサブタイトル（つまり $Subtitle の値）を返します。"
var,Statement,Item,Data manipulation,declaration,false,5.10.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"The `var` statement declares a local variable for storing intermediate results within Tinderbox actions, providing a cleaner alternative to using temporary user attributes.

### Syntax and Initialization
*   **Declaration:** `var vName;` (defaults to an empty string if not initialized).
*   **Initialization:** Variables can be initialized using parentheses or assignment: `var vName(value);` or `var vName = value;`.
*   **Naming Conventions:** Avoid the `var` prefix (e.g., `varX`) as it confuses the parser. The established convention is a `v` prefix (e.g., `vNum`). Local variables do **not** use the `$` prefix used by attributes.

### Data Types
Variables can be explicitly typed using the syntax `var:datatype vName;`.
*   **Supported Types:** boolean, color, date, dictionary, interval, number, list, set, and string (labels must be all-lowercase).
*   **Behavior:** Explicit typing helps Tinderbox determine how to handle operators. For example, using `+` with a `number` variable performs addition, while a `string` variable performs concatenation and a `list` variable appends an item.
*   **Note:** Declaring a type without a value (e.g., `var:number vNum;`) leaves the value undefined (empty string), not zero.

### Scope and Context
*   **Lifecycle:** A variable exists for the duration of the action or the specific code block `{ ... }` (such as an `.each()` loop or function) in which it was declared.
*   **Nesting:** Variables declared outside a loop or function can be read and modified within that scope. However, variables declared inside a block are not accessible outside of it.
*   **Sets and Strings:** `Set` variables automatically remove duplicates during initialization. `String` variables cannot store styled (rich) text.

### Usage and Warnings
*   **Export Code:** Variables declared within `action()` code can be inserted into templates using the `value(vName)` operator, provided they are declared before use.
*   **Resetting:** Within its scope, a variable can be reset to an empty value using `vName=;`.
*   **Name Collisions:** Avoid naming variables after existing attributes, notes, or string literals. If a local variable is out of scope and its name matches an attribute (e.g., `$vNum`), Tinderbox may interpret a reference to `vNum` as the attribute, potentially leading to unintended data modification.","`var` ステートメントは、Tinderbox のアクション内で中間結果を保持するためのローカル変数を宣言します。これは、一時的なユーザー属性を使用する代わりの、よりクリーンな手法を提供します。

### 構文と初期化
*   **宣言:** `var vName;`（初期化されない場合、デフォルトで空の文字列になります）。
*   **初期化:** 変数は、括弧または代入を使用して初期化できます：`var vName(value);` または `var vName = value;`。
*   **命名規則:** `var` プレフィックス（例：`varX`）はパーサーを混乱させるため避けてください。確立された慣習は `v` プレフィックス（例：`vNum`）を使用することです。ローカル変数には、属性で使用される `$` プレフィックスは**使用しません**。

### データ型
変数は、`var:datatype vName;` という構文を使用して明示的に型指定できます。
*   **サポートされている型:** boolean, color, date, dictionary, interval, number, list, set, string（ラベルはすべて小文字である必要があります）。
*   **動作:** 明示的な型指定は、Tinderbox が演算子をどのように扱うかを決定するのに役立ちます。例えば、`number` 型の変数で `+` を使用すると加算が行われますが、`string` 型の変数では結合が行われ、`list` 型の変数では項目の追加が行われます。
*   **注意:** 値を指定せずに型を宣言した場合（例：`var:number vNum;`）、値は 0 ではなく未定義（空の文字列）のままになります。

### スコープとコンテキスト
*   **ライフサイクル:** 変数は、アクションの実行期間中、またはそれが宣言された特定のコードブロック `{ ... }`（`.each()` ループや関数など）の間だけ存在します。
*   **ネスト:** ループや関数の外側で宣言された変数は、そのスコープ内で読み取ったり変更したりできます。ただし、ブロック内で宣言された変数は、その外側からはアクセスできません。
*   **セットと文字列:** `Set` 型の変数は、初期化時に重複を自動的に削除します。`String` 型の変数は、スタイル付き（リッチ）テキストを保存できません。

### 使用法と警告
*   **書き出しコード:** `action()` コード内で宣言された変数は、使用前に宣言されていれば、`value(vName)` オペレータを使用してテンプレートに挿入できます。
*   **リセット:** そのスコープ内であれば、`vName=;` を使用して変数を空の値にリセットできます。
*   **名前の衝突:** 既存の属性、ノート、または文字列リテラルと同じ名前を変数に付けることは避けてください。ローカル変数がスコープ外にあり、その名前が属性（例：`$vNum`）と一致する場合、Tinderbox は `vNum` への参照を属性として解釈し、意図しないデータ変更を招く可能性があります。"
version(),Property,Document,Data manipulation,String,false,8.8.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"version()
version
The action operator version() returns information about the version of Tinderbox. With no argument, it returns a complete version string such as ""8.7.2b472"".
version(""part"") An optional single argument can be supplied. Possible values are: major, minor, fix, and build, each returning a specific part of the overall version.
For example, in Tinderbox 8.7.2b472:
	version() returns: 8.7.2b472 
	version(major) returns: 8 
	version(minor) returns: 7 
	version(fix) returns: 2 
	version(build) returns: b472 
These arguments may be used with or without enclosing quotes. Thus, usage:
	$MyString = version(major); 
or 
	$MyString = version(""fix"");","version()
version
アクション演算子 version() は、Tinderboxのバージョン情報を返します。引数がない場合、""8.7.2b472"" のような完全なバージョン文字列を返します。
version(""part"") オプションで引数を1つ指定できます。指定可能な値は major、minor、fix、build で、それぞれバージョンの特定の部分を返します。
例えば、Tinderbox 8.7.2b472 の場合：
	version() は 8.7.2b472 を返します
	version(major) は 8 を返します
	version(minor) は 7 を返します
	version(fix) は 2 を返します
	version(build) は b472 を返します
これらの引数は、引用符で囲んでも囲まなくても使用できます。したがって、以下のように使用します：
	$MyString = version(major);
または
	$MyString = version(""fix"");"
"weeks(startDate, endDate)",Function,Item,Date-time,Number,false,7.5.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"weeks(startDate, endDate)
This returns the Number of (7-day weeks) weeks between two dates, startDate and endDate. If the dates are within seven days of each other, the result is zero. 
If $DateA is 3 January 2016 and $DateB is 20 January 2016, then:
	$MyNumber = weeks($DateA,$DateB); 
sets $MyNumber to 2.
If endDate is before startDate the result is negative.","weeks(startDate, endDate)
この関数は、2つの日付（startDateとendDate）の間の週数（7日間単位）を数値で返します。2つの日付の間隔が7日未満の場合、結果は0となります。
もし $DateA が 2016年1月3日、$DateB が 2016年1月20日であれば：
	$MyNumber = weeks($DateA,$DateB); 
は、$MyNumber に 2 を設定します。
endDate が startDate より前の日付である場合、結果は負の数値になります。"
while(condition){},Operator,Conditional Group,Data manipulation,boolean test,false,9.5.0,Baseline,,,,1,false,false,false,false,false,false,true,false,false,,false,"The operator while(condition){…} performs an action repeatedly until the condition expression evaluates as false. Put another way, the code in the curly brackets will continue to be run again and again, until condition expression evaluates as false. This operator addresses the scenario where:
-  it is known a task needs to be done multiple times but,
_ the exact number of times to repeat the task is not known
Using while() it is possible to define the a test (condition) to ascertain when the task is done and the repeating/looping action can stop.
For those less used to coding, consider a generalised analogy—the task of filling a bucket with water. Before adding anything to the bucket we might sensibly ask if the bucket is full and only if it is not, do we add another scoop of water. But if the bucket is full, we stop adding water. It can be summarised thus:
* Is the bucket full?
** No?  We add another scoop of water and start over with the original check (i.e. continue the loop).
** Yes? We're done—exit and finish.
Examples
Consider the case where it is desired to process a note's $Text, of unknown size, one sentence at a time. Thus (code commenting is for explanation only, and is not needed in actual code):
	// make a variable holding $Text, so $Text itself is not affected
	var:str vText = $Text;
	// start the loop using vText
	while(vText!=""""){
		// get the first sentence in vText
		var:string vStr = $Text.sentence(0);
		// pass that sentence to function fProcessText() to do whatever task with it ...
		fProcessText(vStr);
		// remove the sentence vStr from vText *before* the loop runs again
		// so that vStr is different in the next loop, i.e. each sentence is used only once
		vText = vText.substr(vStr.size).trim();
	};
This will read $Text and process it to call the user-defined function fProcessText() passing it one sentence at a time. Each loop removes the just-processed sentence, so the text considered in the next loop is one sentence shorter, until eventually vText is empty at which point the while() operator completes and the next action after it, if any, is read.
A programmer might write the same as above more tersely:
	var vt=$Text;while(vt){var:string s=vt.sentence;vt=vt.substr(s.size).trim(); process(s);} 
But, importantly, both do the same thing and the different code has no effect on Tinderbox performance. As long as the code is valid, users are free to choose their style.
Prior to this, it would be necessary to first count the number of discrete sentences and store that in a variable, then make a list of discrete sentences, then iterate this list using a loop counter and checking in each loop to see if the counter figure was below the stored count before taking any per-item action; while() wraps all that up into a simple operator.  
Preventing against infinite loops
An infinite loop occurs when condition always remains false and thus the code loop never stops running. To guard against this unintended scenario while() loops are limited to 10,000 iterations, i.e. if the loop has run 10,000 time it automatically stops regardless of the state of condition.","オペレータ `while(condition){…}` は、条件式（condition）が偽（false）と評価されるまで、アクションを繰り返し実行します。言い換えれば、条件式が偽と評価されるまで、波括弧内のコードが何度も繰り返し実行されます。このオペレータは、以下のようなシナリオに対応します：
- タスクを複数回実行する必要があることが分かっているが、
- タスクを繰り返す正確な回数が不明である場合。
`while()` を使用すると、タスクが完了したかどうかを判断するためのテスト（条件）を定義し、繰り返し/ループアクションを停止させることができます。
プログラミングにあまり慣れていない方は、一般的な例えとして「バケツに水を溜める」作業を考えてみてください。バケツに何かを入れる前に、まず「バケツはいっぱいか？」と確認し、いっぱいでない場合にのみ、もう一杯の水を加えます。しかし、もしバケツがいっぱいなら、水を加えるのを止めます。これは次のようにまとめられます：
* バケツはいっぱいか？
** いいえ：もう一杯の水を加え、最初のチェックに戻る（つまり、ループを継続する）。
** はい：完了。ループを抜けて終了する。
例
ノートの `$Text`（サイズは不明）を一文ずつ処理したい場合を考えてみましょう（コード内のコメントは説明用であり、実際のコードには不要です）：
	// $Text 自体に影響を与えないよう、$Text を保持する変数を作成する
	var:str vText = $Text;
	// vText を使用してループを開始する
	while(vText!=""""){
		// vText 内の最初の文を取得する
		var:string vStr = $Text.sentence(0);
		// その文をユーザー定義関数 fProcessText() に渡し、何らかの処理を行う...
		fProcessText(vStr);
		// ループが再び実行される*前に*、vText から文 vStr を削除する
		// これにより、次のループで vStr が変化する（つまり、各文が一度だけ使用される）
		vText = vText.substr(vStr.size).trim();
	};
このコードは `$Text` を読み込み、それを処理して一文ずつユーザー定義関数 `fProcessText()` を呼び出します。各ループで処理済みの文が削除されるため、次のループで対象となるテキストは一文短くなり、最終的に `vText` が空になった時点で `while()` オペレータは完了し、もしあればその後のアクションが読み込まれます。
プログラマーなら、上記と同じ内容をより簡潔に書くかもしれません：
	var vt=$Text;while(vt){var:string s=vt.sentence;vt=vt.substr(s.size).trim(); process(s);} 
しかし、重要なのは、どちらも同じ動作をし、書き方の違いが Tinderbox のパフォーマンスに影響を与えることはないということです。コードが有効である限り、ユーザーは自分の好みのスタイルを自由に選ぶことができます。
これまでは、まず個々の文の数を数えて変数に保存し、次に文のリストを作成し、ループカウンターを使用して各ループでカウンターの値が保存された数未満かどうかをチェックしながらアクションを実行する必要がありました。`while()` は、これらすべてを一つのシンプルなオペレータにまとめます。
無限ループの防止
無限ループは、条件が常に偽（false）のままであり、その結果コードのループが停止しなくなることで発生します。この意図しないシナリオを防ぐため、`while()` ループは 10,000 回の反復に制限されています。つまり、ループが 10,000 回実行されると、条件の状態に関わらず自動的に停止します。"
word(dataStr),Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"word(dataStr)
Returns Boolean true if the string dataStr (of for or more characters) is contained in the current note's text or title. This operator is quicker for matching whole words than using a regular expression. The function matches all notes that contain a single word matching (case-insensitively) any complete word in:
* the title OR
* the text OR
* any user String data-type attribute(s). This does not include other data types based on strings (List, URL, Set, File, Action, etc.)
The matching is case-insensitive. Note that word() is stricter in its matching than the .contains() function as it looks only for entire words and does not match regular expressions. Although word() examines several different fields, the result is that word() is much faster than .contains().
The word dataStr must be a quoted string containing:
* a single word (no hyphenated words)
* contain only upper or lower case letters, so no white space, digits, or punctuation
* 4 characters or more (values less than 4 characters or fewer are ignored by Tinderbox).
In the query creation pop-ups of agent and Find dialogs this function is listed as ""contains word"".
Example
This query finds any note where the word 'confusion' occurs (in any case variant) in either $Text or $Name :
	word(""Confusion"") 
Note how dataStr is case-insensitive.
Legacy issues
This operator replaces the legacy #word query operator.","word(dataStr)
dataStr（4文字以上の文字列）が現在のノートのテキストまたはタイトルに含まれている場合、真（true）を返します。このオペレーターは、正規表現を使用するよりも単語全体の一致を高速に照合できます。この関数は、以下のいずれかに、大文字小文字を区別せずに完全に一致する単語が含まれるすべてのノートに一致します：
* タイトル
* テキスト
* ユーザー定義のString（文字列）型属性。これには、文字列ベースの他のデータ型（List、URL、Set、File、Actionなど）は含まれません。
照合は大文字小文字を区別しません。word() は完全な単語のみを検索し、正規表現には一致しないため、.contains() 関数よりも照合条件が厳格であることに注意してください。word() は複数の異なるフィールドを調べますが、結果として .contains() よりも大幅に高速です。
引数 dataStr は、以下の条件を満たす引用符で囲まれた文字列である必要があります：
* 単一の単語であること（ハイフンを含む単語は不可）
* 英大文字または小文字のみを含み、空白、数字、句読点は含まないこと
* 4文字以上であること（4文字未満の値は Tinderbox によって無視されます）
エージェントや検索ダイアログのクエリ作成ポップアップでは、この関数は「contains word」としてリストされています。
例
このクエリは、$Text または $Name に（大文字小文字を問わず）「confusion」という単語が含まれるすべてのノートを検索します：
	word(""Confusion"") 
dataStr が大文字小文字を区別しない点に注目してください。
旧バージョンとの互換性
このオペレーターは、旧来の #word クエリ・オペレーターを置き換えるものです。"
"wordsRelatedTo(dataStr[, wordsNum])",Function,Item,Data manipulation,Set,false,8.8.0,Baseline,,,10.15,2,true,false,false,false,false,false,false,true,false,,false,"wordsRelatedTo(dataStr[, wordsNum])
NOTE: This feature needs macOS 10.15.0 or later. If used on older OSs, the function returns no data; i.e. not all users of v8.x maybe able to use this feature as it is macOS version dependent.
The operator tries to return a list (Set) of up to wordsNum (discrete) words related to its dataStr argument. Fewer words may be returned, or no words may be returned if the argument is unusual, or if the current language is not supported.
An optional second argument wordsNum, allows the returned number of related terms to be limited to a specific number of items. wordsNum is 1 or more (integer value), but Tinderbox will only return as many 'related' terms as it can find, i.e. it may return fewer than wordsNum items.
Practically, an wordsNum value of more than 10 items is unlikely to render useful results. Be aware this draws on features still under development in the underlying OS, so there are no certainties.
	$MySet = wordsRelatedTo(""hubris""); 
or to get only 5 (or fewer) values:
	$MySet = wordsRelatedTo(""aspirational"",5); 
It is not certain, but likely, that results returned are ordered by proximity of the relationship in the vector space of the dataStr (bear in mind this is a black-box OS procedure).
Though the product is essentially a Set, i.e. a list without duplicates, Sets may change the order of items during other processes whilst List attributes do not. So if concerned about retaining order exactly as originally returned by the function, it makes would pass the process to an explicit list
	$MyList = wordsRelatedTo(""expectation"",8);","wordsRelatedTo(dataStr[, wordsNum])
注：この機能には macOS 10.15.0 以降が必要です。古い OS で使用した場合、この関数はデータを返しません。つまり、OS のバージョンに依存するため、v8.x のすべてのユーザーがこの機能を利用できるとは限りません。
このオペレーターは、引数 dataStr に関連する最大 wordsNum 個の（個別の）単語のリスト（Set）を返そうと試みます。引数が特異な場合や、現在の言語がサポートされていない場合は、返される単語が少なくなったり、全く返されなかったりすることがあります。
オプションの第2引数 wordsNum を指定することで、返される関連語の最大数を制限できます。wordsNum は1以上の整数ですが、Tinderbox は見つかった「関連」語のみを返すため、結果が wordsNum 未満になる場合もあります。
実用上、wordsNum に10を超える値を指定しても有用な結果が得られる可能性は低いです。この機能は OS の開発途上の機能を利用しているため、動作が保証されているわけではないことに注意してください。
	$MySet = wordsRelatedTo(""hubris""); 
または、5つ（以下）の値のみを取得する場合：
	$MySet = wordsRelatedTo(""aspirational"", 5); 
確実ではありませんが、返される結果は dataStr のベクトル空間における近接順に並んでいる可能性が高いです（これは OS のブラックボックスな処理であることに留意してください）。
この関数の出力は本質的に Set（重複のないリスト）ですが、Set 型は他の処理過程で項目の順序が変わる可能性があります。一方、List 型属性は順序を保持します。そのため、関数が返した順序を厳密に維持したい場合は、結果を明示的にリストに代入することをお勧めします。
	$MyList = wordsRelatedTo(""expectation"", 8);"
XML.each(pathStr){action},Function,Item,Stream parsing,iterator,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"XML.each(pathStr){ action(s) }
This operator locates the xml object for each object at the pathStr (within the XML), generating a loop upon it. The .each(pathStr) invokes the action block with the xml item bound in turn to each book element. On completion, it restores the XML object to its previous state.
Consider a note ""Source note"" with this $Text:
&lt;shelf>
	&lt;book price=""9.95"">War and Peace&lt;/book>
	&lt;book price=""4.95"">No et Moi&lt;/book>
	&lt;audio price=""14.95"">Born To Run&lt;/audio>
&lt;/shelf>
Example usage of path:
$MyList(""test"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book""]+""\n"";
};
which sets $MyList of note ""test"" to a list of children of the &lt;shelf> element that are &lt;book> elements, [War and Peace;No et Moi].
$MyList(""test2"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book[2]""]+""\n"";
};
which sets $MyList of note ""test"" to the value of child element of the &lt;shelf> element that represents the second book, ""No et Moi"". Other iterated elements return a blank. See 'Notes' below.
$MyList(""test2"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book@price""]+""\n"";
};
witch sets $MyList of note ""test"" to a list of the price attribute of each book element, [9.95;4.95].
Notes:
* Acceptable path content is a subset of the XPath standard (see https://www.w3.org/TR/2017/REC-xpath-31-20170321/).
* To accord with standard XML and XPath usage, the first child of an XML node is child [1], not [0].
* XML attributes are not related to Tinderbox attributes.
Consider this source XML string stream:
&lt;shelf>
&lt;book price=""9.95"">War and Peace&lt;/book>
&lt;book price=""4.95"">No et Moi&lt;/book>
&lt;audio price=""14.95"">Born To Run&lt;/book>
&lt;/shelf>
Examples
Stream.xml.each(""/shelf/book"") {action} 
returns every 'book' object in the 'shelf' object and iterates over them, i.e. for each (path-matched) item it invokes the action block with the xml item bound in turn to each book element. In the example above this means the action is run 3 times, once for each of the 3 &lt;book> elements under &lt;shelf>.
Inside the action clause, action code can refer to the value of the iterated item as elementName[], book[]. Any attribute of that item can be addressed as elementName[@attribute] book[@price], i.e. here the 'price' attribute of the XML object in focus.
On completion, it restores the xml object to its previous state.","XML.each(pathStr){ action(s) }
この演算子は、pathStr（XML内）にある各オブジェクトに対応するxmlオブジェクトを特定し、その上でループを生成します。.each(pathStr)は、各book要素に順番にバインドされたxml項目を使用してアクションブロックを呼び出します。完了すると、XMLオブジェクトを以前の状態に戻します。
次の$Textを持つ「Source note」というノートを考えてみます。
&lt;shelf>
	&lt;book price=""9.95"">War and Peace&lt;/book>
	&lt;book price=""4.95"">No et Moi&lt;/book>
	&lt;audio price=""14.95"">Born To Run&lt;/audio>
&lt;/shelf>
パスの使用例：
$MyList(""test"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book""]+""\n"";
};
これは、ノート「test」の$MyListを、&lt;shelf>要素の子要素であり、かつ&lt;book>要素であるもののリスト [War and Peace;No et Moi] に設定します。
$MyList(""test2"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book[2]""]+""\n"";
};
これは、ノート「test」の$MyListを、&lt;shelf>要素の子要素のうち2番目の本を表す「No et Moi」の値に設定します。他の反復要素は空白を返します。以下の「注記」を参照してください。
$MyList(""test2"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book @price""]+""\n"";
};
これは、ノート「test」の$MyListを、各book要素のprice属性のリスト [9.95;4.95] に設定します。
注記：
* 使用可能なパスの内容は、XPath標準のサブセットです（https://www.w3.org/TR/2017/REC-xpath-31-20170321/ を参照）。
* 標準的なXMLおよびXPathの使用法に合わせて、XMLノードの最初の子はchild [1]であり、[0]ではありません。
* XML属性はTinderboxの属性とは関係ありません。
次のソースXML文字列ストリームを考えてみます。
&lt;shelf>
&lt;book price=""9.95"">War and Peace&lt;/book>
&lt;book price=""4.95"">No et Moi&lt;/book>
&lt;audio price=""14.95"">Born To Run&lt;/book>
&lt;/shelf>
例
Stream.xml.each(""/shelf/book"") {action} 
これは、'shelf'オブジェクト内のすべての'book'オブジェクトを返し、それらを反復処理します。つまり、各（パスが一致した）項目に対して、各book要素に順番にバインドされたxml項目を使用してアクションブロックを呼び出します。上記の例では、これはアクションが3回、つまり&lt;shelf>の下にある3つの&lt;book>要素のそれぞれに対して1回ずつ実行されることを意味します。
アクション句の内部では、アクションコードは反復処理される項目の値を elementName[], book[] として参照できます。その項目の属性は elementName[ @attributeName] book[ @price] としてアドレス指定できます。つまり、ここではフォーカスされているXMLオブジェクトの'price'属性です。
完了すると、xmlオブジェクトを以前の状態に戻します。"
XML.xml(pathStr),Function,Item,Stream parsing,source context dependent,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"XML.xml(pathStr)
If there is no current XML object, attempts to parse the string as XML and fails if unsuccessful. If there is a current XML object, it will be reused.
Returns a specific piece of data from the XML object, determined by the pathStr should be an expression or a quoted string.
Consider a note ""Source note"" with this $Text:
&lt;shelf>
	&lt;book price=""9.95"">War and Peace&lt;/book>
	&lt;book price=""4.95"">No et Moi&lt;/book>
	&lt;audio price=""14.95"">Born To Run&lt;/audio>
&lt;/shelf>
Example usage of path:
	$Text(""test"") = $Text(""Source note"").xml(""/shelf/book""); 
sets $Text of note ""test"" to a list of children of the &lt;shelf> element that are &lt;book> elements. ""War and Peace;No et Moi""
	$Text(""test"") = $Text(""Source note"").$Text.xml(""/shelf/book[2]"") 
sets $Text of note ""test"" to the value of child element of the &lt;shelf> element that represents the second book, ""No et Moi"". See 'Notes' below.
	$Text(""test"") = $Text(""Source note"").$Text.xml(""/shelf/book@price"") 
sets $Text of note ""test"" to the price attribute of each book, ""9.954.95""
Notes:
* Acceptable path content is a subset of the XPath standard (see https://www.w3.org/TR/2017/REC-xpath-31-20170321/). This explains the 'book@price' usage above to get the 'price' attribute value from a 'book' element. Explanation of XPath is out of scope for aTbRef.
* To accord with standard XML and XPath usage, the first child of an XML node is child [1], not [0].
* XML attributes are not related to Tinderbox attributes.","XML.xml(pathStr)
現在のXMLオブジェクトが存在しない場合、文字列をXMLとしてパース（解析）しようと試みます。解析に失敗した場合はエラーとなります。現在のXMLオブジェクトが存在する場合は、それが再利用されます。
XMLオブジェクトから、pathStr（式または引用符で囲まれた文字列）によって指定された特定のデータを返します。

$Textに以下の内容を持つノート ""Source note"" を例に考えます：
<shelf>
	<book price=""9.95"">War and Peace</book>
	<book price=""4.95"">No et Moi</book>
	<audio price=""14.95"">Born To Run</audio>
</shelf>

パスの使用例：
	$Text(""test"") = $Text(""Source note"").xml(""/shelf/book""); 
ノート ""test"" の $Text を、<shelf> 要素の子要素である <book> 要素のリスト ""War and Peace;No et Moi"" に設定します。
	$Text(""test"") = $Text(""Source note"").$Text.xml(""/shelf/book[2]"") 
ノート ""test"" の $Text を、2番目の本を表す <shelf> 要素の子要素の値 ""No et Moi"" に設定します。下記の「備考」を参照してください。
	$Text(""test"") = $Text(""Source note"").$Text.xml(""/shelf/book @price"") 
ノート ""test"" の $Text を、各本の price 属性を繋げた値 ""9.954.95"" に設定します。

備考：
* 許容されるパスの内容は、XPath標準（https://www.w3.org/TR/2017/REC-xpath-31-20170321/ を参照）のサブセットです。これは、<book> 要素から 'price' 属性値を取得するための上記の 'book @price' という記法の根拠となっています。XPath 自体の説明は aTbRef の対象外です。
* 標準的な XML および XPath の使用法に従い、XML ノードの最初の子要素は [0] ではなく [1] となります。
* XML の属性 (attributes) は Tinderbox の属性 (attributes) とは関係ありません。"
"year(aDate, yearsNum)",Function,Item,Date-time,Date,false,5.0.0,Baseline,,,,2,true,false,true,false,false,false,false,false,false,,false,"year(aDate,yearsNum) 
creates a new Date based on the theDate date/time expression, but in which the year is set by yearsNum:. For example, if $MyDate is July 4,2009, then 
	$MyDate=hour($MyDate,2011); 
will change $MyDate to July 4, 2011.
If the output is passed back to theDate, its year element is changed
	$MyDate = year($MyDate,2011); $MyDate is changed
but if passed to a different Date object, theDate is not altered:
	$MyDateA = year($MyDate,2011); $MyDate is unaltered

Note that the single-argument version that returns the year segment is documented separately: see year(aDate).","year(aDate,yearsNum)
は、日時（date/time）式 theDate に基づき、年を yearsNum で設定した新しい日付（Date）を作成します。たとえば、$MyDate が2009年7月4日の場合、
	$MyDate=hour($MyDate,2011); 
は $MyDate を2011年7月4日に変更します。
出力結果を theDate に戻すと、その年の要素が変更されます。
	$MyDate = year($MyDate,2011); $MyDate は変更されます
しかし、別の日付オブジェクトに渡された場合、theDate は変更されません。
	$MyDateA = year($MyDate,2011); $MyDate は変更されません

なお、年の部分を返す引数1つのバージョンは別にドキュメント化されています。year(aDate) を参照してください。"
year(aDate),Function,Item,Date-time,Number,false,5.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"year(aDate)
returns the year from the theDate date/time expression:
	$MyNumber = year($MyDate); 
Alternatively, use Date.year.
Note that the double-argument version that alters Dates is documented separately: see year(aDate, yearsNum).","year(aDate)
日付/時刻式 aDate から年を返します。
	$MyNumber = year($MyDate); 
あるいは、Date.year を使用してください。
なお、日付を変更する 2 引数バージョンについては、別途 year(aDate, yearsNum) として記載されています。"
"years(startDate, endDate)",Function,Item,Date-time,Number,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"years(startDate, endDate) 
returns the Number of whole years that elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA is 3 January 2016 and $DateB is 9 January 2018, then:
	$MyNumber = years($DateA,$DateB); 
sets $MyNumber to 2.","years(startDate, endDate) 
startDate から endDate までの経過年数（整数）を返します。endDate が startDate より前の場合は、結果は負の値になります。
$DateA が 2016年1月3日、$DateB が 2018年1月9日の場合：
	$MyNumber = years($DateA,$DateB); 
は $MyNumber を 2 に設定します。"
