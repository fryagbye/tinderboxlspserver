Name,OpClass,OpScope,OpType,OpReturnType,OperatorFlag,OriginalVersion,CodeFirstAdded,CodeAltered,ChangeRefSet,OSVersion,NumberOfArgs,HasNeededArguments,IsDotOp,HasDotOpVersion,HasLoopVariable,HasRegExArgument,HasScopeArgument,HasConditionalArgument,HasOptionalArgument,HasStyledOutput,HonoursLinkType,HasNoCodeSample,Text,TextJa
- (i.e. subtraction),Operator,Item,Mathematical,Number,false,1.0.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"- (i.e. subtraction)
The subtraction operator, - (minus sign character), returns the remainder of the argument before it when the argument after it is subtracted.
	$MyNumber = 3-4; 
When mixing data types (a '-' might be intended as a hyphen) or if working with lists—i.e. List & Set types—see notes under concatenation.","- (つまり、減算)
減算演算子 - (マイナス記号) は、後の引数が減算されるときに、その前の引数の残りを返します。
$MyNumber = 3-4;
データ型を混合する場合 (「-」はハイフンとして使用される場合があります)、またはリストを操作する場合、つまりリストとセットのタイプ - 連結の注を参照してください。"
-= (i.e. decrement),Operator,Item,Mathematical,Number,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"-= (i.e. decrement)
This assignment operator is a convenient shorthand for decrementing an attribute. For example, the two following statements are equivalent:
$MyNumber -= 3; 
$MyNumber = $MyNumber - 3; 
This operator may also be used with Lists and Sets.","-= (つまり、デクリメント)
この代入演算子は、属性をデクリメントするための便利な省略表現です。たとえば、次の 2 つのステートメントは同等です。
$MyNumber -= 3;
$MyNumber = $MyNumber - 3;
この演算子はリストとセットでも使用できます。"
!= (i.e. value inequality),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"!= (i.e. inequality test)
The operator to test inequality (i.e. 'is not the same as') is '!=', an exclamation mark followed by an equals sign.
This operator is used either in agent queries or in the conditional part of an if(condition){action} code. It is the functional opposite of the '==' equality test.
This test cannot be meaningfully applied to Set or List type attribute data, as the entire attribute value is matched, rather than individual values as might otherwise be assumed. For these data types use the .contains() or .icontains() operators instead, noting the scope for ambiguous matching due to stemming of words (""car"" with match ""car"", ""cars"" and ""carrot"").
Because equality comparisons of Date-type data match at day scope, rather than full date/time values (for legacy reasons), use interval() to compare Date-type inequality.
Equality testing can be negated, i.e. nested for a non-match, or combined with greater/less than for a range of tests as further explored in Basic Comparison Codes.
For a case-insensitive lexical equality test, use a lowercase on-the-fly transform:
	""Absquatulate"".lowercase != ""Absquatulate"" 
If we set $MyString to ""Absquatulate"", then:
	$MyString.lowercase != ""Absquatulate"" 
If $MyOtherString(Some note) has the value ""Absquatulate"", then:
	$MyString.lowercase != $MyOtherString(Some note) 
Note the stored left-side value is not altered, but its transformed version is used in the test giving a case-insensitive comparison. This method only works for upper/lower case comparisons; accented characters are lexically different characters regardless of case.","!= (つまり、不等式テスト)
不等号 (つまり、「は同じではない」) をテストする演算子は、感嘆符とそれに続く等号である「!=」です。
この演算子は、エージェントのクエリまたは if(condition){action} コードの条件部分で使用されます。これは、「==」等価性テストの逆の機能です。
このテストは、想定される個々の値ではなく、属性値全体が照合されるため、Set または List タイプの属性データには有意義に適用できません。これらのデータ型の場合は、代わりに .contains() または .icontains() 演算子を使用します。ただし、単語のステミングによるあいまいな一致の範囲に注意してください (「car」と「car」、「cars」、「キャロット」の一致)。
Date 型データの等価比較は、完全な日付/時刻値ではなく (レガシーな理由により) 日のスコープで一致するため、Date 型の不等価性を比較するには、interval() を使用します。
等価性テストは、否定することもできます。つまり、不一致に対してネストしたり、基本的な比較コードで詳しく説明するように、さまざまなテストに対して「より大きい/より小さい」と組み合わせたりすることができます。
大文字と小文字を区別しない字句等価性テストの場合は、小文字のオンザフライ変換を使用します。
""Absquatulate"".小文字 != ""Absquatulate""
$MyString を「Absquatulate」に設定すると、次のようになります。
$MyString. lowercase != ""アブスクアットレート""
$MyOtherString(Some note) の値が ""Absquatulate"" の場合、次のようになります。
$MyString. lowercase != $MyOtherString(メモ)
保存された左側の値は変更されませんが、その変換されたバージョンがテストで使用され、大文字と小文字を区別しない比較が行われることに注意してください。この方法は、大文字と小文字の比較にのみ機能します。アクセント付き文字は、大文字と小文字に関係なく、語彙的に異なる文字です。"
... (i.e. range),Operator,Item,Mathematical,List,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"... (i.e. range)
The range operator constructs a list of numbers from a specified starting point to a specified end point. Note: the range operator is written as 3 dots and not an ellipsis character. White space immediately before or after the operator is ignored as with other mathematical operators. For example:
	1…3 → ""1;2;3""
	3 … 1 → ""3;2;1""
Note do not use enclosing quotes or square brackets with the range operator as the operator will not be correctly evaluated, resulting in the wrong outcome.
	[1…3] → ""1 ... 3"" WRONG!
	""1…3"" → ""1 ... 3"" WRONG!
The range operator binds more tightly than arithmetic operators. Thus
	1...3 * 2 → ""2;4;6""
and is the is the same as
	(1..3) * 2 → ""2;4;6"" 
i.e. the parentheses in the second example are not needed.
The range operator can be useful for performing a task a specific number of times using the List.each() operator:
	 1...10.each(x){var vPath=""/container/item ""+x; create(vPath);} 
and in that example the value of the loop variable x is the value for the source list generated by the range operator, i.e. it is the same as would occur in this literal example:
	""1;2;3;4;5;6;7;8;9;10"".each(x){var vPath=""/container/item ""+x; create(vPath);} 
In both cases, on the second iteration of the .each() loop, the loop variable x would have the value 2.
Using non-literal range specifiers
It may be useful to define one or both range limits. For example, if $MyNumber is 3:
	$MyList = [1 ... $MyNumber]; gives ""1;2;3""
or if variable vNum is 4:
	$MyList = 1 ..vNum; gives ""1;2;3;5""
But for more complex expressions using chained operators, parentheses my be needed to hint intent to Tinderbox. Thus, if $MySet has 4 items:
	$MyList = 1 ... $MySet.size; gives ""1"" WRONG
so add parentheses around the expression:
	$MyList = 1 ... ($MySet.size); gives ""1;2;3;4"" CORRECT
If chaining operators to range specified using expressions, consider using parentheses around the whole range definition:
	(1 ... ($MySet.size)).each(x){$Text+= x+""\n"";}; 
The last example actually works without the parentheses but illustrates the concept.
Using range to supply a loop counter
When working with List.each(), it can be useful to know which source list item is being currently in scope. It is possible to use a variable (see here), but the range operator offers another method. In this method a range-generated list is iterated and in-loop the list being processed is called via List.at(). It in important to note that as .at() numbers from zero, either the range must start from zero, or the range item used with at must be adjusted by -1.
In the following example, $MyList holds the data of interest, and a zero-based range with be generated:
	(0 ... ($MyList.count)).each(N){
		$MyList.at(N) ..tc.
	}
Thus for loop #3, the value of N will be 2 (recall the range code is making a zero based list of numbers). Thus in-loop, $MyList.at(N) will be the same as $MyList.at(2), i.e. addressing the the third item in $MyList.","... (範囲)
range 演算子は、指定された開始点から指定された終了点までの数値のリストを構築します。注: 範囲演算子は、省略記号文字ではなく 3 つのドットとして記述されます。他の算術演算子と同様に、演算子の直前または直後の空白は無視されます。たとえば:
1…3 → 「1;2;3」
3 … 1 → 「3;2;1」
演算子が正しく評価されず、間違った結果が生じるため、範囲演算子で囲む引用符や角括弧を使用しないでください。
[1…3] →「1…3」は間違っています!
「1…3」→「1…3」は間違いです！
範囲演算子は、算術演算子よりも厳密にバインドされます。したがって、
1...3 * 2 → ""2;4;6""
と同じです
(1..3) * 2 → ""2;4;6""
つまり、2 番目の例のかっこは必要ありません。
range 演算子は、List.each() 演算子を使用して特定の回数タスクを実行する場合に便利です。
1...10.each(x){var vPath=""/container/item ""+x;作成(vPath);}
この例では、ループ変数 x の値は、範囲演算子によって生成されたソース リストの値です。つまり、このリテラルの例で発生するものと同じです。
""1;2;3;4;5;6;7;8;9;10"".each(x){var vPath=""/container/item ""+x;作成(vPath);}
どちらの場合も、.each() ループの 2 回目の反復では、ループ変数 x の値は 2 になります。
非リテラル範囲指定子の使用
一方または両方の範囲制限を定義すると便利な場合があります。たとえば、$MyNumber が 3 の場合:
$MyList = [1 ... $MyNumber];「1;2;3」を返します
または、変数 vNum が 4 の場合:
$MyList = 1 ..vNum;「1;2;3;5」を返します
ただし、連鎖演算子を使用するより複雑な式の場合は、Tinderbox に意図を示すためにかっこが必要になる場合があります。したがって、$MySet に 4 つの項目がある場合:
$MyList = 1 ... $MySet.size;「1」は間違っています
したがって、式の周囲にかっこを追加します。
$MyList = 1 ... ($MySet.size);「1;2;3;4」が正解です
式を使用して指定された範囲に演算子を連鎖させる場合は、範囲定義全体を括弧で囲むことを検討してください。
(1 ... ($MySet.size)).each(x){$Text+= x+""\n"";};
最後の例は実際には括弧なしで動作しますが、概念を示しています。
範囲を使用してループカウンターを供給する
List.each() を使用する場合、どのソース リスト項目が現在スコープ内にあるかを知ると便利です。変数を使用することもできますが (こちらを参照)、範囲演算子には別の方法があります。このメソッドでは、範囲で生成されたリストが反復され、ループ内で処理中のリストが List.at() を介して呼び出されます。.at() はゼロから番号を付けるため、範囲はゼロから開始するか、at で使用される範囲項目を -1 で調整する必要があることに注意することが重要です。
次の例では、$MyList に対象のデータが保持され、ゼロから始まる範囲が生成されます。
(0 ... ($MyList.count)).each(N){
$MyList.at(N) ..tc。
}
したがって、ループ #3 では、N の値は 2 になります (範囲コードがゼロベースの数値リストを作成していることを思い出してください)。したがって、ループ内では、$MyList.at(N) は $MyList.at(2) と同じになります。つまり、$MyList の 3 番目の項目をアドレス指定します。"
(!$AttributeName) (i.e. a short form test for no value),Operator,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"(!$AttributeName)
In queries and conditional action code expressions, preceding a '$'-prefixed attribute name with an exclamation mark functions as a shortened form of the Boolean test for a false value. Due to limitations in the underlying parser, an inequality test expression must be enclosed in parentheses.Thus the following are functional equivalents:
	$MyBoolean==false 
	(!$MyBoolean) 
Do not use this form or you may get unexpected results:
	!$MyBoolean Do not use this format, without parentheses!
In both cases the result is false if the value of $MyBoolean is false. 
Usefully Tinderbox also useful supports such short-form !$AttributeName tests for all the other attribute data types, returning true if the attribute has a default value. Per data type, this equates to long form tests like:
	$MyBoolean==false 
	$MyColor=="""" 
	$MyDate==""never"" 
	$MyDictionary=="""" 
	$MyFile=="""" 
	$MyInterval==""00:00"" 
	$MyList==[] (or (deprecated) $MyList=="""") 
	$MyNumber==0 
	$MySet==[] (or (deprecated) $MyList=="""") 
	$MyString=="""" 
	$MyURL=="""" 
This also holds for system-only data types:
	$MyAction=="""" 
	$MyFont=="""" 
In all these cases a short-form test returns true if the attribute value is the default for that data type.
This test is the logical opposite of the $AttributeName test.","(!$属性名)
クエリおよび条件付きアクションのコード式では、「$」で始まる属性名の前に感嘆符を付けると、偽値のブール テストの短縮形として機能します。基礎となるパーサーの制限のため、不等式テスト式は括弧で囲む必要があります。したがって、以下は機能的に同等です。
$MyBoolean==false
(!$MyBoolean)
このフォームは使用しないでください。使用しないと、予期しない結果が生じる可能性があります。
!$MyBoolean この形式は括弧なしで使用しないでください。
どちらの場合も、$MyBoolean の値が false の場合、結果は false になります。
便利なことに、Tinderbox は、他のすべての属性データ型に対してこのような短い形式の !$AttributeName テストをサポートしており、属性にデフォルト値がある場合に true を返します。データ型ごとに、これは次のような長い形式のテストに相当します。
$MyBoolean==false
$MyColor==""""
$MyDate==""決して""
$MyDictionary==""""
$MyFile==""""
$MyInterval==""00:00""
$MyList==[] (または (非推奨) $MyList=="""")
$MyNumber==0
$MySet==[] (または (非推奨) $MyList=="""")
$MyString==""""
$MyURL==""""
これは、システムのみのデータ型にも当てはまります。
$MyAction==""""
$MyFont==""""
これらすべての場合において、属性値がそのデータ型のデフォルトである場合、短い形式のテストは true を返します。
このテストは、$AttributeName テストの論理的に逆です。"
* (i.e. multiplication),Operator,Item,Mathematical,Number,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"* (i.e. multiplication)
The multiplication operator, * (asterisk character), returns the multiplication of the arguments before and after it.
	$MyNumber = 3*4; 
Both arguments are normally Number-type data.
Multiplying Strings
Sometimes there is a need to expand or repeat a String. For this, the multiplication operator * may be used. Due to Tinderbox's internal type coercion effects, the number argument must be used as the first argument; placing it after the * will cause a silent fail with no resulting output. Thus, the expression:
	$MyString = 3*""xyz ""; 
evaluates to a string ""xyz xyz xyz"". But this:
	$MyString = ""xyz ""*3; WRONG!
will return nothing.
Multiplying Lists and Sets
Lists and Sets of numbers may be multiplied by a number. Two lists of numbers may be multiplied if they have the same length, in which case their elements are multiplied.
	[1;2;3;4] * [1;2;3;4]; ➛ [1;4;9;12] 
or, using the range operator:
	1...4 * 1...4 ➛ 1;4;9;12","* (つまり、乗算)
乗算演算子 * (アスタリスク文字) は、その前後の引数の乗算を返します。
$MyNumber = 3*4;
通常、両方の引数は数値型のデータです。
文字列の乗算
場合によっては、文字列を展開したり繰り返したりする必要があります。このために、乗算演算子 * を使用できます。Tinderbox の内部型強制効果により、number 引数を最初の引数として使用する必要があります。これを * の後に配置すると、サイレント エラーが発生し、結果は出力されません。したがって、式は次のようになります。
$MyString = 3*""xyz "";
文字列「xyz xyz xyz」として評価されます。しかし、これは：
$MyString = ""xyz ""*3;間違っている！
何も返しません。
リストとセットの乗算
数値のリストとセットには数値を乗算できます。2 つの数値リストは、長さが同じであれば乗算できます。この場合、それらの要素は乗算されます。
[1;2;3;4] * [1;2;3;4];➛ [1;4;9;12]
または、範囲演算子を使用します。
1...4 * 1...4 ➛ 1;4;9;12"
/ (i.e. division),Operator,Item,Mathematical,Number,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"/ (i.e. division)
The division operator, / (forward slash character), returns the argument before it divided by the argument after it.
	$MyNumber = 3/4; 
By default, up to 5 decimal places are returned, so:
	$MyNumber = 10/3; 
results in $MyNumber having a value of 3.33333. 
Be aware the forward slash character has many other symbolic meanings (POSIX folder delimiter, linguistic use e.g. 'and/or', date component delimiters, etc.). Be careful to ensure to quote or escape the / character where you do not want Tinderbox to assume a division.","/ (つまり、割り算)
除算演算子 / (スラッシュ文字) は、前の引数を後の引数で割った値を返します。
$MyNumber = 3/4;
デフォルトでは、小数点以下 5 桁までが返されるため、次のようになります。
$MyNumber = 10/3;
結果として、$MyNumber の値は 3.33333 になります。
スラッシュ文字には他の多くの記号的な意味があることに注意してください (POSIX フォルダーの区切り文字、「and/or」などの言語使用、日付コンポーネントの区切り文字など)。Tinderbox に除算を想定させたくない場所では、/ 文字を引用符で囲むかエスケープするように注意してください。"
& (i.e. query logical AND join),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"& (i.e. query logical AND join)
The ampersand, &, is used in queries and conditional statements as a logical AND join. Thus:
	if ($HasStock == true & $Price > 20) {$Badge=""ok"";} 
The note's $Badge is only set if both the first and the second argument are true.
See also the OR join and conditional statements using multiple arguments.","& (つまり、クエリ論理 AND 結合)
アンパサンド & は、クエリおよび条件ステートメントで論理 AND 結合として使用されます。したがって:
if ($HasStock == true & $Price > 20) {$Badge=""ok"";}
メモの $Badge は、最初の引数と 2 番目の引数の両方が true の場合にのみ設定されます。
複数の引数を使用した OR 結合および条件ステートメントも参照してください。"
&= (i.e. logical AND assignment),Operator,Item,Assignment,assignment,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"&= (i.e. logical AND assignment)
To make it easier to write rules succinctly, you can use the assignment:
	$TheAttribute &= the_expression; 
…which sets $TheAttribute to the value of the_expression only if it is currently evaluated as true AND the_expression is also evaluates as true. Thus, if $TheAttribute is false, the expression is still evaluated. An attribute that has no value set (or inherited) is evaluated as false.
For most attributes, especially new user attributes, the default value will evaluate as false. But, $TheAttribute's data type does not have to be Boolean.
For new String-type attributes (and string-based Action/Color/File/Font/Interval/List/Set/URL types) the default is an empty string """". For Number-type, is it 0 (zero). For Date-type, it is the string ""never"". For Boolean-type, is it 'false' (with no quotes, and shown as un-ticked if displayed via a tick-box). The """", 0 and ""never"" values—for the appropriate data types—evaluate as false. But, be aware that not all system attributes follow this assumption. For instance, the $Color default is preset to use a named Tinderbox colour, so its default value (even if inherited) would evaluate as true .
Prototypes have no direct effect as the outcome, as it initially depends on the evaluation of the left-side attribute value regardless of whether document default, prototype inherited or locally set.
For example, for the Boolean-type attribute $Urgent:
	$Urgent &= any(children,$Urgent); 
Thus a project is considered urgent if it has been declared to be urgent itself and if any child is urgent.
See also the logical OR assignment.
Errors to the function logic were corrected.","&= (つまり、論理 AND 代入)
ルールを簡潔に記述しやすくするために、次の割り当てを使用できます。
$TheAttribute &= the_expression;
…これは、現在 true と評価され、かつ the_expression も true と評価される場合にのみ、$TheAttribute を the_expression の値に設定します。したがって、$TheAttribute が false の場合でも、式は評価されます。値が設定されていない (または継承されていない) 属性は false として評価されます。
ほとんどの属性、特に新しいユーザー属性では、デフォルト値は false として評価されます。ただし、$TheAttribute のデータ型はブール型である必要はありません。
新しい文字列タイプの属性 (および文字列ベースの Action/Color/File/Font/Interval/List/Set/URL タイプ) のデフォルトは空の文字列 """" です。Number型の場合は0（ゼロ）になります。日付型の場合は「never」という文字列になります。ブール型の場合、「false」ですか (引用符なし、チェックボックスで表示されている場合はチェックされていない状態で表示されます)。適切なデータ型の場合、「」、0、および「never」の値は false として評価されます。ただし、すべてのシステム属性がこの前提に従っているわけではないことに注意してください。たとえば、 $Color のデフォルトは名前付きの Tinderbox カラーを使用するようにプリセットされているため、そのデフォルト値は (継承されている場合でも) true として評価されます。
プロトタイプは、ドキュメントのデフォルト、継承されたプロトタイプ、またはローカルに設定されたかどうかに関係なく、最初は左側の属性値の評価に依存するため、結果として直接的な影響はありません。
たとえば、ブール型属性 $Urgent の場合:
$Urgent &= any(children,$Urgent);
したがって、プロジェクト自体が緊急であると宣言されており、子が緊急である場合、そのプロジェクトは緊急であるとみなされます。
論理 OR の割り当ても参照してください。
関数ロジックのエラーが修正されました。"
%matches (query back-references),Property,Query,Data manipulation,List,false,9.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"%matches
The expression %matches represents a list that contains all available back-references to regular expression matches. This is equivalent to the list of back reference values [$0;$1;$2….$N], where N is the count of available regular expression matches.
If $MyString is ""I do not like green eggs and ham."", then for this code:
	if($MyString.contains(""like (((green) (eggs)) and ham)"")){
		$MyList = %matches;
	};
$MyList now holds 5 back-references:
* $0: like green eggs and ham
* $1 green eggs and ham
* $2 green eggs
* $3 green
* $4 eggs
Query back-references are discussed in fuller detail here.","%一致
式 %matches は、正規表現一致への利用可能なすべての後方参照を含むリストを表します。これは、後方参照値 [$0;$1;$2….$N] のリストと同等です。N は、使用可能な正規表現一致の数です。
$MyString が「緑色の卵とハムが好きではありません。」の場合、このコードでは次のようになります。
if($MyString.contains(""(((緑) (卵)) とハム)"")){
$MyList = %一致;
};
$MyList には 5 つの後方参照が保持されるようになりました。
* $0: 緑の卵やハムなど
* 緑の卵とハム 1 ドル
* 緑色の卵 2 ドル
* $3 グリーン
* 卵4ドル
クエリ逆参照については、ここで詳しく説明します。"
+ (i.e. addition),Operator,Item,Mathematical,Number,false,1.0.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"+ (i.e. addition)
The addition operator, + (plus sign character), returns the sum of the arguments before and after it.
	$MyNumber = 3+4; 
The + sign is also used for string concatenation. Depending on context, Tinderbox will decide which operation is intended by the + sign. This is a very good reason to always enclose literal text strings in quotes.","+ (つまり加算)
加算演算子 + (プラス記号) は、その前後の引数の合計を返します。
$MyNumber = 3+4;
+ 記号は文字列の連結にも使用されます。コンテキストに応じて、Tinderbox は + 記号によってどの操作が意図されているかを決定します。これは、リテラル テキスト文字列を常に引用符で囲むのに十分な理由です。"
+ (i.e. string concatenation),Operator,Item,Mathematical,Number,false,1.0.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"+ (i.e. string concatenation)
The concatenation operator, + (plus sign character), joins the strings/references/expressions before and after it. Thus, the expression
	$FullName = $FirstName+"" ""+$LastName; 
evaluates a first name ""Jane"" and last name ""Doe"" to give a string value ""Jane Doe"" for the FullName attribute. If the right-side code is more complex, consider adding parentheses to help signal user intent to Tinderbox.
Mixing data types
If the right side inputs mix text and numbers—they need treating as numbers (even if stored in strings)—see more on concatenation versus addition.
The + (plus sign) character is also used for numerical addition. Depending on context, Tinderbox will decided which operation is intended by the + sign. This is a very good reason to always enclose literal text strings in quotes.
Concatenating Lists (List & Set type data)
Note that here both List-type and Set-type attributes can be considered the same as data sources, i.e. right-side inputs. 
To concatenate lists, it might appear logical to do this:
	$MyList = $SomeList+$SomeSet; WRONG!
The result is no value is passed to $MyList. When adding lists to lists there are a variety of approaches. Note that depending on the nature of the task, and the method below that is used, it may first be necessary to reset the receiving list to the default (empty) value.
Use the '+=' increment operator:
	$MyList += $SomeList+$SomeSet;
Add to the existing list (older older style—use the above method):
	$MyList = $MyList + $SomeList+$SomeSet;
Or, if if intentionally replacing current $MyList values with new ones, this may be used:
	$MyList = ($SomeList+$SomeSet);
The additional parentheses help Tinderbox to understand all the right-side lists need to be made into one list before being passed to the left-side.","+ (つまり、文字列の連結)
連結演算子 + (プラス記号文字) は、その前後の文字列/参照/式を結合します。したがって、次の式は
$FullName = $FirstName+"" ""+$LastName;
名「Jane」と姓「Doe」を評価して、FullName 属性の文字列値「Jane Doe」を与えます。右側のコードがより複雑な場合は、ユーザーの意図を Tinderbox に知らせるために括弧を追加することを検討してください。
データ型の混合
右側の入力にテキストと数値が混在している場合は、(文字列に格納されている場合でも) 数値として扱う必要があります。連結と加算の詳細を参照してください。
+ (プラス記号) 文字は数値の加算にも使用されます。コンテキストに応じて、Tinderbox は + 記号によってどの操作が意図されているかを決定します。これは、リテラル テキスト文字列を常に引用符で囲むのに十分な理由です。
リストの連結（リスト＆セット型データ）
ここでは、List-type 属性と Set-type 属性の両方がデータ ソース、つまり右側の入力と同じと見なすことができることに注意してください。
リストを連結するには、次のようにするのが論理的であるように思われるかもしれません。
$MyList = $SomeList+$SomeSet;間違っている！
結果として、$MyList には値が渡されません。リストをリストに追加する場合、さまざまな方法があります。タスクの性質、および使用される以下の方法によっては、最初に受信リストをデフォルト (空) 値にリセットする必要がある場合があることに注意してください。
「+=」増分演算子を使用します。
$MyList += $SomeList+$SomeSet;
既存のリストに追加します (以前の古いスタイル - 上記の方法を使用します)。
$MyList = $MyList + $SomeList+$SomeSet;
または、現在の $MyList 値を新しい値に意図的に置き換える場合は、これを使用できます。
$MyList = ($SomeList+$SomeSet);
追加のかっこは、左側に渡す前に右側のすべてのリストを 1 つのリストにまとめる必要があることを Tinderbox が理解するのに役立ちます。"
+= (i.e. increment),Operator,Item,Mathematical,Number,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"+= (i.e. increment)
This assignment operator is a convenient shorthand for incrementing an attribute. For example, the two following statements are equivalent:
$MyNumber += 3; 
$MyNumber = $MyNumber + 3; 
This operator may also be used with Lists and Sets, and += may be used to append strings:
$MyString += ""!""","+= (つまり増分)
この代入演算子は、属性をインクリメントするための便利な省略表現です。たとえば、次の 2 つのステートメントは同等です。
$MyNumber += 3;
$MyNumber = $MyNumber + 3;
この演算子はリストとセットでも使用でき、+= は文字列を追加するために使用できます。
$MyString += ""!"""
< (i.e. less than),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"$MyNumber  is true 
	$MyNumber  is false 
Further explored in Basic Comparison Codes.","$MyNumber は true
$MyNumber は false
基本的な比較コードでさらに詳しく説明します。"
<= (i.e. less than or equal to),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"$MyNumber  is true 
	$MyNumber  is true 
	$MyNumber  is false 
Further explored in Basic Comparison Codes; in some date comparison cases, a two term query may be needed instead.","$MyNumber は true
$MyNumber は true
$MyNumber は false
基本的な比較コードでさらに詳しく説明します。日付比較の場合によっては、代わりに 2 つの用語のクエリが必要になる場合があります。"
= (i.e. value assignment),Operator,Item,Assignment,assignment,false,1.0.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"= (i.e. value assignment)
A single = symbol is used only as a method of assignment. In contrast, for tests of equivalence use a double equals sign e.g. == ):
	$AttributeA = $AttributeB; (attribute value
	$AttributeA = data; (literal data)
	$AttributeA = 4 * ($Price / 2); (expression)
The assignment is always from right to left; the left-side attribute takes the value of the right side attribute/expression. It is more usual for the right side to be evaluated (an expression) than the left, though the latter can occur.
Thus assignment sets the value of the specified left-side attribute the given right-side evaluated result; most often this is simply an attribute value. Where the right-side value is an attribute name, the $-prefix must be used. Take a note that has a $Color value of ""red"" and the $Rule:
	$MyUserColor = ""Color""; 
The result is not the text value red but rather it is a text value ""Color"". Most likely there is no defined named colour named ""Color"" so some other colour value, not the intended one, stored in $MyUserColor. If you want the value of an attribute, i.e. the $Color value of 'red' in this example, then your $Rule should be:
	$MyUserColor = $Color; 
You must use the $-prefix: see further detail below.
Actions and rules are allowed to specify a different referenced note, just as they can with a source attribute reference: 
	$AttribName(parent)=""theValue""; 
	$AttribName(/path/to/note)=""theValue"";
	$AttribName(/path/to/note)=$MyValue(parent); 
	$AttribName($AnotherAttribute)=""theValue""; 
In the last case the secondary attribute will hold a note name or path. Complex use of left-side expressions is allowed.
Do not mix $Attribute and Attribute(regex) syntax in a single call, i.e. $Attribute(regex), as this will cause expected results. Use one syntax or the other. This possible conflict should only ever occur in the context of queries or operations that allow query-style code.
If a value only needs to be assigned once, consider using a logical OR join.
Using Paths (offset addressing)
	$AttributeA = $AttributeB( note/item/path )
This sets the value of the $AttributeA to that of the $AttributeB of the same note (i.e. this or current), if no argument is specified, or of a note specified through name, item or path. (See more on paths). From v4.6, paths may also be used on the left side of the overall expression:
	$AttributeA( note/item/path ) = $AttributeB
	$AttributeA( note/item/path ) = $AttributeB( note/item/path )
Using query back-references
NOTE: the following syntax can only be used in the context of a query. In a query (an agent's query or an if() condition in an action) it is possible to combine a regex query with an action that uses the value of the found regex:
	query: $Text.contains(""email: "")
	action: $TheAddress=$1;
…will set TheAddress attribute value to the regex found in text. It is assumed that back-references $1-$9 may be used, assuming the regex generates more than one such references.","= (つまり、値の割り当て)
単一の = 記号は、代入の方法としてのみ使用されます。対照的に、等価性のテストには、二重等号を使用します。== ):
$属性A = $属性B;(属性値
$AttributeA = データ;(リテラルデータ)
$AttributeA = 4 * ($Price / 2);(式)
割り当ては常に右から左に行われます。左側の属性は、右側の属性/式の値を受け取ります。左辺よりも右辺が評価される (式) ことが一般的ですが、後者が発生する可能性もあります。
したがって、代入により、指定された左側の属性の値が、指定された右側の評価結果に設定されます。ほとんどの場合、これは単なる属性値です。右側の値が属性名である場合は、$-接頭辞を使用する必要があります。$Color 値が「red」で、$Rule が設定されているメモをメモします。
$MyUserColor = ""色"";
結果は、テキスト値 red ではなく、テキスト値 ""Color"" になります。おそらく、「Color」という名前の色が定義されていないため、意図したものではなく、別の色の値が $MyUserColor に格納されます。属性の値、つまりこの例では $Color 値「red」が必要な場合、$Rule は次のようにする必要があります。
$MyUserColor = $Color;
$-プレフィックスを使用する必要があります。詳細については、以下を参照してください。
アクションとルールでは、ソース属性参照の場合と同様に、別の参照先ノートを指定できます。
$AttribName(parent)=""theValue"";
$AttribName(/path/to/note)=""theValue"";
$AttribName(/path/to/note)=$MyValue(親);
$AttribName($AnotherAttribute)=""値"";
最後のケースでは、二次属性はノート名またはパスを保持します。左側の式を複雑に使用することができます。
単一の呼び出し、つまり $Attribute(regex) で $Attribute 構文と Attribute(regex) 構文を混合しないでください。予期した結果が生じる可能性があります。どちらかの構文を使用してください。この競合の可能性は、クエリ スタイルのコードを許可するクエリまたは操作のコンテキストでのみ発生する必要があります。
値を 1 回だけ割り当てる必要がある場合は、論理 OR 結合の使用を検討してください。
パスの使用 (オフセット アドレッシング)
$AttributeA = $AttributeB( ノート/アイテム/パス )
これにより、$AttributeA の値が、引数が指定されていない場合は同じノート (つまり、this または current) の $AttributeB の値、または名前、項目、またはパスで指定されたノートの $AttributeB の値に設定されます。(パスについて詳しくはこちらをご覧ください)。v4.6 からは、式全体の左側でもパスを使用できるようになりました。
$AttributeA( ノート/アイテム/パス ) = $AttributeB
$AttributeA( メモ/アイテム/パス ) = $AttributeB( メモ/アイテム/パス )
クエリ後方参照の使用
注: 次の構文はクエリのコンテキストでのみ使用できます。クエリ (エージェントのクエリまたはアクション内の if() 条件) では、正規表現クエリと、見つかった正規表現の値を使用するアクションを組み合わせることができます。
クエリ: $Text.contains(""電子メール: "")
アクション: $TheAddress=$1;
…TheAddress 属性値をテキスト内で見つかった正規表現に設定します。正規表現が複数のそのような参照を生成すると仮定して、後方参照 $1 ～ $9 が使用される可能性があると想定されます。"
== (i.e. value equality),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"== (i.e. value equality)
The operator to test equality (i.e. 'is the same as') is '==', two equals signs. Note that this replaces older syntax where a single equals sign was used contextually for both assignment and equality tests.
This operator is used either in agent queries or in the conditional part of an if(condition){action} code. It is the functional opposite of the '!=' inequality test.
This test cannot be meaningfully applied to Set or List type attribute data, as the entire attribute value is matched, rather than individual values as might otherwise be assumed. For these data types use the .contains() or .icontains() operators instead, noting the scope for ambiguous matching due to stemming of words (""car"" will match ""car"", ""cars"" and ""carrot"").
Because equality comparisons of Date-type data match at day scope, rather than full date/time values (for legacy reasons), use interval() to compare Date-type equality.
Equality testing can be negated, i.e. tested for a non-match, or combined with greater/less than for a range of tests as further explored in Basic Comparison Codes.
For a case-insensitive lexical equality test, use a lowercase on-the-fly transform:
	""Absquatulate"".lowercase == ""absquatulate"" 
If we set $MyString to ""Absquatulate"", then:
	$MyString.lowercase == ""absquatulate"" 
If $MyOtherString(Some note) has the value ""absquatulate"", then:
	$MyString.lowercase == $MyOtherString(Some note) 
Note the stored left-side value is not altered, but its transformed version is used in the test giving a case-insensitive comparison. This method only works for upper/lower case comparisons; accented characters are lexically different characters regardless of case.
Equality and List or Sets
Using == (and !=) with Lists & Sets means you are checking the entire literal contents, i.e. string like ""ant;bee;cow"" rather than by individual sub-value: ""ant"" and ""bee"" and ""cow"". Thus the equality test cannot be used to check if the attribute contains a discrete value, use .contains() instead (or .icontains() for case-insensitive matches). Importantly, when testing a string (or expression resolving to a string) equivalence against a list, it is the list that must be tested using .contains(). This is best shown using string literals representing a String type and a List type:
	""cow"".contains(""ant;bee;cow"") (does not work as expected)
	""ant;bee;cow"".contains(""cow"") 
	""ant;bee;Cow"".contains(""cow"") 
The first, testing the string, resolves to false but the second, testing the list, gives true. The third is false but would be true if using an .icontains() test. Thus when equivalence testing a string against a list, always run the .contains() on the list and not the string.
To test two lists hold the same values (and only those values), in the same case, in the same order, the == equivalence operator can be used as this tests the stored concatenated value lists in each case. To check common items shared by two lists use list.intersect().
Testing a List vs. a Set, it would be sensible to apply a .sort() or .isort() to each, reflecting that the sort state of a list is unknown and a == test compares the stored concatenated value string: the test would fail if the lists held the same values but stored in different orders. This shows up a difference between lists and sets. Although the literal value of a set may hold values in any order, when tested in code, they are being tested after sorting into (some**) order. Incidentally, this is why you cannot set a sort order as you can with a list as internally your given sort order is ignored. Consider $MySetA and $MyListA both with the values [ant;bee;cow]. $MySetB and $MyListB both have the value [bee;ant]. So:
	$MySetA == $MySetB gives false 
	$MyListA == $MyListB gives false 
both are expected. Now, make both the B attributes value ""bee;ant;cow""
	$MySetA == $MySetB gives true 
	$MyListA == $MyListB gives false 
This is because the Set compares the literal result of sorted values, whereas the List
 does not. But:
	$MyListA == $MyListB.sort gives true 
This is in effect what's happening with the sets, as in:
	$MyListA.sort == $MyListB.sort 
whereas in our last example above, $MyListA was already in default sort order so no applied sort was required. From experiment, this seems to be a (case-sensitive) computer lexical sort, i.e. [Bee;ant;bee] with capitals preceding lowercase letters in the sort.","== (つまり、値の等しい)
等しいかどうか (つまり、「と同じである」) をテストする演算子は、2 つの等号である「==」です。これは、代入テストと等価性テストの両方で単一の等号が状況に応じて使用されていた古い構文を置き換えることに注意してください。
この演算子は、エージェントのクエリまたは if(condition){action} コードの条件部分で使用されます。これは、「!=」不等号テストの逆の機能です。
このテストは、想定される個々の値ではなく、属性値全体が照合されるため、Set または List タイプの属性データには有意義に適用できません。これらのデータ型の場合は、単語のステミングによるあいまいな一致の範囲に注意して、代わりに .contains() または .icontains() 演算子を使用します (「car」は「car」、「cars」、「キャロット」と一致します)。
Date 型データの等価比較は、完全な日付/時刻値ではなく (レガシーな理由により) 日のスコープで一致するため、Date 型の等価性を比較するには、interval() を使用します。
等価性テストは無効にすることができます。つまり、不一致についてテストしたり、基本的な比較コードで詳しく説明するように、さまざまなテストに対して「より大きい/より小さい」と組み合わせたりすることができます。
大文字と小文字を区別しない字句等価性テストの場合は、小文字のオンザフライ変換を使用します。
""absquatulate"".小文字 == ""absquatulate""
$MyString を「Absquatulate」に設定すると、次のようになります。
$MyString. lowercase == ""absquatulate""
$MyOtherString(Some note) の値が「absquatulate」の場合、次のようになります。
$MyString. lowercase == $MyOtherString(メモ)
保存された左側の値は変更されませんが、その変換されたバージョンがテストで使用され、大文字と小文字を区別しない比較が行われることに注意してください。この方法は、大文字と小文字の比較にのみ機能します。アクセント付き文字は、大文字と小文字に関係なく、語彙的に異なる文字です。
等価性とリストまたはセット
Lists & Sets で == (および !=) を使用すると、個々のサブ値 (「ant」、「bee」、「cow」) ではなく、リテラルの内容全体、つまり「ant;bee;cow」のような文字列をチェックすることになります。したがって、属性に離散値が含まれているかどうかを確認するために等価性テストを使用することはできません。代わりに .contains() を使用してください (大文字と小文字を区別しない一致の場合は .icontains() を使用します)。重要なのは、文字列 (または文字列に解決される式) の等価性をリストに対してテストする場合、.contains() を使用してテストする必要があるのはリストです。これは、String 型と List 型を表す文字列リテラルを使用すると最もよくわかります。
""cow"".contains(""ant;bee;cow"")（期待どおりに動作しません）
""アリ;蜂;牛"".contains(""牛"")
""アリ;蜂;牛"".contains(""牛"")
最初の文字列のテストでは false に解決されますが、2 番目のリストのテストでは true が返されます。3 番目は false ですが、.icontains() テストを使用する場合は true になります。したがって、文字列をリストに対して等価テストする場合は、文字列ではなく常にリストに対して .contains() を実行してください。
2 つのリストが同じ値 (およびそれらの値のみ) を同じケース、同じ順序で保持していることをテストするには、格納されている連結された値リストをそれぞれのケースでテストするため、== 等価演算子を使用できます。2 つのリストに共有される共通項目を確認するには、list.intersect() を使用します。
List と Set をテストする場合、それぞれに .sort() または .isort() を適用するのが賢明です。これは、リストの並べ替え状態が不明であり、== テストが格納された連結された値文字列を比較することを反映しています。リストが同じ値を保持しているが、異なる順序で格納されている場合、テストは失敗します。これはリストとセットの違いを示しています。セットのリテラル値は任意の順序で値を保持できますが、コードでテストする場合は、(some**) 順序に並べ替えた後にテストされます。ちなみに、内部的には指定された並べ替え順序が無視されるため、リストの場合のように並べ替え順序を設定できないのはこのためです。$MySetA と $MyListA の両方の値が [ant;bee;cow] であると考えてください。$MySetB と $MyListB はどちらも値 [bee;ant] を持ちます。それで:
$MySetA == $MySetB は false を返します
$MyListA == $MyListB は false を返します
どちらも期待されています。次に、両方の B 属性値を「bee;ant;cow」にします。
$MySetA == $MySetB は true を返します
$MyListA == $MyListB は false を返します
これは、Set は並べ替えられた値のリテラル結果を比較するのに対し、List は並べ替えられた値を比較するためです。
しません。しかし:
$MyListA == $MyListB.sort は true を返します
これは、実際には次のようにセットで起こっていることです。
$MyListA.sort == $MyListB.sort
一方、上記の最後の例では、$MyListA はすでにデフォルトのソート順になっていたため、ソートを適用する必要はありませんでした。実験によると、これは (大文字と小文字を区別する) コンピューター語彙ソート、つまり [Bee;ant;bee] のように大文字が小文字の前にあるようです。"
> (i.e. greater than),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"> (i.e. greater than)
The operator used to test if the left side of an expression is greater than the right side. This operator is used either in agent queries or in the conditional part of an if(condition){action} code. If $MyNumber is 3:
	$MyNumber > 2 is true 
	$MyNumber > 4 is false 
Further explored in Basic Comparison Codes.","> (つまり、より大きい)
式の左辺が右辺より大きいかどうかをテストするために使用される演算子。この演算子は、エージェントのクエリまたは if(condition){action} コードの条件部分で使用されます。$MyNumber が 3 の場合:
$MyNumber > 2 は true
$MyNumber > 4 は false です
基本的な比較コードでさらに詳しく説明します。"
>= (i.e. greater than or equal to),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,">= (i.e. greater than or equal to)
The operator used to test if the left side of an expression is greater than or equal to the right side. This operator is used either in agent queries or in the conditional part of an if(condition){action} code. If $MyNumber is 3:
	$MyNumber >= 2 is true 
	$MyNumber >= 3 is true 
	$MyNumber >= 4 is false 
Further explored in Basic Comparison Codes; in some date comparison cases, a two term query may be needed instead.",">= (つまり、以上)
式の左辺が右辺以上であるかどうかをテストするために使用される演算子。この演算子は、エージェントのクエリまたは if(condition){action} コードの条件部分で使用されます。$MyNumber が 3 の場合:
$MyNumber >= 2 は true
$MyNumber >= 3 は true
$MyNumber >= 4 は false
基本的な比較コードでさらに詳しく説明します。日付比較の場合によっては、代わりに 2 つの用語のクエリが必要になる場合があります。"
| (i.e. query logical OR join),Operator,Query,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"| (i.e. query logical OR join)
The pipe, |, is used in queries and conditional statements as a logical OR join. Thus:
	if ($HasStock == true | $Price > 20) {$Badge=""ok"";} 
The note's $Badge is only set if either the first or the second argument are true.
See also the AND join and conditional statements using multiple arguments.","|(つまり、クエリ論理 OR 結合)
パイプ | は、クエリおよび条件ステートメントで論理 OR 結合として使用されます。したがって:
if ($HasStock == true | $Price > 20) {$Badge=""ok"";}
メモの $Badge は、最初または 2 番目の引数が true の場合にのみ設定されます。
複数の引数を使用した AND 結合および条件ステートメントも参照してください。"
|= (i.e. logical OR assignment),Operator,Item,Assignment,assignment,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"|= (i.e. logical OR assignment)
To make it easier to write rules succinctly, you may use the assignment:
	$TheAttribute |= the_expression; 
…which sets $TheAttribute to the value of the_expression if it is already true OR if the_expression is true. An attribute that has no locally set (or inherited) value is evaluated as false. Thus there are two possible outcomes:
* if $TheAttribute is set to a value that evaluates (the left side of the code) as true. Therefore, regardless of the state of the_expression, the_expression (the right side of the code) is not evaluated and $TheAttribute retains its current value.
* if $TheAttribute is set to a value evaluates (the left side of the code) as false. Therefore the_expression (the right side of the code) is evaluated. If the_expression evaluates as true $TheAttribute takes the value of the_expression. On subsequent iteration of the code $TheAttribute thus evaluates as true. But, if the_expression evaluated to false, both it and the overall action evaluate as false, i.e. $TheAttribute's value remains unchanged.
A more verbose (and less efficient at scale) way to write the same test without the |= operator is
	if((!$TheAttribute)){ ..o the_expression;} 
where '(!$TheAttribute)' is a short-form test meaning if the value of attribute named TheAttribute tests as false. A false value arises differently for for different attribute data types, but for for a string, the above can be further unpacked as:
	if($TheAttribute!=""""){ ..o the_expression;} 
In practical terms this means the left side, usually an attribute, is set to the right side value only if it is not already set locally at note level. This is because for most attributes, especially new user attributes, the default value will evaluate as false. But, $TheAttribute's data type does not have to be Boolean.
For new String-type attributes (and string-based Action/Color/File/Font/Interval/List/Set/URL types) the default is an empty string """". For Number-type, is it 0 (zero). For Date-type, it is the string ""never"". For Boolean-type, is it ' false' (with no enclosing quotes, and shown as un-ticked if displayed via a tick-box). The """", 0 and ""never"" values—for the appropriate data types—evaluate as false. But, be aware that not all system attributes follow this assumption. For instance, the $Color default is preset to use a named Tinderbox colour, so its default value (even if inherited) would evaluate as true .
Prototypes have no direct effect as the outcome, as it initially depends on the evaluation of the left-side attribute value regardless of whether document default, prototype inherited or locally set.
This operator's behaviour makes the |= usage very useful for doing tasks like making code run only once; on the second pass the left side already has a value so no change occurs. This avoids scenarios like successive applications of a rule causing multiple concatenation of strings (one extra each iteration).
For example, for the Boolean-type attribute $Urgent:
	$Urgent |= any(children,$Urgent); 
A project is urgent if it has been declared to be urgent itself, or if any child is urgent.
If using |= assignments, it can be useful to have a means to reset an attribute to default to re-enable |= value assignment.
See also the logical AND assignment (which is likely used less often).","|= (つまり、論理 OR 割り当て)
ルールを簡潔に記述しやすくするために、次の割り当てを使用できます。
$TheAttribute |= the_expression;
…すでに true であるか、the_expression が true である場合、$TheAttribute を the_expression の値に設定します。ローカルに設定された (または継承された) 値を持たない属性は false として評価されます。したがって、考えられる結果は 2 つあります。
* $TheAttribute が (コードの左側) true と評価される値に設定されている場合。したがって、the_expression の状態に関係なく、the_expression (コードの右側) は評価されず、$TheAttribute は現在の値を保持します。
* $TheAttribute が値に設定されている場合、(コードの左側) は false として評価されます。したがって、the_expression (コードの右側) が評価されます。the_expression が true と評価された場合、$TheAttribute は the_expression の値を受け取ります。コードの後続の反復では、$TheAttribute は true として評価されます。ただし、the_expression が false と評価された場合、それとアクション全体の両方が false と評価されます。つまり、$TheAttribute の値は変更されません。
|= 演算子を使用せずに同じテストを記述する、より冗長な (そして大規模では効率が低い) 方法は次のとおりです。
if((!$TheAttribute)){ ..o the_expression;}
ここで、「(!$TheAttribute)」は、TheAttribute という名前の属性の値が false であるかどうかをテストする短い形式のテストです。false 値の発生方法は属性データ型ごとに異なりますが、文字列の場合、上記は次のようにさらに展開できます。
if($TheAttribute!=""""){ ..o the_expression;}
実際には、これは、ノートレベルでまだローカルに設定されていない場合にのみ、左側 (通常は属性) が右側の値に設定されることを意味します。これは、ほとんどの属性、特に新しいユーザー属性では、デフォルト値が false として評価されるためです。ただし、$TheAttribute のデータ型はブール型である必要はありません。
新しい文字列タイプの属性 (および文字列ベースの Action/Color/File/Font/Interval/List/Set/URL タイプ) のデフォルトは空の文字列 """" です。Number型の場合は0（ゼロ）になります。日付型の場合は「never」という文字列になります。ブール型の場合、「false」になります（引用符で囲まれておらず、チェックボックスで表示されている場合はチェックされていない状態で表示されます）。適切なデータ型の場合、「」、0、および「never」の値は false として評価されます。ただし、すべてのシステム属性がこの前提に従っているわけではないことに注意してください。たとえば、 $Color のデフォルトは名前付きの Tinderbox カラーを使用するようにプリセットされているため、そのデフォルト値は (継承されている場合でも) true として評価されます。
プロトタイプは、ドキュメントのデフォルト、継承されたプロトタイプ、またはローカルに設定されたかどうかに関係なく、最初は左側の属性値の評価に依存するため、結果として直接的な影響はありません。
この演算子の動作により、|= の使用法は、コードを 1 回だけ実行するなどのタスクを実行する場合に非常に便利になります。2 回目のパスでは、左側にはすでに値があるため、変更は行われません。これにより、文字列の複数の連結 (反復ごとに 1 つ追加) を引き起こすルールの連続適用などのシナリオが回避されます。
たとえば、ブール型属性 $Urgent の場合:
$Urgent |= any(children,$Urgent);
プロジェクト自体が緊急であると宣言されている場合、または子が緊急である場合、プロジェクトは緊急です。
|= 割り当てを使用する場合、属性をデフォルトにリセットして |= 値の割り当てを再度有効にする手段があると便利です。
論理 AND 割り当て (使用頻度は低いと思われます) も参照してください。"
$AttributeName (i.e. a short form test for value),Operator,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"$AttributeName
In queries and conditional action code expressions, using just an attribute name preceded by a $ character functions as a shortened form of the Boolean test for a true value. Thus the following are functional equivalents:
	$MyBoolean==true 
	$MyBoolean 
In both cases the result is true if the value of $MyBoolean is true.
In all other contexts, the $AttributeName syntax implies a reference to that attribute.
Usefully Tinderbox also useful supports such short-form $AttributeName tests for all the other attribute data types, returning true if the attribute has a non-default value. Per data type, this equates to long form tests like:
	$MyAction!="""" 
	$MyColor!="""" 
	$MyDate!=never 
	$MyFile!="""" 
	$MyInterval!=""00:00"" 
	$MyList!=[] or $MyList!="""" 
	$MyNumber!=0 
	$MySet!=[] or $MySet!="""" 
	$MyString!="""" 
	$MyURL!="""" 
In all these cases a short-form test returns true if the attribute value is not the default for that data type.
A reverse short form test is also offered by (!$AttributeName), i.e. the same syntax with a preceding exclamation mark and enclosing parentheses. In theory, the latter parentheses are not necessary, but in practice it helps Tinderbox when parsing a query.","$属性名
クエリおよび条件アクション コード式では、$ 文字が前に付いた属性名のみを使用すると、true 値のブール テストの短縮形として機能します。したがって、以下は機能的に同等です。
$MyBoolean==true
$MyBoolean
どちらの場合も、$MyBoolean の値が true であれば、結果は true になります。
他のすべてのコンテキストでは、$AttributeName 構文はその属性への参照を意味します。
便利なことに、Tinderbox は、他のすべての属性データ型に対してこのような短い形式の $AttributeName テストをサポートしており、属性がデフォルト以外の値を持つ場合に true を返します。データ型ごとに、これは次のような長い形式のテストに相当します。
$MyAction!=""""
$MyColor!=""""
$MyDate!=決してしない
$MyFile!=""""
$MyInterval!=""00:00""
$MyList!=[] または $MyList!=""""
$MyNumber!=0
$MySet!=[] または $MySet!=""""
$MyString!=""""
$MyURL!=""""
これらすべての場合において、属性値がそのデータ型のデフォルトでない場合、短い形式のテストは true を返します。
逆の短い形式のテストも (!$AttributeName) によって提供されます。つまり、同じ構文の前に感嘆符を付け、括弧で囲んだものです。理論的には、後者の括弧は必要ありませんが、実際には、Tinderbox がクエリを解析する際に役立ちます。"
$AttributeName[(scope)],Property,Item,Assignment,source context dependent,false,4.6.0,Baseline,,,,1,true,false,false,false,false,true,false,false,false,,false,"$AttributeName
In action code contexts, an attribute's name prefixed with a $-character implies a reference to that attribute, thus a placeholder for that attribute's value. In a coding context is acts as a variable name where the variable name must be that of an existing attribute and the variable's value is got from or set to that attribute.
A reference on the right side of an expression fetches the attribute's value. A reference on the left side of an expression has its value set to the result of the right side. The following example combines these uses whereby in the current object (a note, agent, adornment, etc.), the user attribute $MyNumber is being set to the value of system attribute $ChildCount:
	$MyNumber = $ChildCount; 
In queries and conditional expressions, and attribute reference implies a shortened Boolean test.
The test can be turned in a negative (i.e. that no value is set) by using a '!' prefix: see !$AttributeName, occasionally if the !-prefix does not work, try enclosing the expression in parentheses (!$AttributeName) to help signal intent to Tinderbox's action code parser.
$AttributeName(scope)
Besides the basic form above, which is essentially $AttributeName(this), an offset address can also be made to the value of an attribute in another object— i.e. other than the one in current focus, by using an extended syntax where the scope argument (defining scope) to refer to one or more note(s).
Importantly, here the scope argument is not evaluated for expressions unlike in some action code operators. This means that here, scope cannot be a complex code expression. However, where that need arises eval() may offer a workaround or consider using a user attribute to hold the output of the expression and then use that attribute's value (i.e. in the manner of bullet #4 above).
The extended syntax form may be used on the left or right side of an action code expression. In other words, you can use this syntax to fetch (right side) or set (left side) an attribute value from some other object. Generally, offset addresses are used on the right side to fetch data from another object.
Examples, right side:
	$MyString = $MyString(""Some other note""); 
	$MyNumber = $MyNumber(""A root container/Some Container/Some other note""); 
	$MyString = $MyString(agent); (this designator only works in agents)
	$MyString = $MyString(adornment); (this designator only works in adornments)
	$MyList = $MyString(""Some other note;Another note;Different note""); 
Examples, left-side:
	$MyString(""Another note"") = $MyString(""A note""); 
	$MyDate(parent) = $MyDate; 
In fact, an offset can even be used on both sides of the expression. For instance, the rule in a note ""Some note"" might use the following code to refer to attributes in two other notes:
	$MyColor(""A note"") = $MyColor(""Another note"");","$属性名
アクション コードのコンテキストでは、$ 文字が接頭辞として付けられた属性の名前は、その属性への参照を意味し、その属性の値のプレースホルダーになります。コーディング コンテキストでは、 は変数名として機能します。変数名は既存の属性の名前である必要があり、変数の値はその属性から取得されるか、その属性に設定されます。
式の右側の参照は、属性の値を取得します。式の左側の参照の値は右側の結果に設定されます。次の例では、これらの使用法を組み合わせており、現在のオブジェクト (メモ、エージェント、装飾品など) で、ユーザー属性 $MyNumber がシステム属性 $ChildCount の値に設定されています。
$MyNumber = $ChildCount;
クエリと条件式では、属性参照は短縮されたブール テストを意味します。
「!」を使用すると、テストを否定 (値が設定されていないこと) にすることができます。プレフィックス: !$AttributeName を参照してください。場合によっては、!-プレフィックスが機能しない場合は、Tinderbox のアクション コード パーサーに意図を伝えるために、式を括弧 (!$AttributeName) で囲んでみてください。
$AttributeName(スコープ)
本質的に $AttributeName(this) である上記の基本的な形式に加えて、スコープ引数 (スコープの定義) が 1 つ以上のメモを参照する拡張構文を使用することで、別のオブジェクト (つまり、現在フォーカスされているオブジェクト以外) の属性の値に対してオフセット アドレスを作成することもできます。
重要なのは、一部のアクション コード演算子とは異なり、ここではスコープ引数が式に対して評価されないことです。これは、ここではスコープを複雑なコード式にすることはできないことを意味します。ただし、その必要が生じた場合、 eval() は回避策を提供するか、ユーザー属性を使用して式の出力を保持し、その属性の値を使用することを検討します (つまり、上記の箇条書き #4 の方法で)。
拡張構文形式は、アクション コード式の左側または右側で使用できます。つまり、この構文を使用して、他のオブジェクトから属性値を取得 (右側) または設定 (左側) することができます。一般に、オフセット アドレスは、別のオブジェクトからデータをフェッチするために右側で使用されます。
右側の例:
$MyString = $MyString(""その他のメモ"");
$MyNumber = $MyNumber(""ルート コンテナ/一部のコンテナ/その他のメモ"");
$MyString = $MyString(エージェント);(この指定子はエージェント内でのみ機能します)
$MyString = $MyString(装飾);(この指定子は装飾でのみ機能します)
$MyList = $MyString(""他のメモ;別のメモ;別のメモ"");
左側の例:
$MyString(""別のメモ"") = $MyString(""メモ"");
$MyDate(親) = $MyDate;
実際、オフセットは式の両側で使用することもできます。たとえば、メモ「Some note」のルールでは、次のコードを使用して他の 2 つのメモの属性を参照する場合があります。
$MyColor(""別のメモ"") = $MyColor(""別のメモ"");"
$N (query back-reference),Property,Query,Data manipulation,String,false,9.5.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"$N 
The value of the numbered back-reference for the current query (agent or if() conditional).
The valid range for N is from 0 (zero) to 9.
The back-reference $0 always refers to the the whole matched string (or sub-string) for the stated query regex, i.e. it may match all or part of the target string. $1 to $9 refer to any further defined back-references within the overall regex, i.e. sub-strings within $0.
Back-references are numbered in the order created. The order is usually left-to right in order the parentheses open, noting that this allows for nesting of back-references.
Query back-references are discussed in fuller detail here.","$N
現在のクエリ (エージェントまたは if() 条件付き) の番号付き後方参照の値。
N の有効範囲は 0 (ゼロ) ～ 9 です。
後方参照 $0 は常に、指定されたクエリ正規表現に一致した文字列 (または部分文字列) 全体を参照します。つまり、ターゲット文字列のすべてまたは一部と一致する可能性があります。$1 から $9 は、正規表現全体内でさらに定義された後方参照、つまり $0 内の部分文字列を指します。
後方参照には、作成された順序で番号が付けられます。通常、順序はかっこが開くように左から右になりますが、これにより後方参照のネストが可能になることに注意してください。
クエリ逆参照については、ここで詳しく説明します。"
abs(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"abs(sourceNum)
abs() computes the absolute value of its sourceNum argument. This is the non-negative value of sourceNum without regard to its sign. Thus both these result in a $MyNumber value of 3.5:
	$MyNumber = abs(3.5); 
	$MyNumber = abs(-3.5); 
The operator can also evaluate a numerical attribute:
	$MyNumber = abs($SomeNumber); 
A numerical string attribute will be parsed to a number. If $MyString is a value of ""-5"", $MyNumber will be 5:
	$MyNumber = abs($MyString);","abs(ソース番号)
abs() は、sourceNum 引数の絶対値を計算します。これは、符号に関係なく、sourceNum の非負の値です。したがって、これらの両方の結果として $MyNumber 値は 3.5 になります。
$MyNumber = abs(3.5);
$MyNumber = abs(-3.5);
演算子は数値属性を評価することもできます。
$MyNumber = abs($SomeNumber);
数値文字列属性は数値に解析されます。$MyString の値が「-5」の場合、$MyNumber は 5 になります。
$MyNumber = abs($MyString);"
"action([scope,]codeStr)",Function,Item,Data manipulation,success boolean,false,5.8.0,Baseline,9.5.0,,,2,true,false,false,false,false,false,false,true,false,,false,"action([scope, ]codeStr)
action(codeStr)
This function allows execution of the codeStr without the need for a return value. This allows an action be set within an attribute, and perform that action as part of a rule or agent action. The optional scope argument allows the action to be run on a note other than the current note
For example, the Rule
	action('$Color= ""bright red""');
will set the note's primary colour ($Color). 
Note that that in its simplest form, an action() call is a quote-enclosed string. As action codes tend to use double-quoted strings, it may often be necessary to use single quotes for the outer enclosure, as in the example above.
The action() function returns the evaluated result of the codeStr within it. In the above case if $MyString were set to store the result, the value would be true—because the action completed successfully. So, in most cases, there is no requirement for a left-side attribute to accept any output. By comparison, the related eval(expression) function evaluates an expression and returns a value. Whereas eval() is designed to intentionally return an output, action() performs an action such as an assignment.
An action() call can be used with a do(macro) call to create a form of function as macros allow input arguments (its arguments): see do().
The action() call is particularly useful during export where it is desirable to run some action code in the context of the template during template rendering (evaluation)—see more below.
Calling stamp code via action()
If a stamp's code is long/complex it can be convenient to store it in a code note. Thus if a code note 'Test-stamp' held the action code $Colour=""red"";, then a stamp with the code:
	action($Text(""Test-stamp"")); 
when run would result in the stamped note(s) turning red. The example is trivial but shows the technique. Note the offset address in the stamp to the code note is case sensitive and should use a unique $Name (or else cite the full $Path to the code note). Local attribute references, i.e. $Color or $ChildCount, are bound to the note being stamped: it is not possible to reference values in the code note using a designator.
On-the-fly Attribute references using action()
Occasionally it is necessary to make at attribute value reference string from a variable, i.e. if the variable holds 'Path' the result being '$Path' as opposed to the value of $Path. Whilst $MyString refers to the value of attribute MyString, what if the attribute name is itself the value of a variable in the current code? Here action() solves the problem. For instance, if vAnAttr holds as its value the name of an attribute, e.g. ""SomeAttribute"" then the following does not work:
	$MyString = ""$"" + vAnAttr; WRONG ($MyString is the value of $SomeAtttribute)
as $MyString is not set to the value of $SomeAttr. Instead use action():
	action('$MyString = ""$"" + vAnAttr'); CORRECT ($MyString is the string '$SomeAtttribute')
To build a series of $-prefixed attribute references in a loop, use action() instead of eval(), as described in more detail here.
action(scope, code)
If an optional first scope argument is provided, the code is not run on the current note but on that defined by scope (defining scope). Thus:
	action(""Some note"",""$Color = 'blue';""); 
will set the colour of note ""Some note"" to blue.
This option can avoid needing to use offset references in code, especially if the offset address is being defined by a variable.","アクション([スコープ, ]codeStr)
アクション(コード文字列)
この関数を使用すると、戻り値を必要とせずに codeStr を実行できます。これにより、アクションを属性内に設定し、ルールまたはエージェント アクションの一部としてそのアクションを実行できるようになります。オプションのスコープ引数を使用すると、現在のノート以外のノートに対してアクションを実行できます。
たとえば、ルール
action('$Color= ""明るい赤""');
メモの主な色 ($Color) を設定します。
最も単純な形式では、action() 呼び出しは引用符で囲まれた文字列であることに注意してください。アクション コードでは二重引用符で囲まれた文字列が使用される傾向があるため、上記の例のように、外側の囲いに一重引用符を使用することが必要になる場合があります。
action() 関数は、その中の codeStr の評価結果を返します。上記の場合、$MyString が結果を保存するように設定されている場合、アクションが正常に完了したため、値は true になります。したがって、ほとんどの場合、左側の属性が出力を受け入れる必要はありません。比較すると、関連する eval(expression) 関数は式を評価し、値を返します。eval() は意図的に出力を返すように設計されているのに対し、action() は代入などのアクションを実行します。
action() 呼び出しを do(macro) 呼び出しと一緒に使用すると、マクロでは入力引数 (その引数) が許可されるため、関数の形式を作成できます。 do() を参照してください。
action() 呼び出しは、テンプレートのレンダリング (評価) 中にテンプレートのコンテキストでアクション コードを実行することが望ましいエクスポート中に特に役立ちます (詳細は以下を参照)。
action()によるスタンプコードの呼び出し
スタンプのコードが長い/複雑な場合は、コードノートに保存すると便利です。したがって、コード ノート「Test-stamp」にアクション コード $Colour=""red""; が含まれている場合、スタンプには次のコードが含まれます。
アクション($Text(""テストスタンプ""));
実行すると、スタンプされたメモが赤くなります。この例は簡単ですが、テクニックを示しています。コード ノートへのスタンプ内のオフセット アドレスは大文字と小文字が区別され、一意の $Name を使用する必要があることに注意してください (または、コード ノートへの完全な $Path を引用する必要があります)。ローカル属性参照 ($Color または $ChildCount など) は、スタンプされるノートにバインドされます。指定子を使用してコード ノート内の値を参照することはできません。
action() を使用したオンザフライ属性参照
場合によっては、変数から属性値参照文字列を作成する必要があります。つまり、変数が 'Path' を保持している場合、結果は $Path の値ではなく '$Path' になります。$MyString は属性 MyString の値を参照しますが、属性名自体が現在のコード内の変数の値である場合はどうなるでしょうか?ここで action() が問題を解決します。たとえば、vAnAttr がその値として属性の名前を保持している場合、例:「SomeAttribute」の場合、次は機能しません。
$MyString = ""$"" + vAnAttr;間違っています ($MyString は $SomeAtttribute の値です)
$MyString が $SomeAttr の値に設定されていないためです。代わりに action() を使用してください。
action('$MyString = ""$"" + vAnAttr');正しい ($MyString は文字列 '$SomeAtttribute')
ループ内で一連の $ 接頭辞が付いた属性参照を構築するには、ここで詳しく説明するように、eval() の代わりに action() を使用します。
アクション(スコープ、コード)
オプションの最初のスコープ引数が指定されている場合、コードは現在のノートではなく、スコープによって定義されたノート (スコープの定義) で実行されます。したがって:
action(""メモ"",""$Color = 'blue';"");
メモ「Some note」の色を青に設定します。
このオプションを使用すると、特にオフセット アドレスが変数で定義されている場合、コード内でオフセット参照を使用する必要がなくなります。"
"any(scope, condition)",Function,Group,Non-query Boolean,boolean test,false,4.0.0,Baseline,,,,2,true,false,false,false,true,true,true,false,false,,false,"any(scope, condition)
This Boolean operator examines notes at scope (defining scope) and determines whether any note(s) in the defined group evaluates condition as true.
scope may be any group designator, or group defined by find().
The overall condition must not be enclosed in quotes, though a literal string value within the query will need to be quoted. For example:
	any(children,$Status==""Important"") 
	any(children,$Overdue==true) 
	any(children,$Overdue) (using short form test)
	any(children,$Overdue==false) 
	any(children,!$Overdue) (using short form test)
If trying to resolve contains() for multiple matches, use any(children,$Name==""string""). Thus of it is desired for an agent to list the parent containers of all notes titled 'foo', the agent query would be:
	any(children,$Name==""foo"") 
If agents are present, it may be sensible to filter for aliases:
	any(children,$Name==""foo"") & !$IsAlias 
See also: every().","任意(スコープ、条件)
このブール演算子は、スコープ (スコープの定義) でノートを検査し、定義されたグループ内のノートが条件を true と評価するかどうかを判断します。
スコープには、任意のグループ指定子、または find() で定義されたグループを指定できます。
条件全体を引用符で囲むことはできませんが、クエリ内のリテラル文字列値は引用符で囲む必要があります。たとえば:
any(children,$Status==""重要"")
任意(子供たち,$Overdue==true)
any(children,$Overdue) （短い形式のテストを使用）
任意(子供たち,$Overdue==false)
any(children,!$Overdue) （短い形式のテストを使用）
複数の一致に対して contains() を解決しようとする場合は、any(children,$Name==""string"") を使用します。したがって、エージェントが「foo」というタイトルのすべてのメモの親コンテナをリストすることが望ましいため、エージェントのクエリは次のようになります。
任意(子供,$Name==""foo"")
エージェントが存在する場合は、エイリアスをフィルタリングすることが賢明な場合があります。
any(children,$Name==""foo"") & !$IsAlias
「every()」も参照してください。"
atan(radiansNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"atan(radiansNum)
atan() converts its radiansNum, in radians, to the arctangent of that value.
	$MyNumber = atan(6); 
returns 1.405647649 for an input of 6 radians.","atan(ラジアン数値)
atan() は、ラジアン単位の radiansNum をその値の逆正接に変換します。
$MyNumber = atan(6);
6 ラジアンの入力に対して 1.405647649 を返します。"
attribute(attributeNameStr).keys,Function,Document,Document configuration,List,false,9.5.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"attribute(attributeNameStr).keys
This returns a List of the attribute dictionary keys for the attribute named in the attributeNameStr argument. Keys are returned in the order listed for attribute(), and not in alphabetical order—as might be intuited. Being a Dictionary operator, it is possible to retrieve all the above as a list of key:value pairs. Note that any attribute name (any valid name) must be supplied as first argument:
	$MyList = attribute(""Width"").keys; 
returns the entire contents of the Dictionary key:value pairs for the attribute Width.
 From v10.1.1, attributeNameStr may be a variable or attribute value instead of a literal string. As the attribute name may thus be a variable, a more useful method is to iterate the list of keys:

var:list vKeys;
var:string vOutput;
vKeys = attribute(anAttribute).keys;
vKeys.each(aKey){
	vOutput += aKey + "": "" + attribute(anAttribute)[aKey] + ""\n"";
};
$Text = vOutput;
By combining with document(), it is possible to make a stamp that creates a listing of all user attributes in the current document, iterate each one, report only keys with a value and place the resulting data in the $Text of the stamped note the stamp code is;

var:list vKeys;
var:string vOutput;
var:list vAttributes = document[""user-attributes""];
vOutput += ""TBX filename "" + document[name] + ""\n"";
vOutput += ""Number of  user attributes: "" + vAttributes.count + ""\n--------------------\n"";
vAttributes.each(anAttribute){
	vOutput += ""--------------------\n"" + anAttribute + ""\n"" +""----------\n"";
	vKeys = attribute(anAttribute).keys;
	vKeys.each(aKey){
		if(attribute(anAttribute)[aKey] != """" & aKey != ""category""){
			vOutput += aKey + "": "" + attribute(anAttribute)[aKey] + ""\n"";
		};
	};
};
$Text = vOutput;","属性(属性名Str).keys
これは、attributeNameStr 引数で指定された属性の属性辞書キーのリストを返します。直感的にわかるかもしれませんが、キーはアルファベット順ではなく、attribute() にリストされている順序で返されます。Dictionary 演算子であるため、上記のすべてをキーと値のペアのリストとして取得できます。任意の属性名 (任意の有効な名前) を最初の引数として指定する必要があることに注意してください。
$MyList = 属性(""幅"").keys;
属性幅のディクショナリのキー:値ペアの内容全体を返します。
v10.1.1 以降、attributeNameStr はリテラル文字列ではなく変数または属性値になる場合があります。したがって、属性名は変数である可能性があるため、より便利な方法はキーのリストを反復することです。

var:vKey のリスト;
var:string v出力;
vKeys = 属性(属性).keys;
vKeys.each(aKey){
vOutput += aKey + "": "" + 属性(anAttribute)[aKey] + ""\n"";
};
$Text = vOutput;
document() と組み合わせることで、現在のドキュメント内のすべてのユーザー属性のリストを作成するスタンプを作成し、それぞれを反復処理し、値を持つキーのみをレポートし、その結果のデータをスタンプ コードがスタンプされたメモの $Text に配置することができます。

var:vKey のリスト;
var:string v出力;
var:list vAttributes = document[""ユーザー属性""];
vOutput += ""TBX ファイル名 "" + ドキュメント[名前] + ""\n"";
vOutput += ""ユーザー属性の数: "" + vAttributes.count + ""\n-----------------------------\n"";
vAttributes.each(anAttribute){
vOutput += ""----------\n"" + anAttribute + ""\n"" +""----------\n"";
vKeys = 属性(属性).keys;
vKeys.each(aKey){
if(attribute(anAttribute)[aKey] != """" & aKey != ""カテゴリ""){
vOutput += aKey + "": "" + 属性(anAttribute)[aKey] + ""\n"";
};
};
};
$Text = vOutput;"
attribute(attributeNameStr)[keyStr],Function,Document,Document configuration,Dictionary,false,9.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"attribute(attributeNameStr)[keyStr]
The attribute() operator, for the specified attribute attributeNameStr, returns a Dictionary of key values that describe that attribute. attributeNameStr may also be a variable or attribute value instead of a literal string. Keys names are all-lowercase and case-sensitive. The current keys are listed below. Keys are editable value attribute 
* category (read-only): the category (group) in which the attribute appears.
* default: the attribute default value.
* description: a short description the the attribute. For user attributes, this needs to be set by the user (either here via the Inspector).
* lines: the number of lines used for display of values in Displayed Attributes and Get Info tables. Only used for data types Dictionary, List, Set, String.
* readonly (read-only): is true for read-only attributes, else no value. This setting is explained under non-editable notes.
* sequential (read-only): only used by Number data types. A string value YES if true, else no value. 
* suggested: the suggested values. Empty unless set by the user. Only used by data types Dictionary, List, Set, and String.
* type (read-only): a string describing the Data type of the attribute.
Some read-only properties may be modified via the User Attributes Inspector, but not via action code.
Key values
If any key is not set, e.g. there are no 'suggested' values, then an empty string is returned for that key.
All keys return a value called via keyStr. The most appropriate attribute type is shown as the recipient of the data:
	$MyString = attribute(""Width"")[""category""] 
	$MyList = attribute(""Width"")[""default""] 
	$MyString = attribute(""Width"")[""description""] 
	$MyNumber = attribute(""Width"")[""lines""] 
	$MyBoolean = attribute(""Width"")[""readonly""] 
	$MyBoolean = attribute(""Width"")[""sequential""] (as 'YES' coerces to true)
	$MyList = attribute(""Width"")[""suggested""] 
	$MyString = attribute(""Width"")[""type""] 
Note that when using literal (i.e. actual) attribute name or keys it is recommended the word(s) are quote enclosed as above. If using variables, as in the earlier code examples, quotes are not used as this aids the Tinderbox parser detecting literal vs. variable usage.
Attribute categories
All attributes belong to an organisation group, and this is stored in the category property. Note that whilst system attributes comprise a series of groups, all user attributes are in group 'user'.
Editing key values
Some keys can be modified via action code, all others are read-only. Actions may modify the default, description, lines, or suggested values of an attribute:
	attribute(""attributeName"")[""suggested""]=""value 1; value 2""; 
sets two values for the attribute's suggested values list. Likewise a default value can be set:
	attribute(""attributeName"")[""default""]=""value 1""; 
Or a description:
	attribute(""Price"")[""description""]=""The price of the item.""; 
Thus, for instance, action code might find the discrete values for an attributes (use values() or collect(), etc.) and use that list to set/update the attributes suggested values (i.e. the suggested key value).
Setting property values
Both the attribute name and/or the facet to be set may be enclosed in quotation marks (previously, use of quotes caused a failure):
	attribute(AttributeName)[facet]=""testing""; 
or
	attribute(""AttributeName"")[""facet""]=""testing"";","属性(属性名Str)[キーStr]
指定された属性attributeNameStrのattribute()演算子は、その属性を説明するキー値の辞書を返します。attributeNameStr は、リテラル文字列の代わりに変数または属性値にすることもできます。キー名はすべて小文字で、大文字と小文字が区別されます。現在のキーは以下にリストされています。キーは編集可能な値属性です
* カテゴリ (読み取り専用): 属性が表示されるカテゴリ (グループ)。
* デフォルト: 属性のデフォルト値。
* description: 属性の短い説明。ユーザー属性の場合、これはユーザーが (ここではインスペクター経由で) 設定する必要があります。
* 行数: 表示属性テーブルと情報取得テーブルの値の表示に使用される行数。データ型 Dictionary、List、Set、String にのみ使用されます。
* readonly (読み取り専用): 読み取り専用属性の場合は true、それ以外の場合は値はありません。この設定については、編集できないメモで説明されています。
* シーケンシャル (読み取り専用): 数値データ型でのみ使用されます。true の場合は文字列値 YES、それ以外の場合は値なし。
* 推奨: 推奨される値。ユーザーが設定しない限り空です。データ型 Dictionary、List、Set、および String でのみ使用されます。
* type (読み取り専用): 属性のデータ型を説明する文字列。
一部の読み取り専用プロパティは、ユーザー属性インスペクターを介して変更できますが、アクション コードを介して変更することはできません。
キーの値
キーが設定されていない場合、例:「推奨」値がない場合は、そのキーに対して空の文字列が返されます。
すべてのキーは keyStr 経由で呼び出される値を返します。最も適切な属性タイプがデータの受信者として表示されます。
$MyString = 属性(""幅"")[""カテゴリ""]
$MyList = 属性(""幅"")[""デフォルト""]
$MyString = 属性(""幅"")[""説明""]
$MyNumber = 属性(""幅"")[""行数""]
$MyBoolean = 属性(""幅"")[""読み取り専用""]
$MyBoolean =attribute(""Width"")[""sequential""] (「YES」は true に強制されるため)
$MyList = 属性(""幅"")[""推奨""]
$MyString = 属性(""幅"")[""タイプ""]
リテラル (つまり、実際の) 属性名またはキーを使用する場合は、上記のように単語を引用符で囲むことをお勧めします。前のコード例のように変数を使用する場合、Tinderbox パーサーがリテラルと変数の使用法を検出するのに役立つため、引用符は使用されません。
属性カテゴリ
すべての属性は組織グループに属し、これはカテゴリ プロパティに保存されます。システム属性は一連のグループで構成されますが、すべてのユーザー属性はグループ「user」に含まれることに注意してください。
キー値の編集
一部のキーはアクション コードを介して変更できますが、その他はすべて読み取り専用です。アクションにより、属性のデフォルト、説明、行、または推奨値が変更される場合があります。
属性(""属性名"")[""推奨""]=""値 1; 値 2"";
属性の推奨値リストに 2 つの値を設定します。同様に、デフォルト値を設定できます。
属性(""属性名"")[""デフォルト""]=""値 1"";
または説明:
attribute(""Price"")[""description""]=""商品の価格。"";
したがって、たとえば、アクション コードは属性の個別の値を検索し (values() やcollect() などを使用)、そのリストを使用して属性の推奨値 (つまり、推奨キー値) を設定/更新します。
プロパティ値の設定
設定する属性名および/またはファセットの両方を引用符で囲むことができます (以前は、引用符を使用するとエラーが発生していました)。
属性(属性名)[ファセット]=""テスト"";
または
属性(""属性名"")[""ファセット""]=""テスト"";"
attributeEncode(dataStr),Function,Item,Formatting,String,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"attributeEncode(dataStr)
This function encodes all instances of the following in the argument string dataStr to numeric HTML entities . Thus:
* left angle bracket → &amp;lt; 
* right angle bracket → &amp;gt; 
* ampersand → &amp;amp; 
* (straight) double quote → &amp;quot; 
* (straight) apostrophe → &amp;apos; 
* line feed character (ASCII #10) → &amp;#10; 
**This assists with OPML work as paragraph breaks are not allowed within XML attribute values.
For example, if the source dataStr is ""this & that"":
	$MyString = attributeEncode(""this & that"") outputs ""this &amp;amp; that"".
An older export code equivalent was ^^opmlEncode()^^; the latter is deprecated in favour of the form ^^value(attributeEncode(…))^^.
XML export
As attributeEncode() encodes all the unsafe XML characters, this operator can be thought of as 'xmlEncode()', so can even be used to encode $Text.
For website XML sitemaps, e.g. for indexing/SEO purposes, that need to report page URLs in XML (as opposed to HTML) avoid ^^path^^ but instead use ^^value(attributeEncode($HTMLExportPath))^^.","属性エンコード(dataStr)
この関数は、引数文字列 dataStr 内の次のすべてのインスタンスを数値 HTML エンティティにエンコードします。したがって:
* 左山括弧 → &amp;lt;
* 直角括弧 → &amp;gt;
* アンパサンド → &amp;amp;
* (ストレート) ダブルクォーテーション → &amp;quot;
* (ストレート) アポストロフィ → &amp;apos;
* 改行文字 (ASCII #10) → &amp;#10;
**XML 属性値内では段落区切りが許可されないため、これは OPML 作業に役立ちます。
たとえば、ソース dataStr が「this & that」の場合:
$MyString =attributeEncode(""this & that"") は、「this &amp;amp; that」を出力します。
同等の古いエクスポート コードは ^^opmlEncode()^^; でした。後者は非推奨となり、^^value(attributeEncode(…))^^ という形式が優先されます。
XMLエクスポート
attributeEncode() はすべての安全でない XML 文字をエンコードするため、この演算子は「xmlEncode()」と考えることができ、$Text のエンコードにも使用できます。
Web サイトの XML サイトマップの場合、例:インデックス作成や SEO の目的で、(HTML ではなく) XML でページ URL を報告する必要がある場合は、^^path^^ を避け、代わりに ^^value(attributeEncode($HTMLExportPath))^^ を使用します。"
"avg_if(scope, condition, expressionStr)",Function,Conditional Group,Mathematical,Number,false,4.6.0,Baseline,,,,3,true,false,false,false,false,true,true,false,false,,false,"avg_if(scope, condition, expressionStr)
The function avg_if() computes the arithmetic mean of a list of the values of scope items, and returns a List-type data. Each of the items in scope (defining scope) is tested and ignored it if it fails to meet condition, otherwise items supply a value to then adding the value of each list item evaluated using the designated expressionStr. Be aware that the per-item value might be a literal value, an attribute value, or a value/string of content based on that item's expressionStr.
For a related, less focussed, operator see avg().
This computes the arithmetic mean of the value of a expressionStr in a group, as filtered by a condition expression. See avg() for a for a related non-conditional operator.
scope describes the note(s) to be examined and may be any group designator including a find() query.
condition is action code forming a valid conditional query test, i.e. it equates to true when matched. Some query-style operators terms may allow use of regular expressions.
expressionStr may be any valid expression, but will usually be a reference to an attribute; short form Boolean attribute expressions are acceptable.
For example:
	$MyNumber = avg_if(children(/Catalog),$Price!=0,$Price); 
sets $MyNumber to the average price of all the items in Catalog, ignoring any items that have a price of 0.","avg_if(スコープ、条件、式Str)
関数 avg_if() は、スコープ項目の値のリストの算術平均を計算し、リスト型データを返します。スコープ (スコープの定義) 内の各項目がテストされ、条件を満たさない場合は無視されます。それ以外の場合、項目は値を提供し、指定されたexpressionStrを使用して評価された各リスト項目の値を追加します。アイテムごとの値は、リテラル値、属性値、またはそのアイテムのexpressionStrに基づくコンテンツの値/文字列である可能性があることに注意してください。
関連する、あまり焦点を当てていない演算子については、avg() を参照してください。
これは、条件式でフィルタリングされた、グループ内のexpressionStrの値の算術平均を計算します。関連する非条件演算子については、avg() を参照してください。
スコープは検査するメモを記述し、find() クエリを含む任意のグループ指定子にすることができます。
条件は、有効な条件付きクエリ テストを形成するアクション コードです。つまり、一致すると true と同等になります。一部のクエリ スタイルの演算子の用語では、正規表現の使用が許可されている場合があります。
expressionStr には任意の有効な式を指定できますが、通常は属性への参照になります。短い形式のブール属性式も使用できます。
たとえば:
$MyNumber = avg_if(children(/Catalog),$Price!=0,$Price);
$MyNumber をカタログ内のすべてのアイテムの平均価格に設定し、価格が 0 のアイテムを無視します。"
"avg(scope, expressionStr)",Function,Group,Mathematical,Number,false,4.6.0,Baseline,,,,2,true,false,true,false,false,true,false,false,false,,false,"avg(scope, expressionStr)
This computes the arithmetic mean of the value of a expressionStr in a scope. See avg_if() for a for a related conditional operator.
scope describes the notes to be examined and may be any group designator including a find() query.
expressionStr may be any valid expression, but will usually be a reference to an attribute; short form Boolean attribute expressions are acceptable.
For example:
	$MyNumber = avg(children(/Catalog),$Price); 
returns the average price of all the items in Catalog.","avg(スコープ, 式Str)
これは、スコープ内のexpressionStrの値の算術平均を計算します。関連する条件演算子については、avg_if() を参照してください。
スコープは検査するメモを記述し、find() クエリを含む任意のグループ指定子にすることができます。
expressionStr には任意の有効な式を指定できますが、通常は属性への参照になります。短い形式のブール属性式も使用できます。
たとえば:
$MyNumber = avg(子供(/カタログ),$価格);
カタログ内のすべてのアイテムの平均価格を返します。"
"between(valueNum, minNum, maxNum)",Function,Item,Query Boolean,boolean test,false,5.0.0,Baseline,,,,3,true,false,false,false,false,false,false,false,false,,false,"between(valueNum, minNum, maxNum)
Returns Boolean true if the valueNum is greater or equal to minNum and less than maxNum. The comparison method is based on the type of valueNum; numerical, lexical, string and set comparisons are chosen as needed.
The logic is:
	((valueNum >= minNum) & (valueNum true if valueNum==minNum but false if valueNum==maxNum.
If $MyNumber is 7, then:
	$MyBoolean = between($MyNumber, 1, 5); is false 
	$MyBoolean = between($MyNumber, 1, 9); is true 
More realistically the operator would be used in a query or a conditional expression:
	if(between($MyNumber, 1, 5)){…}else{…}; would test as true and execute the code in the first conditional branch.
Do not use this operator for testing Date-type attributes directly. Either use days() instead or use between() with format() or Date.format() to create a suitable string values for testing.
In the query creation pop-ups of agent and Find dialogs this function is listed as ""is between"".
Legacy issues
This operator replaces the legacy #between query operator.","between(valueNum, minNum, maxNum)
valueNum が minNum 以上、maxNum 未満の場合、ブール値 true を返します。比較方法は valueNum のタイプに基づきます。数値、語彙、文字列、セットの比較が必要に応じて選択されます。
ロジックは次のとおりです。
((valueNum >= minNum) & (valueNum valueNum==minNum の場合は true、valueNum==maxNum の場合は false。
$MyNumber が 7 の場合、次のようになります。
$MyBoolean = between($MyNumber, 1, 5);偽です
$MyBoolean = between($MyNumber, 1, 9);それは本当です
より現実的には、演算子はクエリまたは条件式で使用されます。
if(between($MyNumber, 1, 5)){…}else{…};true としてテストされ、最初の条件分岐でコードが実行されます。
日付型属性を直接テストするためにこの演算子を使用しないでください。代わりに days() を使用するか、 between() を format() または Date.format() とともに使用して、テストに適した文字列値を作成します。
エージェントのクエリ作成ポップアップと検索ダイアログでは、この関数は「間にある」としてリストされます。
従来の問題
この演算子は、従来の #between クエリ演算子を置き換えます。"
capitalize(dataStr),Function,Item,Formatting,String,false,4.6.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"capitalize(dataStr)
The contents of text string dataStr is returned with the first letter of each word in upper case.
Functionally equivalent to String.capitalize.
if $MyString is ""hello world"":
	$MyString = $MyString.capitalize(); 
sets it to ""Hello World"".","大文字化(dataStr)
テキスト文字列 dataStr の内容は、各単語の最初の文字が大文字で返されます。
機能的には String.capitalize と同等です。
$MyString が「hello world」の場合:
$MyString = $MyString.capitalize();
「Hello World」に設定します。"
ceil(sourceNum),Function,Item,Mathematical,Number,false,6.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"ceil(sourceNum)
rounds the number value of sourceNum up to next whole integer.
See also Number.floor() and Number.round().
If $MyNumber is 3.2 then:
	$MyNumber = ceil($MyNumber); 
sets $MyNumber to 4. Note unlike normal rounding the value is set upwards to the next integer (i.e. whole number).","ceil(ソース番号)
sourceNum の数値を次の整数に切り上げます。
Number.floor() および Number.round() も参照してください。
$MyNumber が 3.2 の場合:
$MyNumber = ceil($MyNumber);
$MyNumber を 4 に設定します。通常の四捨五入とは異なり、値は次の整数 (つまり、整数) に上方に設定されることに注意してください。"
changed([scope]),Operator,Item,Data manipulation,success boolean,false,9.6.0,Baseline,,,,1,false,true,false,false,false,true,false,true,false,,false,"changed()
changed([scope])
The changed() operator tells the current item to update itself. A likely use for the operator is to refresh Poster notes. There is an optional scope argument, indicating which note(s) need updating. If no scope argument is passed, the target is assumed to be the currently selected note.
The operator needs no left-side argument, so may be called as a simple expression:
	changed(); 
or, more specifically:
	changed(""Some poster note"");","変更されました()
変更されました([スコープ])
Changed() 演算子は、現在の項目にそれ自体を更新するように指示します。このオペレータの用途として考えられるのは、ポスター ノートを更新することです。オプションのスコープ引数があり、どのノートを更新する必要があるかを示します。スコープ引数が渡されない場合、ターゲットは現在選択されているノートであるとみなされます。
演算子は左側の引数を必要としないため、単純な式として呼び出すことができます。
変更されました();
または、より具体的には:
Changed(""あるポスターノート"");"
"collect_if(scope, condition, expressionStr)",Function,Conditional Group,"Dictionary, Set & List operations",List,false,4.0.0,Baseline,,,,3,true,false,true,false,true,true,true,false,false,,false,"collect_if(group, condition, expressionStr)
The function collect_if() returns a List by collecting all the notes in scope (defining scope), testing each note in scope and ignoring it if it fails to meet condition, then adding the value of each list item evaluated using the designated expressionStr. Be aware that the per-item value might be a literal value, an attribute value, or a value/string of content based on that item's expressionStr.
For a related, less focussed, operator see collect().
scope may be any group designator, or group defined by find(). In addition, scope may be argument that designates a particular (single) note other than 'this' collect() omits notes for which $Searchable is false.
condition is action code forming a valid conditional test, i.e. it equates to true when matched.
expressionStr can be any expression, but is typically an attribute's name. If the collected per-item value type is multi-value, i.e. Set or a List type data , collect() adds its elements to the returned list. Thus if an item's evaluated value is a list of 3 terms, that item contributes 3 items to the operator's returned list rather than 1 item.
If the collected expressionStr is not a Set or List type attribute, but contains a semicolon, quotation mark, or parentheses, the value will be added to the result as a quoted string. This behaviour is designed correct a variety of confusing edge cases.
For example,
	$MyList = collect_if(children,$Status==""Important"",$Name); 
will construct a List of the names of all of this note's important children.
Note that collect_if's function is related to agents; many tasks you might perform with collect_if could be done as well, or better, with an agent. 
If a list of unique values is required, i.e. set rather than a list, simply pass the output to a Set attribute. Thus if:
	$MyList = collect_if(children,$Age>6,$FavFruit); $MyList is [Apples;Oranges;Pears;Apples]
	$MySet = collect(children,$Age>6,$FavFruit); $MySet is [Apples;Oranges;Pears] 
If the collected attribute is a Set or a List, collect() adds its elements to the result. If the collected attribute is not a Set or a List, but contains a semicolon, quotation mark, or parentheses, the value will be added to the result as a quoted string. This should avoid a variety of confusing edge case outcomes.
collect_if() resets its regular expression match list for each note it tests. Thus, $1 will be the first matched subexpression for this note, rather than the first matched subexpression for the entire collect_if() statement.
collect_if() vs. list.collect_if()
For working with Lists or Sets of actual values, also see list.collect_if().","collect_if(グループ、条件、式Str)
関数collect_if()は、スコープ内のすべてのノートを収集し(スコープを定義)、スコープ内の各ノートをテストし、条件を満たさない場合は無視し、指定されたexpressionStrを使用して評価された各リスト項目の値を追加することによってリストを返します。アイテムごとの値は、リテラル値、属性値、またはそのアイテムのexpressionStrに基づくコンテンツの値/文字列である可能性があることに注意してください。
関連する、あまり焦点を当てていない演算子については、collect() を参照してください。
スコープには、任意のグループ指定子、または find() で定義されたグループを指定できます。さらに、scope は、「this」以外の特定の (単一の) ノートを指定する引数である場合があります。collect() は、$Searchable が false であるノートを省略します。
条件は、有効な条件テストを形成するアクション コードです。つまり、一致すると true となります。
expressionStr には任意の式を指定できますが、通常は属性の名前です。収集された項目ごとの値のタイプが複数値である場合、つまり Set または List タイプの data の場合、collect() は返されたリストにその要素を追加します。したがって、項目の評価値が 3 つの項のリストである場合、その項目は演算子の返されるリストに 1 つの項目ではなく 3 つの項目を与えます。
収集されたexpressionStrがSetまたはListタイプの属性ではなく、セミコロン、引用符、または括弧が含まれている場合、値は引用符で囲まれた文字列として結果に追加されます。この動作は、さまざまな混乱を招くエッジケースを修正するように設計されています。
たとえば、
$MyList =collect_if(children,$Status==""重要"",$Name);
このメモの重要な子のすべての名前のリストを作成します。
collect_if の関数はエージェントに関連していることに注意してください。collect_if を使用して実行できるタスクの多くは、エージェントを使用しても同様に、あるいはそれ以上に実行できます。
一意の値のリストが必要な場合、つまりリストではなくセットの場合は、単純に出力を Set 属性に渡します。したがって、次の場合:
$MyList =collect_if(子供,$年齢>6,$FavFruit);$MyList は [リンゴ;オレンジ;梨;リンゴ] です
$MySet =collect(子供,$年齢>6,$FavFruit);$MySet は [リンゴ;オレンジ;梨]
収集された属性が Set または List の場合、collect() はその要素を結果に追加します。収集された属性が Set または List ではなく、セミコロン、引用符、または括弧が含まれている場合、値は引用符で囲まれた文字列として結果に追加されます。これにより、さまざまな混乱を招くエッジケースの結果が回避されます。
collect_if() は、テストするメモごとに正規表現一致リストをリセットします。したがって、$1 は、collect_if() ステートメント全体で最初に一致した部分式ではなく、このメモで最初に一致した部分式になります。
collect_if() と list.collect_if() の比較
実際の値のリストまたはセットの操作については、list.collect_if() も参照してください。"
"collect(scope, expressionStr)",Function,Group,"Dictionary, Set & List operations",List,false,4.0.0,Baseline,,,,2,true,false,true,false,false,true,false,false,false,,false,"collect(scope, expressionStr)
The function collect returns a List by collecting all the notes in scope (defining scope), and adding the value of each list item evaluated using the designated expressionStr. Be aware that the per-item value might be a literal value, an attribute value, or a value/string of content based on that item's expressionStr. 
For a related, more focussed, operator see collect_if().
scope may be any group designator, or group defined by find(). In addition, scope may be argument that designates a particular (single) note other than 'this'. collect() omits notes for which $Searchable is false.
expressionStr can be any expression, but is typically an attribute's name. If the collected per-item value type is multi-value, i.e. Set or a List type data , collect() adds its elements to the returned list. Thus if an item's evaluated value is a list of 3 terms, that item contributes 3 items to the operator's returned list rather than 1 item.
If the collected expressionStr is not a Set or List type attribute, but contains a semicolon, quotation mark, or parentheses, the value will be added to the result as a quoted string. This behaviour is designed correct a variety of confusing edge cases.
For example,
	$MyList = collect(children,$Name); 
constructs a set with the name of each child of the note.
For example,
	$MyList = collect(children(/agents/books),$Name); 
does the same for children of the note 'books' inside 'agents'.
	$MyList = collect(children,$Width * $Height); 
collects a series of numerical values of each child's map icon height/width in Tinderbox map units. Thus if a child had a $Width of 4 and $Height of 2, the collect() result for that item would be 8.
If a list of unique values is required, i.e. set rather than a list, simply pass the output to a Set attribute. Thus if:
	$MyList = collect(children,$FavFruit); $MyList is [Apples;Oranges;Pears;Apples]
	$MySet = collect(children,$FavFruit); $MySet is [Apples;Oranges;Pears]
collect() vs. list.collect()
For working with Lists or Sets of actual values, also see list.collect().","収集(スコープ、式Str)
関数collectは、スコープ(スコープを定義)内のすべてのメモを収集し、指定されたexpressionStrを使用して評価された各リスト項目の値を追加することによってリストを返します。アイテムごとの値は、リテラル値、属性値、またはそのアイテムのexpressionStrに基づくコンテンツの値/文字列である可能性があることに注意してください。
関連する、より焦点を当てた演算子については、collect_if() を参照してください。
スコープには、任意のグループ指定子、または find() で定義されたグループを指定できます。さらに、スコープは「this」以外の特定の（単一の）ノートを指定する引数である場合があります。collect() は、$Searchable が false のメモを省略します。
expressionStr には任意の式を指定できますが、通常は属性の名前です。収集された項目ごとの値のタイプが複数値である場合、つまり Set または List タイプの data の場合、collect() は返されたリストにその要素を追加します。したがって、項目の評価値が 3 つの項のリストである場合、その項目は演算子の返されるリストに 1 つの項目ではなく 3 つの項目を与えます。
収集されたexpressionStrがSetまたはListタイプの属性ではなく、セミコロン、引用符、または括弧が含まれている場合、値は引用符で囲まれた文字列として結果に追加されます。この動作は、さまざまな混乱を招くエッジケースを修正するように設計されています。
たとえば、
$MyList = 収集(子供たち,$Name);
ノートの各子の名前を含むセットを構築します。
たとえば、
$MyList =collect(children(/agents/books),$Name);
「エージェント」内のノート「ブック」の子に対しても同じことを行います。
$MyList = 収集(子供,$幅 * $高さ);
Tinderbox マップ単位で、各子のマップ アイコンの高さ/幅の一連の数値を収集します。したがって、子の $Width が 4 で $Height が 2 の場合、その項目のcollect() の結果は 8 になります。
一意の値のリストが必要な場合、つまりリストではなくセットの場合は、単純に出力を Set 属性に渡します。したがって、次の場合:
$MyList = 収集(子供たち,$FavFruit);$MyList は [リンゴ;オレンジ;梨;リンゴ] です
$MySet = 収集(子供,$FavFruit);$MySet は [リンゴ;オレンジ;梨]
collect() と list.collect() の比較
実際の値のリストまたはセットの操作については、list.collect() も参照してください。"
Color.blue(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.blue()
Color.blue
This property sets or returns the value of the blue channel of an RGB colour. The value may be set with a number (0–255) or hex number (#00–#ff). The return value (if coerced to a string or number) is always a number, i.e. 255 and not #ff. By comparison the rgb() operator requires that the values for all three colour channels be set. Examples:
	$MyColor.blue = 255; 
	$MyColor.blue = ""#ff""; 
	$MyOtherColor.green = $MyColor.blue; (value of $MyOtherColor green channel is that of $MyColor blue channel)
	$MyNumber = $MyColor.blue;  (gives 255)
	$MyString = $MyColor.blue;  (gives ""255"")","Color.blue()
カラー.ブルー
このプロパティは、RGB カラーの青チャネルの値を設定または返します。値は数値 (0 ～ 255) または 16 進数 (#00 ～ #ff) で設定できます。戻り値 (文字列または数値に強制された場合) は常に数値、つまり #ff ではなく 255 になります。比較すると、rgb() 演算子では、3 つのカラー チャネルすべての値を設定する必要があります。例:
$MyColor.blue = 255;
$MyColor.blue = ""#ff"";
$MyOtherColor.green = $MyColor.blue;($MyOtherColor 緑チャネルの値は、$MyColor 青チャネルの値です)
$MyNumber = $MyColor.blue;(255を与えます)
$MyString = $MyColor.blue;(「255」を与えます)"
Color.brightness(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.brightness()
Color.brightness
This property sets or returns the brightness value of the associated Color-type attribute. The value is a number in the range 0-100. This operator is intended to replace the existing brightness() operator. Examples:
	$MyColor.brightness = 50; (sets 50% brightness)
	$MyColor2.brightness = $MyColor.brightness; (matches brightness levels) 
	$MyNumber = $MyColor.brightness; (returns 50, from above example)","カラー.明るさ()
色.明るさ
このプロパティは、関連付けられた Color-type 属性の明るさの値を設定または返します。値は 0 ～ 100 の範囲の数値です。この演算子は、既存の Brightness() 演算子を置き換えることを目的としています。例:
$MyColor.brightness = 50;(明るさを 50% に設定します)
$MyColor2.brightness = $MyColor.brightness;(明るさのレベルに一致します)
$MyNumber = $MyColor.brightness;(上記の例では 50 を返します)"
Color.format(),Function,Item,Formatting,String,false,5.8.0,Baseline,,,,,true,true,false,false,false,false,false,false,false,,false,"Color.format()
Returns Color as a hex-string, regardless of source data is a hex value or named color.
Thus if $MyColor is ""bright red"":
	$MyString = $MyColor.format(); gives ""#ff0000""
	$MyString = $MyColor; gives ""bright red""
Whilst if $MyColor is ""#330099"":
	$MyColor.format(); gives ""#330099""
	$MyString = $MyColor; gives ""#330099""
Therefore for a Color-type attribute set to a named colour, to get that name string simply pass the attribute's value to a string. So if $MyColor is ""bright blue"", this:
	$MyString = $MyColor; 
…gives ""bright blue"" and this:
	$MyString = $MyColor + "" (""+$MyColor.format()+"")""; 
…gives ""bright blue (#0000ff)"".
This supplements the existing format() function.","カラー.フォーマット()
ソース データが 16 進値であるか名前付きの色であるかに関係なく、色を 16 進文字列として返します。
したがって、$MyColor が「明るい赤」の場合:
$MyString = $MyColor.format();「#ff0000」を与える
$MyString = $MyColor;「鮮やかな赤」になります
一方、$MyColor が「#330099」の場合:
$MyColor.format();「#330099」を与える
$MyString = $MyColor;「#330099」を与える
したがって、名前付きの色に設定された Color タイプの属性の場合、その名前の文字列を取得するには、属性の値を文字列に渡すだけです。$MyColor が「明るい青」の場合、次のようになります。
$MyString = $MyColor;
…「明るい青」とこれを与えます:
$MyString = $MyColor + "" (""+$MyColor.format()+"")"";
…「明るい青(#0000ff)」になります。
これは既存の format() 関数を補完します。"
Color.green(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.green()
Color.green
This property sets or returns the value of the green channel of an RGB colour. The value may be set with a number (0–255) or hex number (#00–#ff). The return value (if coerced to a string or number) is always a number, i.e. 255 and not #ff. By comparison the rgb() operator requires that the values for all three colour channels be set. Examples:
	$MyColor.green = 255; 
	$MyColor.green = ""#ff""; 
	$MyOtherColor.red = $MyColor.green; (value of $MyOtherColor red channel is that of $MyColor green channel)
	$MyNumber = $MyColor.green;  (gives 255)
	$MyString = $MyColor.green;  (gives ""255"")","Color.green()
カラー.グリーン
このプロパティは、RGB カラーの緑チャネルの値を設定または返します。値は数値 (0 ～ 255) または 16 進数 (#00 ～ #ff) で設定できます。戻り値 (文字列または数値に強制された場合) は常に数値、つまり #ff ではなく 255 になります。比較すると、rgb() 演算子では、3 つのカラー チャネルすべての値を設定する必要があります。例:
$MyColor.green = 255;
$MyColor.green = ""#ff"";
$MyOtherColor.red = $MyColor.green;($MyOtherColor 赤チャネルの値は $MyColor 緑チャネルの値です)
$MyNumber = $MyColor.green;(255を与えます)
$MyString = $MyColor.green;(「255」を与えます)"
Color.hue(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.hue()
Color.hue
This property sets or returns the hue value of the associated Color-type attribute. The value is a number in the range 0-360. This operator is intended to replace the existing hue() operator. Examples:
	$MyColor.hue = 270; (sets hue of 270 degrees)
	$MyColor2 = $MyColor.hue; (matches hues) 
	$MyNumber = $MyColor.hue; (returns 270, from above example)","Color.hue()
色・色合い
このプロパティは、関連付けられた Color-type 属性の色相値を設定または返します。値は 0 ～ 360 の範囲の数値です。この演算子は、既存の hue() 演算子を置き換えることを目的としています。例:
$MyColor.hue = 270;(色相を270度に設定)
$MyColor2 = $MyColor.hue;(色合いは一致します)
$MyNumber = $MyColor.hue;(上記の例では 270 を返します)"
Color.red(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.red()
Color.red
This property sets or returns the value of the blue channel of an RGB colour. The value may be set with a number (0–255) or hex number (#00–#ff). The return value (if coerced to a string or number) is always a number, i.e. 255 and not #ff. By comparison the rgb() operator requires that the values for all three colour channels be set. Examples:
	$MyColor.red = 255; 
	$MyColor.red = ""#ff""; 
	$MyOtherColor.blue = $MyColor.red;  (value of $MyOtherColor blue channel is that of $MyColor red channel)
	$MyNumber = $MyColor.red;  (gives 255)
	$MyString = $MyColor.red;  (gives ""255"")","Color.red()
カラー.レッド
このプロパティは、RGB カラーの青チャネルの値を設定または返します。値は数値 (0 ～ 255) または 16 進数 (#00 ～ #ff) で設定できます。戻り値 (文字列または数値に強制された場合) は常に数値、つまり #ff ではなく 255 になります。比較すると、rgb() 演算子では、3 つのカラー チャネルすべての値を設定する必要があります。例:
$MyColor.red = 255;
$MyColor.red = ""#ff"";
$MyOtherColor.blue = $MyColor.red;($MyOtherColor 青チャンネルの値は $MyColor 赤チャンネルの値です)
$MyNumber = $MyColor.red;(255を与えます)
$MyString = $MyColor.red;(「255」を与えます)"
Color.saturation(),Property,Item,Color,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Color.saturation()
Color.saturation
This property sets or returns the saturation value of the associated Color-type attribute. The value is a number in the range 0-100. This operator is intended to replace the existing saturation() operator. Examples:
	$MyColor.saturation = 50; (sets 50% saturation)
	$MyColor2.saturation = $MyColor.saturation; (matches saturation levels) 
	$MyNumber = $MyColor.saturation; (returns 50, from above example)","Color.saturation()
色・彩度
このプロパティは、関連付けられた Color-type 属性の彩度値を設定または返します。値は 0 ～ 100 の範囲の数値です。この演算子は、既存の saturation() 演算子を置き換えることを目的としています。例:
$MyColor.saturation = 50;(彩度を 50% に設定します)
$MyColor2.saturation = $MyColor.saturation;(飽和レベルに一致)
$MyNumber = $MyColor.saturation;(上記の例では 50 を返します)"
compositeFor(nameStr),Function,Composite,Composite,List,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr)
returns a List-type list of paths of all notes in the composite containing note nameStr.
	$MyList = compositeFor(""Total""); 
By using designator this for item, any note in the composite can refer to its containing composite.
	$MyList = compositeFor(this); 
If the name of a composite is known, but not the note name(s) or any of its constituents, use compositeWithName().","複合対象(nameStr)
ノート nameStr を含むコンポジット内のすべてのノートのパスのリスト型リストを返します。
$MyList =複合For(""合計"");
item に指定子 this を使用すると、コンポジット内のすべてのメモが、そのメモを含むコンポジットを参照できます。
$MyList = 複合For(this);
コンポジットの名前はわかっているが、音名やその構成要素がわからない場合は、compositeWithName() を使用します。"
compositeFor(nameStr):count,Property,Composite,Composite,Number,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):count
returns the Number of notes in the composite containing note nameStr.
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MyNumber = compositeFor(this):count; 
	$MyNumber = my:count;","複合対象(nameStr):カウント
音名Strを含むコンポジット内の音符の数を返します。
このコードでは、「my」指定子を使用して短い形式を指定することもできます。これらは機能的に同等です。
$MyNumber = 複合For(this):count;
$MyNumber = 私の:カウント;"
compositeFor(nameStr):kind,Property,Composite,Composite,String,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):kind
returns the String name of the composite from which the composite containing note nameStr was instantiated.
For example, if a composite was created from the built-in 'list' composite, this function will return ""list"". The query:
	$MyString = compositeFor(this):kind==""book""; 
would locate all notes that participate in composites instantiated from ""book"" – all books.
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MyString = compositeFor(this):kind; 
	$MyString = my:kind;","複合対象(nameStr):種類
note nameStr を含むコンポジットがインスタンス化されたコンポジットの文字列名を返します。
たとえば、コンポジットが組み込みの「list」コンポジットから作成された場合、この関数は「list」を返します。クエリ:
$MyString = complexFor(this):kind==""本"";
「book」からインスタンス化されたコンポジットに参加するすべてのノート (すべての書籍) が検索されます。
このコードでは、「my」指定子を使用して短い形式を指定することもできます。これらは機能的に同等です。
$MyString = 複合For(this):種類;
$MyString = 私の:種類;"
compositeFor(nameStr):name,Property,Composite,Composite,String,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):name
returns the String name of the composite containing note nameStr. This expression is read/write: 
	$MyString = compositeFor(this):name=""example""; 
renames the composite containing the note running this code to 'example'.
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MyString = compositeFor(this):name; 
	$MyString = my:name;","複合対象(nameStr):名前
note nameStr を含むコンポジットの文字列名を返します。この式は読み取り/書き込み可能です。
$MyString =複合For(this):name=""例"";
このコードを実行するメモを含むコンポジットの名前を「example」に変更します。
このコードでは、「my」指定子を使用して短い形式を指定することもできます。これらは機能的に同等です。
$MyString = 複合対象(この):名前;
$MyString = 私の:名前;"
compositeFor(nameStr):role(roleStr),Property,Composite,Composite,List,false,7.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):role(roleStr)
returns a List-type list of paths of all notes in the composite containing note nameStr, but including only the note or notes with the designated role roleStr. For example, to set the color of all notes with the role ""author"": 
	$MyList = $Color(compositeFor(""great books""):role(""author""))=""red""; 
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MyList = compositeFor(this):role(""some role""); 
	$MyList = my:role(""some role"");","複合対象(nameStr):role(roleStr)
ノート nameStr を含むコンポジット内のすべてのノートのパスのリスト型リストを返しますが、指定されたロール roleStr を持つノートのみが含まれます。たとえば、ロール「author」を持つすべてのノートの色を設定するには、次のようにします。
$MyList = $Color(compositeFor(""素晴らしい本""):role(""著者""))=""赤"";
このコードでは、「my」指定子を使用して短い形式を指定することもできます。これらは機能的に同等です。
$MyList = complexFor(this):role(""ある役割"");
$MyList = my:role(""ある役割"");"
compositeFor(nameStr):roles,Property,Composite,Composite,Set,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeFor(nameStr):roles
returns a Set-type list of roles that appear in the composite containing note nameStr.
This code can also use the 'my' designator to give a shorter form. These are functional equivalents:
	$MySet = compositeFor(this):roles; 
	$MySet = my:roles;","複合対象(nameStr):役割
note nameStr を含むコンポジットに表示されるロールの Set タイプのリストを返します。
このコードでは、「my」指定子を使用して短い形式を指定することもできます。これらは機能的に同等です。
$MySet = 複合For(this):役割;
$MySet = 私の:役割;"
compositeWithName(compositeNameStr),Function,Composite,Composite,List,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"compositeWithName(compositeNameStr)
returns a List-type list of paths of all notes within the composite with the name compositeNameStr. If several composites have the same name, data for only one of those composites is returned (first match by $OutlineOrder).
	$MyList = compositeWithName(""Lecture 16"");t
If working in the context of a note already in a composite, compositeFor(this) will also return an appropriate list of paths.","complexWithName(compositeNameStr)
は、compositeNameStr という名前のコンポジット内のすべてのノートのパスのリスト型リストを返します。複数のコンポジットが同じ名前を持つ場合、それらのコンポジットのうちの 1 つのデータのみが返されます ($OutlineOrder による最初の一致)。
$MyList = complexWithName(""講義 16"");t
すでにコンポジット内にあるノートのコンテキストで作業している場合、compositeFor(this) は適切なパスのリストも返します。"
contains(item),Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,1,true,false,true,false,true,false,false,false,false,,false,"contains(item)
Returns Boolean true if the note evaluated from a single  item is a direct child of the current note or, put conversely, if the note is the parent of item. Thus it can be thought of as an ""is parent of"" operator and, as such, a counterpart to the ""is a child of"" operator inside().
The item argument must be quoted unless an attribute reference. Ways to define item.
Examples:
	contains(""/foo"") 
This is a full path so can match only the root-level note 'foo'. But:
	contains(""bar"") 
could match any note with the name 'bar' of which there may be more than one. If there is more that one, Tinderbox chooses one. This is fine if one match was desired but if there are known to be multiple 'bar' notes and it is desired to locate parent container of every one, then a different approach is needed, using any(): the process is described under any().
NOTE: Checking attribute values, as opposed to object containment
There are a range of other tools to check if a String-, List- or Set-type attribute's value contains a desired search string/regex.
* For String attributes there are String.contains() and String.icontains().
* List and Set date type attributes also support .contains() and .icontains() though in this context the scope of regex matches is slightly different from that with a String-type attribute (see the linked articles).
* Single words alone can be checked using word(), which works across $Name, $Text and all String-type attributes.
Legacy issues
This operator replaces the legacy #contains query operator. The latter should not be used for new code.","含まれる(アイテム)
単一のアイテムから評価されたメモが現在のメモの直接の子である場合、または逆にメモがアイテムの親である場合は、ブール値 true を返します。したがって、これは「is の親である」演算子として考えることができ、したがって、「is a child of」演算子の inside() に相当するものと考えることができます。
item 引数は、属性参照でない限り引用符で囲む必要があります。項目を定義する方法。
例:
contains(""/foo"")
これはフルパスであるため、ルートレベルのノート「foo」のみに一致します。しかし:
contains(""バー"")
複数の可能性がある「bar」という名前を持つ任意の音符と一致する可能性があります。複数ある場合は、Tinderbox が 1 つを選択します。1 つの一致が必要な場合はこれで問題ありませんが、複数の「小節」音符が存在することがわかっていて、すべての親コンテナーを見つけたい場合は、any() を使用する別のアプローチが必要です。プロセスは any() で説明されています。
注: オブジェクトの包含ではなく、属性値のチェック
文字列、リスト、またはセットタイプの属性の値に目的の検索文字列/正規表現が含まれているかどうかを確認するためのツールは他にも多数あります。
* String 属性には String.contains() と String.icontains() があります。
* List および Set の日付型属性は .contains() および .icontains() もサポートしますが、このコンテキストでは正規表現一致の範囲が String 型属性の場合とは若干異なります (リンク先の記事を参照)。
* word() を使用して単一の単語だけをチェックできます。これは、$Name、$Text、およびすべての文字列型属性にわたって機能します。
従来の問題
この演算子は、従来の #contains クエリ演算子を置き換えます。後者は新しいコードには使用しないでください。"
cos(radiansNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"cos(radiansNum)
cos() converts its radiansNum, in radians, to the cosine of that value.
	$MyNumber = cos(6); 
returns 0.9601702867 for an input of 6 radians.","cos(ラジアン数)
cos() は、ラジアン単位の radiansNum をその値のコサインに変換します。
$MyNumber = cos(6);
6 ラジアンの入力に対して 0.9601702867 を返します。"
"count_if(scope, condition)",Function,Group,Data manipulation,Number,false,4.6.0,Baseline,,,,2,true,false,true,false,true,true,true,false,false,,false,"count_if(scope, condition)
Counts the number of notes in the list derived from scope that satisfy the evaluated expression condition.
scope describes the notes to be examined (defining scope).
condition is action code forming a valid conditional query test, i.e. it equates to true when matched. Some query-style operators terms may allow use of regular expressions.
This equivalent to use of sum_if(), as the next two code examples have the same result:
	 sum_if(group, condition,1) 
but this is perhaps more easily understood as:
	 count_if(group, condition)","count_if(スコープ、条件)
スコープから導出されたリスト内の、評価された式の条件を満たすノートの数をカウントします。
スコープには、調査対象の注意事項を記述します（スコープの定義）。
条件は、有効な条件付きクエリ テストを形成するアクション コードです。つまり、一致すると true と同等になります。一部のクエリ スタイルの演算子の用語では、正規表現の使用が許可されている場合があります。
次の 2 つのコード例では同じ結果が得られるため、これは sum_if() の使用と同等です。
sum_if(グループ, 条件,1)
しかし、これは次のように理解するほうが簡単かもしれません。
count_if(グループ, 条件)"
count(scope),Function,List,Data manipulation,Number,false,4.0.0,Baseline,,,,1,true,false,true,false,false,true,false,false,false,,false,"count(scope)
The function count() counts the Number of discrete items in the specified list, scope, which is defined as a group of items—i.e. one or more items. 
Most often, list may be a reference to a List or Set typed data. The list argument is evaluated so can use more than literal lists, including offset addresses like $Attribute(note) or more complex expressions to get data as long as the result is a list-based attribute (List or Set data types).
NOTE: where scope is a known List or Set type attribute reference, it is recommended and generally easier, and recommended, to use list.count (or alternatively the older less intuitive list.size); both the latter give the same outcome.
count(scope)
For example if $DisplayAttributes for the current note is [Color;AccentColor;NameFont] then the code
	$MyNumber = count($DisplayAttributes); 
is effectively
	$MyNumber = count([Color;AccentColor;NameFont]); 
and not surprisingly returns 3. Note that the count is not all unique values for the attribute across the whole TBX, scope is restricted to 'this' note or another nominated note. Specimen usage:
	$MyNumber = count($DisplayAttributes); 
	$MyNumber = count($DisplayAttributes(""some other note"")); 
To use count() with a list of items that are attributes or expressions, use list():
	Works: $MyNumber = count(list(4+2,9+6)); (output: 2)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Examples
The following is a trivial example (given we could use $ChildCount instead) but shows how count can be used in a more subtle way:
	$MyNumber = count(collect(children,$Name)); 
The result of collect is List-type data, in this case a number of note titles count(list) will return the number of values in the list (including duplicates). To get a de-duped count, chain the .unique operator to the list reference, inside the count() operator so the .unique filter is applied before the count is taken:
	$MyNumber = count(collect(children,$Name).unique);","カウント(スコープ)
関数 count() は、項目のグループとして定義される、指定されたリスト (スコープ) 内の個別の項目の数をカウントします。1 つ以上の項目。
ほとんどの場合、list は List または Set 型のデータへの参照である可能性があります。list 引数は評価されるため、結果がリストベースの属性 (List または Set データ型) である限り、$Attribute(note) のようなオフセット アドレスやデータを取得するためのより複雑な式など、リテラル リスト以上のものを使用できます。
注: スコープが既知の List または Set タイプの属性参照である場合、list.count (または、以前の直感的ではない list.size) を使用することが一般的に簡単であり、推奨されます。後者はどちらも同じ結果をもたらします。
カウント(スコープ)
たとえば、現在のノートの $DisplayAttributes が [Color;AccentColor;NameFont] の場合、コードは次のようになります。
$MyNumber = count($DisplayAttributes);
効果的には
$MyNumber = count([カラー;アクセントカラー;名前フォント]);
当然のことながら 3 が返されます。カウントは TBX 全体にわたる属性のすべての一意の値ではないことに注意してください。範囲は「この」ノートまたは指定された別のノートに制限されます。検体の使用:
$MyNumber = count($DisplayAttributes);
$MyNumber = count($DisplayAttributes(""他のメモ""));
属性または式である項目のリストで count() を使用するには、 list() を使用します。
動作: $MyNumber = count(list(4+2,9+6));(出力:2)
リスト項目がアクション コード式であるより複雑な例では、 eval() を使用して各リスト項目式をラップする必要がある場合があります。list(eval(式A),eval(式B))。
例
以下は簡単な例です (代わりに $ChildCount を使用できると仮定します) が、より巧妙な方法で count を使用する方法を示しています。
$MyNumber = count(collect(children,$Name));
収集の結果はリスト型のデータです。この場合、ノートタイトル数 count(list) はリスト内の値の数 (重複を含む) を返します。重複排除されたカウントを取得するには、 count() 演算子の内部で .unique 演算子をリスト参照に連結し、カウントが取得される前に .unique フィルターが適用されるようにします。
$MyNumber = count(collect(children,$Name).unique);"
"covid([stateStr, countryStr|zipCodeStr], aDate, keywordStr)",Function,Item,Data manipulation,Number,false,8.7.0,Baseline,,,,4,true,false,false,false,false,false,false,true,false,,false,"covid(zipCodeStr, dateStr, keywordStr)
covid(stateStr, countryStr, aDate, keywordStr)
The operator covid() returns information about the 2020 pandemic of the COVID-19 virus.
covid(zipCodeStr, aDate, keywordStr)
Returns the number of cases, deaths, and recoveries reported that day in the US country that contains this zip code. For example
	$MyNumber = covid(""02148"", date(2020,1,4), ""cases""); 
This returns the number of cases reported in Middlesex County, Massachusetts for 4 January 2020. The keywordStr argument may be a quoted string with any of the following values:
* cases
* deaths
* recoveries
* name (the name of the county)
covid(stateStr, countryStr, aDate, keywordStr)
A four-argument variant allows you to query results by US state:
	$MyNumber = covid(""MA"",""US"",date(2020,1,4),""recoveries""); 
This returns the number of recoveries reported for the date 4 January 2020, from Massachusetts.
Data Source
Data are as reported by the Johns Hopkins Center For Systems Science and Engineering, and are provided by CovidNearMe.org and are provided strictly for educational and academic research purposes. Please note: data are copyright 2020 Johns Hopkins University.","covid(zipCodeStr、dateStr、keywordStr)
covid(stateStr、countryStr、aDate、keywordStr)
演算子 covid() は、2020 年の COVID-19 ウイルスのパンデミックに関する情報を返します。
covid(zipCodeStr, aDate,keywordStr)
この郵便番号を含む米国の国でその日に報告された感染者数、死亡者数、回復者数を返します。たとえば
$MyNumber = covid(""02148"", date(2020,1,4), ""ケース"");
これは、2020 年 1 月 4 日にマサチューセッツ州ミドルセックス郡で報告された症例数を返します。keywordStr 引数は、次のいずれかの値を含む引用符で囲まれた文字列にすることができます。
* 場合
* 死亡者
* 回復
* 名前 (郡の名前)
covid(stateStr、countryStr、aDate、keywordStr)
4 つの引数のバリアントを使用すると、米国の州ごとに結果をクエリできます。
$MyNumber = covid(""MA"",""US"",date(2020,1,4),""回復"");
これは、マサチューセッツ州から 2020 年 1 月 4 日に報告された回収数を返します。
データソース
データはジョンズ・ホプキンス大学システム科学工学センターによって報告されたものであり、CovidNearMe.org によって提供されており、教育および学術研究の目的でのみ提供されます。注: データの著作権は 2020 ジョンズ ホプキンス大学にあります。"
"create([containerStr, ]nameStr)",Function,Item,Document configuration,String,false,8.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"create(name)
This creates a new note called nameStr at the designated location, and returns the full path to that note. If the designated note already exists, no new note is created and the operator returns the empty string.
The create() operator always returns the path to the new (or pre-existing) note.
This function needs no left-side expression argument, i.e. '$SomeAttribute=', to invoke it.
nameStr is typically actually a complete path:
	create(""/hardware/taps""); 
but if nameStr is a unique note $Name, a new note is created as a new (last) child of the current note, but only if nameStr does not already exist. For example:
	create(""taps""); 
Importantly, if nameStr is only a $Name and not a $Path, the note title nameStr it must be unique to the whole the current document. But, if nameStr is a $Path then it need only be unique within the current container. 
create(containerStr, nameStr)
A two-argument variant is also offered that allows the container for a new item to be specified, and the new item's $Name. The containerStr argument can be a path, an $ID, or an $IDString. This may be useful if you need to create several notes in the same container, for example is iterating a list with .each(). For example:
	create(""/hardware"",""taps""); 
Or, more pertinently, using a loop variable 'aPlace':
	$SomeList.each(aPlace){
		create(aPlace,""urgentTasks"");
	};
Essentially, the two-input form allows 3 forms of variation:
* different path, different name (via two nested loops—one for paths, one for names)
* different path, same name (loop with path variants)
* same path, different name (loop with name variants)
Designators and evaluation
Paths like that below, which mix literal and computed values are not evaluated, nor are inline designators:
	create(/Resources/Test/$MyString) 
Instead use code like this:
	var path=""/Resources/Test/""+$MyString;
	create(path);
Testing for pre-existing notes
Although create() will not re-create a note that already exists, a scenario in a big/complex document occurs where it may be necessary to run a number of action once only on newly created notes. How to test for a note already existing? Here is one possible solution:
	var:string vTestPath = ""/foo/bar/baz"";
	var:string vTest = $IDString(vTestPath);
	if(vTest==""""){
		$Text = create(vTestPath);
		// do tasks only needed once, for new notes
	};
A non-existent note cannot have an $IDString value. So by testing the $IDString(path) for the path of the note to be created before calling create(path), it is possible to ensure create() is only called if needed and in context all the code desired to be run, once, at new note creation.","作成(名前)
これにより、指定された場所に nameStr という名前の新しいメモが作成され、そのメモへの完全なパスが返されます。指定されたノートがすでに存在する場合、新しいノートは作成されず、オペレーターは空の文字列を返します。
create() 演算子は常に、新しい (または既存の) ノートへのパスを返します。
この関数を呼び出すには、左側の式引数、つまり '$SomeAttribute=' は必要ありません。
nameStr は通常、実際には完全なパスです。
create(""/ハードウェア/タップ"");
ただし、nameStr が一意のノート $Name である場合、nameStr がまだ存在しない場合に限り、新しいノートが現在のノートの新しい (最後の) 子として作成されます。たとえば:
create(""タップ"");
重要なのは、nameStr が $Path ではなく単なる $Name である場合、メモのタイトル nameStr は現在のドキュメント全体で一意である必要があることです。ただし、nameStr が $Path の場合、現在のコンテナ内で一意である必要があるだけです。
create(containerStr, nameStr)
新しい項目のコンテナーと新しい項目の $Name を指定できる 2 つの引数のバリアントも提供されています。containerStr 引数には、パス、$ID、または $IDString を指定できます。これは、同じコンテナ内に複数のメモを作成する必要がある場合、たとえば .each() でリストを反復する場合に便利です。たとえば:
create(""/ハードウェア"",""タップ"");
または、より適切には、ループ変数 'aPlace' を使用します。
$SomeList.each(aPlace){
create(aPlace,""緊急タスク"");
};
基本的に、2 つの入力フォームでは 3 つの形式のバリエーションが可能です。
* 異なるパス、異なる名前 (2 つのネストされたループ経由 (1 つはパス用、もう 1 つは名前用)
* 異なるパス、同じ名前 (パスのバリアントを含むループ)
* 同じパス、異なる名前 (名前のバリアントを含むループ)
指定者と評価
リテラル値と計算値が混在する以下のようなパスは評価されず、インライン指定子も評価されません。
create(/Resources/Test/$MyString)
代わりに、次のようなコードを使用します。
var path=""/Resources/Test/""+$MyString;
作成(パス);
既存のメモのテスト
create() は既存のノートを再作成しませんが、大規模で複雑なドキュメントでは、新しく作成されたノートに対してのみ多数のアクションを 1 回実行する必要があるシナリオが発生します。既存のメモをテストするにはどうすればよいですか?考えられる解決策の 1 つを次に示します。
var:string vTestPath = ""/foo/bar/baz"";
var:string vTest = $IDString(vTestPath);
if(vTest==""""){
$Text = create(vTestPath);
// 新しいメモのために必要なタスクを 1 回だけ実行します
};
存在しないメモには $IDString 値を設定できません。そのため、create(path) を呼び出す前に、作成されるノートのパスの $IDString(path) をテストすることで、必要な場合にのみ create() が呼び出され、コンテキスト内で新しいノートの作成時に実行される必要のあるすべてのコードが一度に呼び出されることを確認できます。"
"createAdornment([containerStr, ] nameStr)",Function,Item,Document configuration,String,false,9.5.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"createAdornment([containerStr, ] nameStr)
The operator createAdornment(), creates an adornment at the designated path. If an adornment already exists with that path, no new adornment is created.
createAdornment(nameStr)
This creates a new adornment called nameStr at the designated location, and returns the full path to that adornment. If the designated adornment already exists, no new adornment is created and the operator returns the empty string.
The createAdornment() operator always returns the path to the new (or pre-existing) adornment. Previously, if the adornment already existed, the operator returned false.
This function needs no left-side expression argument, i.e. '$SomeAttribute=', to invoke it.
nameStr is typically actually a complete path:
	create(""/hardware/taps""); 
but if nameStr is a unique note $Name, a new adornment is created as a child of the current note. For example:
	createAdornment(""taps""); 
createAdornment(containerStr, nameStr)
A two-argument variant is also offered that allows the container for a new item to be specified, and the new item's $Name. The containerStr argument can be a path, an $ID, or an $IDString. This may be useful if you need to create several adornments in the same container, for example is iterating a list with .each(). For example:
	createAdornment(""/hardware"",""taps""); 
Or, more pertinently, using a loop variable 'aPlace':
	$SomeList.each(aPlace){
		createAdornment(aPlace,""urgentTasks"");
	};
Essentially, the two-input form allows 3 forms of variation:
* different path, different name (via two nested loops—one for paths, one for names)
* different path, same name (loop with path variants)
* same path, different name (loop with name variants)
The createAdornment() operator evaluates its first argument, permitting use of an expression to compute a value. Note that this means that paths should be quoted: createAdornment(""/Containers/People/Mark"") , as otherwise parts of paths may be evaluated as expressions. 
Designators and evaluation
Paths like that below, which mix literal and computed values are not evaluated, nor are inline designators:
	createAdornment(/Resources/Test/$MyString) 
Instead use code like this:
	var path=""/Resources/Test/""+$MyString;
	createAdornment(path);","createAdornment([containerStr, ] nameStr)
演算子 createAdornment() は、指定されたパスに装飾を作成します。そのパスに装飾がすでに存在する場合、新しい装飾は作成されません。
createAdornment(nameStr)
これにより、指定された場所に nameStr という新しい装飾が作成され、その装飾への完全なパスが返されます。指定された装飾がすでに存在する場合、新しい装飾は作成されず、オペレーターは空の文字列を返します。
createAdornment() 演算子は常に、新しい (または既存の) 装飾へのパスを返します。以前は、装飾がすでに存在する場合、演算子は false を返しました。
この関数を呼び出すには、左側の式引数、つまり '$SomeAttribute=' は必要ありません。
nameStr は通常、実際には完全なパスです。
create(""/ハードウェア/タップ"");
ただし、nameStr が一意のノート $Name である場合、新しい装飾が現在のノートの子として作成されます。たとえば:
createAdornment(""タップ"");
createAdornment(containerStr, nameStr)
新しい項目のコンテナーと新しい項目の $Name を指定できる 2 つの引数のバリアントも提供されています。containerStr 引数には、パス、$ID、または $IDString を指定できます。これは、同じコンテナ内に複数の装飾を作成する必要がある場合、たとえば .each() でリストを反復する場合に便利です。たとえば:
createAdornment(""/hardware"",""taps"");
または、より適切には、ループ変数 'aPlace' を使用します。
$SomeList.each(aPlace){
createAdornment(aPlace,""緊急タスク"");
};
基本的に、2 つの入力フォームでは 3 つの形式のバリエーションが可能です。
* 異なるパス、異なる名前 (2 つのネストされたループ経由 (1 つはパス用、もう 1 つは名前用)
* 異なるパス、同じ名前 (パスのバリアントを含むループ)
* 同じパス、異なる名前 (名前のバリアントを含むループ)
createAdornment() 演算子は最初の引数を評価し、式を使用して値を計算できるようにします。これは、パスを createAdornment(""/Containers/People/Mark"") のように引用符で囲む必要があることを意味することに注意してください。そうしないと、パスの一部が式として評価される可能性があります。
指定者と評価
リテラル値と計算値が混在する以下のようなパスは評価されず、インライン指定子も評価されません。
createAdornment(/Resources/Test/$MyString)
代わりに、次のようなコードを使用します。
var path=""/Resources/Test/""+$MyString;
createAdornment(パス);"
"createAgent([containerStr, ]nameStr)",Function,Item,Document configuration,String,false,8.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"createAgent(nameStr)
This creates a new agent called nameStr at the designated location, and returns the full path to that agent. If the designated agent already exists, no new agent is created and the operator returns the empty string.
The create() operator always returns the path to the new (or pre-existing) agent.
This function needs no left-side expression argument, i.e. '$SomeAttribute=', to invoke it.
nameStr is typically actually a complete path:
	createAgent(""/agents/urgentTasks""); 
but if name is a unique agent $Name, a new agent is created as a child of the current note. Be aware though that cannot be used if the current object is an agent rather than a note. For example:
	create(""urgentTasks""); 
create(containerStr, nameStr)
A two-argument variant is also offered that allows the container for a new item to be specified, and the new item's $Name. The containeStr argument can be a path, an $ID, or an $IDString. This may be useful if you need to create several agents in the same container, for example is iterating a list with .each(). For example:
	create(""/agents"",""urgentTasks""); 
Or, more pertinently, using a loop variable 'aPlace':
	$SomeList.each(aPlace){
		create(aPlace,""urgentTasks"");
	};
Essentially, the two-input form allows 3 forms of variation:
* different path, different name (via two nested loops—one for paths, one for names)
* different path, same name (loop with path variants)
* same path, different name (loop with name variants)
Designators and evaluation
Paths like that below, which mix literal and computed values are not evaluated, nor are inline designators:
	createAgent(""Resources/Test/$MyString) 
Instead use code like this:
	var:string vPath=""/Resources/Test/""+$MyString;
	createAgent(vPath);","createAgent(nameStr)
これにより、指定された場所に nameStr という名前の新しいエージェントが作成され、そのエージェントへのフル パスが返されます。指定されたエージェントがすでに存在する場合、新しいエージェントは作成されず、オペレーターは空の文字列を返します。
create() オペレーターは常に、新しい (または既存の) エージェントへのパスを返します。
この関数を呼び出すには、左側の式引数、つまり '$SomeAttribute=' は必要ありません。
nameStr は通常、実際には完全なパスです。
createAgent(""/agents/urgentTasks"");
ただし、name が固有のエージェント $Name である場合、新しいエージェントが現在のメモの子として作成されます。ただし、現在のオブジェクトがメモではなくエージェントである場合は使用できないことに注意してください。たとえば:
create(""緊急タスク"");
create(containerStr, nameStr)
新しい項目のコンテナーと新しい項目の $Name を指定できる 2 つの引数のバリアントも提供されています。containseStr 引数には、パス、$ID、または $IDString を指定できます。これは、同じコンテナ内に複数のエージェントを作成する必要がある場合、たとえば .each() でリストを反復する場合に便利です。たとえば:
create(""/agents"",""緊急タスク"");
または、より適切には、ループ変数 'aPlace' を使用します。
$SomeList.each(aPlace){
create(aPlace,""緊急タスク"");
};
基本的に、2 つの入力フォームでは 3 つの形式のバリエーションが可能です。
* 異なるパス、異なる名前 (2 つのネストされたループ経由 (1 つはパス用、もう 1 つは名前用)
* 異なるパス、同じ名前 (パスのバリアントを含むループ)
* 同じパス、異なる名前 (名前のバリアントを含むループ)
指定者と評価
リテラル値と計算値が混在する以下のようなパスは評価されず、インライン指定子も評価されません。
createAgent(""リソース/テスト/$MyString)
代わりに、次のようなコードを使用します。
var:string vPath=""/Resources/Test/""+$MyString;
createAgent(vPath);"
"createAlias(containerStr, originalNote)",Function,Item,Document configuration,String,false,11.5.0,11.5.0,,11.5.0,,2,true,false,false,false,false,false,false,false,false,,false,"createAlias(containerStr, nameStr)
This creates a new alias of nameStr in the designated container at path containerStr. If successful, the operator returns the path of the newly created alias. If a unique, nameStr can be a $Name but will more likely be a $Path value.
Important. Note that the alias must be created in a container other than the container that holds the original note.
Example:
	var:string vNewAlias = createAlias(/path/to/Acontainer,""Foo""); 
The result is that an alias of the note 'Foo' is generated at path /path/to/Acontainer/Foo.","createAlias(containerStr, nameStr)
これにより、パスcontainerStrの指定されたコンテナにnameStrの新しいエイリアスが作成されます。成功すると、オペレーターは新しく作成されたエイリアスのパスを返します。一意の場合、nameStr は $Name になる可能性がありますが、$Path 値になる可能性が高くなります。
重要。エイリアスは、元のメモを保持するコンテナとは別のコンテナに作成する必要があることに注意してください。
例:
var:string vNewAlias = createAlias(/path/to/Acontainer,""Foo"");
その結果、ノート「Foo」のエイリアスがパス /path/to/Acontainer/Foo に生成されます。"
"createAttribute(nameStr[, dataType])",Function,Item,Document configuration,n/a - no return,false,9.2.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"createAttribute(nameStr[, dataType])
The operator createAttribute(name[, type]) can create a new user attributes. If an attribute of the same nameStr already exists, the operator has no effect and returns false. Otherwise, a new user attribute is created. The nameStr argument is case-sensitive and should use the capitalisation as for the desired attribute. Thus nameStr values of Test and test result in different attributes called 'Test' and 'test'.
Optionally, a dataType argument may be supplied to determine the data type of the new attribute. Recognised values for dataType include: string, number, boolean, date, color, interval, file, list, set, url, email, and dictionary. If no dataType valued is supplied, Tinderbox creates a String-type attribute. The dataType argument is case-sensitive: number produces a number type attribute, but Number would result in a (default) string type attribute.
A basic example using just the nameStr argument, results in a new String-type attribute called 'SomeList':
	$MyBoolean = createAttribute(""SomeList""); 
But, in the example above, the chosen name for the new attribute indicates the intended data-type should be of List data type. Therefore, use of the optional dataType argument would make more sense to signal user intent to Tinderbox more clearly:
	$MyBoolean = createAttribute(""SomeList"", ""list""); 
Again, the action results in a new String-type attribute called 'SomeList'.
Note that action code cannot alter the new attribute's name or type, nor delete the attribute. This can be done but only via the User attribute inspector.
Some other aspects of the attribute, e.g. default value) can be changed after the attribute is created, using attribute(). Here below, a number-type attribute is created, its default is set and then a value is applied:
	createAttribute(""Tester"",""number""); 
	attribute(""Tester"")[""default""] = 10; 
	$Tester = 1000;","createAttribute(nameStr[, dataType])
演算子 createAttribute(name[, type]) は、新しいユーザー属性を作成できます。同じ nameStr の属性がすでに存在する場合、演算子は効果がなく、false を返します。それ以外の場合は、新しいユーザー属性が作成されます。nameStr 引数では大文字と小文字が区別され、目的の属性と同様に大文字を使用する必要があります。したがって、Test と test の nameStr 値は、「Test」と「test」という異なる属性になります。
オプションで、新しい属性のデータ型を決定するために dataType 引数を指定できます。dataType として認識される値には、文字列、数値、ブール値、日付、色、間隔、ファイル、リスト、セット、URL、電子メール、辞書が含まれます。dataType 値が指定されていない場合、Tinderbox は文字列型の属性を作成します。dataType 引数では大文字と小文字が区別されます。number は数値型属性を生成しますが、Number は (デフォルトの) 文字列型属性になります。
nameStr 引数のみを使用した基本的な例では、「SomeList」という新しい文字列型属性が生成されます。
$MyBoolean = createAttribute(""SomeList"");
ただし、上記の例では、新しい属性に選択された名前は、目的のデータ型がリスト データ型である必要があることを示しています。したがって、ユーザーの意図をより明確に Tinderbox に伝えるには、オプションの dataType 引数を使用する方が合理的です。
$MyBoolean = createAttribute(""SomeList"", ""リスト"");
この場合も、アクションの結果、「SomeList」という名前の新しい文字列型属性が生成されます。
アクション コードでは、新しい属性の名前やタイプを変更したり、属性を削除したりすることはできないことに注意してください。これはユーザー属性インスペクターを介してのみ実行できます。
属性のその他の側面。デフォルト値) は、属性の作成後に、attribute() を使用して変更できます。以下では、number-type 属性が作成され、そのデフォルトが設定されてから、値が適用されます。
createAttribute(""テスター"",""番号"");
属性(""テスター"")[""デフォルト""] = 10;
$テスター = 1000;"
"createLink(sourceItem, destinationItem[, linkTypeStr])",Function,Item,Linking,success boolean,false,9.1.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"createLink(sourceItem,destinationItem[, linkTypeStr]) 
The operator createLink() can be used for link creation. This is useful when neither the source nor the destination of the link are this note. The arguments sourceItem and destinationItem must be defined so as to identify a single (existing) item.
Example:
	$MyList2.each(anItem2){
		$MyList.each(anItem1){
			createLink(anItem1,anItem2);
		};
	};
createLink() may also cope better than linkTo() and linkFrom() with the edge case when a note's $Name (or those of other notes in the note's path) contain forward slashes. Such paths are challenge as in string form the differing meaning of the use of slashes (container delimiter vs. note title) is ambiguous to the parser.
Optionally, a link type for the new link may be specified using linkTypeStr. If that link type does not exist, it is created.","createLink(sourceItem,destinationItem[, linkTypeStr])
演算子 createLink() はリンクの作成に使用できます。これは、リンク元もリンク先もこのノートではない場合に便利です。引数sourceItemとdestinationItemは、単一の(既存の)項目を識別するように定義する必要があります。
例:
$MyList2.each(anItem2){
$MyList.each(anItem1){
createLink(anItem1,anItem2);
};
};
createLink() は、ノートの $Name (またはノートのパス内の他のノートの $Name) にスラッシュが含まれている場合のエッジ ケースにも、linkTo() や linkFrom() よりもうまく対処できる可能性があります。文字列形式ではスラッシュの使用の異なる意味 (コンテナの区切り文字とメモのタイトル) がパーサーにとって曖昧であるため、このようなパスは困難です。
オプションで、linkTypeStr を使用して新しいリンクのリンク タイプを指定できます。そのリンク タイプが存在しない場合は作成されます。"
Date.day(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.day()
Date.day
Returns the 1 or 2 digit day for the Date-type attribute specified. Valid range 1-31.
If $MyDate is 25 Oct 1415 16:20 then:
	$MyNumber = $MyDate.day; sets $MyNumber to 25 
The operator may also be used to set the attribute's day, using a valid figure
	$MyDate.day = 20; sets the day of $MyDate to 20th of the month","日付.day()
日付.日
指定された日付型属性の 1 桁または 2 桁の日を返します。有効な範囲は 1 ～ 31 です。
$MyDate が 1415 年 10 月 25 日 16:20 の場合:
$MyNumber = $MyDate.day;$MyNumber を 25 に設定します
演算子は、有効な数値を使用して属性の日を設定するために使用することもできます。
$MyDate.day = 20;$MyDate の日を毎月 20 日に設定します"
Date.format(formatStr),Function,Item,Formatting,String,false,5.8.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Date.format(formatStr)
Returns Date as a String, formatted as per the quoted date format string formatStr.
This supplements the existing format() function.
For example:
	$MyString = $MyDate.format(""L"") 
gets the note's creation date and formats it as a ""long local date"" such as ""Sunday, 23 March, 2007"" and sets that as the value of $MyString.
If data is a date, the format string is the same as the format used by Tinderbox's date format codes.","Date.format(formatStr)
引用符で囲まれた日付書式文字列 formatStr に従って書式設定された日付を文字列として返します。
これは既存の format() 関数を補完します。
たとえば:
$MyString = $MyDate.format(""L"")
メモの作成日を取得し、「2007 年 3 月 23 日日曜日」などの「長いローカル日付」としてフォーマットし、それを $MyString の値として設定します。
データが日付の場合、形式文字列は Tinderbox の日付形式コードで使用される形式と同じです。"
Date.hour(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.hour()
Date.hour
Returns the 1 or 2 digit hour for the Date-type attribute specified. Valid range 0-23.
If $MyDate is 25 Oct 1415 16:20 then:
	$MyNumber = $MyDate.hour; returns 16 
The operator may also be used to set the attribute's hour, using a valid figure
	$MyDate.hour = 20; sets the hour to 20 (8 PM) 
Setting time
If wanting to alter the hours element of a Date's time—or multiple time elements in one action, consider using time().","日付.時間()
日付.時間
指定された日付型属性の 1 桁または 2 桁の時間を返します。有効な範囲は 0 ～ 23 です。
$MyDate が 1415 年 10 月 25 日 16:20 の場合:
$MyNumber = $MyDate.hour;16を返します
演算子は、有効な数値を使用して属性の時間を設定するために使用することもできます。
$MyDate.hour = 20;時間を 20 (午後 8 時) に設定します
設定時間
日付の時間の時間要素を変更したい場合、または 1 つのアクションで複数の時間要素を変更したい場合は、time() の使用を検討してください。"
Date.minute(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.minute()
Date.minute
Returns the 1 or 2 digit minute for the Date-type attribute specified. Valid range 0-59.
If $MyDate is 25 Oct 1415 15:20 then:
	$MyNumber = $MyDate.minute; returns 20 
The operator may also be used to set the attribute's minute, using a valid figure
	$MyDate.minute = 36; sets the minute to 36th of the hour 
Setting time
If wanting to alter the minutes element of a Date's time—or multiple time elements in one action, consider using time().","日付.分()
日付.分
指定された日付型属性の 1 桁または 2 桁の分を返します。有効な範囲は 0 ～ 59 です。
$MyDate が 1415 年 10 月 25 日 15:20 の場合:
$MyNumber = $MyDate.分;20を返します
演算子は、有効な数値を使用して属性の分を設定するために使用することもできます。
$MyDate.分 = 36;分を時の 36 日に設定します
設定時間
日付の時間の分要素を変更したい場合、または 1 つのアクションで複数の時間要素を変更したい場合は、time() の使用を検討してください。"
Date.month(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.month()
Date.month
Returns the 1 or 2 digit month for the Date-type attribute specified. Valid range 1-12.
If $MyDate is 25 Oct 1415 15:20 then:
	$MyNumber = $MyDate.month returns 10 
The operator may also be used to set the attribute's month, using a valid figure.
	$MyDate.month = 6; sets the month to 6 (June)","日付.月()
日付.月
指定された日付型属性の 1 桁または 2 桁の月を返します。有効な範囲は 1 ～ 12 です。
$MyDate が 1415 年 10 月 25 日 15:20 の場合:
$MyNumber = $MyDate.month は 10 を返します
演算子は、有効な数値を使用して属性の月を設定するために使用することもできます。
$MyDate.month = 6;月を 6 (6 月) に設定します"
Date.second(),Property,Item,Date-time,Number,false,6.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.second()
Date.second
Returns the 1 or 2 digit seconds for the Date-type attribute specified. Valid range 0-59.
If $MyDate is 25 Oct 1415 15:20:06 then:
	$MyNumber = $MyDate.second returns 6 
The operator may also be used to set the attribute's month, using a valid figure
	$MyDate.second = 24; sets the seconds element of the time to 24.
Setting time
If wanting to alter the seconds element of a Date's time—or multiple time elements in one action, consider using time().","Date.秒()
日付.秒
指定された日付型属性の 1 桁または 2 桁の秒を返します。有効な範囲は 0 ～ 59 です。
$MyDate が 1415 年 10 月 25 日 15:20:06 の場合:
$MyNumber = $MyDate.sec は 6 を返します
演算子は、有効な数値を使用して属性の月を設定するために使用することもできます。
$MyDate.秒 = 24;時刻の秒要素を 24 に設定します。
設定時間
日付の時刻の秒要素を変更したい場合、または 1 つのアクションで複数の時刻要素を変更したい場合は、time() の使用を検討してください。"
Date.week(),Property,Item,Date-time,Number,false,7.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.week()
Date.week
The Date operator .week() returns the number of the week in the current year. For example, January 1 is in week 1. 
Be aware that to allow for the fact the calendar year and week start are only aligned every seventh year, in some years days that the very end of the year may report as week #53.
Date.week() is read-only.
	$MyNumber = $MyDate.week(); 
Thus is $MyDate is 4 January, $MyNumber would be 1.","日付.week()
日付.週
日付演算子 .week() は、現在の年の週番号を返します。たとえば、1 月 1 日は第 1 週になります。
暦年と週の始まりは 7 年ごとにのみ調整されるという事実を考慮して、年によっては年末が第 53 週として報告される場合があることに注意してください。
Date.week() は読み取り専用です。
$MyNumber = $MyDate.week();
したがって、$MyDate は 1 月 4 日であり、$MyNumber は 1 になります。"
Date.weekday(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.weekday()
Date.weekday
Returns the day number for the Date-type attribute specified. Value range is 1-7. Days number from 1 (Monday) to 7 (Sunday). This numbering allows easy testing for weekday (#1-5) vs. weekend (#6-7).
This operator is read-only and cannot be used to change a Date attributes value.
	$MyNumber = $MyDate.weekday; 
Thus if the day of $MyDate is Tuesday, $MyNumber would be 2.","日付.weekday()
日付.平日
指定された日付型属性の日数を返します。値の範囲は 1 ～ 7 です。日数は 1 (月曜日) から 7 (日曜日) までです。この番号付けにより、平日 (#1 ～ 5) と週末 (#6 ～ 7) を簡単にテストできます。
この演算子は読み取り専用であり、日付属性値の変更には使用できません。
$MyNumber = $MyDate.weekday;
したがって、$MyDate の日が火曜日の場合、$MyNumber は 2 になります。"
Date.year(),Property,Item,Date-time,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Date.year()
Date.year
Returns the 1 to 4 digit year for the Date-type attribute specified.
If $MyDate is 25 Oct 1415 16:20 then:
	$MyNumber = $MyDate.year; returns 1415 
The operator may also be used to set the attribute's day, using a valid figure
	$MyDate.year = 1805; sets the year to 1805","Date.year()
日付.年
指定された日付型属性の 1 ～ 4 桁の年を返します。
$MyDate が 1415 年 10 月 25 日 16:20 の場合:
$MyNumber = $MyDate.year;1415 を返します
演算子は、有効な数値を使用して属性の日を設定するために使用することもできます。
$MyDate.year = 1805;年を 1805 年に設定します"
date(dateStr),Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"date(dateStr) 
This constructs a Date-type object from a quoted string or string expression. Note there is an alternate method for specifying a date using the discrete elements (year, month, etc.), see here.
Originally, this is not necessary and Tinderbox would coerce the bare  dateStr to a Date-type automatically. This can still happen but best practice, now action code is more complex, is to be more explicit as to intent  by using the date() operator. (See format() and .format() to convert dates into strings).
Note that in the examples below, whilst the date() operator creates Date-type data, the examples below are actually coercing it back into a string. As formatting is locale dependent and as aTbRef is written using a UK locale (en-GB), the examples below use day-month order. Thus should be correct for most of the world except the USA and the Philippines where moth-day order is used and where readers will need to transpose the month and day segments of the example output. The action code shown is being exported via ^^value()^^.
Note that the seconds element of stored Date data is ignored (from v5 onwards). Thus, if present in the Date, seconds are not used and instead are coerced to '00'.
Default: using $MyDate = date(""24/10/2009""); will set $MyDate to a ""^value(date(""24/10/2009""))^"" (24 October 2009). If no time is supplied hh:mm:ss are set at current system time when $MyDate is set.  In the example here, the equivalent date is set on the fly via ^^value()^^ so the time is the system time as at exporting the note to HTML. The resulting string is the same as you see for a date displayed as a Displayed Attribute. The exact format will depend on the users international settings—also see Document Settings ▸ Displayed Attributes date format.
Now, as above but providing an explicit time element, omitting seconds: $MyDate = date(""24/10/2009 01:30:22"") gives $MyDate a value of ""^value(date(""24/10/2009 01:30""))^""; the specified time gets used, with the seconds added in as per the system clock. If providing a full hh:mm:ss string this is honoured.
But, if you use a date formatting string, you get a formatted string of the date:
	$MyString = date(""24/10/2009 01:30:00"").format(""l""); gives $MyString a value of ""^value(format(date(""24/10/2009 01:30:00""),""l""))^""
or:
	$MyString = date(""24/10/2009 01:30:00"").format(""*""); gives $MyString a value of ""^value(date(""24/10/2009 01:30:00"").format(""*""))^""
The two methods are equivalent, note also the change of format due to use of a date format string.
An attribute can also provide part of the input:
	$EndDate = date($StartDate+""7 days""); 
With care this can be extended. In the following, $MyString is ""7 days"" and $MyNumber is 7. The outcome is that $MyDateA/B/C are all set to the same date:
	$MyDateA = date($MyDate+""7 days""); 
	$MyDateB = date($MyDate+$MyString); 
	$MyDateC = date($MyDate+($MyNumber+"" days"")); note the extra parentheses here are optional but suggested","日付(日付文字列)
これは、引用符で囲まれた文字列または文字列式から日付型オブジェクトを構築します。個別の要素 (年、月など) を使用して日付を指定する別の方法があることに注意してください。こちらを参照してください。
本来、これは必要なく、Tinderbox は裸の dateStr を自動的に Date 型に強制します。これは依然として発生する可能性がありますが、ベスト プラクティスでは、アクション コードがより複雑になり、date() 演算子を使用して意図をより明示的にすることです。(日付を文字列に変換するには、format() および .format() を参照してください)。
以下の例では、date() 演算子が Date 型データを作成する一方で、実際にはそれを強制的に文字列に戻していることに注意してください。書式設定はロケールに依存し、aTbRef は英国ロケール (en-GB) を使用して記述されるため、以下の例では日月順を使用しています。これは、月日順が使用され、読者が出力例の月と日のセグメントを入れ替える必要がある米国とフィリピンを除く、世界のほとんどの地域で正しいはずです。表示されているアクション コードは、^^value()^^ 経由でエクスポートされています。
保存された日付データの秒要素は無視されることに注意してください (v5 以降)。したがって、日付に秒が存在する場合、秒は使用されず、強制的に「00」になります。
デフォルト: $MyDate = date(""24/10/2009""); を使用します。$MyDate を ""^value(date(""24/10/2009""))^"" (2009 年 10 月 24 日) に設定します。時間が指定されていない場合、$MyDate が設定されているときに hh:mm:ss が現在のシステム時間に設定されます。この例では、同等の日付が ^^value()^^ を介してオンザフライで設定されるため、時間はメモを HTML にエクスポートするときのシステム時間になります。結果の文字列は、表示属性として表示される日付の文字列と同じです。正確な形式はユーザーの国際設定によって異なります。「ドキュメント設定」▸「表示される属性の日付形式」も参照してください。
ここで、上記と同様に、秒を省略して明示的な時間要素を指定します。 $MyDate = date(""24/10/2009 01:30:22"") は、$MyDate に ""^value(date(""24/10/2009 01:30""))^"" の値を与えます。指定された時間が使用され、システム クロックに従って秒が追加されます。完全な hh:mm:ss 文字列を指定する場合、これが受け入れられます。
ただし、日付の書式設定文字列を使用すると、書式設定された日付の文字列が得られます。
$MyString = date(""2009/10/24 01:30:00"").format(""l"");$MyString に値「^value(format(date(""24/10/2009 01:30:00""),""l""))^"" を与える
または:
$MyString = date(""2009/10/24 01:30:00"").format(""*"");$MyString に値「^value(date(""24/10/2009 01:30:00"").format(""*""))^"" を与えます。
2 つのメソッドは同等ですが、日付フォーマット文字列の使用によるフォーマットの変更にも注意してください。
属性は入力の一部を提供することもできます。
$EndDate = 日付($StartDate+""7 日"");
注意すればこれを延長することができます。以下では、$MyString は「7 days」、$MyNumber は 7 です。その結果、$MyDateA/B/C はすべて同じ日付に設定されます。
$MyDateA = 日付($MyDate+""7 日"");
$MyDateB = 日付($MyDate+$MyString);
$MyDateC = date($MyDate+($MyNumber+""日""));ここでの余分な括弧はオプションですが、推奨されていることに注意してください"
"date(yearNum, monthNum, dayNum[, hourNum, minNum])",Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,5,true,false,false,false,false,false,false,true,false,,false,"date(yearNum, monthNum, dayNum[, hourNum, minNum])
constructs a Date from individual numeric elements. This is useful, for example, if you need to assemble a date from separate attributes. Note an alternate method for specifying dates using a String representation of the whole date (or date/time), see here.
year is the 4-digit year
month is a number from 1–12
day is a number from 1 to 31
The time arguments are optional, and are specified in a 24-hour clock.
hour is a number from 0 to 23
minute is a number from 0 to 59
Using this operator, do not quote the whole argument list: these should be left as individual numbers.
Wrong: $MyDate = date(""2004,7,23,16,45""); 
Right: $MyDate = date(2004,7,23,16,45); 
Examples:
	$MyDate = date(2004,7,23,16,45); …sets 23 July 2004 16:45","date(年番号, 月番号, 日番号[, 時番号, 分番号])
個々の数値要素から日付を構築します。これは、たとえば、個別の属性から日付を組み立てる必要がある場合に便利です。日付全体 (または日付/時刻) の文字列表現を使用して日付を指定する別の方法については、こちらを参照してください。
年は 4 桁の年です
month は 1 ～ 12 の数字です
日は 1 から 31 までの数字です
時刻引数はオプションで、24 時間形式で指定します。
時間は 0 から 23 までの数値です
分は0から59までの数字です
この演算子を使用する場合は、引数リスト全体を引用しないでください。これらは個別の数値のままにしておく必要があります。
間違い: $MyDate = date(""2004,7,23,16,45"");
右: $MyDate = date(2004,7,23,16,45);
例:
$MyDate = 日付(2004,7,23,16,45);…設定 2004 年 7 月 23 日 16:45"
"day(aDate, dayNum)",Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"day(theDate, dayNum)
creates a new Date based on the aDate expression, but in which the day of the month is dayNumDate is not changed unless theDate is an attribute and the attribute is re-setting itself:
	$MyDateA = day($MyDate,14); $MyDate is unaltered
	$MyDate = day($MyDate,14); $MyDate is changed
Examples. If $MyDate is July 4, 2009 then
	$MyNumber = day($MyDate); …is 4
If $MyDate is July 4,2009, then 
	$MyDate = day($MyDate,5); 
will change $MyDate to July 5, 2009.
The single-argument merthod, used to read the day in the date is documented separately: see day(aDate).","day(theDate, dayNum)
aDate 式に基づいて新しい Date を作成しますが、月の日が dayNumDate である場合、theDate が属性であり、属性がそれ自体を再設定しない限り、Date は変更されません。
$MyDateA = 日($MyDate,14);$MyDate は変更されません
$MyDate = 日($MyDate,14);$MyDate が変更されました
例。$MyDate が 2009 年 7 月 4 日の場合、
$MyNumber = 日($MyDate);…は4です
$MyDate が 2009 年 7 月 4 日の場合、
$MyDate = 日($MyDate,5);
$MyDate は 2009 年 7 月 5 日に変更されます。
日付の日を読み取るために使用される単一引数メソッドについては、別途文書化されています。day(aDate) を参照してください。"
day(aDate),Function,Item,Date-time,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"day(aDate)
returns, as a Number, the day of the month from the aDate expression, which may simply be a date-type attribute value.
	$MyNumber = day($MyDate); 
Alternatively, use Date.day.
The two-argument method, used to alter a Date, is documented separately: see day(aDate, dayNum).","日(日付)
aDate 式から月の日を数値として返します。これは単に日付タイプの属性値である場合もあります。
$MyNumber = 日($MyDate);
あるいは、Date.day を使用します。
Date を変更するために使用される 2 つの引数のメソッドについては、別途文書化されています。day(aDate, dayNum) を参照してください。"
"days(firstDate, lastDate)",Function,Item,Date-time,Number,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"days(firstDate, lastDate) 
returns the Number of 'days' (as defined below) that elapsed between firstDate and lastDate. If lastDate is earlier than firstDate then the result is negative. 
The operator returns the number of 24-hour blocks [sic] between two dates, rounded toward zero. So if days() measures the difference between a date/time of 09:30 today and 08:30 tomorrow, the result is 0 (zero) as the difference is only 23 hours. If the times are same a whole day increment is recorded. 
Thus days does not return a simplistic calendar day difference as some users might intuit it would. If times vary between firstDate and lastDate, the returned difference figure may thus be one day high or low of an expected calendar day-based value.
If $DateA is 3 January 2016 and $DateB is 9 January 2016, then:
	$MyNumber = days($DateA,$DateB); 
sets $MyNumber to 6.
Also see minutes(date1,date2).","days(firstDate, lastDate)
firstDate と lastDate の間に経過した「日数」(以下に定義) を返します。lastDate が firstDate より前の場合、結果は負になります。
演算子は、2 つの日付の間の 24 時間ブロックの数 [原文どおり] を、ゼロに向かって四捨五入して返します。したがって、 days() が今日の 09:30 と明日の 08:30 の日付/時刻の差を測定する場合、その差はわずか 23 時間であるため、結果は 0 (ゼロ) になります。時間が同じ場合は、丸 1 日の増分が記録されます。
したがって、days は、一部のユーザーが直感的にそう思うかもしれないような、単純化された暦日の差を返しません。firstDate と lastDate の間で時間が異なる場合、返される差の数値は、予想される暦日ベースの値の 1 日高いか低い可能性があります。
$DateA が 2016 年 1 月 3 日、$DateB が 2016 年 1 月 9 日の場合、次のようになります。
$MyNumber = 日($DateA,$DateB);
$MyNumber を 6 に設定します。
minutes(date1,date2) も参照してください。"
degrees(radiansNum),Function,Item,Mathematical,Number,false,6.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"degrees(radiansNum)
Takes an angle argument, radiansNum, specified in radians and return the angle in degrees.
	$MyNumber = degrees(6); 
returns 343.7746771 for an input of 6 radians.
See also radians() which converts an angle in degrees to radians.","度(ラジアン数値)
ラジアンで指定された角度引数 radiansNum を受け取り、角度を度で返します。
$MyNumber = 度(6);
6 ラジアンの入力に対して 343.7746771 を返します。
度単位の角度をラジアンに変換する radians() も参照してください。"
delete(scope),Function,Group,Data manipulation,success boolean,false,8.7.0,Baseline,,,,1,true,false,false,false,false,true,false,false,false,,false,"delete(scope)
Deletes the note(s) designated by scope; defining scope. If a designated note does not exist, the expression has no effect and returns false, i.e. nothing happens: no deletion, no message of no deletion. If the designated note exists, it will be deleted and the expression returns its former path.
	delete(""Some note""); 
However, it is strongly suggesting using a path ($Path) for scope and not just the note's title ($Name), thus:
	delete(""/The/path/to/Some note""); 
Avoid using this operator when possible. It can automatically delete notes you intended to create, and it can potentially saw off the branch you are standing on. In almost all circumstances, it is better to move the unwanted note to a container, and then to delete the note manually if you really need to delete it at all.
The delete() operator returns true if at least one note was deleted, and false otherwise.","削除(スコープ)
スコープで指定されたメモを削除します。範囲の定義。指定されたメモが存在しない場合、式は何の効果もなく false を返します。つまり、何も起こりません。削除も削除もメッセージも行われません。指定されたノートが存在する場合、それは削除され、式は以前のパスを返します。
delete(「メモ」);
ただし、メモのタイトル ($Name) だけでなく、スコープにパス ($Path) を使用することを強く提案しています。
delete(""/メモへの/パス"");
可能な場合は、この演算子の使用を避けてください。作成しようとしていたメモを自動的に削除したり、あなたが立っている枝を見落としたりする可能性があります。ほとんどの場合、不要なメモをコンテナに移動し、どうしても削除する必要がある場合は手動でメモを削除することをお勧めします。
delete() 演算子は、少なくとも 1 つのメモが削除された場合は true を返し、それ以外の場合は false を返します。"
descendedFrom(item),Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"descendedFrom(item)
Returns Boolean true if item is an ancestor of the current note, i.e. it matches all descendants of item however deep the outline branch beneath it.
The item argument must be quoted unless an attribute reference. Ways to define item.
To return a Set of all items descended from container at path '/foo/bar' use the query:
	descendedFrom(/foo/bar) 
Or if 'bar' is a unique title in the document, $Name alone can be used:
	descendedFrom(""bar"") 
the latter being the form most usually encountered.
Unlike the paring of contains() and inside(), there is no converse operator that looks for notes that are ancestors of item. 
Legacy issues
This operator replaces the legacy #descendedFrom query operator.","子孫から(アイテム)
item が現在のノートの祖先である場合、つまり、その下のアウトライン分岐の深さにかかわらず item のすべての子孫と一致する場合、ブール値 true を返します。
item 引数は、属性参照でない限り引用符で囲む必要があります。項目を定義する方法。
パス「/foo/bar」のコンテナから派生したすべてのアイテムのセットを返すには、次のクエリを使用します。
子孫から(/foo/bar)
または、「bar」がドキュメント内で一意のタイトルである場合は、$Name のみを使用できます。
ディセンデッドフロム(""バー"")
後者は最も一般的に見られる形式です。
contains() と inside() の組み合わせとは異なり、item の先祖であるノートを検索する逆の演算子はありません。
従来の問題
この演算子は、従来の #descendedFrom クエリ演算子を置き換えます。"
Dictionary.add(itemDict),Function,Item,"Dictionary, Set & List operations",Dictionary,false,9.1.0,Baseline,,,,,true,true,false,false,false,false,false,false,false,,false,"Dictionary.add(itemDict)
This reads a Dictionary-type argument itemDict from which a key and a value are parsed. 
 	$MyDictionary = $MyDictionary.add({apple:green}); 
Note that quotes are not needed around the key and value.
If key does not exist, that key is created with a value of value.
If key exists, key is given a value of value. This replaces any/all existing values for this key.
Assume $MyDictionary has no 'apple' key. Example:
 	$MyDictionary = $MyDictionary.add({apple:fruit}); 
The key 'apple' is added and now has value 'fruit'
 	$MyDictionary = $MyDictionary.add({apple:green}); 
The key 'apple' now has a new value 'green'. Now assume the 'apple' key has multiple values of 'fruit;green;red':
	$MyDictionary = $MyDictionary.add({apple:pie}); 
Now the value is just 'pie' because an .add() operator replaces all existing value(s). 
This operator is also equivalent to:
 	Dictionary[""key""] = ""value""; 
To add an additional value(s) to existing value(s), see Dictionary.extend().
To remove a key—and any value(s) it has—from the Dictionary, there is no operator but instead the key string is deleted using a minus operator: see 'Deleting key:value pairs' here.
The .add() operator accepts quoted strings. The following expressions are equivalent:
	$MyDictionary.add({1:able}) 
	$MyDictionary.add(""{1:able}"") 
But do not use either of the following example syntax:
	$MyDictionary.add({""1:able""}) WRONG!
	$MyDictionary.add({""1"":""able""}) WRONG!
Using offset addresses within itemDict
Either the keyStr or the valueStr may need to be calculated variable, for instance the valueStr might need to be the value of an offset attribute reference, e.g. $MyString(""Some note""), or inside a loop e.g. $MyString(loopVar). These expressions cannot be resolved within the .add() operator but itemDict can be a variable. Thus, in a loop, rather than:
	vDict = vDict.add({$Name(aState)+"":""+$Color(aState)}); WRONG!
use:
	vList.each(aState){
		var:string vPair = $Name(aState)+"":""+$Color(aState);
		vDict = vDict.add({vPair});
	};
Legacy form (pre-v9.5.0)
Dictionary.add(keyStr, valueStr)
This sets a keyStr to the valueStr. 
If keyStr does not exist, that key is created with a value of valueStr.
If keyStr exists, keyStr is given value valueStr. This replaces any/all existing values for this key.
Assume $MyDictionary has no 'apple' keyStr. Example:
 	$MyDictionary = $MyDictionary.add(""apple"",""fruit""); 
The keyStr 'apple' is added and now has valueStr 'fruit'
 	$MyDictionary = $MyDictionary.add(""apple"",""green""); 
The keyStr 'apple' now has a new value 'green'. Now assume the 'apple' key has multiple values of 'fruit;green;red':
	$MyDictionary = $MyDictionary.add(""apple"",""pie""); 
Now the value is just 'pie' because an .add() operator replaces all existing valueStr(s).","Dictionary.add(itemDict)
これは、キーと値が解析される Dictionary 型の引数 itemDict を読み取ります。
$MyDictionary = $MyDictionary.add({apple:green});
キーと値を引用符で囲む必要がないことに注意してください。
キーが存在しない場合、そのキーは value の値で作成されます。
キーが存在する場合、キーには value の値が与えられます。これにより、このキーの既存の値の一部またはすべてが置き換えられます。
$MyDictionary には「apple」キーがないと仮定します。例:
$MyDictionary = $MyDictionary.add({apple:fruit});
キー「apple」が追加され、値は「fruit」になりました。
$MyDictionary = $MyDictionary.add({apple:green});
キー「apple」に新しい値「green」が設定されました。ここで、「apple」キーに「fruit;green;red」という複数の値があると仮定します。
$MyDictionary = $MyDictionary.add({apple:pie});
.add() 演算子が既存の値をすべて置き換えるため、値は単なる「円」になります。
この演算子は以下と同等です。
Dictionary[""キー""] = ""値"";
既存の値に追加の値を追加するには、Dictionary.extend() を参照してください。
ディクショナリからキー (およびキーが持つ値) を削除するには、演算子は使用せず、代わりにマイナス演算子を使用してキー文字列を削除します。こちらの「キーと値のペアの削除」を参照してください。
.add() 演算子は引用符で囲まれた文字列を受け入れます。次の式は同等です。
$MyDictionary.add({1:able})
$MyDictionary.add(""{1:able}"")
ただし、次の例の構文は使用しないでください。
$MyDictionary.add({""1:able""}) 間違っています!
$MyDictionary.add({""1"":""able""}) 間違っています!
itemDict 内でのオフセット アドレスの使用
keyStr または valueStr は計算された変数である必要がある場合があります。たとえば、valueStr はオフセット属性参照の値である必要がある場合があります。$MyString(""Some note"")、またはループ内、例:$MyString(loopVar)。これらの式は .add() 演算子内では解決できませんが、itemDict は変数にすることができます。したがって、ループ内では次のようになります。
vDict = vDict.add({$Name(aState)+"":""+$Color(aState)});間違っている！
使用:
vList.each(aState){
var:string vPair = $Name(aState)+"":""+$Color(aState);
vDict = vDict.add({vPair});
};
従来のフォーム (v9.5.0 より前)
Dictionary.add(keyStr, valueStr)
これにより、keyStr が valueStr に設定されます。
keyStr が存在しない場合、そのキーは valueStr の値で作成されます。
keyStr が存在する場合、keyStr には値 valueStr が与えられます。これにより、このキーの既存の値の一部またはすべてが置き換えられます。
$MyDictionary には「apple」keyStr がないと仮定します。例:
$MyDictionary = $MyDictionary.add(""リンゴ"",""果物"");
keyStr 'apple' が追加され、valueStr 'fruit' が追加されました。
$MyDictionary = $MyDictionary.add(""リンゴ"",""緑"");
keyStr 'apple' に新しい値 'green' が追加されました。ここで、「apple」キーに「fruit;green;red」という複数の値があると仮定します。
$MyDictionary = $MyDictionary.add(""リンゴ"",""パイ"");
.add() 演算子が既存のすべての valueStr(s) を置き換えるため、値は単なる「パイ」になります。"
Dictionary.contains(keyStr),Function,Item,Query Boolean,boolean test,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Dictionary.contains(keyStr)
The expression:
	$MyDictionary.contains(key) 
is true if the dictionary contains the designated key.
Note that keyStr is literal string and not a regex pattern (unlike the operator's use chained with some other data types).
Dictionaries are case-sensitive, but Dictionary.icontains(key) is available for case-insensitive matching.","Dictionary.contains(keyStr)
式:
$MyDictionary.contains(キー)
ディクショナリに指定されたキーが含まれている場合は true です。
keyStr はリテラル文字列であり、正規表現パターンではないことに注意してください (演算子が他のデータ型と連鎖して使用する場合とは異なります)。
辞書は大文字と小文字を区別しますが、Dictionary.icontains(key) は大文字と小文字を区別しない一致に使用できます。"
Dictionary.count(),Property,Item,"Dictionary, Set & List operations",Number,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Dictionary.count()
Dictionary.count
A Number-type property. Returns the number of keys in the dictionary (by their nature all keys are discrete so there is not potential of duplication in the count). If:
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyNumber = $MyDictionary.count; 
MyNumber is now 3.
Dictionary.count and Dictionary.size are interchangeable. Use which ever seems more intuitive.","Dictionary.count()
Dictionary.count
数値型のプロパティ。辞書内のキーの数を返します (その性質上、すべてのキーは個別であるため、カウントが重複する可能性はありません)。次の場合:
$MyDictionary = {猫:動物;犬:動物;岩石: 鉱物};
$MyNumber = $MyDictionary.count;
マイナンバーは3になりました。
Dictionary.count と Dictionary.size は交換可能です。より直感的と思われる方を使用してください。"
Dictionary.empty(),Property,Item,"Dictionary, Set & List operations",boolean test,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Dictionary.empty()
Dictionary.empty
A Boolean-type property. Returns true if the dictionary has no keys, and is false otherwise.
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyBoolean = $MyDictionary.empty; 
MyBoolean is now false
	$MyDictionary = ; (or $MyDictionary = {};)
	$MyBoolean = $MyDictionary.empty; 
MyBoolean is now true","Dictionary.empty()
Dictionary.empty
ブール型のプロパティ。辞書にキーがない場合は true を返し、それ以外の場合は false を返します。
$MyDictionary = {猫:動物;犬:動物;岩石: 鉱物};
$MyBoolean = $MyDictionary.empty;
MyBoolean は false になりました
$MyDictionary = ;(または $MyDictionary = {};)
$MyBoolean = $MyDictionary.empty;
MyBoolean が true になりました"
Dictionary.extend(itemDict),Function,Item,"Dictionary, Set & List operations",Dictionary,false,9.1.0,Baseline,9.5.2,,,2,true,true,false,false,false,false,false,false,false,,false,"Dictionary.extend(itemDict)
This reads a Dictionary-type argument itemDict from which a key and a value are parsed. It adds the value string to the value(s) of a key.
If key does not exist, that key is created with a value of value.
If key exists, value is appended to key's existing value(s).
Assume $MyDictionary has no 'pear' key. Example:
 	$MyDictionary = $MyDictionary.extend({pear:fruit}); 
The key 'pear' is added and now has value 'fruit'. Next:
 	$MyDictionary = $MyDictionary.extend({pear:green}); 
The key 'pear' now has an additional new value 'green', but the overall value is now a list and the key:value pair is pear:fruit;green.
To set the new valueStr so it replaces all existing value(s) see Dictionary.add().
Note that quotes are not used around either/both the keyStr and valueStr. The .extend() operator accepts quoted strings. The following expressions are equivalent:
	$MyDictionary.extend({1:able}) 
	$MyDictionary.extend(""{1:able}"") 
But do not use either of the following example syntax:
	$MyDictionary.extend({""1:able""}) WRONG!
	$MyDictionary.extend({""1"":""able""}) WRONG!
Dictionary.extend(keyStr, valueStr)
This adds the valueStr string to the value(s) of a keyStr.
If keyStr does not exist, that key is created with a value of valueStr.
If keyStr exists, valueStr is appended to keyStr's existing value(s).
Assume $MyDictionary has no 'pear' keyStr. Example:
 	$MyDictionary = $MyDictionary.extend(""pear"",""fruit""); 
The keyStr 'pear' is added and now has valueStr 'fruit'. Next:
 	$MyDictionary = $MyDictionary.extend(""pear"",""green""); 
The keyStr 'pear' now has an additional new valueStr 'green', but the overall value is now a list and the key:value air is pear:fruit;green.
To set the new valueStr so it replaces all existing value(s) see Dictionary.add().
Dictionary.extend(dictStr)
The Dictionary.extend() operator takes a single argument, a dictionary—using the new {} syntax of key:pair elements which will extend the current elements.
 	$MyDictionary = $MyDictionary.extend({pear:green}); 
Note that quotes may be used around either/both the keyStr and valueStr. The following expressions are equivalent:
	$MyDictionary = $MyDictionary.extend({1:able}}; 
	$MyDictionary = $MyDictionary.extend(""{1:able}""}; 
But do not use either of the following example syntax:
	$MyDictionary = $MyDictionary.extend({""1:able""}}; WRONG!
	$MyDictionary = $MyDictionary.extend({""1"":""able""}}; WRONG!
Using offset addresses within itemDict
Either the keyStr or the valueStr may need to be calculated variable, for instance the valueStr might need to be the value of an offset attribute reference, e.g. $MyString(""Some note""), or inside a loop e.g. $MyString(loopVar). These expressions cannot be resolved within the .extend() operator but itemDict can be a variable. Thus, in a loop, rather than:
	vDict = vDict.extend({$Name(aState)+"":""+$Color(aState)}); WRONG!
use:
	vList.each(aState){
		var:string vPair = $Name(aState)+"":""+$Color(aState);
		vDict = vDict.extend({vPair});
	};","Dictionary.extend(itemDict)
これは、キーと値が解析される Dictionary 型の引数 itemDict を読み取ります。値文字列をキーの値に追加します。
キーが存在しない場合、そのキーは value の値で作成されます。
キーが存在する場合、値はキーの既存の値に追加されます。
$MyDictionary には「pear」キーがないと仮定します。例:
$MyDictionary = $MyDictionary.extend({pear:fruit});
キー「pear」が追加され、値は「fruit」になりました。次へ:
$MyDictionary = $MyDictionary.extend({pear:green});
キー「pear」には新しい値「green」が追加されましたが、全体の値はリストになり、キー:値のペアは pear:fruit;green になります。
すべての既存の値を置き換えるように新しい valueStr を設定するには、Dictionary.add() を参照してください。
keyStr と valueStr のどちらかまたは両方を引用符で囲んでいないことに注意してください。.extend() 演算子は引用符で囲まれた文字列を受け入れます。次の式は同等です。
$MyDictionary.extend({1:able})
$MyDictionary.extend(""{1:able}"")
ただし、次の例の構文は使用しないでください。
$MyDictionary.extend({""1:able""}) 間違っています!
$MyDictionary.extend({""1"":""able""}) 間違っています!
Dictionary.extend(keyStr, valueStr)
これにより、valueStr 文字列が keyStr の値に追加されます。
keyStr が存在しない場合、そのキーは valueStr の値で作成されます。
keyStr が存在する場合、valueStr が keyStr の既存の値に追加されます。
$MyDictionary には 'pear' keyStr がないと仮定します。例:
$MyDictionary = $MyDictionary.extend(""梨"",""果物"");
keyStr 'pear' が追加され、valueStr 'fruit' になりました。次へ:
$MyDictionary = $MyDictionary.extend(""pear"",""green"");
keyStr 'pear' には新しい valueStr 'green' が追加されましたが、全体の値はリストになり、key:value air は pear:fruit;green になります。
すべての既存の値を置き換えるように新しい valueStr を設定するには、Dictionary.add() を参照してください。
Dictionary.extend(dictStr)
Dictionary.extend() 演算子は、現在の要素を拡張する key:pair 要素の新しい {} 構文を使用して、単一の引数、つまり辞書を受け取ります。
$MyDictionary = $MyDictionary.extend({pear:green});
keyStr と valueStr のいずれかまたは両方を引用符で囲むことができることに注意してください。次の式は同等です。
$MyDictionary = $MyDictionary.extend({1:able}};
$MyDictionary = $MyDictionary.extend(""{1:able}""};
ただし、次の例の構文は使用しないでください。
$MyDictionary = $MyDictionary.extend({""1:able""}}; 間違っています!
$MyDictionary = $MyDictionary.extend({""1"":""able""}}; 間違っています!
itemDict 内でのオフセット アドレスの使用
keyStr または valueStr は計算された変数である必要がある場合があります。たとえば、valueStr はオフセット属性参照の値である必要がある場合があります。$MyString(""Some note"")、またはループ内、例:$MyString(loopVar)。これらの式は .extend() 演算子内では解決できませんが、itemDict は変数にすることができます。したがって、ループ内では次のようになります。
vDict = vDict.extend({$Name(aState)+"":""+$Color(aState)});違います!
使用:
vList.each(aState){
var:string vPair = $Name(aState)+"":""+$Color(aState);
vDict = vDict.extend({vPair});
};"
Dictionary.icontains(keyStr),Function,Item,Query Boolean,boolean test,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Dictionary.icontains(keyStr)
The expression:
	$MyDictionary.icontains(key) 
is true if the dictionary contains the designated key or case variations of it.
Note that keyStr is literal string and not a regex pattern (unlike the operator's use chained with some other data types).
Dictionaries are case-sensitive, and Dictionary.contains(key) is available for case-sensitive matching.","Dictionary.icontains(keyStr)
式:
$MyDictionary.icontains(キー)
指定されたキーまたはその大文字小文字のバリエーションが辞書に含まれている場合は true です。
keyStr はリテラル文字列であり、正規表現パターンではないことに注意してください (演算子が他のデータ型と連鎖して使用する場合とは異なります)。
辞書では大文字と小文字が区別され、大文字と小文字を区別した一致には Dictionary.contains(key) が使用できます。"
Dictionary.keys(),Property,Item,"Dictionary, Set & List operations",List,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Dictionary.keys()
Dictionary.keys
A List-type property. Returns a list of unsorted key names (i.e. only the keys' strings and not those of values) for this note. Unlike a List or Set, the Dictionary cannot be iterated directly using .each(). Instead, Dictionary.keys provides an iter-able list. So:
$MyDictionary.keys.each(x){
	if($MyDictionary[x] == ""Whoops""){
		 ...
	}
}
Therefore do not try: $MyDictionary.each(x)
A dictionary cannot be sorted but as above Dictionary.keys can be sorted. This is the previous example above, but with an added .sort operator inserted after .keys:
$MyDictionary.keys.sort.each(x){
	if($MyDictionary[x] == ""Whoops""){
		 ...
	}
}
Note that when iterating a dictionary with .each(X) the loop variable X is the String value of the key.
Depending on your needs you might prefer to pass the dictionary explicitly to a list attribute before doing further work:
	$MyList = $MyDictionary.keys; // then work with MyList","Dictionary.keys()
辞書.キー
リスト型のプロパティ。このノートのソートされていないキー名のリスト (つまり、値の文字列ではなくキーの文字列のみ) を返します。List や Set とは異なり、Dictionary は .each() を使用して直接反復することはできません。代わりに、Dictionary.keys は反復可能なリストを提供します。それで:
$MyDictionary.keys.each(x){
if($MyDictionary[x] == ""おっと""){
...
}
}
したがって、$MyDictionary.each(x) は試さないでください。
辞書はソートできませんが、上記のように Dictionary.keys はソートできます。これは上記の例ですが、.keys の後に .sort 演算子が追加されています。
$MyDictionary.keys.sort.each(x){
if($MyDictionary[x] == ""おっと""){
...
}
}
.each(X) で辞書を反復処理する場合、ループ変数 X はキーの String 値であることに注意してください。
ニーズに応じて、さらなる作業を行う前に、リスト属性に辞書を明示的に渡したい場合があります。
$MyList = $MyDictionary.keys;// その後、MyList を操作します"
Dictionary.size(),Property,Item,"Dictionary, Set & List operations",Number,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Dictionary.size()
Dictionary.size
A Number-type property. Returns the number of keys in the dictionary (by their nature all keys are discrete so there is not potential of duplication in the count). If:
	$MyDictionary = {cat:animal; dog:animal; rock: mineral}; 
	$MyNumber = $MyDictionary.size; 
MyNumber is now 3.
Dictionary.size and Dictionary.count are interchangeable. Use which ever seems more intuitive.","Dictionary.size()
辞書のサイズ
数値型のプロパティ。辞書内のキーの数を返します (その性質上、すべてのキーは個別であるため、カウントが重複する可能性はありません)。次の場合:
$MyDictionary = {猫:動物;犬:動物;岩石: 鉱物};
$MyNumber = $MyDictionary.size;
マイナンバーは3になりました。
Dictionary.size と Dictionary.count は交換可能です。より直感的と思われる方を使用してください。"
dictionary(dictionaryStr),Function,Document,"Dictionary, Set & List operations",Dictionary,false,9.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"dictionary(dictionaryStr)
This operator constructs a new dictionary from a dictionaryStr. The dictionaryStr must contain pairs of keys and values separated by a colon; each key/value pair is separated by a semicolon. For example:
	$MyDictionary=dictionary(""cat:animal; dog:animal; rock: mineral""); 
The key ""cat"" has the value ""animal"", while the key ""rock"" has the value ""mineral"".
Normally the output will be passed to a Dictionary attribute, but if passed to an action code variable the latter should function as if a dictionary.
The operator's input string will be in the form of semi-colon delimited set of key:value pairs, i.e.
	$MyDictionary = dictionary(""cat:animal; dog:animal; rock:mineral""); 
Or
	$MyString = ""cat:animal; dog:animal; rock:mineral""; 
	$MyDictionary = dictionary($MyString); 
dictionary({dictionaryStr})
Using the newer {}-defined declaratory method for dictionary data:
	$MyDictionary = dictionary({cat:animal; dog:animal; rock:mineral}); 
Or
	$MyString = ""cat:animal; dog:animal; rock:mineral""; 
	$MyDictionary = dictionary({$MyString}); 
Here the braces (curly brackets) replace the need for quotes enclosing strings.
Direct creation from a string (deprecated)
It is possible that a dictionary can be made by passing an appropriately structured string to a Dictionary type attribute, thus:
	$MyDictionary = ""cat:animal; dog:animal; rock:mineral""; 
This latter usage is deprecated and the more explicit dictionary() operator should be used in its place.","辞書(dictionaryStr)
この演算子は、dictionaryStr から新しい辞書を構築します。DictionaryStr には、コロンで区切られたキーと値のペアが含まれている必要があります。各キーと値のペアはセミコロンで区切られます。たとえば:
$MyDictionary=dictionary(""猫:動物; 犬:動物; 岩石:鉱物"");
キー「cat」は値「animal」を持ち、キー「rock」は値「mineral」を持ちます。
通常、出力は Dictionary 属性に渡されますが、アクション コード変数に渡された場合、後者は辞書のように機能する必要があります。
演算子の入力文字列は、セミコロンで区切られたキー:値のペアのセットの形式になります。
$MyDictionary = Dictionary(""猫:動物; 犬:動物; 岩:鉱物"");
または
$MyString = ""猫:動物; 犬:動物; 岩:鉱物"";
$MyDictionary = 辞書($MyString);
辞書({dictionaryStr})
辞書データに対して、新しい {} 定義の宣言メソッドを使用します。
$MyDictionary = Dictionary({猫:動物; 犬:動物; 岩:鉱物});
または
$MyString = ""猫:動物; 犬:動物; 岩:鉱物"";
$MyDictionary = Dictionary({$MyString});
ここでは、文字列を囲む引用符の必要性を中括弧 (中括弧) で置き換えています。
文字列からの直接作成 (非推奨)
適切に構造化された文字列を Dictionary タイプ属性に渡すことで辞書を作成できる可能性があります。次のようにします。
$MyDictionary = ""猫:動物; 犬:動物; 岩石:鉱物"";
この後者の使用法は非推奨であり、より明示的な Dictionary() 演算子を代わりに使用する必要があります。"
Dictionary[keyStr],Function,Item,"Dictionary, Set & List operations",source context dependent,false,9.0.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"Dictionary[keyStr]
returns the Dictionary's value for the submitted keyStr string. For example, make a dictionary:
	$MyDictionary={cat:animal; dog:animal; rock: mineral}; 
or (now deprecated):
	$MyDictionary=""cat:animal; dog:animal; rock: mineral""; 
then test like so:
	$MyString = $MyDictionary[""dog""]; 
sets MyString to the string ""animal"".
It is not required to use quotes around keyStr.
The keyStr may also be a (loop) variable, or an attribute value. The latter are evaluated before use:
	$MyList.each(anItem){$MyString = $MyString + "", "" + $MyDictionary[anItem];} 
	$MyString = $MyDictionary[$SomeAttribute];} 
This has the same effect as .at( ), but may be more convenient. Note that in both the square-bracket syntax and .at() syntax a numerical key value is interpreted as a key and not a list item number, unlike list.at().","辞書[keyStr]
送信された keyStr 文字列の辞書の値を返します。たとえば、辞書を作成します。
$MyDictionary={猫:動物;犬:動物;岩石: 鉱物};
または (現在は非推奨です):
$MyDictionary=""猫:動物; 犬:動物; 岩石:鉱物"";
次に、次のようにテストします。
$MyString = $MyDictionary[""犬""];
MyString を文字列「animal」に設定します。
keyStr を引用符で囲む必要はありません。
keyStr は、(ループ) 変数または属性値である場合もあります。後者は使用前に評価されます。
$MyList.each(anItem){$MyString = $MyString + "", "" + $MyDictionary[anItem];}
$MyString = $MyDictionary[$SomeAttribute];}
これは .at( ) と同じ効果がありますが、より便利な場合があります。角括弧構文と .at() 構文の両方で、数値キー値は list.at() とは異なり、リスト項目番号ではなくキーとして解釈されることに注意してください。"
"distance(startItem, endItem)",Function,Item,Data manipulation,Number,false,7.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"distance(startItem, endItem)
returns a Number, the map distance (in map units) between the centres of two notes. startItem and endItem are a name, path, attribute value or expression returning a unique reference to a single note.
To find the distance between note 'AA' and note 'BB':
	$MyNumber = distance(""AA,""BB"");","距離(開始項目、終了項目)
2 つのノートの中心間のマップ距離 (マップ単位) を数値で返します。startItem と endItem は、単一のノートへの一意の参照を返す名前、パス、属性値、または式です。
音符「AA」と音符「BB」の間の距離を調べるには:
$MyNumber = distance(""AA,""BB"");"
"distanceTo(startItem, endItem)",Function,Item,Data manipulation,Number,false,8.0.4,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"distanceTo(startItem, endItem)
distanceTo computes the approximate distance in kilometres between two notes for which a $Latitude and $Longitude are known. startItem and endItem are a name, path, attribute value or expression returning a unique reference to a single note.
For example, if note startItem 'Boston' has the latitude and longitude of Boston and note endItem 'Paris' has the latitude a longitude of Paris, then for 
	$MyNumber = distanceTo(""Boston"",""Paris"");  
$MyNumber is about 5582 (km).
Long distances should use a great circle route.
Note the measurement is approximate and not intended for precise navigation.","distanceTo(startItem, endItem)
distanceTo は、$Latitude と $Longitude がわかっている 2 つのノート間のおおよその距離をキロメートル単位で計算します。startItem と endItem は、単一のノートへの一意の参照を返す名前、パス、属性値、または式です。
たとえば、note startItem 'Boston' にボストンの緯度と経度があり、note endItem 'Paris' にパリの緯度と経度がある場合、
$MyNumber = distanceTo(""ボストン"",""パリ"");
$MyNumber は約 5582 (km) です。
長距離の場合は大圏ルートを使用する必要があります。
測定値はおおよそのものであり、正確なナビゲーションを目的としたものではないことに注意してください。"
"do(macroStr[,argumentsList])",Function,Item,Data manipulation,String,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"do(macroStr[, argumentsList])
The do() operator do lets rules and actions use macros. Action code macros cannot, generally, evaluate action (or export) code within the macro itself and so might best be thought of sections of boilerplate text with configurable text inputs.
do() always returns an output (string) and so will expect a left side attribute. To do something useful with the output consider wrapping the it in an eval() call. Assume macro ""Hello world"" has the code: ""Hello $1!"". Then:
	$ReturnString = eval(do(""Hello world"",""Nibbler"")); 
would set a $ReturnString value of ""Hello Nibbler!"".
Alternatively, if the macro is written so the left side is included, action() can be used. Macro ""Hello world2"" has the code: $ReturnString = ""Hello $1!"". Using the macro thus:
	action(do(""Hello world2"",""Cubert"")); 
which would set a $ReturnString value of the current note to ""Hello Cubert!"". Notice how action() requires no left-side receiving attribute as there is no direct output. The assignment to $ReturnString occurs within the macro; the assigned attribute being whatever system/user attribute the user decides, it is not a fixed output assignment.
An offset within an action call is also possible. Macro ""Hello world3"":
 	$ReturnString('$2') = ""Here's $1!""; 
Use the macro thus:
	action(do(""Hello world3"",""Calculon"", ""All My Circuits"")); 
which would set a $ReturnString(""All My Circuits"") to ""Here's Calculon!"".
Note that if an input is itself an expression, it may prove beneficial to evaluate it before insertion into the macro. Why? It may affect outcome if the context of the input evaluation and the output evaluation differ, e.g. where the reference 'this' might refer to a different note in each context.
do(macro[,arg1,arg2,arg3] )
The first argument is the name of the macro. Subsequent argumentsList (comma delimited) arguments are optional and are passed to the macro, which can refer to them as $1, $2, $3, and so forth.
After the macro is evaluated, its result string is returned and is parsed again as a rule, action, or expression. For example:
	$Name|=do(computeName,$Name,$Name(parent)); 
sets name to the result of a macro called computeName. This if the macro code were:
	$2: $1 
Then, if $Name were ""mammal"" and $Name(parent) were ""horse"", the result on the above call would be a new $Name of ""mammal: horse""
	do(Instructions); 
simply returns whatever text is stored in a macro called Instructions.
Macros cannot be used in agent queries (this was supported in early versions).
Macros called in action code via do() do not evaluate any embedded export codes. This is because such behaviour is reserved for export use.","do(macroStr[, argumentList])
do() 演算子 do を使用すると、ルールとアクションでマクロを使用できるようになります。一般に、アクション コード マクロはマクロ自体内のアクション コード (またはエクスポート) を評価できないため、設定可能なテキスト入力を含むボイラープレート テキストのセクションと考えるのが最も適切かもしれません。
do() は常に出力 (文字列) を返すため、左側の属性が期待されます。出力を有効に使用するには、それを eval() 呼び出しでラップすることを検討してください。マクロ「Hello world」に「Hello $1!」というコードがあるとします。次に:
$ReturnString = eval(do(""Hello world"",""ニブラー""));
$ReturnString 値を「Hello Nibbler!」に設定します。
あるいは、左側が含まれるようにマクロが記述されている場合は、action() を使用できます。マクロ「Hello world2」のコードは $ReturnString = ""Hello $1!"" です。このマクロを使用すると、次のようになります。
action(do(""Hello world2"",""Cubert""));
これにより、現在のノートの $ReturnString 値が「Hello Cubert!」に設定されます。直接出力がないため、action() には左側の受信属性が必要ないことに注目してください。$ReturnString への代入はマクロ内で行われます。割り当てられる属性は、ユーザーが決定するシステム/ユーザー属性であり、固定された出力割り当てではありません。
アクション呼び出し内のオフセットも可能です。マクロ「Hello world3」:
$ReturnString('$2') = ""これが $1 です!"";
このマクロを次のように使用します。
action(do(""Hello world3"",""Calculon"", ""すべての回路""));
これは $ReturnString(""All My Circuits"") を ""Here's Calculon!"" に設定します。
入力自体が式である場合、マクロに挿入する前にそれを評価すると有益な場合があることに注意してください。なぜ？入力評価と出力評価のコンテキストが異なる場合、結果に影響を与える可能性があります。ここで、「this」という参照は、コンテキストごとに異なるメモを指す場合があります。
do(マクロ[,arg1,arg2,arg3])
最初の引数はマクロの名前です。後続のargumentsList (カンマ区切り) 引数はオプションであり、マクロに渡され、$1、$2、$3 などとして参照できます。
マクロが評価されると、その結果文字列が返され、ルール、アクション、または式として再度解析されます。たとえば:
$Name|=do(computeName,$Name,$Name(親));
name を computeName というマクロの結果に設定します。マクロコードが次の場合は次のようになります。
2ドル: 1ドル
次に、$Name が ""mammal"" で、$Name(parent) が ""horse"" の場合、上記の呼び出しの結果は、新しい $Name として ""mammal: horse"" になります。
do(指示);
単に命令と呼ばれるマクロに保存されているテキストを返します。
マクロはエージェント クエリでは使用できません (これは初期のバージョンでサポートされていました)。
do() を介してアクション コードで呼び出されるマクロは、埋め込まれたエクスポート コードを評価しません。これは、そのような動作がエクスポート用に予約されているためです。"
document.keys(),Function,Document,Document configuration,List,false,9.5.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"document.keys()
document.keys
returns a List of the document() dictionary's keys of useful properties of the current document. The operator returns the document Dictionary object as a single string, noting that no operator trailing parentheses are needed:
	$MyList = document.keys; 
The returned list is in the dictionary's stored order as listed for document().
The document.keys operator can assist in getting a readable output of all the keys and their values
	$Text =;
	document.keys.each(aKey){
		var:list vKey = document[aKey];
		$Text += aKey + "": "" + vKey.format("", "") +""\n\n"";
	};
which will list in $Text of the current note each key name and then its value with a blank line in between. For multi-item values like user-attributes and link-types list formatting applies a ', ' delimiter for legibility.","document.keys()
ドキュメントキー
現在のドキュメントの有用なプロパティの document() ディクショナリのキーのリストを返します。演算子はドキュメント Dictionary オブジェクトを単一の文字列として返しますが、演算子の末尾に括弧が必要ないことに注意してください。
$MyList = ドキュメント.キー;
返されるリストは、document() のリストと同じように辞書に格納された順序になります。
document.keys 演算子は、すべてのキーとその値の読み取り可能な出力を取得するのに役立ちます。
$Text =;
document.keys.each(aKey){
var:list vKey = document[aKey];
$Text += aKey + "": "" + vKey.format("", "") +""\n\n"";
};
これにより、現在のノートの $Text に各キー名とその値が空白行を挟んでリストされます。ユーザー属性やリンク タイプなどの複数項目の値の場合、読みやすくするためにリストの書式設定に「,」区切り文字が適用されます。"
document(),Function,Document,Document configuration,Dictionary,false,9.6.0,Baseline,11.0.0,11.0.0,,,false,false,false,false,false,false,false,true,false,,false,"document()
document
document() or document returns a Dictionary of useful properties of the current document. The properties of the document are exposed this way (in this order in the dictionary):
* path: the POSIX file path of the current TBX file
* id: the TBX file's internal UUID.
* user-attributes: a list of all the user attributes currently defined in the document
* url: the local file:// URL of the current TBX file.
* name: the full name of the current TBX including the file extension.
* link-types: a list of discrete link types currently defined in the document. 
* file-size: the size (in bytes) of the saved Tinderbox file (from v11.0.0)
Importantly, The document() Dictionary object is read-only.
The operator returns the document Dictionary object as a single string:
	$Text = document(); 
Although trailing parentheses are not needed, when calling the 'bare' operator, add parentheses—i.e. document()— may help the user and parse not mistake the operator document for the literal string ""document"". 
As reading the Dictionary data as a single string can be hard, a neater and more easily understood method is use the document.keys() method.
It is possible to address the document() Dictionary directly for a specific key value using the document[keyStr] method.
However, calling document() with no other handling, returns the entire, unformatted Dictionary contents. To split the items onto separate lines as discrete key:value pairs, chain the .format() operator:
	$MyString = document.format(""\n""); 
To get the values (without their keys) on separate lines in the current note's $Text:
	$Text=;
	document().keys.each(aKey){
		$Text+= aKey + "": "" + document()[aKey] + ""\n"";
	};","ドキュメント()
文書
document() または document は、現在のドキュメントの有用なプロパティの辞書を返します。ドキュメントのプロパティは次のように公開されます (辞書内ではこの順序で)。
* path: 現在の TBX ファイルの POSIX ファイル パス
* id: TBX ファイルの内部 UUID。
* user-attributes: ドキュメント内で現在定義されているすべてのユーザー属性のリスト
* url: 現在の TBX ファイルのローカル file:// URL。
* name: ファイル拡張子を含む現在の TBX の完全な名前。
* link-types: ドキュメント内で現在定義されている個別のリンク タイプのリスト。
* file-size: 保存された Tinderbox ファイルのサイズ (バイト単位) (v11.0.0 以降)
重要なのは、document() Dictionary オブジェクトは読み取り専用であることです。
演算子は、ドキュメント Dictionary オブジェクトを単一の文字列として返します。
$Text = ドキュメント();
末尾の括弧は必要ありませんが、「裸の」演算子を呼び出すときは括弧を追加します。document() - ユーザーと解析がオペレーターの document をリテラル文字列「document」と間違えないようにするのに役立ちます。
Dictionary データを単一の文字列として読み取るのは難しい場合があるため、よりすっきりしていて理解しやすい方法は document.keys() メソッドを使用することです。
document[keyStr] メソッドを使用して、特定のキー値に対して document() ディクショナリを直接アドレス指定することができます。
ただし、他の処理を行わずに document() を呼び出すと、書式設定されていない辞書の内容全体が返されます。項目を個別のキー:値のペアとして別々の行に分割するには、.format() 演算子を連鎖させます。
$MyString = document.format(""\n"");
現在のノートの $Text の別々の行にある値 (キーなし) を取得するには、次のようにします。
$Text=;
document().keys.each(aKey){
$Text+= aKey + "": "" + document()[aKey] + ""\n"";
};"
document[keyStr],Function,Document,Document configuration,source context dependent,false,9.0.0,Baseline,11.0.0,11.0.0,,1,false,false,false,false,false,false,false,true,false,,false,"document[keyStr]
To address the document() Dictionary to access a particular key use a keyStr argument. The values for the Dictionary's available properties can be accessed individually by supplying the relevant key. Quotes around the key are optional, both forms are illustrated below:
	$MyFile = document[""path""]; 
	$MyString = document[""id""]; 
	$MyList = document[""user-attributes""]; 
	$MyURL = document[""url""]; 
	$MyString = document[""name""]; 
	$MyList = document[link-types]; 
	$MyNumber = document[file-size]; 
All property keyStr above return a string value. However, the values are more usable when passed to attributes (or variables) of the precise data types shown in the examples above.","ドキュメント[キー文字列]
document() ディクショナリをアドレス指定して特定のキーにアクセスするには、keyStr 引数を使用します。ディクショナリの使用可能なプロパティの値には、関連するキーを指定することで個別にアクセスできます。キーの前後の引用符はオプションであり、両方の形式を以下に示します。
$MyFile = ドキュメント[""パス""];
$MyString = ドキュメント[""id""];
$MyList = document[""ユーザー属性""];
$MyURL = ドキュメント[""url""];
$MyString = ドキュメント[""名前""];
$MyList = ドキュメント[リンクタイプ];
$MyNumber = ドキュメント[ファイルサイズ];
上記のすべてのプロパティ keyStr は文字列値を返します。ただし、値は、上記の例に示されている正確なデータ型の属性 (または変数) に渡されると、より使いやすくなります。"
drivingTimeTo(item),Function,Item,Data manipulation,Interval,false,8.0.4,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"drivingTimeTo(item) 
drivingTimeTo estimates the driving time between the location specified by the selected (current) note and the location specified by the item path.
Location essentially means explicit $Latitude and $Longitude values for both notes—i.e. start and destination, or data such as $GeocodedAddress that can be examined to retrieve suitable Lat/Long data.
The result is a time interval (interval data type) estimating the approximate driving time, based on traffic conditions prevailing when the action was invoked. For example to find the time to drive from the current location's 
if ($MyInterval==0) {
   $MyInterval = drivingTimeTo(/places/faves/Swarthmore);
}
There is no result, i.e. estimated driving time is zero (interval of 00:00) if:
* a location for either note cannot be determined
* no route can be found between the two locations (or the locale is not mapped for driving time)
* the internet is not accessible. 
Avoid excessive use
Note that this function can be slow and relies on the underlying macOS. Therefore consider using an edict rather than a rule, and avoid recalculating the driving time if you already know it. Code as in the example above should stop unneeded calls. Which such code, if there is a driving time, delete it, and the conditional guard query will allow a fresh call to drivingTimeTo().","運転時間(項目)
DrivingTimeTo は、選択された (現在の) ノートで指定された位置とアイテム パスで指定された位置の間の運転時間を推定します。
場所は本質的に、両方のメモの明示的な $Latitude と $Longitude の値を意味します。開始点と目的地、または適切な緯度/経度データを取得するために検査できる $GeocodedAddress などのデータ。
結果は、アクションが呼び出されたときの交通状況に基づいて、おおよその運転時間を推定する時間間隔 (間隔データ タイプ) です。たとえば、現在地から車で移動する時間を調べる場合などです。
if ($MyInterval==0) {
$MyInterval = DrivingTimeTo(/places/faves/Swarthmore);
}
次の場合、結果はありません。つまり、推定運転時間はゼロ (00:00 の間隔) です。
* どちらの音符の位置も特定できません
* 2 つの場所間のルートが見つかりません (または、場所が運転時間にマップされていません)
※インターネットにはアクセスできません。
過度の使用を避ける
この機能は遅くなる可能性があり、基盤となる macOS に依存することに注意してください。したがって、ルールではなく法令を使用することを検討し、運転時間をすでに知っている場合は再計算しないようにしてください。上記の例のようなコードは、不要な呼び出しを停止する必要があります。このようなコードは、運転時間が存在する場合は削除し、条件付きガード クエリにより、drivingTimeTo() を新たに呼び出すことができるようになります。"
"eachLink(loopVar[,scope]){actions}",Function,Item,Linking,Dictionary,false,9.1.0,Baseline,,,,2,true,false,false,true,false,true,false,true,false,,false,"eachLink(loopVar){action(s)}
The eachLink() operator examines a Dictionary of data for each link for the current note, either inbound or outbound; prototype links are excluded. The local, user-named, variable loopVar argument is bound to a dictionary-type object of per-link properties, and is used in the {}-enclosed action code.
.eachLink() may also be a more flexible replacement for the older links() operator.
.eachLink() includes 11  read-write keys in the dictionary it builds for each link. These first two can be useful when several notes in a container have identical names and the remaining new keys cover various display aspects of the link. The per-link Dictionary-type data comprises the following keys. All are editable except item in italics:
* type. The link's link type. 
* anchor. For text links, the links' anchor text within $Text.
* comment. For ad hoc information about the link or its purpose
* source. $Path of source object.
* sourceID. $ID of the source note.
* sourceIDString. $IDString of the source note.
* dest. $Path of destination object. Alternate for 'destination', more consistent with ID-based versions.
* destID. $ID of the destination note.
* destIDString. $IDString of the destination note.
* destination. $Path of destination object. Alternate for 'dest'. 
* class. HTML link class attribute.
* title. HTML link title attribute.
* target. HTML link target attribute.
* url. For Web links only, the linked-to URL.
* boolean visual properties:
** visible
** dashed
** dotted
** bold
** broad
** linear
* isFirst true if the first (or only) listed link for this note.
* isLast true if the last listed link for this note.
* outbound true for links whose source is this note (the note being processed).
* basic true for basic links and false for text links.

The eachLink(){} operator adds two new read-only items to the dictionary created for each link. The value of outbound is true for links whose source is this note. The value of basic is true for basic links and false for text links.
Another way to understand the keys, is in terms of their general purpose:
* link type information: type, anchor comment
* Identity of linked items: source, sourceID, sourceIDString, dest, destID, destIDString, destination
* Web link configuration for HTML export: class, title, target, url. See more under the Browse Links dialog.
* Configuration of visible links (Map and Timeline views): visible, dashed, dotted, bold, broad, linear. See more under the Links Inspector.
For editing key values, see section 'Editing link properties' below.
Note that it is not possible to read a link target's anchor text (i.e. for a link linking to a $Text selection) via eachLink(). Currently such data is only observable via the source XML of the document.
eachLink() examines each link in the sequence as seen in the listing in Browse Links…, so it examines text links is the order their anchor text appears within $Text.
Link Counts
The count of the links iterated for a given note by eachLink() is $OutboundLinkCount plus $InboundLinkCount:
	var:number vLkCt = $OutboundLinkCount + $InboundLinkCount; 
First and Last item tests
Although eachLinks() is functionally like a list iterator (i.e. List.each()), it works off a dynamically generated List but the loopVar is bound to each list item's Dictionary. This means the list object properties of List.count, List.first and List.last are not available. However, the per-link Dictionary object offers two special keys:
* loopVar[""isFirst""] is true for the first link in the enumeration and false otherwise.
* loopVar[""isLast""] is true for the final link in the enumeration and false otherwise.
In effect these keys mimic, for eachlink(), the .first() and .last() tests as used by .each().  This the following example the first conditional if() test uses the long form test for a boolean true, the second the short form—both give the same result:
	eachLink(aLink){
		if(aLink[""isFirst""]==true){
			//this is the first link in the listing;
		};
		if(aLink[""isLast""]){
			//this is the last link in the listing;
		};
	};
Why might this be used? If the links are being processed so as to only export certain typed links, it may be necessary to add additional text/styling before the first and after the last link.
Detecting basic vs. text vs. web links
The 3 types differ in that:
* Only web links have an anchor and url value.
* Only text links have an anchor but no url value.
* Only basic links have neither an anchor nor a url value.
These conditions can be tested for when iterating a note's links
	eachLink(aLink){
		if(aLink[""url""]!=""""){
			// this is a web link
		}else{
			if(aLink[""anchor""]!=""""){
				// this is a text link (has anchor but no url)
			}else{
				// this is basic link (has neither anchor nor url)
			}
		}
	};
Or as a function:
	function fWhatSortOfLink(iAnchor:string, iURL:string){
		if(iURL!=""""){
			return ""web"";
		}else{
			if(iAnchor!=""""){
				return ""text"";
			}else{
				return ""basic"";
			}
		}
	};
	var:string vTypeOfLink;
	eachLink(aLink){
		vTypeOfLink = fWhatSortOfLink(aLink[""anchor""],aLink[""url""]);
			// do something depending on the type of link
		};
More examples
Filtering inbound vs. outbound links. Outbound links share the same $ID as the note whose links are being read):
	function fLinkDirection(iIdNote:string, iIdLinkSource:string){
		if(iIdNote == iIdLinkSource){
			return ""outbound"";
		}else{
			return ""inbound"";
		}
	};
	// called like so within a loop that is populating loop variable 'aLink'
	// pass to a list as likely more then one link
	$MyList += fLinkDirection($ID,$ID(aLink[""source""]));
Thus in-loop this test could be used to only process inbound links:
	eachLink(aLink){
		if(fLinkDirection($ID,$ID(aLink[""source""]))=""inbound""){
			// process this link's data
		};
	};
for such tests, the function could more usefully be re-written:
	function fIsLinkOutbound(iIdNote:string, iIdLinkSource:string){
		if(iIdNote == iIdLinkSource){
			return true;
		}else{
			return false;
		}
	};
	// called as below within a loop that is populating loop variable 'aLink'
	// testing for *inbound* links only
	if(fIsLinkOutbound($ID,$ID(aLink[""source""]))==false){...};
Testing link type. Does this note have a link of type ""agree""?
	function fIsAgreeable(){
		eachLink(aLink) {
			if(aLink[""type""]==""agree""){
				return true;
			};
		};
		return false;
	};
Counting. Count the number of links from this note to tasks:
	function fLinkedTasks(){
		var:number vCount=0;
		eachLink(aLink){
			if($Prototype(aLink[""destination""])==""Task""){
				vCount += 1;
			};
		};
		return count;
	};
The examples use line breaks for clarity, and the last example may equally well be stored and used without line breaks, though still taking care to delimit/terminate discrete expressions with semicolons
The latter might make sense if trying to use a function within something like a rule, but if the code is defined in a Library note within Hints, then there is little gain in a one-line approach as it can be hard to read.
eachLink(loopVar,scope){action(s)}
An optional second argument for eachLink() allows designating the note whose links are to be examined, using a path or designator as the scope argument. Previously, eachLink() was explicitly bound to the current note. 
For example,:
	eachLink(aLink, parent){
		… // action code here
	};
performs an action on each of the links to and from the parent of the current note (i.e. this note). 
Note that scope is a single item; if needing to work a list of notes, use a nesting List.each() with the outer loop passing a single scope item to eachLink(). Consider the following:
	$MyList.collect(children,$ID);
	$MyList.each(anID){
	   eachLink(aLink,anID){
	      // do stuff on the links of the note defined by current anID value, i.e. $ID(anID)
	   }
	};
The latter might as easily be done with a function, that takes $ID as an input and wraps the eachLink() loop using the passed-in ID as the eachLink() second argument. Regardless of whether scope is a $Name, $Path, $ID, etc., when referencing the scope value is should be as the value of an attribute, not as a'bare' value. Thus, for the last example above, as $ID(anID) and not as anID alone.
Where the designator argument would be this, it may be omitted as the original usage  eachLink(aLink){…}  automatically assume the context of the action performed on each link to and from this note.
Editing link properties
In eachLink() loops, most properties of the link are editable. For example, to change any of the current note's 'untitled' links to link type 'reference':
	eachLink(aLink){
		if(aLink[""type""] == ""*untitled""){
			aLink[""type""]  = ""reference"";
		}
	};
If the link type being set does not already exist, it is created and applied. But, what if the note to be checked is not the current note?  Consider working via an agent, where the current note is an alias. In that case, it is necessary to use the optional scope argument and additionally rather than specify a note name or path to use the original designator. The same task as above now becomes:
	eachLink(aLink,original){
		if(aLink[""type""] == ""*untitled""){
			aLink[""type""]  = ""reference"";
		}
	};
the only change being the extra use of the scope argument to define the correct context for evaluating the links.
To change the link type of any link of type 'disagree' to 'agree', within the eachLink() loop use:
	if(aLink[""type""]==""agree""){aLink[""type""]=""disagree"";};",
escapeHTML(dataStr),Function,Item,Formatting,String,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"escapeHTML(dataStr)
escapeHTML converts HTML and XML special characters in string dataStr to HTML/XML entities. For example, '&lt;' is replaced by '&amp;lt;' and '&amp;' is replaced by '&amp;amp;'.
For example, if the source dataStr is ""this & that"":
	$MyString = escapeHTML(""this & that"") outputs ""this &amp;amp; that"".
See also attributeEncode(), especially if working with XML strings.","エスケープHTML(dataStr)
escapeHTML は、文字列 dataStr 内の HTML および XML 特殊文字を HTML/XML エンティティに変換します。たとえば、「&lt;」は「&lt;」に置き換えられます。と「&amp;」は「&amp;amp;」に置き換えられます。
たとえば、ソース dataStr が「this & that」の場合:
$MyString =scapeHTML(""this & that"") は、「this &amp;amp; that」を出力します。
特に XML 文字列を扱う場合は、attributeEncode() も参照してください。"
"eval([item], expressionStr)",Function,Item,Data manipulation,source context dependent,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"eval([item,] expressionStr)
The item argument must be quoted unless an attribute reference. Ways to define item.
The eval() function takes two quoted evaluated (as string) arguments. The first argument, item, is optional. The second argument , expressionStr, holds string holding an action code expression to be evaluated. Thus, in basic form:
	if($MyBool){$AttribX = ""$Name(parent)+' XYZ'"";}else{$AttribX = ""$Name(grandparent) + 'ABC'"";}; $AttribY = eval($AttribX); 
will set AttribY to the name of the current note's parent's title plus string ""XYZ"" or that of its grandparent plus string ""ABC"", depending on the value of attribute MyBool by evaluating attribute AttribX. Thus eval() gives the action code result of an attribute rather than its literal value. As such eval is normally applied to string-based attributes.
If trying to construct an attribute reference from ""$"" and a literal string or variable, use action() instead.
Further examples
The eval() function can be useful for inserting a local attribute value in an expression that will be evaluated in a different context. Consider this find() in an a rule:
	$ArtistCount = find($ArtistName==$Name & !$IsAlias).size; 
For each note evaluated, the note's $Name is compared to ArtistName. However, what if the intent was to use this in a note with an artist's name where it is necessary to come the calling note's $Name, not that of the in-scope note. There is no designator for that relationship, but eval() offers a way around:
	$ArtistCount = eval('(find($ArtistName==""'+$Name+'"" & !$IsAlias).size)'); 
This first of all makes a string using the correct find code but also inserting the value of the calling note's $Name, and then the whole is evaluated as if it were the original verbatim find() call above. 
The process can be made clearer by splitting it into two steps by first using a placeholder $TempString attribute:
	$TempString = '(find($ArtistName==""'+$Name+'"" & !$IsAlias).size)'; 
The outer parentheses are simply to ensure the .size() call chained on the end of the find is evaluated with the find(). For a note called ""Jacques Brel"", $TempString would be the string: (find($ArtistName==""Jacques Brel"" & !$IsAlias).size). Now, to use eval():
	$ArtistCount = eval($TempString); 
Side note: the actual scenario above can also be solved using the 'that' designator, although the example holds true as an exploration of how eval() works.
A more complex example, using nested eval() calls is described under 'using long sections of code'.
Macros: eval() can be combined with do(macro). As macros take input arguments, an evaluated macro can work a bit like a code function, taking inputs and returning output that once passed through eval() gives an evaluated result. See the do() operator.
The eval() operator also allows access to two and the app version of the currently used Tinderbox on the user's Mac:
	eval(^^docTitle^^) gives a value of ""^docTitle^"" (note no '.tbx' extension)
	eval(^^version^^) gives ""^version^"" (note that you might want to prefix the return string with 'v' or 'v.' thus: ""v.^version^"").
In full syntax form, an additional first argument is added that is an expression string evaluating as a note name, path or note name. Where specified, this indicates the note from which attribute values in the second argument should be drawn.
To create an attribute reference ($-prefixed as in '$Name' not 'Name') use action() instead of eval(). 
Example using both inputs
A different example, using the optional path argument. Take two root-level notes, AA and BB.
	$Text(""AA"") is: 1+1
	$Text(""BB"") is: """"(i.e. nothing)
	$Rule(""BB"") is: $Text=eval(""AA"",$Text) 
…after a brief delay, the text of note BB becomes 2, i.e. the sum of the expression stored in aa's text. The item argument ""AA"" simply indicates that the source of the expressionStr is the note AA.
Now change AA's text:
	$Text(""AA"") is: if(1){42}else{1000}
…after a brief delay, the text of note BB becomes 42. How? Any if(condition) is a Boolean test trying to get a true/false result. If the condition does not result in an actual Boolean value (e.g. testing the value of a Boolean attribute) a Boolean is coerced from the result. Thus an empty string or set or the number zero equate to false, all other values to true. Thus in AA's text above, the condition (1) equates to true so the result is 42.
Again, replace the $Text of note 'AA' with
	$Text(""AA""): $Color==""red""
This is less obvious. When the expression is evaluated, the result will be true if AA is red, and false otherwise. So, $Text(""BB"") will be empty unless AA is red; if AA's $Color is red,
	$Text(""BB""): true","eval([項目,] 式Str)
item 引数は、属性参照でない限り引用符で囲む必要があります。項目を定義する方法。
eval() 関数は、引用符で評価された 2 つの (文字列として) 引数を受け取ります。最初の引数 item はオプションです。2 番目の引数、expressionStr は、評価されるアクション コード式を保持する文字列を保持します。したがって、基本的な形式では次のようになります。
if($MyBool){$AttribX = ""$Name(親)+' XYZ'"";}else{$AttribX = ""$Name(祖父母) + 'ABC'"";};$AttribY = eval($AttribX);
属性 AttribX を評価することにより、属性 MyBool の値に応じて、AttribY を現在のノートの親のタイトルに文字列 ""XYZ"" を加えた名前、またはその祖父母のタイトルに文字列 ""ABC"" を加えた名前に設定します。したがって、 eval() は、属性のリテラル値ではなく、属性のアクション コードの結果を返します。そのため、eval は通常、文字列ベースの属性に適用されます。
「$」とリテラル文字列または変数から属性参照を構築しようとする場合は、代わりに action() を使用してください。
さらなる例
eval() 関数は、別のコンテキストで評価される式にローカル属性値を挿入する場合に役立ちます。ルール内のこの find() を考えてみましょう。
$ArtistCount = find($ArtistName==$Name & !$IsAlias).size;
評価されるノートごとに、ノートの $Name が ArtistName と比較されます。ただし、スコープ内のノートの $Name ではなく、呼び出し元のノートの $Name が必要なアーティスト名のノートでこれを使用することが目的だった場合はどうなるでしょうか。その関係を表す指定子はありませんが、 eval() は回避策を提供します。
$ArtistCount = eval('(find($ArtistName==""'+$Name+'"" & !$IsAlias).size)');
これは、まず正しい検索コードを使用して文字列を作成しますが、呼び出し元のメモの $Name の値も挿入します。その後、全体が上記の元の逐語的な find() 呼び出しであるかのように評価されます。
最初にプレースホルダー $TempString 属性を使用して、プロセスを 2 つのステップに分割することで、プロセスをより明確にすることができます。
$TempString = '(find($ArtistName==""'+$Name+'"" & !$IsAlias).size)';
外側の括弧は、検索の最後に連鎖する .size() 呼び出しが find() で評価されることを保証するためのものです。「Jacques Brel」という名前のノートの場合、$TempString は文字列 (find($ArtistName==""Jacques Brel"" & !$IsAlias).size) になります。ここで eval() を使用するには:
$ArtistCount = eval($TempString);
補足: 上記の実際のシナリオは、「that」指定子を使用して解決することもできますが、この例は eval() がどのように機能するかを調べるものとして当てはまります。
ネストされた eval() 呼び出しを使用するより複雑な例は、「コードの長いセクションの使用」で説明されています。
マクロ: eval() は do(macro) と組み合わせることができます。マクロは入力引数を取るため、評価されたマクロはコード関数のように動作し、入力を受け取り、 eval() を通過すると評価結果が得られる出力を返します。do() 演算子を参照してください。
eval() 演算子を使用すると、アクション構文や属性値では利用できない 2 つの Tinderbox プロパティへのアクセスも可能になります。現在の TBX ドキュメントのファイル名 (拡張子なし) と、ユーザーの Mac で現在使用されている Tinderbox のアプリ バージョンがあります。
eval(^^docTitle^^) は値「^docTitle^」を返します (「.tbx」拡張子がないことに注意してください)
eval(^^version^^) は ""^version^"" を返します (返される文字列の前に 'v' または 'v.' を付けると、""v.^version^"" のようになります)。
完全な構文形式では、ノート名、パス、またはノート名として評価される式文字列である最初の引数が追加されます。指定されている場合、これは 2 番目の引数の属性値を取得する注記を示します。
属性参照 ('Name' ではなく '$Name' のように $ 接頭辞が付けられます) を作成するには、eval() の代わりに action() を使用します。
両方の入力を使用した例
オプションの path 引数を使用した別の例。AA と BB という 2 つのルートレベルのメモを取ります。
$Text(""AA"") は: 1+1
$Text(""BB"") は次のとおりです: """" (つまり、何もありません)
$Rule(""BB"") は次のとおりです: $Text=eval(""AA"",$Text)
…少し遅れて、メモ BB のテキストは 2、つまり aa のテキストに保存されている式の合計になります。item 引数 ""AA"" は、expressionStr のソースがノート AA であることを単に示します。
次に、AA のテキストを変更します。
$Text(""AA"") は: if(1){42}else{1000}
…少し遅れて、メモ BB のテキストは 42 になります。どうやって?すべての if(条件) は、true/false の結果を取得しようとするブール テストです。条件の結果が実際のブール値にならない場合 (ブール属性の値のテストなど)、結果からブール値が強制的に取得されます。したがって、空の文字列、セット、または数値ゼロは false に相当し、他のすべての値は true に相当します。したがって、上記の AA のテキストでは、条件 (1) が true に等しいため、結果は 42 になります。
もう一度、メモ「AA」の $Text を次のように置き換えます。
$Text(""AA""): $Color==""赤""
これはあまり明らかではありません。式が評価されると、AA が赤の場合は結果が true になり、それ以外の場合は false になります。したがって、AA が赤でない限り、$Text(""BB"") は空になります。AA の $Color が赤の場合、
$Text(""BB""): true"
"every(scope, condition)",Function,Group,Non-query Boolean,boolean test,false,4.0.0,Baseline,,,,2,true,false,false,false,true,true,true,false,false,,false,"every(scope, condition)
This Boolean operator examines notes at scope and determines whether any note (i.e. at least one) in the group evaluates condition as true.
scope is the notes to be examined and may be any group designator including a find() query. If group evaluates to contain no items, see the edge case described below.
condition may be any valid expression, but will usually be a reference to an attribute; short form Boolean attribute expressions are acceptable. 
condition must not be enclosed in quotes.
For example:
	every(child,$Status==""Important"") 
	every(children,$Overdue==true) 
	every(children,$Overdue) (using short from test)
	every(children,$Overdue==false) 
	every(children,!$Overdue) (using short from test)
Be aware that a counter-intuitive edge case occurs if the scope is empty. Thus, every() is false if condition is false for any designated note. If there are no designated notes at all, i.e. scope is empty, every() is therefore true, whereas the user might have assumed no outcome and thus no true result. If problematic to the user's intent, this condition can be worked around by first ensuring that scope contains something. In the above example, that uses the scope 'children', a modification can be used, like this:
	$ChildCount>0 & every(children,$Overdue==true) 
See also: any().","すべて(スコープ、条件)
このブール演算子はスコープでノートを調べ、グループ内のいずれかのノート (つまり、少なくとも 1 つ) が条件を true と評価するかどうかを判断します。
スコープは検査するメモであり、find() クエリを含む任意のグループ指定子にすることができます。グループに項目が含まれていないと評価された場合は、以下で説明するエッジ ケースを参照してください。
条件には任意の有効な式を指定できますが、通常は属性への参照になります。短い形式のブール属性式も使用できます。
条件を引用符で囲むことはできません。
たとえば:
すべて(子,$Status==""重要"")
すべて(子供たち,$Overdue==true)
each(children,$Overdue) （テストの short を使用）
すべて(子供たち,$Overdue==false)
each(children,!$Overdue) （テストの short を使用）
スコープが空の場合、直感に反するエッジケースが発生することに注意してください。したがって、指定された音符の条件が false の場合、every() は false になります。指定されたメモがまったくない場合、つまりスコープが空の場合、every() は true になりますが、ユーザーは結果を想定していないため、真の結果も得られない可能性があります。ユーザーの意図にとって問題がある場合は、まずスコープに何かが含まれていることを確認することで、この状況を回避できます。スコープ「children」を使用する上記の例では、次のように変更を使用できます。
$ChildCount>0 & each(children,$Overdue==true)
「any()」も参照してください。"
exp(powerNum),Function,Item,Mathematical,Number,false,5.10.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"exp(powerNum)
Returns the exponential value of powerNum as e to the power of powerNum.
	$MyNumber = exp(3); 
returns 20.08553692 for an input of 3.","exp(powerNum)
powerNum の指数値を e の powerNum 乗として返します。
$MyNumber = exp(3);
入力が 3 の場合、20.08553692 を返します。"
"expand(scope,methodStr)",Function,Group,Formatting,success boolean,false,9.7.0,Baseline,,,,2,true,false,false,false,false,true,false,false,false,,false,"expand(scope,methodStr)
For Map view, this operator alters notes at scope and alters their $Width and/or $Height to fit the $Name string, according to the method given in methodStr. This operator does not require a left-side recipient, although it does return a true/false value if it is desired to check.
There are three valid choices for methodStr. Given in parentheses below are the equivalent settings from Document Settings ▸ Maps ▸ If note name is too long: see the latter link for an explanation of the resulting change. The options are:
* horizontally (same as Expand horizontally)
* vertically (same as Expand vertically)
* proportionately (same as Expand proportionately)
This function allows scoped resetting of map view note icon sizes. For example, to reset all child map notes using the proportional option, run this code on the maps' parent container:
	expand(children, proportional); 
To do similar but for an ad hoc selection on the current map, use a stamp with code:
	expand(this, proportional); 
recalling that a stamp is run individually on each selected item, so the code only needs a scope of the currently addressed item, i.e. this.","Expand(スコープ,メソッドStr)
マップ ビューの場合、このオペレーターは、methodStr で指定されたメソッドに従って、スコープでノートを変更し、$Name 文字列に合わせて $Width および/または $Height を変更します。この演算子は左側の受信者を必要としませんが、チェックが必要な場合は true/false 値を返します。
MethodStr には 3 つの有効な選択肢があります。以下の括弧内は、ドキュメント設定 ▸ マップ ▸ ノート名が長すぎる場合: 結果として生じる変更の説明については、後者のリンクを参照してください。オプションは次のとおりです。
* 水平方向 (水平方向に拡張と同じ)
* 垂直方向 (垂直方向に拡張と同じ)
* 比例して (比例して拡大するのと同じ)
この機能を使用すると、マップ ビューのメモ アイコンのサイズを範囲指定してリセットできます。たとえば、比例オプションを使用してすべての子マップ ノートをリセットするには、マップの親コンテナで次のコードを実行します。
Expand(子、比例);
同様のことを、現在のマップ上でアドホックに選択するには、コード付きのスタンプを使用します。
Expand(this, 比例);
スタンプは選択された各項目に対して個別に実行されるため、コードには現在アドレス指定されている項目、つまり this のスコープのみが必要であることを思い出してください。"
"exportedString(item[, templateStr])",Function,Item,Formatting,String,false,4.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"exportedString(item[, templateStr])
The operator exportedString() applies an export template to a note, returning the result as a String. 
item designates the note to be exported; and is a note name, path or item designator. An attribute may not be used as a placeholder for such information. By default, the note used is the current note, i.e. 'this'. exportedString() also binds 'current' designator to 'this' when resolving item.
The second argument, templateStr, has three forms.
* an HTML export template name; this argument is evaluated allowing use of attribute values and expressions. Full template paths should not be quotes, but enclose template names ($Name) in double-quotes.
* the name of an attribute or variable whose value is  a string of actual template code (i.e. what would normally be the contents of a template), which is then applied to the referenced note. The attribute reference cannot use a path extension to refer to a different note, $ExportCode is OK but an offset address like $ExportCode(Another note) will fail.
* a literal string of export code. The most usual use of this is as '^^text^^', i.e. the export encoded $Text of the note. This form is suggested only for very short code strings. For longer code, place it in a discrete template and use it via the two-argument form.
In the short, single argument, usage the template to evaluate is not supplied as the target note's inherited or locally assigned template is used. In long-lived projects, it can be useful to use the two-argument form (assuming the template assignment will not change!). Doing this makes it easier to see in code which template will be used rather than have to go and look up that value. Making such a change has no performance input.
The exportedString() operator is especially useful in conjunction with the runCommand() operator. You can use exportedString() to assemble the input an external program will require, and then pass that input to the external program.
If you simply wish to transform a string or attribute value (e.g. $Name) into a 'safe' value for use as an HTML/XML element 'id' value, a possible alternative is to use idEncode().
Examples
exportedString(item)
Use of exportedString with just the target item. If using only the (unique) note $Name, it should be quote-enclosed.
	$MyString = exportedString(""Some Note""); 
or using a full $Path for the template, do not use quotes:
	$MyString = exportedString(/Projects/X/Some Note); 
exportedString(item, templateStr) 
The first form using templateStr takes a reference to a note and the name of a template note and returns the result of applying the template to the note. If item is a path or title, the value requires quotes:
	$MyString = exportedString(this,""tSome_Template""); 
	$MyString = exportedString(""Some note"",""tSome_Template""); 
or use the unquoted full $Path for the template:
	$MyString = exportedString(this,/Templates/tSome_Template); 
The second form using templateStr requires as its second argument is the template string itself which may be a reference to an attribute or action code variable:
	$MyString = exportedString(this,$MyTemplateCode); 
	$MyString = exportedString(this,vTemplate); 
The third form using templateStr requires as its second argument some literal code:
	$MyString = exportedString(""/Path/To/Some note"",""^^text^^""); 
	$MyString = exportedString(""/Path/To/Some note"",""^^value($Name(parent))^^"");","exportedString(item[, templateStr])
演算子exportedString()は、エクスポートテンプレートをノートに適用し、結果を文字列として返します。
item はエクスポートするメモを指定します。はノート名、パス、またはアイテムの指定子です。属性をそのような情報のプレースホルダーとして使用することはできません。デフォルトでは、使用されるノートは現在のノート、つまり「this」です。また、exportedString() は、項目を解決するときに「current」指定子を「this」にバインドします。
2 番目の引数 templateStr には 3 つの形式があります。
* HTML エクスポート テンプレート名;この引数は、属性値と式の使用を許可して評価されます。テンプレートの完全なパスは引用符ではなく、テンプレート名 ($Name) を二重引用符で囲む必要があります。
* 値が実際のテンプレート コード (つまり、通常はテンプレートの内容となるもの) の文字列である属性または変数の名前。これは参照されるメモに適用されます。属性参照では、パス拡張子を使用して別のノートを参照することはできません。$ExportCode は問題ありませんが、$ExportCode(Another note) のようなオフセット アドレスは失敗します。
* エクスポート コードのリテラル文字列。これの最も一般的な使用法は、「^^text^^」、つまりメモのエクスポート エンコードされた $Text として使用することです。この形式は、非常に短いコード文字列の場合にのみ推奨されます。長いコードの場合は、それを個別のテンプレートに配置し、2 つの引数の形式で使用します。
短い単一の引数では、ターゲット ノートの継承されたテンプレートまたはローカルに割り当てられたテンプレートが使用されるため、評価するテンプレートの使用法は指定されません。長期にわたるプロジェクトでは、2 つの引数形式を使用すると便利です (テンプレートの割り当てが変更されないと仮定して)。こうすることで、値を調べに行く必要がなく、どのテンプレートが使用されるかをコード内で簡単に確認できるようになります。このような変更を行ってもパフォーマンスは変化しません。
exportedString() 演算子は、runCommand() 演算子と組み合わせると特に便利です。exportedString() を使用して、外部プログラムが必要とする入力をアセンブルし、その入力を外部プログラムに渡すことができます。
単に文字列または属性値 ($Name など) を HTML/XML 要素の「id」値として使用するために「安全な」値に変換したい場合、考えられる代替案は idEncode() を使用することです。
例
エクスポートされた文字列(項目)
ターゲット項目のみでのexportedStringの使用。(一意の) メモ $Name のみを使用する場合は、引用符で囲む必要があります。
$MyString = exportedString(""メモ"");
またはテンプレートに完全な $Path を使用する場合は、引用符を使用しないでください。
$MyString = exportedString(/プロジェクト/X/メモ);
エクスポートされた文字列(項目, テンプレート文字列)
templateStr を使用する最初のフォームは、ノートへの参照とテンプレート ノートの名前を取得し、テンプレートをノートに適用した結果を返します。item がパスまたはタイトルの場合、値には引用符が必要です。
$MyString = exportedString(this,""tSome_Template"");
$MyString = exportedString(""メモ"",""tSome_Template"");
または、テンプレートに引用符で囲まれていない完全な $Path を使用します。
$MyString = exportedString(this,/Templates/tSome_Template);
templateStr を 2 番目の引数として使用する 2 番目の形式は、属性またはアクション コード変数への参照である可能性があるテンプレート文字列自体です。
$MyString = exportedString(this,$MyTemplateCode);
$MyString = exportedString(this,vTemplate);
templateStr を使用する 3 番目の形式では、2 番目の引数としてリテラル コードが必要です。
$MyString = exportedString(""/パス/宛先/メモ"",""^^テキスト^^"");
$MyString = exportedString(""/パス/宛先/メモ"",""^^value($Name(parent))^^"");"
fail(),Function,Item,Stream parsing,success boolean,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"fail()
fail
The fail operator makes an explicit declaration of a failure, and if invoked only ever returns false.
Often, in stream processing a failure occurs implicitly, for example because the end of the processed string is reached without finding the desired data. However, sometimes, there is a definite need to signal failure; for example, because the parsed data are invalid.
For example:
	$MyString.try{
	   $MyString.skipTo("":"").captureWord(""TheWord"");
	   if($TheWord.contains(""None"")) {
	      fail();
	   }
	}
The above skips through $MyString to the first colon and then captures the next discrete word after the colon into $TheWord. The action fails if:
* if there is no colon
* if there is no word after the colon
* if $TheWord contains ""None"" as a case-sensitive exact full match or substring match.","失敗()
失敗する
失敗演算子は失敗を明示的に宣言し、呼び出された場合にのみ false を返します。
多くの場合、ストリーム処理では、たとえば、目的のデータが見つからないまま処理された文字列の終わりに到達するなどの理由で、暗黙的に失敗が発生します。ただし、場合によっては、失敗を明確に通知する必要がある場合があります。たとえば、解析されたデータが無効であるためです。
たとえば:
$MyString.try{
$MyString.skipTo("":"").captureWord(""TheWord"");
if($TheWord.contains(""なし"")) {
失敗();
}
}
上記は、$MyString を最初のコロンまでスキップし、コロンの後の次の個別の単語を $TheWord にキャプチャします。次の場合、アクションは失敗します。
*コロンがない場合
* コロンの後に単語がない場合
* $TheWord に、大文字と小文字を区別する完全一致または部分文字列一致として「None」が含まれる場合。"
"fetch(urlStr,headersDict,attrNameStr,cmdStr[,httpMethod,POSTbody])",Function,Item,Document configuration,String,false,9.6.0,Baseline,,,,4,true,false,false,false,false,false,false,false,false,,false,"fetch(urlStr,headersDict,attrNameStr,cmdStr[,httpMethod,POSTbody])
The fetch() operator enables collecting data from a server when greater flexibility than when using AutoFetch. For most purposes, AutoFetch should be the primary choice;> If uncertain use AutoFetch unless it proves not to work; fetch() is an advanced operator for the few who need it.
urlStr is the URL source to be called into Tinderbox.
headersDict is a dictionary of HTTP(S) headers. This must be an empty dictionary {} (no enclosing quotes) if you do not need custom headers.
attrNameStr is the name of (not a reference to) an attribute or local variable in which the output of the fetch process is stored. Note the difference from AutoFetch which places the output directly into $Text. Here, the data from the remote server will be fetched asynchronously, and stored in this attribute or local variable. Note that this parameter is not evaluated, i.e. ""MyString"" not $MyString, unless attribute MyString hold the name of an attribute. This attribute cannot be left empty and must be a literal quoted string, an attribute reference or a variable.
cmdStr is a Tinderbox action expression (or semi-colon delimited sequence of actions) to be performed after the data is fetched; i.e. the value is action code. Be aware that the latter may be some time after the fetch operator returns; do not assume full processing happens immediately. It may be an empty string """" if no transform is needed on the recovered data (this in unlikely to be the case).
httpMethod is an optional argument, indicating the HTTP request method to be used. HTTP 1.1. defined methods (per RFC 9110) are GET, HEAD, POST , PUT (including PATCH), DELETE, CONNECT, OPTIONS, and TRACE. If httpMethod is not specified, fetch() defaults to using a GET request. The methods allowed are as per the HTP protocol in use at the server, rather than a restriction by Tinderbox. Also be aware that support for a given method may also be a constraint at the server end of the request.
POSTbody is an optional argument. If the httpMethod is POST, POSTbody specifies a message body to be sent to the designated server.
Note that the server might take several seconds or more before supplying a response. fetch() returns immediately without waiting for the server, and arranges for the command to be evaluated when the data arrive; Tinderbox will continue to try for c.30 seconds before giving up. Why? Because Tinderbox has no control over the time the source at urlStr takes to return the requested data.
Given this possible delay between calling fetch() and the completion of the full process, it may be necessary to take steps to avoid repeating the fetch() call before the previous operation has completed. For example, this can be done by setting a $MyBoolean(/In Progress) to true immediately before starting the fetch, and setting it to false when all is complete. Note: the choice of an ""In Progress"" note to hold the boolean is just one approach—where the boolean value is stored and in which attribute are choices for the user to make.
fetch() processes its command on a serial queue. So, if several fetch() requests are outstanding, they will not interfere: that queue is the sequence in which they will be evaluated.
The show() operator can be used as part of the cmdStr, as a way of giving feedback.
Examples
Suppose there is a need to interact with an API. Typically, that means:
* Passing a GET or POST message to a designated URL.
** Possibly doing this using some custom headers for authentication or other reasons.
* Wait for the server to respond.
* When the server does respond, take what is returned and process it.
Note how this is more complex than previous AutoFetch. But, custom headers may be needed or it may be necessary to process the results right away. For example, the result might say: ""Here are the first ten results; and here is a magic token to send to get the next ten."" Such tokens are typically good for a short time only. AutoFetch was not designed for such complications.
In the following example, notice the fetch() argument #2 uses the newer {} style of dictionary declaration:
 var string aServerULR = ""https://yourserver.com"";
	var string myPayload = ""?status=publish"";
	
	fetch(aServerULR + myPayload,{Content-Type: application/json},""aTempVariable"",""doProcessCallback(aTempVariable);"",POST)
	
	function doProcessCallback(returnValue:string) {
   		show(returnValue);
	};
Here is a fuller example of a Readwise data importer function as an example. Be aware that the code refers to user fuctions, e.g. 'rwHeaders()' that are not included in the example code:

function getHighlights(auth:string,page:string) {
	rwSetup();
	if(rwIsInProgress()) {
		show(""Readwise already in progress"");
		return;
		}

	show(""Readwise starting import"");
	rwMarkInProgress();

	var:string theLog=create(""/log"");
	fetch(rwURL(page),rwHeaders(auth),""temp"",""rwParse(temp,/log,0)"");

	}

Note: everything in the above example with an 'rw' prefix is a function.",
find(query),Function,Query,"Dictionary, Set & List operations",List,false,5.6.0,Baseline,,,,1,true,false,false,false,false,true,false,false,false,,false,"find(query)
The find() operator returns List-type data of the $Path of all items matching the query argument scope (defining scope). Note that find(), unlike agent queries, does not de-duplicate its matches so any aliases in scope with be matched: to avoid the latter see section 'Filtering out aliases' below. 
To return a list of paths for notes with prototype of 'pRef' and fro which boolean $HasRef is false use:
	find($Prototype==""pRef"" & $HasRef==false) 
Conceptually find() is intended for where no item or group designator exists for use inline in action code (note: such designators were the only scoping terms in early version of Tinderbox). In most cases an agent is the likely and better alternative, noting that agents can also use the results of other agents. find() can also be thought of as a short way of writing:
	$MyList = collect_if(all, expression, $Path); 
where the expression is scope.
The find() operator omits notes for which $Searchable is false.
Filtering out aliases
The find() operator does not de-dupe results in the way an agent does. As find() collects $Path data, aliases both inside and outside agents may also match the query. Adding !$IsAlias as a query term will scrub any aliases from matching a search.
Thus if getting unexpected results via find(), consider whether it is because some de-duping was (incorrectly) assumed and be prepared to sharpen the query terms accordingly.
In the above example, to additionally filter out possible alias matches add an extra query term:
	find($Prototype==""pRef"" & $HasRef==false & $IsAlias==false) 
See also: querying for aliases.","検索(クエリ)
find() 演算子は、クエリ引数のスコープ (定義スコープ) に一致するすべての項目の $Path のリスト型データを返します。エージェント クエリとは異なり、find() は一致の重複を排除しないので、スコープ内のエイリアスが一致することに注意してください。後者を避けるには、以下の「エイリアスのフィルタリング」セクションを参照してください。
プロトタイプが「pRef」で、ブール値の $HasRef が false であるノートのパスのリストを返すには、以下を使用します。
find($Prototype==""pRef"" & $HasRef==false)
概念的には、 find() は、アクション コード内でインラインで使用するアイテムまたはグループ指定子が存在しない場合に使用することを目的としています (注: このような指定子は、Tinderbox の初期バージョンでは唯一の範囲指定用語でした)。ほとんどの場合、エージェントは他のエージェントの結果も使用できることに注意して、エージェントがより適切な代替手段となる可能性が高くなります。find() は、次のような短い書き方と考えることもできます。
$MyList =collect_if(all, 式, $Path);
ここで、式はスコープです。
find() 演算子は、$Searchable が false であるメモを省略します。
エイリアスのフィルタリング
find() オペレーターは、エージェントのように結果の重複を排除しません。find() は $Path データを収集するため、エージェントの内部と外部の両方のエイリアスもクエリに一致する可能性があります。!$IsAlias をクエリ用語として追加すると、検索に一致するエイリアスが除外されます。
したがって、find() を介して予期しない結果が得られた場合は、重複除外が (誤って) 想定されたためであるかどうかを検討し、それに応じてクエリ用語をシャープにする準備をしてください。
上記の例では、エイリアスの一致の可能性をさらに除外するために、追加のクエリ用語を追加します。
find($Prototype==""pRef"" & $HasRef==false & $IsAlias==false)
エイリアスのクエリも参照してください。"
"first(item[, childrenNum])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"first(item[, childrenNum])
Returns Boolean true if the current note is among the first itemsNum of children of item. If itemsNum is missing, a value of 1 is assumed. The item argument must be quoted unless an attribute reference. Ways to define item.
Both arguments are evaluated and can be a literal string/number, an attribute value or an action code expression evaluating to that same.
If the current note has a $SiblingOrder value of 2, then if first() is run on its parent container:
	first(""Note A"", 5) returns true 
but if 'it has a $SiblingOrder value of 7:
	first(""Note A"", 5) returns false
first() also has a logical opposite in last().
Legacy issues
This operator replaces the legacy #first query operator.","first(item[,childrenNum])
現在のノートが item の子の最初の itemsNum に含まれる場合、ブール値 true を返します。itemsNum が欠落している場合は、値 1 が想定されます。item 引数は、属性参照でない限り引用符で囲む必要があります。項目を定義する方法。
両方の引数が評価され、リテラル文字列/数値、属性値、またはそれを評価するアクション コード式にすることができます。
現在のノートの $SiblingOrder 値が 2 である場合、親コンテナーで first() が実行されると次のようになります。
first(""Note A"", 5) は true を返します
ただし、$SiblingOrder 値が 7 の場合:
first(""Note A"", 5) は false を返します
first() には、last() の論理反対もあります。
従来の問題
この演算子は、従来の #first クエリ演算子を置き換えます。"
firstWord(dataStr),Function,Item,Data manipulation,String,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"firstWord(dataStr)
The firstWord() operator has one argument, dataStr (a quoted string), and it returns the first word of dataStr (as a String). The delimiter used to define words is one or more spaces (possibly also line break(s)?).
The dataStr argument is evaluated so could be an expression. For example, if the note 'First Line' has the body text ""Winter is coming."", then 
	$MyString = firstWord($Text(""First Line"")); 
should give a result of ""Winter"".","firstWord(dataStr)
firstWord() 演算子には 1 つの引数、dataStr (引用符で囲まれた文字列) があり、dataStr の最初の単語を (文字列として) 返します。単語を定義するために使用される区切り文字は 1 つ以上のスペースです (改行も可能ですか?)。
dataStr 引数は評価されるため、式にすることができます。たとえば、メモ「最初の行」の本文が「冬が来ています。」である場合、
$MyString = firstWord($Text(""最初の行""));
「冬」という結果が得られるはずです。"
floor(sourceNum),Function,Item,Mathematical,Number,false,6.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"floor(sourceNum)
rounds the number value of sourceNum down to next whole integer.
See also ceil() and round().
If $MyNumber is 3.9 then:
	$MyNumber = ceil($MyNumber); 
sets $MyNumber to 3. Note unlike normal rounding the value is set downwards to the next integer (i.e. whole number).","フロア(ソース番号)
sourceNum の数値を次の整数に切り捨てます。
ceil() およびround() も参照してください。
$MyNumber が 3.9 の場合:
$MyNumber = ceil($MyNumber);
$MyNumber を 3 に設定します。通常の四捨五入とは異なり、値は次の整数 (つまり、整数) に下方に設定されることに注意してください。"
"format(dataStr, formatStr[, additionalArguments])",Function,Item,Formatting,String,false,4.0.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"format(dataStr, formatStr[,additionalArguments])
Note: in most cases it is better to use newer .format() dot-operator for this task.
The operator format() converts various Tinderbox objects to strings. In quoted ("") string arguments a \"" is converted into a quotation mark (a.k.a. double quote), \n to a carriage return and \t to a tab.
The argument dataStr is evaluated, and is usually an attribute reference or expression. An attribute reference can take both short and long forms:
	$MySet (i.e. the current note's $MySet)
	$MySet(Test) (i.e. set $MySet data from note 'Test')
The meaning of formatStr depends on the type of object represented by what. Additionally, number of additionalArguments may be supplied depending on the dataStr data type. Tinderbox data types Date, Set and Number are handled using different sets of arguments as described below.
This function is being supplemented by per-data-type .format() dot operators which are usually more flexible when writing non-trivial code: links to per-data-type dot operators are added below.
DATE-Type Data
If dataStr is a date, the format string is the same as the format used by Tinderbox's date export codes.
format(dataStr, formatStr)
For example:
	$MyString = format($Created,""L""); 
gets the note's creation date and formats it as a ""long local date"" such as ""Sunday, 23 March, 2007"". 
Also use Date.format(""formatString"").
SET/LIST-Type Data
If data is a Set or a List, the format string is the delimiter used to separate set elements:
format(data, formatStr)
The process preserves original data; duplicate values in lists are maintained. For example
	$MyString = format($DisplayedAttributes,"", ""); 
converts Displayed Attributes to a comma+space-separated list. To put each item on a separate line use this:
	$MyString = format($DisplayedAttributes,""\n""); 
Thus $Text may be created from concatenation of other texts:
	$Text = format(collect(children, $Text),""\n""); 
To strip duplicates from a List, do not use format(). Instead, simply set a Set attribute to the contents of the List attribute (or any function/expression returning List-type data).
Also use List.format(""formatString"").
Optionally, you may supply formatStr as four discrete arguments to format a list, for example as an HTML list:
format(data,list-prefix,item-prefix,item-suffix,list-suffix)
For example
	$MyString = format($Classes,""&lt;ul>"",""&lt;li>"",""&lt;/li>"",""&lt;/ul>""); 
will return HTML code for a bulleted list with each set member marked up as a list item. Note that the tags must be in double quotes. To have each element on a separate line and indent the items add tabs and line breaks:
	$MyString = format($Classes,""&lt;ul>\n"",""\t&lt;li>"",""&lt;/li>\n"",""&lt;/ul>\n""); 
To make this easier to use in a code export context, you might pass the output of format into another attribute and call the latter within the template with a ^^value()^^ code. By a repeat call to format it is possible to export lists of links.
Also use List.format(""listPrefix"",""itemPrefix"",""itemSuffix"",""listSuffix"")
NUMBER-Type Data
Use of format() with number data is deprecated in favour of either the Number.precision() or Number.format() operators.
If dataStr is a number, then the arguments are numeric and interpreted as follows:
format(dataStr,precisionNum[, widthNum][,padStr])
The precisionNum argument controls the number of decimal places returned. The optional widthNum argument allows the returned value to be a string left padded with spaces, e.g. to return a string with the same number of characters as submitted. 
For example, if $MyNumber is 3.1415927, then
	$MyString = format($MyNumber,2,7); is ""&nbsp;&nbsp;&nbsp;3.14"" (3 spaces + number + period + 3 numbers = 7)
	$MyString = format($MyNumber,2); is 3.14
	$MyString = format($MyNumber,0); is 3
	$MyString = format($MyNumber,0,2); is '&nbsp;&nbsp;3' (two left-padding spaces) 
	$MyString = format(5.1415927,2); is 5.14
Note that with widthNum, decimal character is not counted as part of the number.
If the optional padStr is given, this specifies the character used for padding. The default is a space:
	$MyString = format(7,0,3); gives ""  7"" 	
	$MyString = 7.format(7,0,3,""0""); gives ""007""
	$MyString = format(7,0,3,""#""); gives ""##7""
An alternate number format is offered using a quoted format string:
Number.format( formatStr)
Currently only one such string is supported ""L"". This will return a string of the number formatted with (OS) locale-dependent group & decimal delimiters. For example, for the US locale these are a comma and a period; in other locales they may vary.
Also use Number.format(decimalsN,widthN).
COLOR-Type Data
If dataStr is color type, format strings are ignored:
format(colorStr)
The operator returns the colour colorStr in hex form, e.g. ""#ff00ff"", regardless of whether the stored value is hex or a named Tinderbox colour.
	$MyString = format($MyColor) 
is ""#ff00ff"" if $MyColor is ""purple""
Also use Color.format().
INTERVAL-Type Data
If data is interval-type, format strings can use date-type format strings. An interval of 00:00 (hours:minutes) is always displayed as an empty string.
Also use Interval.format().",
function,Statement,Document,Data manipulation,declaration,false,9.1.0,Baseline,,,,,false,false,false,true,false,false,false,false,false,,true,"function
The function statement defines a user-defined function. Unusually as an operator function is used as a statement which is then followed by the definition of a user-named function fName. Atypically, trailing empty parentheses must not used by function. Thus:
function fName([argumentsList]){code}
Once defined a function is called in action code using the user-defined function name (here fName), as described here. Any function may several arguments or none at all. These are defined via a comma-delimited argumentsList. All arguments defined in the list are mandatory, unlike some action code operators which define some arguments as optional. In use, all defined arguments must be supplied, even if only as a default value, e.g. 0 for a number, etc.
All input arguments (the argumentsList) are available to use in code within the function. Thus by using the argument name as defined in the argumentsList, each argument's supplied value is retrievable anywhere within the function. Just as with a loop variable, the defined argument name is the code used to retrieve that argument's value.
As functions are more complex than other operators, their complete syntax and use is described in detail in the article on Functions and its sub-articles.
Function declarations may optionally specify the date type of their input arguments, as passed via argumentsList.
Private functions
A private function is a function that can only be called within the note in which it is defined. That note will usually be a library note.
The point of a private function is it allows for the scenario where two (or more) functions might have the same name as might arise if using library notes created by different people. Thus two (or more) library notes can each define private functions with identical names; each library note will use its own version of the private function. As long as functions are labelled private, they will only be callable from their containing note and not from other (library) notes. Be aware that if a note only contains one function it should not be made private—as nothing outside the note can call it. 
A function is designated private by inserting the word private between the function's argument parentheses and the curly brace starting the function's code:
	function fFunctionName(Args) private { ...code... }
White space(s) before/after the private is optional.","機能
function ステートメントはユーザー定義関数を定義します。通常、演算子関数はステートメントとして使用され、その後にユーザー名付き関数 fName の定義が続きます。通常、関数では末尾の空の括弧を使用してはなりません。したがって:
関数 fName([引数リスト]){コード}
関数を定義すると、ここで説明するように、ユーザー定義の関数名 (ここでは fName) を使用してアクション コードで関数が呼び出されます。どの関数にも複数の引数があるか、まったく引数がない場合があります。これらは、カンマ区切りの argumentList によって定義されます。一部の引数をオプションとして定義する一部のアクション コード演算子とは異なり、リストで定義されているすべての引数は必須です。使用時には、たとえデフォルト値としてのみであっても、定義されたすべての引数を指定する必要があります。数値の場合は 0 など。
すべての入力引数 (argumentsList) は、関数内のコードで使用できます。したがって、argumentsList で定義されている引数名を使用すると、各引数に指定された値を関数内のどこからでも取得できます。ループ変数の場合と同様に、定義された引数名は、その引数の値を取得するために使用されるコードです。
関数は他の演算子よりも複雑であるため、その完全な構文と使用法については、関数に関する記事とそのサブ記事で詳しく説明されています。
関数宣言では、オプションで、argumentsList を介して渡される入力引数の日付型を指定できます。
プライベート機能
プライベート関数は、それが定義されているノート内でのみ呼び出すことができる関数です。そのメモは通常、図書館のメモになります。
プライベート関数のポイントは、異なる人が作成したライブラリ ノートを使用する場合に発生する可能性がある、2 つ (またはそれ以上) の関数が同じ名前を持つシナリオを許容することです。したがって、2 つ (またはそれ以上) のライブラリ ノートはそれぞれ同じ名前のプライベート関数を定義できます。各ライブラリ ノートは、独自のバージョンのプライベート関数を使用します。関数がプライベートとラベル付けされている限り、関数はその関数を含むノートからのみ呼び出すことができ、他の (ライブラリ) ノートからは呼び出すことができません。ノートに 1 つの関数しか含まれていない場合は、ノートの外部からその関数を呼び出すことができないため、プライベートにしないでください。
関数がプライベートであることを指定するには、関数の引数の括弧と関数のコードを開始する中括弧の間に private という単語を挿入します。
function fFunctionName(Args) private { ...コード... }
プライベートの前後の空白はオプションです。"
"hasLocalValue(attributeNameStr[, item])",Function,Item,Data manipulation,success boolean,false,7.0.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"hasLocalValue(attributeNameStr[,item])
For the current note this tests if an attribute name attributeNameStr has a locally set value (returning a Boolean true), or whether that value is inherited from a prototype or document default (false). The main input is a quote-enclosed system or currently defined user attribute (without a $ prefix):
	$MyBoolean = hasLocalValue(""Rule"") 
The arguments are evaluated, so 
	$MyBoolean = hasLocalValue($MyString) 
returns information about the attribute whose name is currently saved as the current note's value of $MyString.
The note evaluated is the current note. The 'item' input allows for offset addressing. For example:
	$MyBoolean = hasLocalValue(""Rule"",""Some Note"") 
checks the local value status of $Rule not for the current note but for the note called ""Some Note""
As the operator returns a boolean, it can be used in a query in agents or find(), like so:
	$MyBoolean = hasLocalValue(""Edict"") 
in this case matching any note with a locally-set $Edict value.
Note: most users will not have need of this but it is useful in very large document to find the odd note with a local setting, when visual review would take too long. It is also useful where (re-)inheritance of attribute values appears broken or is not reset as expected.","hasLocalValue(属性名Str[,項目])
現在のメモの場合、これは属性名attributeNameStrにローカルに設定された値があるかどうか（ブール値のtrueを返す）、またはその値がプロトタイプまたはドキュメントのデフォルトから継承されているかどうか（false）をテストします。主な入力は、引用符で囲まれたシステムまたは現在定義されているユーザー属性 ($ プレフィックスなし) です。
$MyBoolean = hasLocalValue(""ルール"")
引数は評価されるので、
$MyBoolean = hasLocalValue($MyString)
$MyString の現在のメモの値として現在保存されている名前を持つ属性に関する情報を返します。
評価されるノートは現在のノートです。「item」入力を使用すると、オフセット アドレス指定が可能になります。たとえば:
$MyBoolean = hasLocalValue(""ルール"",""メモ"")
$Rule のローカル値ステータスを現在のノートではなく「Some Note」というノートに対してチェックします。
演算子はブール値を返すため、次のようにエージェントまたは find() のクエリで使用できます。
$MyBoolean = hasLocalValue(""勅令"")
この場合、ローカルに設定された $Edict 値を持つ任意のメモと一致します。
注: ほとんどのユーザーはこれを必要としませんが、非常に大きなドキュメントで視覚的なレビューに時間がかかりすぎる場合に、ローカル設定で奇妙なメモを見つけるのに役立ちます。また、属性値の (再) 継承が壊れているように見える場合、または期待どおりにリセットされない場合にも役立ちます。"
"hour(aDate, hoursNum)",Function,Item,Date-time,Date,false,5.7.0,Baseline,,,,2,true,false,true,false,false,false,false,false,false,,false,"hour(theDate, hoursNum)
creates a new Date based on the aDate expression, but in which the hour is hoursNumDate is not changed unless theDate is an attribute and the attribute is re-setting itself:
	$MyDateA = hour($MyDate,14); $MyDate is unaltered
	$MyDate = hour($MyDate,14); $MyDate is changed
Examples. If $MyDate is July 4,2009 09:30, then 
	$MyDate=hour($MyDate,19); 
will change $MyDate to July 4, 2009 19:30.
The single-argument form that reads the hour value is documented separately: see hour(aDate).","時間(日付、時間数)
aDate 式に基づいて新しい Date を作成しますが、時間が hoursNumDate である場合、theDate が属性であり、属性がそれ自体を再設定しない限り、NumDate は変更されません。
$MyDateA = 時間($MyDate,14);$MyDate は変更されません
$MyDate = 時間($MyDate,14);$MyDate が変更されました
例。$MyDate が 2009 年 7 月 4 日 09:30 の場合、
$MyDate=時間($MyDate,19);
$MyDate は 2009 年 7 月 4 日 19:30 に変更されます。
時間の値を読み取る単一引数の形式については、個別に文書化されています。「hour(aDate)」を参照してください。"
hour(aDate),Function,Item,Date-time,Number,false,5.7.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"hour(aDate)
returns the hour element from the aDate date/time expression, which may simply be a date-type attribute value.
Alternatively, use Date.hour.
The two-argument merthod used to set Dates is documented separately: see hour(aDate, hoursNum).","時(日付)
aDate 日付/時刻式から時間要素を返します。これは単に日付タイプの属性値である場合もあります。
あるいは、Date.hour を使用します。
日付の設定に使用される 2 つの引数メソッドについては、別途文書化されています。hour(aDate, hoursNum) を参照してください。"
"hours(startDate, endDate)",Function,Item,Date-time,Number,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"hours(startDate, endDate) 
returns the Number of whole hours that elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA has time 12:30 and $DateB has time 15:00, then:
	$MyNumber = hours($DateA,$DateB); 
sets $MyNumber to 2.","時間(開始日、終了日)
startDate と endDate の間に経過した整数の時間数を返します。endDate が startDate より前の場合、結果は負になります。
$DateA の時刻が 12:30、$DateB の時刻が 15:00 の場合、次のようになります。
$MyNumber = 時間($DateA,$DateB);
$MyNumber を 2 に設定します。"
idEncode(dataStr),Function,Item,Formatting,String,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"idEncode(data)
Returns input argument string data in a form suitable for use an id attribute value in HTML and XML. This addresses the problem of using general text strings such as note names as 'id' attributes in output for marked up languages like HTML and XML.
idEncode(""stringValue"")
idEncode($AttributeName)
Using idEncode() ensures the result begins with a letter or underscore, and contains only letters, digits, and the underscore character. Multiple underscores are collapsed to a single character. For example:
	idEncode(string) → result string
	frogs → frogs 
	frogs dogs → frogs_dogs 
	War And Peace → War_And_Peace 
	3 blind mice → _3_blind_mice 
	Wow!!! Look → Wow_Look 
Notice that leading numbers (not legal for 'id' initial characters) are preceded by underscores to maintain legibility vs. the source string.
Note too (see syntax examples at top) that string literal values are ""quoted"" whereas attribute names are not, the latter's status being indicated by their $ prefix.
In code, the last example above can be expressed:
	$MyString = idEncode(""Wow!!! Look"") 
which gives a value ""Wow_Look"".","idエンコード(データ)
入力引数の文字列データを、HTML および XML での id 属性値の使用に適した形式で返します。これにより、HTML や XML などのマークアップ言語の出力でノート名などの一般的なテキスト文字列を「id」属性として使用する問題が解決されます。
idEncode(""文字列値"")
idEncode($AttributeName)
idEncode() を使用すると、結果が文字またはアンダースコアで始まり、文字、数字、アンダースコア文字のみが含まれるようになります。複数のアンダースコアは 1 文字に折りたたまれます。たとえば:
idEncode(文字列) → 結果文字列
カエル→カエル
カエル犬 → frogs_dogs
戦争と平和 → 戦争と平和
盲目のマウス 3 匹 → _3_blind_mice
うわー！見て→Wow_Look
ソース文字列に対する読みやすさを維持するために、先頭の数字 (「id」の頭文字としては無効です) の前にアンダースコアが付いていることに注意してください。
文字列リテラル値は「引用符で囲まれ」ますが、属性名は引用符で囲まれていないことにも注意してください (先頭の構文例を参照)。後者のステータスは $ プレフィックスで示されます。
コードでは、上記の最後の例を次のように表現できます。
$MyString = idEncode(""すごい!!! 見てください"")
これにより、値「Wow_Look」が得られます。"
if(condition){actions}[else{actions}],Function,Conditional Group,Data manipulation,boolean test,false,1.0.0,Baseline,,,,1,true,false,false,false,true,false,true,true,false,,false,"if(condition){actions}[else{actions}]
In rules and (agent) actions, Tinderbox uses this conditional action syntax:
	if(condition){ action(s) }
	if (condition){ action(s) }else{ action(s) }
Where:
* condition is any action code involving an evaluation to a conditional test that resolves to a Boolean true (if the condition is as expected). If the expression is in the form of an $Attribute.[i]contains(regex) query, regex back-references can be used in in the action code of the actions. A conditional expression can also be a query, such as find(), where matching zero results is false and otherwise true is returned.)
* actions is a list of one or more action code expressions, separated by semicolons.
Example:
	if($ChildCount > 5){$Color = ""red"";$Width = 3.5;}else{$Color = ""blue"";} 
A condition can have multiple tests. And (&) or Or (I) joins are allowed as is parenthesised nesting of expressions:
	if($ChildCount > 5 | $Badge = ""ok""){$Color=""red"";$Width=3.5;} 
	if(($ChildCount > 5 & $Badge = ""ok"") | $WordCount >= 450){$Color = ""red"";$Width = 3.5;} 
If the expression is a complex set of condition clauses it may make sense to calculate the conditions, store the value in an attribute and test that in the if(). This form of re-writing the test is a normal part of incremental formalisation such as may occur as a document gets bigger and more complex.
Negative tests
The testing for negatives, the absence of a value (or being in default condition), may be done in several ways. For an attribute value test, the attribute name may simply be prefixed with an exclamation mark, using the short form Boolean test:
	if(!$MyString){…etc. 
Otherwise the != operator is used:
	if($MyString != ""some value""){…etc. 
Closing statements
It is not necessary to close the (last) action code statement in an action list, i.e. put a semi-colon before the closing '}'. However, a semi-colon closure is required after the last closing '}' if other action code follows within the same rule or action:
	if($ChildCount > 5){$Color = ""red"";$Width = 3.5;}else{$Color = ""blue"";}; $Badge = ""ok""; 
	if(!$MyString){
		$Color = ""red"";
	}else{
		$Color = ""blue"";
	};
	$WordCount(parent) = $WordCount(parent)+$WordCount;
Testing multiple conditions
Whilst a single if() test can use a complex expression to form its conditional test, it may be necessary to run a set of linked tests. However, there is no 'else if' construct as found in many programming languages. To handle more than two branches to a condition test, nest an additional if() in either action-list of the first test. Thus:
	if(!$MyString){
		…
	}else{
		if($MyBoolean){
			…
		}else{
			if($MyNumber > 2){
				…
			}else{
				…
			}
		}
	}
In the example above there are two nested if tests within the original if(). Note how nesting is achieved. It is probably more normal that the additional if goes in the 'else' branch of the preceding condition but that is not a requirement. It can be in either branch according to the needs of the scenario. Indeed, both branches of an if could in theory hold another if().
However, this form of coding can quickly get complex and care should be taken with placing appropriate '}' closures. In complex branching, consider using additional queries to hold some initial levels of test, rather than do everything in a complex nested call.
Back-references
Back-references found by regular expression matches in operators like .contains() are available in if() clauses. For example, the rule:
	if($Name.contains(""a(..)"") ){$MyString = $1;}
will set $MyString to ""pp"" if $Name is ""apple"", or to ""rs"" if $Name is ""pears"". Note that the $0 back-reference contains the full matched expression.
Within an overall action, any existing back-references generated by at if() persist until another if(0 statement is met. Note:
* back-references created by an if() statement persist beyond its {}-enclosed code. They last to the end of the action or a new if() statement.
* an if() statement re-sets all previous back-references even if it does not populate them. Thus if the first if() set a $1 and $2, and a second if sets only $1, $2 is now empty—the previous $2 value does not persist.
* even a nested if() resets all back-references for all the rest of the action.
* back-references are not accessible within an ‘else’ branch. An if() nested under the else branch is only evaluated (and thus sets back-references) if the original if() test fails. In other words, if the opening if is true, the code in the else { ... } scope is never evaluated. But if the opening test fails, only the else scope is evaluated.
Inline use of if() statements
Assignment to an inline if() expression is permitted. For example:
	$Color = if($MyBoolean){""red""}else{""blue""}; 
However, when practical, the more conventional and idiomatic style is preferred:
	if($MyBoolean){$Color = ""red"";}else{$Color = ""blue"";}; 
Both the above are functionally equivalent.","if(条件){アクション}[else{アクション}]
ルールと (エージェント) アクションでは、Tinderbox は次の条件付きアクション構文を使用します。
if(条件){ アクション }
if (条件){ アクション }else{ アクション }
場所:
* 条件は、ブール値 true (条件が期待どおりの場合) に解決される条件付きテストの評価を含むアクション コードです。式が $Attribute.[i]contains(regex) クエリの形式である場合、アクションのアクション コード内で正規表現後方参照を使用できます。条件式は、find() などのクエリにすることもできます。この場合、一致する結果がゼロの場合は false が返され、それ以外の場合は true が返されます。)
* アクションは、セミコロンで区切られた 1 つ以上のアクション コード式のリストです。
例:
if($ChildCount > 5){$Color = ""red"";$Width = 3.5;}else{$Color = ""blue"";}
条件には複数のテストを含めることができます。And (&) または Or (I) 結合は、括弧で囲まれた式のネストと同様に許可されます。
if($ChildCount > 5 | $Badge = ""ok""){$Color=""red"";$Width=3.5;}
if(($ChildCount > 5 & $Badge = ""ok"") | $WordCount >= 450){$Color = ""red"";$Width = 3.5;}
式が条件句の複雑なセットである場合、条件を計算し、その値を属性に格納し、それを if() でテストすることが合理的である場合があります。テストを書き直すこの形式は、ドキュメントが大きくなり複雑になるにつれて発生する可能性がある増分形式化の通常の部分です。
検査結果が陰性
ネガティブ、つまり値が存在しない (またはデフォルト状態にある) かどうかのテストは、いくつかの方法で実行できます。属性値テストの場合は、短い形式のブール テストを使用して、属性名の前に感嘆符を付けるだけで済みます。
if(!$MyString){…など
それ以外の場合は、!= 演算子が使用されます。
if($MyString != ""何らかの値""){…など
閉会の挨拶
アクション リスト内の (最後の) アクション コード ステートメントを閉じる必要はありません。つまり、終了 '}' の前にセミコロンを置きます。ただし、同じルールまたはアクション内で他のアクション コードが続く場合は、最後の終了 '}' の後にセミコロン クロージャーが必要です。
if($ChildCount > 5){$Color = ""red"";$Width = 3.5;}else{$Color = ""blue"";};$Badge = ""ok"";
if(!$MyString){
$Color = ""赤"";
}その他{
$Color = ""青"";
};
$WordCount(親) = $WordCount(親)+$WordCount;
複数の条件をテストする
単一の if() テストでは複雑な式を使用して条件テストを形成できますが、リンクされた一連のテストを実行する必要がある場合があります。ただし、多くのプログラミング言語に見られるような「else if」構造はありません。条件テストへの 3 つ以上の分岐を処理するには、最初のテストのいずれかのアクション リストに追加の if() をネストします。したがって:
if(!$MyString){
…
}その他{
if($MyBoolean){
…
}その他{
if($MyNumber > 2){
…
}その他{
…
}
}
}
上の例では、元の if() 内に 2 つのネストされた if テストがあります。ネストがどのように実現されるかに注目してください。おそらく追加の if が前の条件の 'else' 分岐に入るのがより一般的ですが、これは必須ではありません。シナリオのニーズに応じて、どちらのブランチにも存在できます。実際、理論的には、if の両方の分岐に別の if() を保持できます。
ただし、この形式のコーディングはすぐに複雑になる可能性があるため、適切な '}' クロージャを配置する際には注意が必要です。複雑な分岐では、複雑なネストされた呼び出しですべてを実行するのではなく、追加のクエリを使用して初期レベルのテストを保持することを検討してください。
後方参照
.contains() などの演算子の正規表現一致によって検出された後方参照は、if() 句で使用できます。たとえば、次のようなルールがあります。
if($Name.contains(""a(..)"") ){$MyString = $1;}
$Name が ""apple"" の場合は $MyString を ""pp"" に設定し、$Name が ""pears"" の場合は ""rs"" に設定します。$0 後方参照には、完全に一致した式が含まれていることに注意してください。
アクション全体内では、at if() によって生成された既存の後方参照は、別の if(0 ステートメントが満たされるまで保持されます)。
* if() ステートメントによって作成された後方参照は、{} で囲まれたコードを超えて存続します。これらはアクションまたは新しい if() ステートメントの終わりまで続きます。
* if() ステートメントは、値を設定しない場合でも、以前のすべての後方参照を再設定します。したがって、最初の if() が $1 と $2 を設定し、2 番目の if() が $1 のみを設定した場合、$2 は空になります。以前の $2 の値は保持されません。
* ネストされた if() であっても、残りのすべてのアクションのすべての後方参照がリセットされます。
* 'else' ブランチ内では後方参照にアクセスできません。else 分岐の下にネストされた if() は、元の if() テストが失敗した場合にのみ評価されます (したがって後方参照が設定されます)。つまり、開始 if が true の場合、else { ... } スコープ内のコードは決して評価されません。ただし、開始テストが失敗した場合は、else スコープのみが評価されます。
if() ステートメントのインライン使用
インライン if() 式への代入が許可されます。たとえば:
$Color = if($MyBoolean){""red""}else{""blue""};
ただし、実際的な場合は、より伝統的で慣用的なスタイルが推奨されます。
if($MyBoolean){$Color = ""赤"";}else{$Color = ""青"";};
上記の両方は機能的に同等です。"
"indented(depthNum[, item])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"indented(depthNum[, item])
Returns Boolean true if the current note is depthNum levels below the root (i.e. target $OutlineDepth minus one). Where item is supplied, depthNum is instead tested against the number of outline levels between the current note and item (as opposed to root). This is essentially a way to test the $OutlineDepth of a note. Query:
	indented(3) 
is true for any notes whose $OutlineDepth value is 4.
The item argument must be quoted unless an attribute reference. Ways to define item.
Legacy issues
This operator replaces the legacy #indented query operator.","インデント(深さ番号[, 項目])
現在のノートがルートより下の DepthNum レベル (つまり、ターゲット $OutlineDepth から 1 を引いたもの) の場合、ブール値 true を返します。item が指定されている場合、代わりに DepthNum が現在のノートとアイテムの間のアウトライン レベルの数 (ルートではなく) に対してテストされます。これは基本的に、メモの $OutlineDepth をテストする方法です。クエリ:
インデント(3)
これは、$OutlineDepth 値が 4 であるすべてのノートに当てはまります。
item 引数は、属性参照でない限り引用符で囲む必要があります。項目を定義する方法。
従来の問題
この演算子は、従来の #indented クエリ演算子を置き換えます。"
"inheritsFrom([item, ]prototypeStr)",Function,Item,Query Boolean,boolean test,false,6.6.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,false,"inheritsFrom([item, ]prototypeStr)
inheritsFrom(), is Boolean true if a specific prototypeStr (note) is used by a note, either directly or through other prototypes. For a direct inheritance, the value of $Prototype can be checked but inheritsFrom() allows checking of inheritance via multiple prototypes. Where a note X inherits from a prototype A but the latter itself uses a prototype B, inheritsFrom() allows testing if X inherits indirectly from B. As such inheritance occurs via A, it is otherwise difficult to test such inheritance. This is a specialist operator unlikely to be used except where prototypes themselves use other prototypes.
In a query, or find(), all notes are tested. In an action context (rule, edict, agent action, OnAdd, expression, etc.) only the current note (this) is evaluated. To query the document for notes inheriting from prototype 'pEvent', use the query term:
	inheritsFrom(""pEvent"") 
It is possible to test, via an action, the inheritance of a different note using the optional second scoping argument item. Thus to test if 'Note B' inherits from prototype 'pTask':
	inheritsFrom(""Note B"",""pTask"") 
For example, suppose prototype 'pFlower' has the prototype 'pPlant', and note 'Rose' uses the prototype 'pFlower'. Then
	inheritsFrom(""pPlant"") 
is true for both pFlower and pPlant.
	inheritsFrom(""pFlower"") 
is true for Rose, but false for pPlant.
N.B. note that the stated prototype is also included in the items testing true. This makes sense if actual notes in the document are prototypes, as opposed to using only deliberate 'non-content' prototypes. To filter the latter, and exclude all prototype notes, use a query like:
	inheritsFrom(""pFlower"") & $IsPrototype==false 
You can also write an offset test so note 'Rose' can test if note 'Camelia' uses prototype 'pFlower':
	inheritsFrom(""Camelia"",""pFlower"") 
This returns true if 'Camelia' inherits from that prototype. Or, 'Rose' might want to check if its parent uses that prototype:
	inheritsFrom(""parent,""pFlower"")","継承から([アイテム, ]プロトタイプStr)
特定のprototypeStr（ノート）がノートによって直接または他のプロトタイプを介して使用される場合、inheritsFrom()はブール値のtrueになります。直接継承の場合、$Prototype の値をチェックできますが、inheritsFrom() を使用すると、複数のプロトタイプを介して継承をチェックできます。ノート X がプロトタイプ A から継承しているが、後者自体がプロトタイプ B を使用している場合、inheritsFrom() を使用すると、X が B から間接的に継承しているかどうかをテストできます。このような継承は A を介して発生するため、そうでない場合はそのような継承をテストするのは困難です。これは、プロトタイプ自体が他のプロトタイプを使用する場合を除いて、使用される可能性が低い専門オペレーターです。
クエリまたは find() では、すべてのメモがテストされます。アクション コンテキスト (ルール、布告、エージェント アクション、OnAdd、式など) では、現在のメモ (this) のみが評価されます。プロトタイプ「pEvent」から継承するメモについてドキュメントをクエリするには、次のクエリ用語を使用します。
継承From(""pEvent"")
オプションの 2 番目のスコープ引数項目を使用して、アクションを介して別のノートの継承をテストすることができます。したがって、「Note B」がプロトタイプ「pTask」から継承しているかどうかをテストするには、次のようにします。
継承From(""ノートB"",""pTask"")
たとえば、プロトタイプ「pFflower」にはプロトタイプ「pPlant」があり、「Rose」はプロトタイプ「pFflower」を使用しているとします。それから
継承から(""pPlant"")
pFflower と pPlant の両方に当てはまります。
継承から(""pフラワー"")
Rose の場合は true ですが、pPlant の場合は false です。
注：記載されたプロトタイプも、true をテストする項目に含まれることに注意してください。これは、意図的に「非コンテンツ」プロトタイプのみを使用するのではなく、文書内の実際のメモがプロトタイプである場合には意味があります。後者をフィルタリングして、すべてのプロトタイプ ノートを除外するには、次のようなクエリを使用します。
継承From(""pFflower"") & $IsPrototype==false
また、ノート 'Rose' がノート 'Camelia' がプロトタイプ 'pFflower' を使用しているかどうかをテストできるように、オフセット テストを作成することもできます。
継承From(""カメリア"",""pフラワー"")
「Camelia」がそのプロトタイプから継承する場合、これは true を返します。または、「Rose」は、その親がそのプロトタイプを使用しているかどうかを確認したい場合があります。
継承From(""親,""pFflower"")"
inside(item),Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"inside(item)
Returns Boolean true if the current note is a direct child of item or, put conversely, if item is the parent of the note. Thus it can be thought of as an ""is a child of"" operator and as such a counterpart to the ""is parent of"" operator contains(). Note that aliases can be matched by inside(), which may appear counter-intuitive at first encounter: if only wanting to match original notes, see section 'Filtering out aliases' below.
The item argument must be quoted unless an attribute reference. Ways to define item.
Pertinent to map view, inside() and adornments:
* inside(item) is true for a note that is a child of the map's container item.
* inside(item) is true for a map note that is on top of (within or overlapping) the adornment item.
* inside(item) for a map container item does not match any child adornments.
In a more general context inside(""X"") is true for note A if any of the following are true:
* original A is inside X
* an alias of A is inside X
* A is an alias elsewhere, but its original is inside X
The last of these, if overlooked, can give unexpected results. The more expansive matching above is necessary to do things like looking inside agents. 
If more than one container matching item is present, inside() returns items matching the first such container as listed in $OutlineOrder. If deliberately wanting to match notes inside any of several same-named containers, e.g. ""exploded notes"", then use $Name(parent)==""container name"" instead.
Filtering out aliases 
To match only originals, i.e. just the first of the three conditions in the previous list above, use inside(""X"") & $IsAlias==false.
Legacy issues
This operator replaces the legacy #inside query operator.","内側(アイテム)
現在のノートが項目の直接の子である場合、または逆に、項目がノートの親である場合は、ブール値 true を返します。したがって、これは「is a child of」演算子として考えることができ、「is aparent of」演算子 contains() に相当するものと考えることができます。エイリアスは inside() によって照合できることに注意してください。これは、最初は直観に反しているように見えるかもしれません。元のノートと照合したいだけの場合は、以下の「エイリアスのフィルタリング」セクションを参照してください。
item 引数は、属性参照でない限り引用符で囲む必要があります。項目を定義する方法。
マップビュー、inside()、および装飾に関連するもの:
* inside(item) は、マップのコンテナ アイテムの子であるメモの場合に true です。
* inside(item) は、装飾アイテムの上 (内部または重複) にあるマップ ノートの場合に true です。
* マップコンテナアイテムの inside(item) は、どの子装飾とも一致しません。
より一般的なコンテキストでは、次のいずれかが true の場合、 inside(""X"") はノート A に対して true になります。
* オリジナルの A は X の中にあります
* A のエイリアスは X 内にあります
* A は他の場所のエイリアスですが、そのオリジナルは X 内にあります
これらの最後の部分を無視すると、予期しない結果が生じる可能性があります。エージェントの内部を調べるなどのことを行うには、上記のより広範なマッチングが必要です。
項目に一致するコンテナーが複数存在する場合、 inside() は、$OutlineOrder にリストされている最初のコンテナーに一致する項目を返します。複数の同じ名前のコンテナのいずれか内のメモを意図的に一致させたい場合。「展開されたメモ」の場合は、代わりに $Name(parent)==""コンテナ名"" を使用してください。
エイリアスのフィルタリング
オリジナルのみ、つまり上記のリストの 3 つの条件の最初の条件のみに一致するには、 inside(""X"") & $IsAlias==false を使用します。
従来の問題
この演算子は、従来の #inside クエリ演算子を置き換えます。"
Interval.day(),Property,Item,Date-time,Number,false,6.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Interval.day()
Interval.day
Returns the Interval expressed as a Number of whole days. Thus, if $MyInterval is 1day 12 hours 30 minutes then:
	$MyNumber = $MyInterval.day; 
returns 1.
If the interval is less than 1 day ( i.e. less than 24 hours), the operator returns a zero value.
This operator is read-only and cannot be used to set/edit an Intervals' day part. 
Intervals can also be tested at hour, minute or second scope.","間隔.日()
間隔日
整数の日数として表現された間隔を返します。したがって、$MyInterval が 1 日 12 時間 30 分の場合、次のようになります。
$MyNumber = $MyInterval.day;
1を返します。
間隔が 1 日未満 (つまり 24 時間未満) の場合、演算子はゼロ値を返します。
この演算子は読み取り専用であり、間隔の日の部分の設定/編集には使用できません。
間隔は、時、分、または秒のスコープでテストすることもできます。"
Interval.format(formatStr),Function,Item,Formatting,String,false,6.6.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Interval.format(formatStr)
For this data type formatStr strings can use date-type format strings. The function returns Interval as a String formatted as per the quoted date/interval format string formatStr.
This supplements the existing format() function. 
When used with Interval-type data, .format() expects the interval to be less than one hour and thus comprising only minutes and seconds data (i.e. 'mm:ss'). Note that the default short Interval form is 'hh:mm' so there is scope for confusion. If passing 'hh:mm' data to .format(), it makes sense to add a blank seconds segment, i.e. 'hh:mm:ss' so the segments of the interval are parsed correctly.
Furthermore, only two date format strings are accepted for formatStr: Interval.format (""l"") and Interval.format (""L""), both of which format the hours and minutes of the Interval date the current locale's style. The lower-case ""l"" format uses the locale's abbreviated form, while ""L"" gives the interval in a phrase customised to local usage.
If $MyInterval is ""12:55:23:""
	$MyString = $MyInterval.format(""l""); gives ""12:55""
	$MyString = $MyInterval.format(""L""); gives ""12 hours, 55 minutes""
An Interval value of ""00:00"" (minutes:seconds)—i.e. that data type's default—always returns an empty string. This if $MyInterval the default 00:00 then:
	$MyString = $MyInterval.format(""l""); 
results in """", i.e. no value is set in $MyString.
Formatting Intervals of over one hour
The expectation of input as being only mm:ss only can cause confusion when using .format(). If the value of $MyInterval is ""12:55:40"" (12 hours, 55 minutes and 14 seconds):
	$MyString = $MyInterval.format(""l"") 
The resulting $MyString value is ""12:56"", i.e. the seconds are rounded (up or down accordingly) and an hours:minutes string is returned.
As Interval maximum scope is days/hours/minutes/seconds, if the aim is to get the entire interval duration, simply pass the Interval data direct to a string. This if $MyInterval is ""1 day 12:55:23"":
	$MyString = $MyInterval; 
sets $MyString to ""1 day 12:55:23"". If only part of the source is needed, a different approach is needed. Thus, if $MyInterval is ""1 day 12:55:23"" and only the number of whole minutes is needed, some string manipulation is required:
	$MyString = $MyInterval.extract(""(\d{2}):\d{2}$""); 
setting $MyString to ""55"". Note that regular expressions are very specific. If the closing '$' is omitted from the regex pattern, this results in a $MyString value of ""12"" instead of ""55"". Why? Because the latter pattern returns the first pair of digits followed explicitly by a colon and two more digits. Adding the '$' tells the regex that the literal sequence must come at the end of the source string, resulting in ""55"" being extracted.","間隔.format(formatStr)
このデータ型の場合、formatStr 文字列では日付型の書式文字列を使用できます。この関数は、引用符で囲まれた日付/間隔の書式文字列 formatStr に従って書式設定された文字列として Interval を返します。
これは既存の format() 関数を補完します。
Interval タイプのデータで使用される場合、.format() は間隔が 1 時間未満であることを想定しているため、分と秒のデータ (つまり 'mm:ss') のみで構成されます。デフォルトの短い間隔形式は「hh:mm」であるため、混乱が生じる可能性があることに注意してください。「hh:mm」データを .format() に渡す場合、間隔のセグメントが正しく解析されるように、空白の秒セグメント、つまり「hh:mm:ss」を追加するのが合理的です。
さらに、formatStr では、Interval.format (""l"") と Interval.format (""L"") の 2 つの日付書式文字列のみが受け入れられます。どちらも、Interval 日付の時間と分を現在のロケールのスタイルで書式設定します。小文字の「l」形式はロケールの短縮形を使用し、「L」はローカルの使用法に合わせてカスタマイズされた語句の間隔を示します。
$MyInterval が「12:55:23:」の場合
$MyString = $MyInterval.format(""l"");「12:55」を返します
$MyString = $MyInterval.format(""L"");「12時間55分」となります。
間隔値「00:00」(分:秒)、つまりそのデータ型のデフォルト - 常に空の文字列を返します。$MyInterval がデフォルトの 00:00 の場合、次のようになります。
$MyString = $MyInterval.format(""l"");
結果は「」になります。つまり、$MyString には値が設定されません。
1 時間を超えるフォーマット間隔
入力が mm:ss のみであると期待されると、.format() を使用するときに混乱が生じる可能性があります。$MyInterval の値が「12:55:40」(12 時間 55 分 14 秒) の場合:
$MyString = $MyInterval.format(""l"")
結果の $MyString 値は「12:56」です。つまり、秒は切り上げられ (それに応じて上下します)、時:分の文字列が返されます。
間隔の最大範囲は日/時間/分/秒であるため、間隔期間全体を取得することが目的の場合は、単に間隔データを文字列に直接渡すだけです。$MyInterval が「1 日 12:55:23」の場合:
$MyString = $MyInterval;
$MyString を「1 日 12:55:23」に設定します。ソースの一部のみが必要な場合は、別のアプローチが必要です。したがって、$MyInterval が「1 day 12:55:23」で、整数の分数のみが必要な場合は、いくつかの文字列操作が必要です。
$MyString = $MyInterval.extract(""(\d{2}):\d{2}$"");
$MyString を「55」に設定します。正規表現は非常に特殊であることに注意してください。正規表現パターンから終了 '$' が省略されている場合、$MyString 値は ""55"" ではなく ""12"" になります。なぜ？後者のパターンは最初の数字のペアを返し、その後にコロンとさらに 2 つの数字が明示的に続くためです。「$」を追加すると、リテラル シーケンスがソース文字列の最後に来る必要があることが正規表現に伝えられ、結果として「55」が抽出されます。"
Interval.hour(),Property,Item,Date-time,Number,false,6.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Interval.hour()
Interval.hour
Returns the Interval expressed as a Number of whole or partial hours within the current day (ignoring whole days). Thus, if $MyInterval is 12 hours 30 minutes then:
	$MyNumber = $MyInterval.hour; 
returns 12.
This operator is read-only and cannot be used to set/edit an Intervals' hour part. 
Intervals can also be tested at day, minute or second scope.","間隔.時間()
間隔時間
現在の日の全体または部分的な時間数として表現された間隔を返します (丸日は無視します)。したがって、$MyInterval が 12 時間 30 分の場合、次のようになります。
$MyNumber = $MyInterval.hour;
12を返します。
この演算子は読み取り専用であり、間隔の時間部分の設定/編集には使用できません。
間隔は、日、分、または秒のスコープでテストすることもできます。"
Interval.minute(),Property,Item,Date-time,Number,false,6.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Interval.minute()
Interval.minute
Returns the Interval expressed as a Number of whole or partial minutes within the current hour (ignoring whole hours). Thus, if $MyInterval is 1 hour, 30 minutes and 15 seconds then:
	$MyNumber = $MyInterval.minute; 
returns 30.
This operator is read-only and cannot be used to set/edit an Intervals' minute part. 
Intervals can also be tested at day, hour or second scope.","間隔.分()
間隔.分
現在の時間内の分全体または部分の数として表現された間隔を返します (時間全体は無視します)。したがって、$MyInterval が 1 時間 30 分 15 秒の場合、次のようになります。
$MyNumber = $MyInterval.分;
30を返します。
この演算子は読み取り専用であり、間隔の分部分の設定/編集には使用できません。
間隔は、日、時間、または秒の範囲でテストすることもできます。"
Interval.second(),Property,Item,Date-time,Number,false,7.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Interval.second()
Interval.second
Returns the Interval expressed as a Number of whole seconds within the current minute (ignoring whole minutes). Thus, if $MyInterval is 1 hour, 30 minutes and 15 seconds then:
	$MyNumber = $MyInterval.second; 
returns 15
Although date-time units are stored as milliseconds under the hood, Tinderbox does not return increments smaller than one second.
This operator is read-only and cannot be used to set/edit an Intervals' seconds part. 
Intervals can also be tested at day, hour or minute scope.","間隔.秒()
間隔.秒
現在の 1 分間の整数秒数として表現された間隔を返します (整数の分は無視します)。したがって、$MyInterval が 1 時間 30 分 15 秒の場合、次のようになります。
$MyNumber = $MyInterval.秒;
15を返します
日付と時刻の単位は内部でミリ秒として保存されますが、Tinderbox は 1 秒より小さい増分を返しません。
この演算子は読み取り専用であり、間隔の秒部分の設定/編集には使用できません。
間隔は、日、時間、または分の範囲でテストすることもできます。"
interval(dataStr),Function,Item,Date-time,Interval,false,9.5.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"interval(dataStr)
The operator interval(dataStr) converts a string to an interval. For example:
	$MyInterval = interval(""00:30:00"") 
is an interval of thirty minutes. 
The dataStr can be a literal string, String-type attribute value or a string variable. The string must be in Interval, for which see the 'Alternative syntax' section of the Interval data type.) For instance:
	var:number vHr = 21;
	var:number vMin = 14;
	var:string vInterval = vHr+"":""+vMin;
	$MyInterval = interval(vInterval);
The two Date-type argument version of interval() is documented separately, see interval(start,end): it continues to return the Interval between two Date-type arguments.
If any time element is larger than expected, it is parsed to increment the next larger time element. Thus:
	$MyInterval = interval(""00:90:00"") 
evaluates as if:
	$MyInterval = interval(""01:30:00"") 
This can be helpful, especially if using calculated variables (as above) and where the calculated value may be more than expected if setting values manually.","間隔(データ文字列)
演算子 interval(dataStr) は、文字列を間隔に変換します。たとえば:
$MyInterval = 間隔(""00:30:00"")
30分間隔です。
dataStr には、リテラル文字列、文字列型の属性値、または文字列変数を指定できます。文字列は Interval である必要があります。これについては、Interval データ型の「代替構文」セクションを参照してください。) たとえば、次のようになります。
var:数値 vHr = 21;
var:数値 vMin = 14;
var:string vInterval = vHr+"":""+vMin;
$MyInterval = 間隔(vInterval);
Interval() の 2 つの Date 型引数バージョンについては個別に文書化されています。interval(start,end) を参照してください。これは引き続き 2 つの Date 型引数の間の Interval を返します。
いずれかの時間要素が予想よりも大きい場合は、次に大きい時間要素をインクリメントするために解析されます。したがって:
$MyInterval = 間隔(""00:90:00"")
次のように評価します。
$MyInterval = 間隔(""01:30:00"")
これは、(上記のような) 計算変数を使用する場合や、手動で値を設定すると計算値が予想より大きくなる可能性がある場合に特に役立ちます。"
"interval(startDate, endDate)",Function,Item,Date-time,Interval,false,6.3.1,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"interval(startDate, endDate)
The function interval(startDate,endDate) returns, in Interval data-type form, the time interval between two Date-type dates. For example, to test the interval between a note's initial creation and its most recent modification and to then store it in an Interval-type attribute:
	$MyInterval = interval($Created,$Modified); 
The interval() function can be used to test the exact equivalence of two Date-type attribute values, using the full Date and time. Thus:
	if(interval($DateA,$DateB)==""00:00""){… 
The latter gets around the fact that == and != operators match Date-type attributes only at day scope rather than the actual date-time values.
If needing the duration expressed in whole time units of a particular time element (or hours, etc.), see days(), hours(), minutes() or seconds().
The single argument method of interval(), used to create Interval-type data is documented separately—see interval(dataStr).","間隔(開始日、終了日)
関数 interval(startDate,endDate) は、2 つの Date 型日付の間の時間間隔を Interval データ型形式で返します。たとえば、メモの最初の作成と最新の変更の間の間隔をテストし、それを Interval-type 属性に保存するには、次のようにします。
$MyInterval = 間隔($Created,$Modified);
interval() 関数を使用すると、完全な日付と時刻を使用して、2 つの日付タイプの属性値が正確に等しいかどうかをテストできます。したがって:
if(間隔($DateA,$DateB)==""00:00""){…
後者は、== 演算子と != 演算子が実際の日付/時刻値ではなく日スコープでのみ日付型属性と一致するという事実を回避します。
特定の時間要素 (または時間など) の全体の時間単位で表現される期間が必要な場合は、days()、hours()、 minutes()、または Seconds() を参照してください。
Interval 型データの作成に使用される、interval() の単一引数メソッドについては、別途文書化されています。interval(dataStr) を参照してください。"
isbn10(dataStr),Function,Item,Data manipulation,String,false,6.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"isbn10(dataStr)
takes quoted an ISBN-13 format code as the dataStr input and returns is in ISBN-10 format. Any dashes or other punctuation will be ignored. If the argument is not a valid ISBN code, the function returns an empty string. If such characters as in the source string and quotes are omitted, hyphen may be mis-parsed as minus signs giving a wrong result.
Consider a book with the ISBN-10 '1472268997' and the ISBN-13 '978-1472268990':
	$MyString = isbn10(""978-1472268990"") gives the correct '1472268997' but note, without any hyphens.
be aware that if dataStr is not in quotes, the input is treated as an arithmetical expression:
	$MyString = isbn10(""978-1472268990"") gives the incorrect value '1472268012'.","isbn10(データ文字列)
dataStr 入力として引用符で囲まれた ISBN-13 形式のコードを受け取り、ISBN-10 形式で返します。ダッシュやその他の句読点は無視されます。引数が有効な ISBN コードでない場合、関数は空の文字列を返します。ソース文字列や引用符などの文字が省略されている場合、ハイフンがマイナス記号として誤って解析され、誤った結果が生じる可能性があります。
ISBN-10 '1472268997' と ISBN-13 '978-1472268990' の書籍を考えてみましょう。
$MyString = isbn10(""978-1472268990"") は正しい '1472268997' を返しますが、ハイフンが含まれていないことに注意してください。
dataStr が引用符で囲まれていない場合、入力は算術式として扱われることに注意してください。
$MyString = isbn10(""978-1472268990"") は誤った値 '1472268012' を返します。"
isbn13(dataStr),Function,Item,Data manipulation,String,false,6.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"isbn13(data)
takes an ISBN-10 format code as the quoted string dataStr and returns it in ISBN-13 format. Any dashes or other punctuation will be ignored. If the argument is not a valid ISBN code, the function returns an empty string. If such characters as in the source string and quotes are omitted, hyphen may be mis-parsed as minus signs giving a wrong result.
Consider a book with the ISBN-10 '1472268997' and the ISBN-13 '978-1472268990':
	$MyString = isbn13(""1472268997"") gives the correct '9781472268990' but note, without any hyphens.
be aware that if dataStr is not in quotes, result is the same.","isbn13(データ)
ISBN-10 形式のコードを引用符で囲まれた文字列 dataStr として受け取り、ISBN-13 形式で返します。ダッシュやその他の句読点は無視されます。引数が有効な ISBN コードでない場合、関数は空の文字列を返します。ソース文字列や引用符などの文字が省略されている場合、ハイフンがマイナス記号として誤って解析され、誤った結果が生じる可能性があります。
ISBN-10 '1472268997' と ISBN-13 '978-1472268990' の書籍を考えてみましょう。
$MyString = isbn13(""1472268997"") は正しい '9781472268990' を返しますが、ハイフンが含まれていないことに注意してください。
dataStr が引用符で囲まれていない場合でも、結果は同じになることに注意してください。"
isDuplicateName(),Property,Item,Non-query Boolean,boolean test,false,8.0.0,Baseline,,,,1,false,false,false,false,false,false,false,false,false,,false,"isDuplicateName
isDuplicateName()
This is true if another note in the document has the same $Name as the current note. isDuplicateName() ignores all aliases. The parentheses may be omitted. In an action, the current note might be tested:
	$MyBoolean = isDuplicateName(); 
If the current note has any duplicate-named notes, $MyBoolean is true.
In an agent, all instances of notes with duplicates are listed. Thus, the query:
	isDuplicateName() 
lists all instances of any note with duplicates.
This can be useful if trying to find/resolve notes with duplicate names within a document. If expecting to use action code to work with notes, it helps if a note's title ($Name) is unique.","重複名です
isDuplicateName()
これは、ドキュメント内の別のメモが現在のメモと同じ $Name を持つ場合に当てはまります。isDuplicateName() はすべてのエイリアスを無視します。括弧は省略できます。アクションでは、現在のメモがテストされる場合があります。
$MyBoolean = isDuplicateName();
現在のノートに重複する名前のノートがある場合、$MyBoolean は true です。
エージェントでは、重複のあるメモのすべてのインスタンスがリストされます。したがって、クエリは次のようになります。
isDuplicateName()
重複のあるメモのすべてのインスタンスをリストします。
これは、ドキュメント内で重複した名前を持つメモを検索/解決しようとする場合に役立ちます。アクション コードを使用してメモを操作する場合は、メモのタイトル ($Name) が一意であると便利です。"
JSON.each([pathStr]){actions},Function,List,Stream parsing,iterator,false,9.6.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"JSON.each([pathStr]){action(s)}
JSON.each{action(s)}
If the top-level element is an array, rebinds the JSON object in turn to each array element. After calling the action block for each element, the JSON object is restored. 
For example, if the value of $MyString is [{""price"":1}, {""price"":2}], then
	$MyList=[];
	$MyString.json.each{$MyList += json[""price""]*3;}
would set $MyList to ""3;6"".
JSON.each(pathStr){action(s)}
In .json.each(){…}, an optional path argument, pathStr, supplies a path to the array to be iterated. For example, if $Text is:
{  
   ""person"": { ""firstName"": ""Thomas"",  lastName: ""Roe""},
   ""coordinates"" : [-90,41] 
}
then $Text.captureJson().json.each(coordinates){…} would iterate through the array of coordinates.
If String.json.each begins a statement,
	$Text.json.each(coordinates){...} 
.json.each(){} reuses the current JSON object. This can be much faster than repeatedly re-parsing a complex json package.
As a result, the older syntax $Text.json[coordinates].each(x){…}, that chained of JSON.json[keyStr] is no longer supported.
Loading a dictionary of dictionaries from JSON and looking up items
Let $Text be:
{ ""French"":{ ""child"":""enfant""; ""cat"":""chat""}; ""Swedish"":{""child"":""barn"";""cat"":""katt""} } 
Now:
$Text.json[French][cat] is ""chat""
$Text.json[""Swedish""][""cat""] is ""katt""
$Text.json.keys is ""French; Swedish""
$Text.json.keys.each(x){ 
	$MyList=$MyList+$Text.json[x][cat];
};
$MyList is [chat;katt].
Loading a list of dictionaries from JSON a and looking up items
Let $Text be:
[ { ""child"":""enfant""; ""cat"":""chat""} , {""child"":""barn"";""cat"":""katt""} ] 
Now:
$Text.json[0][cat] is chat
$Text.json[0]['cat'] is katt
$Text.json.count is 2
$Text.json.each(x){
	$MyList += x[child];
}
$MyList is now [enfant;barn].","JSON.each([pathStr]){アクション}
JSON.each{アクション}
最上位要素が配列の場合、JSON オブジェクトを各配列要素に順番に再バインドします。各要素のアクション ブロックを呼び出した後、JSON オブジェクトが復元されます。
たとえば、$MyString の値が [{""price"":1}, {""price"":2}] の場合、
$MyList=[];
$MyString.json.each{$MyList += json[""価格""]*3;}
$MyList を「3;6」に設定します。
JSON.each(pathStr){アクション}
.json.each(){…} では、オプションのパス引数 pathStr により、反復される配列へのパスが指定されます。たとえば、$Text が次の場合:
{
""person"": { ""firstName"": ""Thomas"", lastName: ""Roe""},
「座標」：[-90,41]
}
$Text.captureJson().json.each(coodys){…} は座標の配列を反復処理します。
String.json.each がステートメントを開始する場合、
$Text.json.each(座標){...}
.json.each(){} は現在の JSON オブジェクトを再利用します。これは、複雑な JSON パッケージを繰り返し再解析するよりもはるかに高速です。
その結果、JSON.json[keyStr] を連鎖させた古い構文 $Text.json[座標].each(x){…} はサポートされなくなりました。
JSON から辞書の辞書を読み込み、項目を検索する
$Text を次のようにします。
{ ""フランス語"":{ ""子供"":""子供"";""猫"":""チャット""};""スウェーデン語"":{""子供"":""納屋"";""猫"":""カット""} }
今:
$Text.json[フランス語][猫]は「チャット」です
$Text.json[""スウェーデン語""][""cat""] は ""katt"" です
$Text.json.keys は「フランス語; スウェーデン語」です
$Text.json.keys.each(x){
$MyList=$MyList+$Text.json[x][cat];
};
$MyList は [チャット;カット] です。
JSON から辞書のリストを読み込み、項目を検索する
$Text を次のようにします。
[ { ""子供"":""幼児"";""猫"":""チャット""} , {""子"":""納屋"";""猫"":""カット""} ]
今:
$Text.json[0][cat] はチャットです
$Text.json[0]['cat'] はキャットです
$Text.json.count は 2 です
$Text.json.each(x){
$MyList += x[子];
}
$MyList は [enfant;barn] になりました。"
JSON.json[itemNum],Function,Item,Stream parsing,source context dependent,false,9.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"JSON.json[itemNum]
If there is no current JSON object, attempts to parse the string as JSON and fails if unsuccessful. If there is a current JSON object, that object will be reused. See JSON.json[keyStr], for more information as to when String.captureJson() might need to be used before applying this operator.
If the top-level element is an array, JSON.json[N] returns the itemNum object. Note that [ ] square brackets, not ( ) parentheses must be used to pass N. If the top-level element is an object, see JSON.json[keyStr].
For example, if the $Text is:
{ [1,4,9,16,25] } 
Then $Text.json[1] is 4.
This usage follows the existing list[N] convention.","JSON.json[項目番号]
現在の JSON オブジェクトがない場合、文字列を JSON として解析しようとしますが、失敗すると失敗します。現在の JSON オブジェクトがある場合は、そのオブジェクトが再利用されます。この演算子を適用する前に String.captureJson() を使用する必要がある場合の詳細については、「JSON.json[keyStr]」を参照してください。
最上位要素が配列の場合、JSON.json[N] は itemNum オブジェクトを返します。N を渡すには、( ) 括弧ではなく [ ] 角括弧を使用する必要があることに注意してください。最上位の要素がオブジェクトの場合は、JSON.json[keyStr] を参照してください。
たとえば、$Text が次の場合:
{ [1,4,9,16,25] }
すると、$Text.json[1] は 4 になります。
この使用法は、既存の list[N] 規則に従います。"
JSON.json[keyStr],Function,Item,Stream parsing,source context dependent,false,9.6.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"JSON.json[keyStr]
If there is no current JSON object, attempts to parse the string as JSON and fails if unsuccessful. If there is a current JSON object, that object will be reused. keyStr is a quoted key name and [ ] square brackets, not ( ) parentheses must be used to pass keyStr. Be aware of possible operator name confusion as described in the Notes section further below.
If the top-level element is an object, Stream.json[key] returns a dictionary for that object. If the top-level element is an array, see JSON.json[itemNum].
For example if $Text is:
{ ""title"":""Becket"", ""price"": 9.95 } 
and $Subtitle is set to ""title"", then:
$Text.json[""title""]; is ""Becket"".
$Text.json[title]; is ""Becket"".
$Text.json[""price""]; is ""9.95"".
$Text.json['$Subtitle']; no such field.
$Text.json[$Subtitle]; is ""Becket"".
Though multiple bracketed arguments can be used to address a JSON path, consider use of .jsonValue(pathStr) instead. For example:
Text:  {
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
MyString: ""person.lastName""
Then:
$Text.json['person']['lastName'] gives 'Roe'
But, easier:
$Text.json.jsonValue(person.lastName) gives 'Roe'
$Text.json.jsonValue($MyString) gives 'Roe'
Again, using the same JSON as above:
$MyString=""coordinates""; 
Now
$Text.json['coordinates'][0] gives -90 
$Text.json[$MyString][1] gives 41 
Notes
Be aware:
* If the source is $Text containing a mix of text and JSON first use .captureJson() to extract only the JSON code: see String.captureJson(). 
* Do not confuse this operator .json[] (note trailing square brackets) with the deprecated/legacy operator .json() (note trailing parentheses).
** The latter was used for export but is now replaced by String.jsonEncode().
** However, .json() does still work (legacy support) but is not the same as .json[] for reading JSON data as is described in this article.","JSON.json[keyStr]
現在の JSON オブジェクトがない場合、文字列を JSON として解析しようとしますが、失敗すると失敗します。現在の JSON オブジェクトがある場合は、そのオブジェクトが再利用されます。keyStr は引用符で囲まれたキー名であり、keyStr を渡すには () 括弧ではなく [ ] 角括弧を使用する必要があります。以下の「注」セクションで説明されているように、演算子名の混同の可能性があることに注意してください。
最上位要素がオブジェクトの場合、Stream.json[key] はそのオブジェクトの辞書を返します。最上位要素が配列の場合は、JSON.json[itemNum] を参照してください。
たとえば、$Text が次の場合:
{ ""タイトル"":""ベケット""、""価格"": 9.95 }
$Subtitle が「title」に設定されている場合、次のようになります。
$Text.json[""タイトル""];「ベケット」です。
$Text.json[タイトル];「ベケット」です。
$Text.json[""価格""];は「9.95」です。
$Text.json['$Subtitle'];そのようなフィールドはありません。
$Text.json[$Subtitle];「ベケット」です。
括弧で囲まれた複数の引数を使用して JSON パスを指定できますが、代わりに .jsonValue(pathStr) の使用を検討してください。たとえば:
テキスト: {
""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" },
「座標」: [-90,41]
}
MyString: ""人.姓""
次に:
$Text.json['person']['lastName'] は 'Roe' を与えます
しかし、もっと簡単に:
$Text.json.jsonValue(person.lastName) は「Roe」を与えます
$Text.json.jsonValue($MyString) は「Roe」を与えます
ここでも、上記と同じ JSON を使用します。
$MyString=""座標"";
今
$Text.json['座標'][0] は -90 を与えます
$Text.json[$MyString][1] は 41 を返します
注意事項
注意してください:
* ソースがテキストと JSON が混在した $Text の場合は、最初に .captureJson() を使用して JSON コードのみを抽出します。String.captureJson() を参照してください。
* この演算子 .json[] (末尾の角括弧に注意) と、非推奨/レガシー演算子 .json() (末尾の括弧に注意) を混同しないでください。
** 後者はエクスポートに使用されていましたが、現在は String.jsonEncode() に置き換えられています。
** ただし、.json() は引き続き動作します (レガシー サポート) が、この記事で説明されているように、JSON データを読み取るための .json[] とは異なります。"
JSON.jsonValue(),Function,Item,Stream parsing,source context dependent,false,9.6.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"JSON.jsonValue()
JSON.jsonValue
The .jsonValue() operator returns a json object, from the cursor position to the end of the current code. In an attribute, e.g. $Text, containing only JSON code, the operator returns that whole code segment. If, via stream parsing the input cursor has advanced to the start of a code segment, the complete code segment starting at that point is returned (though other discrete code samples may exist further on the source string—these are ignored)
For example, if $Text is :
Some text.
{
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
Then:
	$MyString = $Text.skipline.captureJson.jsonValue(); 
sets $MyString to the JSON code found at the second paragraph of Text. So, the opening text paragraphs (here paragraph #1, Some text in the above example) are ignored and the first encountered section of JSON, here paragraph #1 is returned.
Important Note: the captured JSON is always, and only, the first discrete section of code in text. 
Thus, if $Text (or other source string) is all JSON code, the use of .captureJson() is moot But, if the $Text (or other source string) contains more than one JSON code section, use stream parsing to detect the desired JSON section and .jsonValue()to capture the desired section of code. For example, if $Text is :
Some text.
{
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
Another paragraph here.
{
  ""person"": { ""firstName"": ""Martin"", ""lastName"": ""Brown"" }, 
  ""coordinates"": [-80,61]
}
Some more text.

In this case the second discrete section of embedded JSON cannot be accessed via .jsonValue().","JSON.jsonValue()
JSON.jsonValue
.jsonValue() 演算子は、カーソル位置から現在のコードの末尾までの json オブジェクトを返します。属性内で、例えばJSON コードのみを含む $Text の場合、演算子はそのコード セグメント全体を返します。ストリーム解析によって入力カーソルがコード セグメントの先頭まで進んだ場合は、その時点から始まる完全なコード セグメントが返されます (ただし、他の個別のコード サンプルがソース文字列のさらに先に存在する可能性がありますが、これらは無視されます)。
たとえば、$Text が次の場合:
いくつかのテキスト。
{
""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" },
「座標」: [-90,41]
}
次に:
$MyString = $Text.skipline.captureJson.jsonValue();
$MyString を Text の 2 番目の段落にある JSON コードに設定します。したがって、開始テキスト段落 (ここでは段落 #1、上の例では一部のテキスト) は無視され、JSON の最初に見つかったセクション、ここでは段落 #1 が返されます。
重要な注意: キャプチャされた JSON は、常に、そして唯一、テキスト内のコードの最初の個別のセクションです。
したがって、$Text (または他のソース文字列) がすべて JSON コードである場合、.captureJson() の使用は意味がありません。ただし、$Text (または他のソース文字列) に複数の JSON コード セクションが含まれている場合は、ストリーム解析を使用して目的の JSON セクションを検出し、.jsonValue() を使用してコードの目的のセクションをキャプチャします。たとえば、$Text が次の場合:
いくつかのテキスト。
{
""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" },
「座標」: [-90,41]
}
ここで別の段落。
{
""person"": { ""firstName"": ""Martin"", ""lastName"": ""Brown"" },
「座標」: [-80,61]
}
もう少しテキストを追加します。

この場合、埋め込み JSON の 2 番目の個別セクションには .jsonValue() 経由でアクセスできません。"
JSON.jsonValue(pathStr),Function,Item,Stream parsing,source context dependent,false,9.6.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"JSON.jsonValue(pathStr)
The .jsonValue() operator allows a json object to be addressed by its JSON path. By comparison .json[keyStr] must use a key name. For example:
Text value:  {
  ""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" }, 
  ""coordinates"": [-90,41]
}
MyString value: ""person.lastName""
Then:
$Text.json['person']['lastName'] gives 'Roe'
But, easier:
$Text.json.jsonValue(person.lastName) gives 'Roe'
Or if $MyString holds ""person.lastName"", then:
$Text.json.jsonValue($MyString) gives 'Roe'","JSON.jsonValue(pathStr)
.jsonValue() 演算子を使用すると、JSON オブジェクトをその JSON パスでアドレス指定できるようになります。比較すると、.json[keyStr] はキー名を使用する必要があります。たとえば:
テキスト値: {
""person"": { ""firstName"": ""Thomas"", ""lastName"": ""Roe"" },
「座標」: [-90,41]
}
MyString 値: ""person.lastName""
次に:
$Text.json['person']['lastName'] は 'Roe' を与えます
しかし、もっと簡単に:
$Text.json.jsonValue(person.lastName) は「Roe」を与えます
または、$MyString が「person.lastName」を保持している場合は、次のようになります。
$Text.json.jsonValue($MyString) は「Roe」を与えます"
jsonEncode(dataStr),Function,Item,Formatting,String,false,5.7.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"jsonEncode(dataStr)
This operator returns a JSON-encoded UTF-8 version of the dataStr string. The straight double quote, solidus (forward slash) and backslash characters are all escaped by a preceding backslash character. The control characters backspace, form feed, new line, carriage return, horizontal tab are encoded as standard JavaScript escapes (\b, \f, \n, \r\, \t ). Unicode addresses are also escaped: \u2345.
Note: the single apostrophe (straight quote) is not escaped as this can cause some Ajax functions to fail.
If dataStr holds the words 'hello	world' separated by a Tab not a space character, then:
	jsonEncode(""hello	world"") 
gives output of 'hello\tworld'.
For string-type data, see also the '.jsonEncode()' operator.","jsonEncode(dataStr)
この演算子は、dataStr 文字列の JSON エンコードされた UTF-8 バージョンを返します。直線の二重引用符、塗りつぶし (スラッシュ)、およびバックスラッシュ文字はすべて、前にバックスラッシュ文字を付けてエスケープされます。制御文字のバックスペース、フォーム フィード、改行、キャリッジ リターン、水平タブは、標準の JavaScript エスケープ (\b、\f、\n、\r\、\t ) としてエンコードされます。Unicode アドレスもエスケープされます: \u2345。
注: 一部の Ajax 関数が失敗する可能性があるため、単一のアポストロフィ (直線引用符) はエスケープされません。
dataStr がスペース文字ではなくタブで区切られた「hello world」という単語を保持している場合、次のようになります。
jsonEncode(""ハローワールド"")
'hello\tworld' が出力されます。
文字列型のデータについては、「.jsonEncode()」演算子も参照してください。"
"last(item[, childrenNum])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"last(item[item[, childrenNum])
Returns Boolean true if the current note is among the last childrenNum of children of item. If childrenNum is missing, a value of 1 is assumed.
The item argument must be quoted unless an attribute reference. Ways to define item.
Both arguments are evaluated and can be a literal string/number, an attribute value or an action code expression evaluating to that same.
If the current note has a $SiblingOrder value of 7, then if first() is run on its parent container with 10 children:
	first(""Note A"", 5) returns true 
but if it has a $SiblingOrder value of 2:
	first(""Note A"", 5) returns false 
last() also has a logical opposite in first().
Legacy issues
This operator replaces the legacy #last query operator.","last(アイテム[アイテム[, 子供の数])
現在のノートが item の子の最後の ChildrenNum に含まれる場合、ブール値 true を返します。ChildrenNum が欠落している場合は、値 1 が想定されます。
item 引数は、属性参照でない限り引用符で囲む必要があります。項目を定義する方法。
両方の引数が評価され、リテラル文字列/数値、属性値、またはそれを評価するアクション コード式にすることができます。
現在のノートの $SiblingOrder 値が 7 である場合、10 個の子を持つ親コンテナ上で first() が実行されるとします。
first(""Note A"", 5) は true を返します
ただし、$SiblingOrder 値が 2 の場合:
first(""Note A"", 5) は false を返します
last() には、first() の論理反対もあります。
従来の問題
この演算子は、従来の #last クエリ演算子を置き換えます。"
lastWord(dataStr),Function,Item,Data manipulation,String,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"lastword(""data"")
The lastWord() operator has one argument, dataStr (a quoted a string), and it returns the final word of the data string. The delimiter used to define words is one or more spaces (possibly also line break(s)?).
The dataStr argument is evaluated so could be an expression. For example, if the note 'First Line' has the body text ""Winter is coming."", then 
	$MyString = lastWord($Text(""First Line"")); 
should give a result of ""coming"".","ラストワード(""データ"")
lastWord() 演算子には引数 dataStr (引用符で囲まれた文字列) が 1 つあり、データ文字列の最後の単語を返します。単語を定義するために使用される区切り文字は 1 つ以上のスペースです (改行も可能ですか?)。
dataStr 引数は評価されるため、式にすることができます。たとえば、メモ「最初の行」の本文が「冬が来ています。」である場合、
$MyString = lastWord($Text(""最初の行""));
「来る」という結果が得られるはずです。"
"linkedFrom(scope[, linkTypeStr])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkedFrom(scope[, linkTypeStr])
A test for inbound links. This boolean test at returns true if the current note has a least one link from any of the note(s) defined by scope; this is optionally filtered to only links of type linkTypeStr. Put another way:
* ""Does an inbound link exist to the current note from any of scope's item(s)?"".
or
* ""Do any of scope's item(s) have an outbound link to the current note?"".
As this is effectively only a query term, (with a Boolean result), if trying to collect data about the linked note(s), use links() instead.
scope defines a group of items in a number of ways. An additional option to normal group descriptors is a wildcard designator * that matches all notes in the document and replaces the normal ""all"" group designator.
For linkTypeStr, links of type 'prototype' are ignored. Used in an agent, 'this' note is the alias in the agent and not its original, making this action unsuitable for testing in an agent action. If using linkTypeStr, you must use the value ""*untitled"" to match an 'untitled' type link (rather than an empty string, """", or ""untitled"").
Thus, to test if any note using the 'Event' prototype has an inbound link of the 'untitled' link type the agent query would be:
	$Prototype==""Event"" & linkedFrom(""*"", ""*untitled"") 
The logical opposite of this test is linkedTo().
This function can match a link from an alias as opposed to an original (if the logical choice).
Working with aliases
If testing links using aliases (e.g. those created by an agent query) be aware that, for basic type links only, the original and alias can and may have differing numbers of basic links. Thus if wishing to check, unambiguously, the original's links from the context of one of its aliases, use originalLinkedFrom() instead.
Legacy issues
This replaces the legacy #linkedFrom query operator (deprecated since v4.6).
Counting links (of a type)
To know how many inbound links there are, use links() and .count() the resulting list.","linkedFrom(スコープ[, linkTypeStr])
インバウンドリンクのテスト。このブール テストは、現在のノートにスコープで定義されたいずれかのノートからのリンクが少なくとも 1 つある場合に true を返します。これはオプションで、linkTypeStr タイプのリンクのみにフィルタリングされます。別の言い方をすると:
* 「スコープの項目のいずれかから現在のノートへのインバウンド リンクは存在しますか?」
または
* 「スコープの項目のいずれかに、現在のノートへの送信リンクがありますか?」
これは事実上単なるクエリ用語であるため (ブール結果を伴う)、リンクされたメモに関するデータを収集しようとする場合は、代わりに links() を使用してください。
スコープはさまざまな方法で項目のグループを定義します。通常のグループ記述子への追加オプションは、ドキュメント内のすべてのメモと一致し、通常の「all」グループ指定子を置き換えるワイルドカード指定子 * です。
linkTypeStr の場合、タイプ「prototype」のリンクは無視されます。エージェントで使用される「この」メモは、エージェント内のエイリアスであり、オリジナルではないため、このアクションはエージェント アクションでのテストには適していません。linkTypeStr を使用する場合は、(空の文字列、""""、または ""untitled"" ではなく) 'untitled' タイプのリンクと一致させるために、値 ""*untitled"" を使用する必要があります。
したがって、「イベント」プロトタイプを使用するメモに「無題」リンク タイプの受信リンクがあるかどうかをテストするには、エージェント クエリは次のようになります。
$Prototype==""イベント"" & linkedFrom(""*"", ""*無題"")
このテストの論理的逆は、linkedTo() です。
この関数は、元のリンクとは対照的に、エイリアスからのリンクを照合できます (論理的な選択の場合)。
エイリアスの操作
エイリアス (エージェント クエリによって作成されたリンクなど) を使用してリンクをテストする場合は、基本タイプのリンクの場合に限り、元のリンクとエイリアスでは基本リンクの数が異なる可能性があることに注意してください。したがって、エイリアスのいずれかのコンテキストからオリジナルのリンクを明確にチェックしたい場合は、代わりにoriginalLinkedFrom()を使用してください。
従来の問題
これは、従来の #linkedFrom クエリ演算子 (v4.6 以降非推奨) を置き換えます。
(あるタイプの) リンクを数える
受信リンクの数を知るには、links() と .count() を使用して結果のリストを取得します。"
"linkedTo(scope[, linkTypeStr])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkedTo(scope[, linkTypeStr])
A test for outbound links. This boolean test at returns true if the current note has a least one link to any of the note(s) defined by scope; this is optionally filtered to only links of type linkTypeStr. Put another way:
* ""Does an outbound link exist from the current note to any of scope's item(s)?"".
or
* ""Do any of scope's item(s) have an inbound link from the current note?"".
As this is effectively only a query term, (with a Boolean result), if trying to collect data about the linked note(s), use links() instead.
scope defines a group of items in a number of ways. An additional option to normal group descriptors wildcard designator * that matches all notes in the document and replaces the normal ""all"" group designator.
For linkTypeStr, links of type 'prototype' are ignored. Used in an agent, 'this' note is the alias in the agent and not its original, making this action unsuitable for testing in an agent action. If using linkTypeStr, you must use the value ""*untitled"" to match an 'untitled' type link (rather than an empty string, """", or ""untitled"").
Thus, to test if any note using the 'Event' prototype has an outbound link of the 'untitled' link type the agent query would be:
	$Prototype==""Event"" & linkedTo(""*"", ""*untitled"");  
The logical opposite of this test is linkedFrom().
This function can match a link from an alias as opposed to an original (if the logical choice).
Working with aliases
If testing links using aliases (e.g. those created by an agent query) be aware that, for basic type links only, the original and alias can and may have differing numbers of basic links. Thus if wishing to check, unambiguously, the original's links from the context of one of its aliases, use originalLinkedTo() instead.
Legacy issues
This replaces the legacy #linkedTo query operator (deprecated since v4.6).
Counting links (of a type)
To know how many outbound links there are, use links() and .count() the resulting list.","linkedTo(スコープ[, linkTypeStr])
アウトバウンドリンクのテスト。このブール テストは、現在のノートにスコープで定義されたいずれかのノートへのリンクが少なくとも 1 つある場合に true を返します。これはオプションで、linkTypeStr タイプのリンクのみにフィルタリングされます。別の言い方をすると:
* 「現在のノートからスコープのアイテムへのアウトバウンドリンクは存在しますか?」
または
* 「スコープの項目のいずれかに、現在のノートからのインバウンドリンクがありますか?」
これは事実上単なるクエリ用語であるため (ブール結果を伴う)、リンクされたメモに関するデータを収集しようとする場合は、代わりに links() を使用してください。
スコープはさまざまな方法で項目のグループを定義します。通常のグループ記述子のワイルドカード指定子 * への追加オプション。文書内のすべてのメモと一致し、通常の「all」グループ指定子を置き換えます。
linkTypeStr の場合、タイプ「prototype」のリンクは無視されます。エージェントで使用される「この」メモは、エージェント内のエイリアスであり、オリジナルではないため、このアクションはエージェント アクションでのテストには適していません。linkTypeStr を使用する場合は、(空の文字列、""""、または ""untitled"" ではなく) 'untitled' タイプのリンクと一致させるために、値 ""*untitled"" を使用する必要があります。
したがって、「イベント」プロトタイプを使用するメモに「無題」リンク タイプの送信リンクがあるかどうかをテストするには、エージェント クエリは次のようになります。
$Prototype==""イベント"" & linkedTo(""*"", ""*無題"");
このテストの論理的逆は、linkedFrom() です。
この関数は、元のリンクとは対照的に、エイリアスからのリンクを照合できます (論理的な選択の場合)。
エイリアスの操作
エイリアス (エージェント クエリによって作成されたリンクなど) を使用してリンクをテストする場合は、基本タイプのリンクの場合に限り、元のリンクとエイリアスでは基本リンクの数が異なる可能性があることに注意してください。したがって、エイリアスのいずれかのコンテキストからオリジナルのリンクを明確にチェックしたい場合は、代わりにoriginalLinkedTo()を使用してください。
従来の問題
これは、従来の #linkedTo クエリ演算子 (v4.6 以降非推奨) を置き換えます。
(あるタイプの) リンクを数える
送信リンクの数を知るには、links() と .count() を使用して結果のリストを取得します。"
"linkFrom(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkFrom(""item|group""[,""linkType""])
This creates an untitled type basic link from scope to the current note (i.e. an inbound link).
The scope argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString. Ways to define scope.
The scope can be group scoped including use of group designators and operators like find,() collect() and links().
linkTypeStr (string). Optionally, instead of an 'untitled' link the link can be of linkTypeStr type. An untitled type link can be explicitly specified using the string ""*untitled"". Unlike unlinking, this argument may only contain a single link type value.
Both arguments are evaluated. This operator does not require a left-side argument, simply calling effects a result. A new link will not be created if a link of the stated type already exists.
Examples
Linking from a note ""Some note"":
	No link type: linkFrom(""Some note"") 
	Link type 'agree': linkFrom(""Some note"",""agree""); 
Linking from the first child (via a designator):
	linkFrom(child); 
	linkFrom(child,""agree""); 
Relevant similar operators: linkTo, unlinkTo, unlinkFrom.
Use of this action does not shift note focus; in addition if scope contains operators (brackets, plus, minus, etc.) Tinderbox will first look for a match to the literal item string and only if there is no match will the app try evaluating to operators and testing the resulting string. For example:
	linkFrom(""Example 1 (a test)""); 
will link from the note named 'Example 1 (a test)'. If no note matches this string, Tinderbox will attempt to evaluate the string. Thus for:
	linkFrom(""2+2"") 
will link from the note named '2+2' but if no match will look for a note named '4'.
This function can link from an alias as opposed to an original (if the logical choice) and can accept a group scope.
Use in agents
Beware that the action is working on an alias of the current note and note the current note itself. As originals and aliases support discrete basic links this function should not generally be used in an agent. The best way to use the function is by using a prototype and apply a $Rule to it thus running the code in all notes using the prototype.
An alternative linkFromOriginal() code will ensure any link created is between two original notes regardless of whether an alias is the context of execution of the code.","linkFrom(""アイテム|グループ""[,""リンクタイプ""])
これにより、スコープから現在のノートへの無題タイプの基本リンク (つまり、インバウンドリンク) が作成されます。
属性参照でない限り、スコープ引数は引用符で囲む必要があります。「メモ」と $MyString の比較。スコープを定義する方法。
スコープは、グループ指定子や find、()、collect()、links() などの演算子の使用を含めて、グループ スコープにすることができます。
linkTypeStr (文字列)。オプションで、「無題」リンクの代わりに、リンクを linkTypeStr タイプにすることもできます。無題タイプのリンクは、文字列「*untitled」を使用して明示的に指定できます。リンク解除とは異なり、この引数には単一のリンク タイプ値のみを含めることができます。
両方の引数が評価されます。この演算子は左側の引数を必要とせず、単に結果としてエフェクトを呼び出します。指定されたタイプのリンクがすでに存在する場合、新しいリンクは作成されません。
例
メモ「あるメモ」からのリンク:
リンクタイプなし: linkFrom(""Some note"")
リンクタイプ '同意': linkFrom(""メモ"",""同意"");
最初の子からのリンク (指定子経由):
linkFrom(子);
linkFrom(child,""同意する"");
関連する同様の演算子: linkTo、unlinkTo、unlinkFrom。
このアクションを使用してもノートのフォーカスは移動しません。さらに、スコープに演算子 (括弧、プラス、マイナスなど) が含まれている場合、Tinderbox はまずリテラル項目文字列との一致を探し、一致がない場合にのみ、アプリは演算子を評価して結果の文字列をテストします。たとえば:
linkFrom(""例 1 (テスト)"");
「例 1 (テスト)」という名前のメモからリンクします。この文字列に一致するメモがない場合、Tinderbox は文字列の評価を試みます。したがって、次のようになります。
linkFrom(""2+2"")
「2+2」という名前のノートからリンクしますが、一致しない場合は「4」という名前のノートを探します。
この関数は、オリジナルではなくエイリアスからリンクでき (論理的な選択の場合)、グループ スコープを受け入れることができます。
エージェントでの使用
このアクションは現在のノートのエイリアスに対して動作していることと、現在のノート自体に注意してください。オリジナルとエイリアスは個別の基本リンクをサポートしているため、この関数は通常エージェントでは使用しないでください。この関数を使用する最良の方法は、プロトタイプを使用し、それに $Rule を適用して、プロトタイプを使用してすべてのノートでコードを実行することです。
代替の linkFromOriginal() コードは、エイリアスがコード実行のコンテキストであるかどうかに関係なく、作成されたリンクが 2 つの元のノートの間にあることを保証します。"
"linkFromOriginal(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,6.4.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkFromOriginal(scope[, linkTypeStr])
This function works exactly as the same as linkFrom(), except for one important difference that the link created is always between two originals even if either/both the evaluated source or destination are an alias.
For more detail of use, see linkFrom().
Examples
Linking from the original note ""Some note"" (and not an alias of it):
	No link type: linkFromOriginal(""Some note"") 
	Link type 'agree': linkFromOriginal(""Some note"",""agree""); 
See also linkToOriginal(), unlinkFromOriginal(), unlinkToOriginal().","linkFromOriginal(scope[, linkTypeStr])
この関数は linkFrom() とまったく同じように機能しますが、評価されるソースまたは宛先のどちらかまたは両方がエイリアスであっても、作成されるリンクは常に 2 つのオリジナルの間にあるという重要な違いが 1 つあります。
使用方法の詳細については、「linkFrom()」を参照してください。
例
元のメモ「Some note」（その別名ではありません）からのリンク:
リンクタイプなし: linkFromOriginal(""Some note"")
リンクタイプ '同意': linkFromOriginal(""メモ"",""同意"");
linkToOriginal()、unlinkFromOriginal()、unlinkToOriginal() も参照してください。"
"linkPath(pathNameStr[, startStr, endStr])",Function,Item,Linking,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,false,false,true,false,,false,"linkPath(pathNameStr)
linkPath(pathNameStr[, startStr, endStr])
These functions return a list of notes that are on a designated path. The pathNameStr input must be supplied but can use a value  ""*"" designates any path, regardless of path name—i.e. all notes that have at least one inbound or outbound link. This operator in many ways mirrors the visual function of the Hyperbolic view.
If startStr is provided, that path starts at the designated note and ends on reaching the endStr note or when all links on the path reachable from start are exhausted. If only the pathName is provided, all notes on the path are listed, whether or not they all form one contiguous network.
For example, to collect all notes on the path ""example"":
	$MyList = linkPath(""example""); 
Or, to return all notes connected by links of any type:
	$MyList = linkPath(""*""); 
To find notes linked by the link type ""Project A"", starting at ""RFC"" :
	$MyList = linkPath(""Project A"", ""RFC""); 
To find notes linked by the link type ""Project A"", starting at ""RFC"" and ending at ""Archive"":
	$MyList = linkPath(""Project A"", ""RFC"", ""Archive""); 
If several possible paths exist from startStr to endStr, Tinderbox will return the shortest path, or at least a path which is not longer than any other path. Bear in mind that in richly interlinked documents, there may be no 'obvious' single path between the specified notes.
 If only endStr is supplied, still include the argument delimiter for the unused startStr:
	$MyList = linkPath(""Project A"", , ""Archive""); 
The underlying graph may contain cycles (i.e. have looping paths).","リンクパス(パス名Str)
linkPath(pathNameStr[, startStr, endStr])
これらの関数は、指定されたパス上にあるノートのリストを返します。pathNameStr 入力は指定する必要がありますが、値「*」を使用できます。パス名に関係なく、任意のパスを指定します。少なくとも 1 つの受信リンクまたは送信リンクを持つすべてのメモ。この演算子は、多くの点で双曲線ビューの視覚機能を反映しています。
startStr が指定されている場合、そのパスは指定されたノートから始まり、endStr ノートに到達するか、開始点から到達可能なパス上のすべてのリンクが使い果たされたときに終了します。pathName のみを指定した場合は、すべてが 1 つの連続したネットワークを形成しているかどうかに関係なく、パス上のすべてのメモがリストされます。
たとえば、パス「example」上のすべてのメモを収集するには、次のようにします。
$MyList = linkPath(""例"");
または、任意のタイプのリンクによって接続されているすべてのノートを返すには、次のようにします。
$MyList = linkPath(""*"");
リンクタイプ「Project A」でリンクされているノートを検索するには、「RFC」で始まります。
$MyList = linkPath(""プロジェクト A"", ""RFC"");
リンクタイプ「Project A」でリンクされているノートを検索するには、「RFC」で始まり「Archive」で終わります。
$MyList = linkPath(""プロジェクト A"", ""RFC"", ""アーカイブ"");
startStr から endStr までの可能なパスが複数存在する場合、Tinderbox は最短のパス、または少なくとも他のパスよりも長くないパスを返します。相互リンクが豊富な文書では、指定されたメモの間に「明らかな」単一パスが存在しない可能性があることに留意してください。
endStr のみが指定されている場合でも、未使用の startStr の引数区切り文字を含めます。
$MyList = linkPath(""プロジェクト A"", , ""アーカイブ"");
基礎となるグラフにはサイクルが含まれる場合があります (つまり、ループ パスがある場合)。"
links[(scope)].directionStr.[linkTypeRegex].attributeNameRefStr,Function,Conditional Group,"Dictionary, Set & List operations",List,false,4.0.0,Baseline,,,,4,true,false,false,false,true,true,false,true,false,true,false,"links[(scope)].directionStr.[linkTypeRegex].attributeNameStr
The links() operator builds a List from a collection of links. It selects the note(s) whose links should be inspected. 
	Note: although links() is not deprecated, Eastgate advise that for many existing uses of links(), employing eachLink() may provide better/easier control.
The scope is one or more items (defining scope), but note the scope argument is not fully evaluated, so only use simple expressions. scope never matches aliases. When using links() in the context of an agent's action, remember that aliases can have different basic links to their originals. Therefore, it is likely that act action using 'this' will want to replace it with 'original' as the scope when re-used in an agent action.
The mandatory directionStr argument filters the directionality of the links collected. It is mandatory, and should not be quoted. Note that links() can only test for one link direction at a time, i.e. in or out. The directionStr may or may not be in quotes but its value can only be either one of these two: 
* inbound
* outbound
The optional linkTypeRegex argument is evaluated as a regular expression. Although the most normal usage will be as a literal string of a single link type name. Regex use allows for It collects only links of a specified link type, or such type(s) as match the linkTypeRegex regex amongst the link type names defined in the current TBX. Regular expression wild-card characters are permitted and retain their special meanings. If the linkTypeStr value contains white space or periods, it must be enclosed in double quotes:
	links.outbound.""responds to"".$Name 
If linkTypeRegex is left empty, links of all types are collected except prototype links. Prototype links are always omitted. Single quotes can be used to enclose linkTypeRegex but if the quoted string includes a single quote this must be backslash-escaped or double quote used instead:
	links.outbound.""Peter's place"".$Name OK
	links.outbound.'Peter's place'.$Name wrong
	links.outbound.'Peter\'s place'.$Name OK
The is evaluated for regex.
The attributeNameRefStr argument is the $-prefixed reference to the attribute whose values are to be collected in the result. An attribute reference, e.g. $Name(""nextSibling"") is invalid, the command work but the reference is ignored and the stated attribute for the linked note is used, i.e. attributeNameRefStr is a literal value and cannot be an expression.
If simply wishing to test the state of links between two items, consider the Boolean queries linkedFrom() and linkedTo().
Examples
	$MyList=links(/config).outbound.supports.$Name; 
constructs a List of all the titles (from Name attribute) of notes that are linked to the top-level note named 'config' via links with the link type 'supports'. This does the same but for all link types;
	$MyList=links(/config).outbound..$Name; 
For multi-word link type names use quotes (or if using regex characters):
	$MyList=links(/config).outbound.""agrees with"".$Name; 
Whilst it is likely that 'Name' will be the most usual value for attribute, it can be any currently defined attribute:
	$MyList=links.inbound.""went to"".$SchoolName; 
collects a List of values of the attribute 'SchoolName' for notes that have an inbound link to the current note of link type ""went to"". 
Beware when using a TBX that has notes with duplicate (same) $Name values. As a set contains unique values, if several notes have identical names, then
	$MySet=links.inbound..$Name; 
will list the distinct Names only once in MySet, and so the latter will have fewer values than the actual number of matching links. In the same scenario:
	$MyList=links.inbound..$Name; 
will create a list containing duplicates.
The format() or List.format() operators can help make more use of links() data during export, e.g. as lists or lists of links. Internally, if analysing links and there is no real need to keep set-type data, using agents employing linkedTo() and linkedFrom() will find most of the same data as links() can provide.
The links() function can be chained by dot operators pertinent to use with List type data. But, as links() uses dot-chained arguments, it is necessary to use parentheses to chain other dot operators. Thus, to get a count of the number of linked items found:
	(links(children).inbound..$StartDate).size 
In addition, the use of parentheses helps make sense of the intended order of execution of the tasks chained to links():
	$MyList=(links.inbound.""colleague of"".$Name).sort(""$StartDate""); 
More examples of links() syntax:
	links.outbound.agree.$Name 
	links(this).outbound.agree.$Name 
	links(children).inbound..$StartDate 
	links(""A note"").outbound.""example|agree"".$Name 
	links(""A note;A different note"").inbound.""*untitled"".$Path 
	links($MyString).outbound..$TutorName 
	links(find(descendedFrom(""Some note"")).inbound.my_link.$SomeAttribute 
	links(find(descendedFrom(""Some note"")&$MyDate==$StartDate).outbound..$Width 
	links($MySet).outbound.example.$Name 
	 links($MyList).inbound.note.$WordCount 
N.B links().outbound is treated as equivalent to links(this).outbound, so making the scope explicit to Tinderbox (in older versions the two forms evaluated differently).
Working with links
If needing to return multiple items from linked items or to do more complex link-based work, see the eachLink() operator which offers a wider range of options.
Counting links (of a type)
As links() returns a list of 1 or more matches, the count of the resulting list indicates how many links of the stated direction/type that there are. To count the number of outbound notes of any type from the current notes (excluding web links!):
	$MyNumber = (links(this).outbound..$Name).count; 
To limit the count to only links of type 'example', use""
	$MyNumber = (links(this).outbound.""example"".$Name).count;",
"linkTo(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkTo(scope[, linkTypeStr])
This creates an untitled type basic link to scope from the current note (i.e. an outbound link).
The scope argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString. Ways to define scope.
scope can be group scoped including use of group designators and operators like find,() collect() and links().
linkType (string). Optionally, instead of an 'untitled' link the link can be of linkTypeStr type. An untitled type link can be explicitly specified using the string ""*untitled"". Unlike unlinking, this argument may only contain a single link type value. 
Both arguments are evaluated. This operator does not require a left-side argument, simply calling effects a result. A new link will not be created if a link of the stated type already exists.
Examples
Linking to a note ""Some note"":
	No link type: linkTo(""Some note""); 
	Link type 'agree': linkTo(""Some note"",""agree""); 
Linking to the first child (via a designator):
	linkTo(child); 
	linkTo(child,""agree""); 
Relevant similar operators: linkFrom, unlinkTo, unlinkFrom.
Use of this action does not shift note focus; in addition if scope contains operators (brackets, plus, minus, etc.) Tinderbox will first look for a match to the literal item string and only if there is no match will the app try evaluating to operators and testing the resulting string. For example:
	linkTo(""Example 1 (a test)"") 
will link to the note named 'Example 1 (a test)'. If no note matches this string, Tinderbox will attempt to evaluate the string. Thus for:
	linkTo(""2+2""); 
will link to the note named '2+2' but if no match will look for a note named '4'.
This function can link to an alias as opposed to an original (if the logical choice) and can accept a group scope.
Use in agents
Beware that the action is working on an alias of the current note and note the current note itself. As originals and aliases support discrete basic links this function should not generally be used in an agent. The best way to use the function is by using a prototype and apply a $Rule to it thus running the code in all notes using the prototype.
An alternative linkFromOriginal() code will ensure any link created is between two original notes regardless of whether an alias is the context of execution of the code.","linkTo(スコープ[, linkTypeStr])
これにより、現在のノートからスコープへの無題タイプの基本リンク (つまり、送信リンク) が作成されます。
属性参照でない限り、スコープ引数は引用符で囲む必要があります。「メモ」と $MyString の比較。スコープを定義する方法。
スコープは、グループ指定子や find、()、collect()、links() などの演算子の使用を含めて、グループ スコープにすることができます。
リンクタイプ (文字列)。オプションで、「無題」リンクの代わりに、リンクを linkTypeStr タイプにすることもできます。無題タイプのリンクは、文字列「*untitled」を使用して明示的に指定できます。リンク解除とは異なり、この引数には単一のリンク タイプ値のみを含めることができます。
両方の引数が評価されます。この演算子は左側の引数を必要とせず、単に結果としてエフェクトを呼び出します。指定されたタイプのリンクがすでに存在する場合、新しいリンクは作成されません。
例
メモ「メモ」へのリンク:
リンクタイプなし: linkTo(""Some note"");
リンクタイプ '同意': linkTo(""メモ"",""同意"");
最初の子へのリンク (指定子経由):
リンク先(子);
linkTo(child,""同意する"");
関連する同様の演算子: linkFrom、unlinkTo、unlinkFrom。
このアクションを使用してもノートのフォーカスは移動しません。さらに、スコープに演算子 (括弧、プラス、マイナスなど) が含まれている場合、Tinderbox はまずリテラル項目文字列との一致を探し、一致がない場合にのみ、アプリは演算子を評価して結果の文字列をテストします。たとえば:
linkTo(""例 1 (テスト)"")
「例 1 (テスト)」という名前のメモにリンクします。この文字列に一致するメモがない場合、Tinderbox は文字列の評価を試みます。したがって、次のようになります。
linkTo(""2+2"");
は「2+2」という名前のノートにリンクしますが、一致しない場合は「4」という名前のノートを探します。
この関数は、元のエイリアスではなくエイリアスにリンクでき (論理的な選択の場合)、グループ スコープを受け入れることができます。
エージェントでの使用
このアクションは現在のノートのエイリアスに対して動作していることと、現在のノート自体に注意してください。オリジナルとエイリアスは個別の基本リンクをサポートしているため、この関数は通常エージェントでは使用しないでください。この関数を使用する最良の方法は、プロトタイプを使用し、それに $Rule を適用して、プロトタイプを使用してすべてのノートでコードを実行することです。
代替の linkFromOriginal() コードは、エイリアスがコード実行のコンテキストであるかどうかに関係なく、作成されたリンクが 2 つの元のノートの間にあることを保証します。"
"linkToOriginal(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,6.4.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"linkToOriginal(scope[, linkType])
This function works exactly as the same as linkTo(), except for one important difference that the link created is always between two originals even if either/both the evaluated source or destination are an alias.
For more detail of use, see linkTo().
Examples
Linking to the original note ""Some note"" (and not an alias of it):
	No link type: linkToOriginal(""Some note""); 
	Link type 'agree': linkToOriginal(""Some note"",""agree""); 
See also linkFromOriginal(), unlinkFromOriginal(), unlinkToOriginal().","linkToOriginal(scope[, linkType])
この関数は linkTo() とまったく同じように機能しますが、評価されるソースまたは宛先のどちらかまたは両方がエイリアスであっても、作成されるリンクは常に 2 つのオリジナルの間にあるという重要な違いが 1 つあります。
使用方法の詳細については、「linkTo()」を参照してください。
例
元のメモ「Some note」へのリンク (別名ではありません):
リンクタイプなし: linkToOriginal(""Some note"");
リンクタイプ '同意': linkToOriginal(""メモ"",""同意"");
linkFromOriginal()、unlinkFromOriginal()、unlinkToOriginal()も参照してください。"
"list.any(loopVar, expressionStr)",Function,List,Query Boolean,boolean test,false,8.1.0,Baseline,,,,2,true,true,false,true,false,false,false,false,false,,false,"list.any(loopVar, expressionStr)
This is true if any loopVar in the List- or Set-type list matches the expression.
	$MyBoolean = $MyList.any(x,x>5) 
is true if any loopVar in $MyList is greater than 5. 
The comparison may also be applied to literal lists:
	""apple; pear; plum"".any(x, x==""plum"") 
is true because at least one element has the value ""plum"".
If the target list or set is empty, .any() always returns false, and .every() always returns true.
The loopVar is a user-set case-sensitive string. ""x"", ""anItem"", etc., are equally applicable. Similar to a loop variable in .each(x){}, the point of the loopVar value, is to set a reference variable for each list element. This can then be used in the code provided by the expressionStr argument. Using a number for loopVar, e.g. '1' or '42' is not recommended. Choose a value that makes sense for your own style of work  
The expressionStr is any action code expression that is a test resolving to a Boolean true/false answer.
For example, to test if any item exactly matches the value stored in the $MyString of 'Some note':
	$MyBoolean = $MyList.any(anItem, anItem == $MyString(""Some Note"")); 
Or, any list value that starts with the string 'Large':
	$MyBoolean = $MyList.any(Z, Z.contains(""^Large""));","list.any(loopVar、expressionStr)
これは、List 型リストまたは Set 型リスト内のいずれかのloopVar が式と一致する場合に当てはまります。
$MyBoolean = $MyList.any(x,x>5)
$MyList 内のいずれかのloopVarが5より大きい場合はtrueです。
比較はリテラル リストにも適用できます。
""リンゴ; ナシ; プラム"".any(x, x==""プラム"")
少なくとも 1 つの要素の値が「plum」であるため、これは true です。
ターゲットのリストまたはセットが空の場合、.any() は常に false を返し、.every() は常に true を返します。
LoopVar は、ユーザーが設定した大文字と小文字を区別する文字列です。「x」、「anItem」なども同様に適用できます。.each(x){} のループ変数と同様に、loopVar 値のポイントは、リスト要素ごとに参照変数を設定することです。これは、expressionStr 引数によって提供されるコードで使用できます。たとえば、loopVar に数値を使用します。「1」または「42」は推奨されません。自分の作業スタイルに適した値を選択してください
expressionStr は、ブール値の true/false 回答を解決するテストであるアクション コード式です。
たとえば、「Some note」の $MyString に格納されている値と完全に一致する項目があるかどうかをテストするには、次のようにします。
$MyBoolean = $MyList.any(anItem, anItem == $MyString(""メモ""));
または、文字列「Large」で始まるリスト値:
$MyBoolean = $MyList.any(Z, Z.contains(""^Large""));"
list.asString(),Function,Item,Data manipulation,String,false,9.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.asString()
list.asString
The dot-operator .asString(), converts a List- or Set-type list to a String-type representation. This addresses an issue where much-used operators .contains() and .icontains() behave differently for Strings (where it searches for a regular expression match) compared to Lists and Sets (where it tests for set membership). Occasionally, is desirable to perform a regular expression test on a list or set—for example, to ask if any of the members of $MyList begin with the letter ""a"":
	$MyBoolean = $MyList.asString().contains(^a""); 
Note there are no arguments for this operator so the trailing parentheses optionally may be omitted:
 	$MyBoolean = $MyList.asString.contains(^a""); 
The role of .asString() is simple:
     $MyList = [winken;blinken;nod];
     $MyString = $MyList.asString();
The value of MyString is now ""winken;blinken;nod"", still the literal stored value of my list complete with semicolon delimiters, but—importantly—Tinderbox now treats this is a literal String, despite the semicolons, and not as List or Set type data. That allows the .contains() example above to do a regex (String behaviour) match on what is otherwise treated as a 3-item list.","list.asString()
list.asString
ドット演算子 .asString() は、List 型または Set 型のリストを String 型の表現に変換します。これにより、よく使用される演算子 .contains() および .icontains() が、リストおよびセット (セットのメンバーシップをテストする) と比較して、文字列 (正規表現の一致を検索する) に対して異なる動作をするという問題が解決されます。場合によっては、リストまたはセットに対して正規表現テストを実行することが望ましい場合があります。たとえば、$MyList のメンバーの中に文字「a」で始まるものがあるかどうかを尋ねる場合です。
$MyBoolean = $MyList.asString().contains(^a"");
この演算子には引数がないため、オプションで末尾の括弧を省略できることに注意してください。
$MyBoolean = $MyList.asString.contains(^a"");
.asString() の役割は単純です。
$MyList = [ウィンケン;ブリンケン;うなずく];
$MyString = $MyList.asString();
MyString の値は ""winken;blinken;nod"" になり、セミコロン区切り文字を備えたリストのリテラル格納値のままですが、重要なことに、Tinderbox はこれを、セミコロンにもかかわらず、List 型や Set 型のデータとしてではなく、リテラル String として扱うようになりました。これにより、上記の .contains() の例では、通常は 3 項目のリストとして扱われるものに対して正規表現 (文字列の動作) 照合を行うことができます。"
list.at(itemNum),Function,Item,Data manipulation,source context dependent,false,5.7.1,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.at(itemNum)
This returns the value of item itemNum of the List- or Set-type list as a string. List can be either Set or List type attributes (or string literal, regex, or expression equivalents thereof). This operator is read-only: list values can be read, but not set.
Note: for accessing look-up tables, use list.lookup().
The operator is zero-based, i.e. an itemNum value of 0 returns the first list item, an itemNum of 1 returns value #2, etc. If the value of N exceeds the number of items in the list an empty string (blank value) is returned. A negative number returns an item numbering in reverse, but one-based not zero-based, so '-1' returns the last item on the list, '-2' the last but one item, etc.
Examples (where $MyList is ""ant;bee;cow""):
	$MyString = $MyList.at(0); returns ""ant""
	$MyString = ""XX;YY;ZZ"".at(2); returns ""ZZ""
	$MyString = $MyList.at(5); returns """" (nothing) 
	$MyString = $MyList.at(-2); returns ""bee""
See also the more recent list[N] usage.
To address particular locations in a list, also see list.first(), list.last() and list.randomItem().

Legacy use (pre-v8)
list.at(""key"")
This usage is deprecated, use list.lookup(""key"") instead. The remainder of this section is for explanation of legacy code use only.
The .at() function is also useful for accessing values from look-up tables by providing the relevant key. Consider a look-up list:
	$RegionList=""AL:South;AK:NorthWest;default:North""; 
This allows actions like:
	$Region=$RegionList.at(""AL""); 
or
	$Region=$RegionList.at($State);","list.at(項目番号)
List 型または Set 型リストの項目 itemNum の値を文字列として返します。List には、Set または List タイプの属性 (または文字列リテラル、正規表現、またはそれらと同等の式) を指定できます。この演算子は読み取り専用です。リスト値は読み取ることができますが、設定することはできません。
注: ルックアップ テーブルにアクセスするには、list.lookup() を使用します。
演算子はゼロベースです。つまり、itemNum の値が 0 の場合は最初のリスト項目が返され、itemNum の値が 1 の場合は値 #2 が返されます。N の値がリスト内の項目の数を超える場合は、空の文字列 (空白の値) が返されます。負の数値は項目の番号付けを逆に返しますが、0 からではなく 1 から始まるため、「-1」はリストの最後の項目を返し、「-2」は最後から 1 つ前の項目を返します。
例 ($MyList が「ant;bee;cow」の場合):
$MyString = $MyList.at(0);「アリ」を返します
$MyString = ""XX;YY;ZZ"".at(2);「ZZ」を返します
$MyString = $MyList.at(5);"""" (何も返さない) を返します
$MyString = $MyList.at(-2);「蜂」を返します
最新の list[N] の使用法も参照してください。
リスト内の特定の位置を指定するには、list.first()、list.last()、および list.randomItem() も参照してください。

レガシー使用 (v8 以前)
list.at(""キー"")
この使用法は非推奨です。代わりに list.lookup(""key"") を使用してください。このセクションの残りの部分は、レガシー コードの使用についてのみ説明します。
.at() 関数は、関連するキーを指定してルックアップ テーブルの値にアクセスする場合にも役立ちます。ルックアップ リストを考えてみましょう。
$RegionList=""AL:南;AK:北西;デフォルト:北"";
これにより、次のようなアクションが可能になります。
$Region=$RegionList.at(""AL"");
または
$Region=$RegionList.at($State);"
list.avg(),Function,List,"Dictionary, Set & List operations",Number,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.avg()
list.avg
Returns the mean value of a List- or Set-type list of numbers. For example, if MyList is a list of numerical values '3;4;8;3;9;2;12':
	$MyNumber = $MyList.avg; returns 5.85714
To get only two decimal places:
	$MyNumber = $MyList.avg.format(""2""); returns 5.86","list.avg()
リスト.平均
List または Set タイプの数値リストの平均値を返します。たとえば、MyList が数値「3;4;8;3;9;2;12」のリストである場合:
$MyNumber = $MyList.avg;5.85714 を返します
小数点以下 2 桁だけを取得するには:
$MyNumber = $MyList.avg.format(""2"");5.86 を返します"
"list.collect_if(loopVar, condition, expressionStr)",Function,List,"Dictionary, Set & List operations",List,false,9.0.0,Baseline,,,,3,true,true,false,true,false,false,true,false,false,,false,"list.collect_if(loopVar, condition, expressionStr)
The dot-operator .collect_if() collects the members of a List- or Set-type list that satisfy a condition. Each item in the list is bound in turn to loopVar, and then the expressionStr is evaluated.
loopVar is essentially the same as the loop variable used by the List.each() operator. In the examples below, for clarity the loopVar value ""anItem"" is used, but as with any loop variable a shorter less expressive values such a ""x"" can be used (e.g. by more expert users).
The condition argument is a conditional expression for which each tested item must return true or false.
The operator applies the action code expressionStr to only those list items for which condition is  true. For only list items meeting condition, the result of expressionStr on loopVar is returned as List-type data. Unlike list.collect(), the returned list may well contain fewer items than the source list, unless all source items match condition.
If $MyList is ""1;2;3;4;5"", anItem, is 1, then 2, etc. For example:
	$MyListA = $MyList.collect_if(anItem, anItem  returns 1;2 (only 2 of 5 source items match condition)
	$MyListA = $MyList.collect_if(anItem, mod(anItem,2), anItem); returns 1;3;5 (only 3 of 5 source items match condition)
	$MyListA = $MyList.collect_if(anItem, mod(anItem,2), anItem* anItem); returns 1;9;25 (only 3 of 5 source items match condition)
	$MyListA = $MyList.collect_if(anItem, anItem>0, anItem* anItem); returns 1;4;9;16;25 (all 5 source items match condition)
In the first three examples above note how only some of the original 5 source list items are returned as some input items fail the condition test. In the last example, as all 5 items are greater than zero (the condition) to the expressionStr is applied to every one of them and all are returned.
If $MyList is ""Winken;Blinken;Nod"", then:
	$MyListA = $MyList.collect_if(anItem, anItem.contains('i'),anItem.lowercase); returns ""winken;blinken"" (only 2 items are returned)
In the last example note how only 2 of the original 3 source list items are returned as the item  ""Nod"" does not contain the letter 'i' and so fails the condition test.
list.collect_if() vs. collect_if()
Although the two appear similar. This operator works directly on the source list values, whereas collect_if() creates a list of $Path values and returns on an attribute value from each of those paths (where the item at the $Path meets the condition).","list.collect_if(loopVar, 条件, 式Str)
ドット演算子 .collect_if() は、条件を満たす List 型または Set 型のリストのメンバーを収集します。リスト内の各項目は順番にloopVarにバインドされ、expressionStrが評価されます。
loopVar は、List.each() 演算子で使用されるループ変数と本質的に同じです。以下の例では、わかりやすくするために、loopVar 値「anItem」が使用されていますが、他のループ変数と同様に、「x」などのより短く表現力の低い値も使用できます (たとえば、より専門的なユーザーによって)。
条件引数は、テストされた各項目が true または false を返す必要がある条件式です。
演算子は、条件が true であるリスト項目のみにアクション コードexpressionStr を適用します。条件を満たすリスト項目のみ、loopVarのexpressionStrの結果をList型データとして返します。list.collect() とは異なり、すべてのソース項目が条件に一致しない限り、返されるリストにはソース リストよりも少ない項目が含まれる可能性があります。
$MyList が ""1;2;3;4;5"" の場合、anItem は 1、次に 2 というようになります。次に例を示します。
$MyListA = $MyList.collect_if(anItem, anItem は 1;2 を返します (5 つのソース項目のうち 2 つだけが条件に一致します)
$MyListA = $MyList.collect_if(anItem, mod(anItem,2), anItem);1;3;5 を返します (5 つのソース項目のうち 3 つだけが条件に一致します)
$MyListA = $MyList.collect_if(anItem, mod(anItem,2), anItem* anItem);1;9;25 を返します (5 つのソース項目のうち 3 つだけが条件に一致します)
$MyListA = $MyList.collect_if(anItem, anItem>0, anItem* anItem);1;4;9;16;25 を返します (5 つのソース項目すべてが条件に一致します)
上記の最初の 3 つの例では、一部の入力項目が条件テストに失敗したため、元の 5 つのソース リスト項目の一部だけが返されることに注目してください。最後の例では、5 つの項目すべてが 0 (条件) より大きいため、expressionStr がそれらのすべてに適用され、すべてが返されます。
$MyList が「Winken;Blinken;Nod」の場合、次のようになります。
$MyListA = $MyList.collect_if(anItem, anItem.contains('i'),anItem. lowercase);「winken;blinken」を返します（2 つの項目のみが返されます）
最後の例では、項目「Nod」に文字「i」が含まれていないため、条件テストに失敗し、元の 3 つのソース リスト項目のうち 2 つだけが返されることに注意してください。
list.collect_if() とcollect_if()
両者は似ているように見えますが。この演算子はソース リストの値に直接作用しますが、collect_if() は $Path 値のリストを作成し、それらの各パスからの属性値 ($Path の項目が条件を満たす場合) を返します。"
"list.collect(loopVar, expressionStr)",Function,List,"Dictionary, Set & List operations",List,false,9.0.0,Baseline,,,,2,true,true,false,true,false,false,false,false,false,,false,"list.collect(loopVar, expression)
Each item in the List- or Set-type list is bound in turn to loopVar, and then the expressionStr is evaluated). 
loopVar is essentially the same as the loop variable used by the List.each() operator. In the examples below, for clarity the loopVar value ""anItem"" is used, but as with any loop variable a shorter less expressive values such a ""x"" can be used (e.g. by more expert users). 
The operator applies the action code expressionStr to each list item in turn. The result of expression on loopVar is returned as List-type data. The operator always returns a list of all the results, i.e. the size of the input and output lists are the same. By comparison, this may not be the case with the similar list.collect_if() operator.
If $MyList is ""1;2;3;4;5"", anItem, is 1, then 2, etc. For example:
	 $MyListA = $MyList.collect(anItem,anItem+1); returns 2;3;4;5;6
	 $MyListA = $MyList.collect(anItem, anItem* anItem); returns 1;4;9;16;25
If $MyList is ""Winken;Blinken;Nod"", then:
	$MyListA = $MyList.collect(anItem, anItem.lowercase); returns ""winken;blinken;nod""
list.collect() vs. collect()
Although the two appear similar. This operator works directly on the source list values, whereas collect() creates a list of $Path values and returns on an attribute value from each of those paths.","list.collect(loopVar, 式)
List 型または Set 型のリスト内の各項目は、順番にloopVar にバインドされ、expressionStr が評価されます。
loopVar は、List.each() 演算子で使用されるループ変数と本質的に同じです。以下の例では、わかりやすくするために、loopVar 値「anItem」が使用されていますが、他のループ変数と同様に、「x」などのより短く表現力の低い値も使用できます (たとえば、より専門的なユーザーによって)。
演算子は、アクション コードexpressionStr を各リスト項目に順番に適用します。loopVarの式の結果をList型データとして返します。演算子は常にすべての結果のリストを返します。つまり、入力リストと出力リストのサイズは同じです。比較すると、同様の list.collect_if() 演算子には当てはまらない可能性があります。
$MyList が ""1;2;3;4;5"" の場合、anItem は 1、次に 2 というようになります。次に例を示します。
$MyListA = $MyList.collect(anItem,anItem+1);2;3;4;5;6 を返します
$MyListA = $MyList.collect(anItem, anItem* anItem);1;4;9;16;25 を返します
$MyList が「Winken;Blinken;Nod」の場合、次のようになります。
$MyListA = $MyList.collect(anItem, anItem. lowercase);「ウィンケン;ブリンケン;うなずく」を返します
list.collect() とcollect()
両者は似ているように見えますが。この演算子はソース リストの値に直接作用しますが、collect() は $Path 値のリストを作成し、それらの各パスからの属性値を返します。"
list.contains(matchStr),Function,Item,Query Boolean,boolean test,false,5.7.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.contains(matchStr)
This operator tests whether the string matchStr matches a whole discrete value string within a the referenced  List- or Set-type list value. Unlike when used with a String, e.g. String.contains, there is no regex functionality. With lists the function behaves as if the chained list were being iterated and an equality (==) test was being run on each list item.
Matches are always case-sensitive, unlike list.icontains() where the matches are always case-sensitive.
Used with a list (List or Set data types), .contains() cannot match to granularity less than a single whole item in the chained list. Importantly, this differs from the operator's use with String data, e.g. String.contains(), where regular expression matching is applied. If regex parsing is needed, e.g. to match a partial list value, coerce the list to a string and use to operator on that string—see below.
A match gives a numerical result which is the 1-based matched list position. That number coerces to the boolean result needed for use in queries: ) to false and 1 or more to true.
matchStr is one of:
* an action code expression (which includes just referencing a single attribute name)
* a quoted literal string (i.e. actual text). Important: do not omit the enclosing quotes. If omitted, Tinderbox will try to evaluate the string as an expression. Doing this may result in the expected result but this is actually a false positive. So, remember to enclose your literals in quotes.
$MyList.contains(matchStr)
The contains operator may also be used with both sets and lists, in which case it tests for set membership, i.e. matching to complete individual values rather than part of values. Thus:
	$MyList.contains(""Tuesday"") 
	$MyList(parent).contains(""Tuesday"") 
are both true if $MyList contains ""Monday;Tuesday;Friday"". A match can use an attribute value as the matchStr. Consider a single-value String-type attribute 'MyDay':
	$MyList.contains($MyDay) 
is true if the value of $MyDay for a given note is any of ""Monday"", ""Tuesday or ""Friday"". Thus in an agent or find query, the regex varies by the source value in the currently-tested note.
The chained list may also be a literal list:
	""Saturday;Sunday"".contains(""Sunday"") 
	""Saturday;Sunday"".contains($MyDay) 
If the matchStr is found the function returns a number which is the 1-based matched list position. In the last example above the returned value will be 2, because 'Sunday' is the second item in the list. 
Testing a negative: ""does not contain""
Use a ! prefix to the query argument:
	!$MyList.contains(""Tuesday"") 
Use of parentheses around the negated query term, can assist Tinderbox's parsing:
	(!$MyList.contains(""Tuesday"")) 
Matching partial list values
As changing to list suppresses the normal string regex parsing, interposing the .asString() operator allows the list to be treats a a string so as to behave like a String.contains() test. See the .asString() operator listing for more detail. This is a more elegant replacement for the old workaround of using List.format(""#"").icontains(""some match) as may be seen in some older code samples.","list.contains(matchStr)
この演算子は、文字列 matchStr が、参照されたリスト型またはセット型のリスト値内の離散値文字列全体と一致するかどうかをテストします。文字列で使用する場合とは異なります。String.contains には正規表現機能はありません。リストの場合、この関数は、連鎖リストが反復され、各リスト項目に対して等価 (==) テストが実行されているかのように動作します。
一致では常に大文字と小文字が区別される list.icontains() とは異なり、一致では常に大文字と小文字が区別されます。
リスト (List データ型または Set データ型) とともに使用すると、.contains() は連鎖リスト内の 1 つの項目全体よりも小さい粒度に一致することはできません。重要なのは、これは演算子による文字列データの使用とは異なります。String.contains()。正規表現一致が適用されます。正規表現解析が必要な場合、例:部分的なリスト値と一致させるには、リストを文字列に強制変換し、その文字列に対して to 演算子を使用します。以下を参照してください。
一致すると、1 から始まる一致リストの位置である数値結果が得られます。この数値は、クエリでの使用に必要なブール結果に強制的に変換されます: ) は false、1 以上は true です。
matchStr は次のいずれかです。
* アクション コード式 (単一の属性名の参照のみを含む)
* 引用符で囲まれたリテラル文字列 (つまり、実際のテキスト)。重要: 囲みの引用符を省略しないでください。省略した場合、Tinderbox は文字列を式として評価しようとします。これを実行すると期待どおりの結果が得られる可能性がありますが、これは実際には誤検知です。したがって、リテラルを引用符で囲むことを忘れないでください。
$MyList.contains(matchStr)
contains 演算子は、セットとリストの両方で使用することもできます。この場合、セットのメンバーシップをテストします。つまり、値の一部ではなく個々の値を完全に一致させるかどうかをテストします。したがって:
$MyList.contains(""火曜日"")
$MyList(親).contains(""火曜日"")
$MyList に「Monday; Tuesday; Friday」が含まれる場合、両方とも true になります。一致では、属性値を matchStr として使用できます。単一値の文字列型属性「MyDay」について考えてみましょう。
$MyList.contains($MyDay)
指定されたメモの $MyDay の値が「月曜日」、「火曜日」または「金曜日」のいずれかである場合は true です。したがって、エージェントまたは検索クエリでは、正規表現は現在テストされているメモのソース値によって異なります。
連鎖リストはリテラル リストである場合もあります。
""土曜日;日曜日"".contains(""日曜日"")
""土曜日;日曜日"".contains($MyDay)
matchStr が見つかった場合、関数は 1 から始まる一致リストの位置を示す数値を返します。上記の最後の例では、「Sunday」がリストの 2 番目の項目であるため、戻り値は 2 になります。
陰性のテスト:「含まれていない」
! を使用してください。クエリ引数の接頭辞:
!$MyList.contains(""火曜日"")
否定されたクエリ用語を括弧で囲むと、Tinderbox の解析が容易になります。
(!$MyList.contains(""火曜日""))
部分的なリスト値の一致
list に変更すると通常の文字列正規表現解析が抑制されるため、.asString() 演算子を挿入すると、リストを文字列として処理して String.contains() テストのように動作できるようになります。詳細については、.asString() 演算子のリストを参照してください。これは、古いコード サンプルで見られるように、List.format(""#"").icontains(""some match) を使用する古い回避策をより洗練された代替策です。"
list.containsAnyOf(regexList),Function,Item,Query Boolean,boolean test,false,8.8.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"list.containsAnyOf(regexList)
The operator .containsAnyOf(regexList) is true if any of the words in a set of words (i.e. a List- or Set-type list) is contained in the chained-to target string. As shown below, the list may have many or only one entry. The test is case-sensitive (previously it was case-insensitive). For example:
	$MyBoolean = $MyList.containsAnyOf(""emulate""); 
Will be true if the tested note's $Text contains the word ""emulate""; unlike with .contains() or .icontains() a partial value may be matched in the target list. If $MyList holds the values 'emulate', 'mimic' and 'simulate', the list is tested as if a literal string, i.e. with the semi-colon delimiters present:
	$MyBoolean = ""emulate;mimic;simulate"".containsAnyOf(""emulate""); 
A more applied example:
	$MyBoolean = $MyList.containsAnyOf(wordsRelatedTo(""emulate"")); 
Will be true if the tested note's $MyList contains the word ""emulate"".
regexList implies using a list of values (ideally with no dupes). This can be a literal list of 1 or more values—as in the example above, or an attribute reference holding a list of values, for instance:
	$MyBoolean = $MyList.containsAnyOf($MySet); 
It is important to note that .containsAnyOf() is always a case-sensitive test. Thus in the first example above, it will match ""emulate"" but not ""Emulate"" or any other case variant of the word.
Although the examples above use whole words the list in regexList is actually processed assuming they are regular expressions (which may of course be literal strings). Thus in the first example above, it will match both ""emulate"" and ""emulated"" but not ""emulating"". The test value ""emulate\b"", expecting a word break after the final 'e' would this match ""emulate"" but not ""emulated"".
For a case-insensitive version if this operator see list.icontainsAnyOf().
Note the slightly different behaviour from that when chaining a String.","list.containsAnyOf(regexList)
演算子 .containsAnyOf(regexList) は、単語のセット (つまり、List 型または Set 型のリスト) 内のいずれかの単語が連鎖先のターゲット文字列に含まれている場合に true になります。以下に示すように、リストには多数のエントリが含まれる場合もあれば、1 つのエントリのみが含まれる場合もあります。テストでは大文字と小文字が区別されます (以前は大文字と小文字が区別されませんでした)。たとえば:
$MyBoolean = $MyList.containsAnyOf(""エミュレート"");
テストされたメモの $Text に「emulate」という単語が含まれている場合は true になります。.contains() や .icontains() とは異なり、部分的な値がターゲット リスト内で一致する可能性があります。$MyList が値「emulate」、「mimic」、および「simulate」を保持している場合、リストはリテラル文字列であるかのように、つまりセミコロン区切り文字が存在するかのようにテストされます。
$MyBoolean = ""エミュレート;模倣;シミュレート"".containsAnyOf(""エミュレート"");
より応用的な例:
$MyBoolean = $MyList.containsAnyOf(wordsManyTo(""emulate""));
テストされたノートの $MyList に「emulate」という単語が含まれている場合は true になります。
regexList は、値のリスト (理想的には重複のないもの) を使用することを意味します。これは、上記の例のように 1 つ以上の値のリテラル リストにすることも、値のリストを保持する属性参照にすることもできます。次に例を示します。
$MyBoolean = $MyList.containsAnyOf($MySet);
.containsAnyOf() は常に大文字と小文字を区別するテストであることに注意することが重要です。したがって、上記の最初の例では、「エミュレート」には一致しますが、「エミュレート」やその他の大文字と小文字が異なる単語には一致しません。
上記の例では単語全体が使用されていますが、regexList 内のリストは実際には正規表現 (もちろんリテラル文字列の場合もあります) であると想定して処理されます。したがって、上記の最初の例では、「エミュレート」と「エミュレートされた」の両方に一致しますが、「エミュレート」には一致しません。テスト値「emulate\b」は、最後の「e」の後に単語の区切りがあると予想されますが、これは「emulate」には一致しますが、「emulated」には一致しません。
この演算子の大文字と小文字を区別しないバージョンについては、list.icontainsAnyOf() を参照してください。
String をチェーンする場合とは動作が若干異なることに注意してください。"
"list.count_if(loopVar, condition)",Function,Group,Data manipulation,Number,false,9.5.0,Baseline,,,,,true,false,false,true,false,false,true,false,false,,false,"list.count_if(loopVar, condition)
The dot-operator .count_if() counts the members of a List- or Set-type list that satisfy a condition. Each item in the list is bound in turn to loopVar, and if condition is met, then that item is added to the returned count.
loopVar is essentially the same as the loop variable used by the List.each() operator. In the examples below, for clarity the loopVar value ""anItem"" is used, but as with any loop variable a shorter less expressive values such a ""x"" can be used (e.g. by more expert users).
The condition argument is a conditional expression for which each tested item must return true or false.
For example if $MyList is ""1;2;3;4;5"", then:
	$MyListA =- $MyList.count_if(anItem, anItem>3) 
returns 2, being the number of items in $MyList whose value is greater than 3. If $MyList is ""1;1;2;2;3;3;4;4;5;5"", then:
	$MyListA =- $MyList.count_if(anItem, anItem>3) 
returns 4, being the number of items in $MyList whose value is greater than 3 and values '4' and '5' each occur twice.
list.count_if() vs. .count_if()
Although the two appear similar. This operator works directly on the source list values, whereas count_if() creates a list of $Path values and returns on an attribute value from each of those paths (where the item at the $Path meets the condition).","list.count_if(ループ変数、条件)
ドット演算子 .count_if() は、条件を満たす List 型または Set 型のリストのメンバーをカウントします。リスト内の各項目は、loopVar に順番にバインドされ、条件が満たされると、その項目が返されたカウントに追加されます。
loopVar は、List.each() 演算子で使用されるループ変数と本質的に同じです。以下の例では、わかりやすくするために、loopVar 値「anItem」が使用されていますが、他のループ変数と同様に、「x」などのより短く表現力の低い値も使用できます (たとえば、より専門的なユーザーによって)。
条件引数は、テストされた各項目が true または false を返す必要がある条件式です。
たとえば、$MyList が ""1;2;3;4;5"" の場合、次のようになります。
$MyListA =- $MyList.count_if(anItem, anItem>3)
$MyList 内の値が 3 より大きい項目の数である 2 を返します。$MyList が ""1;1;2;2;3;3;4;4;5;5"" の場合、次のようになります。
$MyListA =- $MyList.count_if(anItem, anItem>3)
$MyList 内の値が 3 より大きい項目の数である 4 を返します。値 '4' と '5' はそれぞれ 2 回出現します。
list.count_if() と .count_if()
両者は似ているように見えますが。この演算子はソース リストの値に直接作用しますが、count_if() は $Path 値のリストを作成し、それらの各パスからの属性値 ($Path の項目が条件を満たす場合) を返します。"
list.count(),Property,List,Data manipulation,Number,false,7.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.count()
list.count
The property .count counts the Number of discrete items in the specified List- or Set-type list.
This is better used instead of count(list) or list.size.
The subject list is evaluated so can use a literal list or $attribute(note). It can also use more complex expressions to get data as long as the result is an attribute of the List or Set data type.
For example if $DisplayedAttributes for the current note is ""Color;AccentColor;NameFont"" then the code
	$MyNumber = $DisplayedAttributes.count; 
is effectively
	$MyNumber = (""Color;AccentColor;NameFont"").count; 
and not surprisingly returns 3. Note that the count is not all unique values for the attribute across the whole TBX; scope is restricted to 'this' note or another nominated note. Specimen usage:
	$MyNumber = $DisplayedAttributes.count; 
	$MyNumber = $DisplayedAttributes(""some other note"").count; 
To use .count with a list of items that are attributes or expressions, use list() to pre-create a list:
	Works: $MyNumber = list(4+2,9+6).count; (output: 2)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Examples
The following is a trivial example (given you could use $ChildCount instead) but shows how count can be used in a more subtle way:
	$MyNumber = collect(children,$Name).count; 
The result of collect() is a List, in this case a number of note titles. List.count will return the number of values in the list (including duplicates). To get a de-duped count, chain the .unique function before the .count:
	$MyNumber = collect(children,$Name).unique.count; 
Similarly, find() returns a List but note that find() does not de-dupe for aliases. Thus test $IsAlias in the query to weed alias results from the returned list:
	$MyNumber = find($Prototype==""pProject""&$IsAlias==false&$ChildCount>1).count;","list.count()
リストカウント
プロパティ .count は、指定されたリスト型リストまたはセット型リスト内の個別の項目の数をカウントします。
これは、count(list) や list.size の代わりに使用することをお勧めします。
件名リストが評価されるため、リテラル リストまたは $attribute(note) を使用できます。結果が List または Set データ型の属性である限り、より複雑な式を使用してデータを取得することもできます。
たとえば、現在のノートの $DisplayedAttributes が「Color;AccentColor;NameFont」の場合、コードは次のようになります。
$MyNumber = $DisplayedAttributes.count;
効果的には
$MyNumber = (""カラー;アクセントカラー;名前フォント"").count;
当然のことながら、3 が返されます。カウントは、TBX 全体にわたる属性のすべての一意の値ではないことに注意してください。範囲は「この」ノートまたは指定された別のノートに制限されます。検体の使用:
$MyNumber = $DisplayedAttributes.count;
$MyNumber = $DisplayedAttributes(""他のメモ"").count;
属性または式である項目のリストで .count を使用するには、 list() を使用してリストを事前に作成します。
動作: $MyNumber = list(4+2,9+6).count;(出力:2)
リスト項目がアクション コード式であるより複雑な例では、 eval() を使用して各リスト項目式をラップする必要がある場合があります。list(eval(式A),eval(式B))。
例
以下は簡単な例 (代わりに $ChildCount を使用できることを前提としています) ですが、より巧妙な方法で count を使用する方法を示しています。
$MyNumber =collect(children,$Name).count;
collect() の結果はリストであり、この場合はメモのタイトルの数です。List.count は、リスト内の値の数 (重複を含む) を返します。重複排除されたカウントを取得するには、.count の前に .unique 関数を連鎖させます。
$MyNumber =collect(children,$Name).unique.count;
同様に、find() は List を返しますが、find() はエイリアスの重複を除外しないことに注意してください。したがって、クエリで $IsAlias をテストして、返されたリストからエイリアスの結果を取り除きます。
$MyNumber = find($Prototype==""pProject""&$IsAlias==false&$ChildCount>1).count;"
list.countOccurrencesOf(literalStr),Function,List,Data manipulation,Number,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.countOccurrencesOf(literalStr)
This function returns the Number of times that the literal string literalStr appears in the source List- or Set-type list. A string of the attribute's raw concatenated list values (i.e. with semicolon delimiters) is tested.
If $MyList contains ""ant;bee;ant;cow;ant"", then:
	$MyNumber = $MyList.countOccurrencesOf(""ant""); returns 3
Sets de-duplicate, but partial matches of Sets do not. If $MySet contains ""cat;cut;hat;hit;hut;pat;sat"", then
	$MyNumber = $MySet.countOccurrencesOf(""at""); returns 4
literalStr is literal and must not be a regular expression. If the latter is needed use list.contains() or list.icontains().","list.countOccurrencesOf(literalStr)
この関数は、リテラル文字列 literalStr がソースのリスト型リストまたはセット型リストに出現する回数を返します。属性の生の連結リスト値の文字列 (つまり、セミコロン区切り文字を含む) がテストされます。
$MyList に「ant;bee;ant;cow;ant」が含まれる場合、次のようになります。
$MyNumber = $MyList.countOccurrencesOf(""ant"");3を返します
セットは重複排除されますが、セットの部分一致は重複排除されません。$MySet に ""cat;cut;hat;hit;hut;pat;sat"" が含まれる場合、
$MyNumber = $MySet.countOccurrencesOf(""at"");4を返します
literalStr はリテラルであり、正規表現であってはなりません。後者が必要な場合は、list.contains() または list.icontains() を使用します。"
list.each(loopVar){actions},Function,Item,Data manipulation,iterator,false,5.10.0,Baseline,,,,1,true,true,false,true,false,false,false,false,false,,false,"list.each(loopVar){ action(s) }
This allows you to operate in turn on each item in a List- or Set-type list. Put another way you 'iterate;' or loop though, every item in the list evaluating any code inside the { } brackets. The user-defined (i..e. named by the user) loopVar can be used inside the loop to refer to the value of the current list item value being iterated. If the list is a list of path info (or $IDString, $ID, or unique $Name) then in-loop loopVar can be used for offset addressing the note at that path via an attribute offset argument, i.e. $SomeAttribute(loopVar).
What is a loop variable?
For example, for a note with a list of values in $MyList:
	$MyList.each(x){$Result=$Result +x+""\n"" ;} 
will replace the current note's value of $Result with a list of every value from $MyList, but each on its own line. The loopVar, here the in-loop variable 'x', is simply the string defined in .each(), and is case-sensitive and a '$' prefix is not required for in-loop references to the loop variable. For most Tinderbox users, a more readable/understandable version of the above is this:
	$MyList.each(aString){
		$Result=$Result +aString+""\n"" ;
	}
What has changed? Firstly, the loop has been broken out onto speaker lines and in-loop code indented. Tinderbox ignores line breaks and white space between operators and values so both the above seems the same to the parser. Secondly, the obfuscatory 'x' loopVar name has been changed to a more descriptive 'aString' based on the presumption that $Result is a String (it cannot be a Number because Number-type data cannot have line breaks within a single value) and, for the calling note, we are compiling a string the list $Result values. 
Thus .each(loopVar) would iterate using references to loopVar, and thus .each(Y) would iterate using references to 'Y', whilst .each(Abracadabra) would iterate using references to 'Abracadabra', and so forth. Consider making the loop variable something clear to both the user and to Tinderbox. In the trivial example above, 'x' seems pretty clear but might be misread by the users—in a mathematical context—as a multiplication symbol; Tinderbox will not be confused as it uses * for multiplication but consider how something like 'LoopVar' might be clearer. By the same token make sure the loop variable name does not clash with existing attribute names or attribute string values of the same name that might be used as part of the data being processed.
A variable declared using var() may be altered from within the scope of an .each() loop.
If $Total is a numeric attribute and $MyList is a list of numbers:
	$TotalNumber=0;
	$MyList.each(aNumber){
		$TotalNumber += aNumber*aNumber; // parentheses not required but can be useful if calculation is not simple
	} 
computes the sum of the squares of the values in $MyList and stored it in $TotalNumber. As the list is a list of numbers, the user-chosen loopVar name used is 'aNumber'.
Note: remember that you, the user, choose the actual name of loopVar in your own code. It can vary per use, as in the examples on this page.
The loopVar can be a path and this can be used as a variable designator for attribute offset addressing inside the loop:
	$Text="""";
	collect(children,$Path).each(aPath){ 
		$Text += ""\n""+$Text(aPath);
	}
In the above, a list is created on the fly of the current note's children. Then the current note's $Text is appended, for each child, with a line and the child's $Text. As the list is a list of paths, the user-chosen loopVar name used is 'aPath'. Thus for each iteration of the loop aPath's value is being used to provide the offset address in the loop to $Text(loopVar).
If it is desired to iterate a list a particular number of times, another approach to the above is to use the range '...' operator which can be used to provide a numbered loop variable (see).
After each iteration of an each(){} loop, accumulated back-references are cleared. Formerly, back-references from each iteration were retained for the lifetime of the loop, making it very difficult to retrieve the desired reference.
To test for position in a loop, i.e. detecting if processing the first or last items, see list.first() and list.last().
To get a random item from a list without needing to use a loop, see list.randomItem().
A worked example of looping is here.
Examples of using action() within a loop to create attribute references is given here.","list.each(loopVar){ アクション }
これにより、リスト型またはセット型のリスト内の各項目を順番に操作できます。別の言い方をすると、「反復」します。ただし、ループでは、リスト内のすべての項目が { } 括弧内のコードを評価します。ユーザー定義 (つまり、ユーザーが名前を付けた) ループ変数をループ内で使用して、反復されている現在のリスト項目値の値を参照できます。リストがパス情報 (または $IDString、$ID、または一意の $Name) のリストである場合、ループ内ループ Var を使用して、属性オフセット引数 (つまり、$SomeAttribute(loopVar)) を介してそのパスにあるメモをアドレス指定するオフセットに使用できます。
ループ変数とは何ですか?
たとえば、$MyList に値のリストが含まれるメモの場合:
$MyList.each(x){$Result=$Result +x+""\n"" ;}
現在のメモの $Result の値を $MyList のすべての値のリストに置き換えますが、それぞれが別の行に表示されます。ここでは、loopVar (ループ内変数 'x') は .each() で定義された単なる文字列であり、大文字と小文字が区別され、ループ変数へのループ内参照には '$' プレフィックスは必要ありません。ほとんどの Tinderbox ユーザーにとって、上記のより読みやすく理解しやすいバージョンは次のとおりです。
$MyList.each(aString){
$Result=$Result +aString+""\n"" ;
}
何が変わったのでしょうか？まず、ループがスピーカー回線に分割され、ループ内コードがインデントされています。Tinderbox は演算子と値の間の改行と空白を無視するため、パーサーには上記の両方が同じように見えます。次に、難読な 'x' ループ変数名が、$Result が文字列であるという前提に基づいて、より説明的な 'aString' に変更されました (数値型のデータは単一の値内に改行を含めることができないため、数値にすることはできません)。また、呼び出し元のメモとして、$Result 値のリストの文字列をコンパイルしています。
したがって、.each(loopVar) は、loopVar への参照を使用して反復し、したがって、.each(Y) は、「Y」への参照を使用して反復し、.each(Abracadabra) は、「Abracadabra」への参照を使用して反復します。ループ変数をユーザーと Tinderbox の両方にとって明確なものにすることを検討してください。上の簡単な例では、「x」は非常に明確に見えますが、数学的な文脈において、乗算記号としてユーザーに誤って読み取られる可能性があります。Tinderbox は乗算に * を使用するため混乱することはありませんが、「LoopVar」のようなものの方が明確であることを考慮してください。同様に、ループ変数名が、処理されるデータの一部として使用される可能性のある既存の属性名または同じ名前の属性文字列値と衝突しないことを確認してください。
var() を使用して宣言された変数は、.each() ループのスコープ内から変更できます。
$Total が数値属性で、$MyList が数値のリストの場合:
$TotalNumber=0;
$MyList.each(aNumber){
$TotalNumber += aNumber*aNumber;// 括弧は必須ではありませんが、計算が単純でない場合に便利です
}
$MyList 内の値の二乗和を計算し、$TotalNumber に保存します。リストは数値のリストであるため、使用されるユーザーが選択したloopVar名は「aNumber」です。
注: ユーザーであるあなたが、独自のコード内で、loopVar の実際の名前を選択することに注意してください。このページの例のように、用途によって異なる場合があります。
loopVar はパスにすることができ、これをループ内の属性オフセット アドレス指定の変数指定子として使用できます。
$Text="""";
collect(children,$Path).each(aPath){
$Text += ""\n""+$Text(aPath);
}
上記では、現在のノートの子のリストがその場で作成されます。次に、現在のノートの $Text に、子ごとに行と子の $Text が追加されます。リストはパスのリストであるため、使用されるユーザーが選択したloopVar名は「aPath」です。したがって、ループの反復ごとに、aPath の値を使用して、ループ内のオフセット アドレスが $Text(loopVar) に提供されます。
リストを特定の回数だけ反復する必要がある場合、上記に対する別のアプローチは、番号付きループ変数を提供するために使用できる範囲 '...' 演算子を使用することです (参照)。
each(){} ループの各反復の後、蓄積された後方参照はクリアされます。以前は、各反復からの逆参照はループの存続期間中保持されていたため、目的の参照を取得することが非常に困難でした。
ループ内の位置をテストするには、つまり最初の項目を処理するか最後の項目を処理するかを検出するには、list.first() と list.last() を参照してください。
ループを使用せずにリストからランダムな項目を取得するには、list.randomItem() を参照してください。
ループの実際の例はここにあります。
ここでは、ループ内で action() を使用して属性参照を作成する例を示します。"
list.empty(),Property,Item,Non-query Boolean,boolean test,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.empty()
list.empty
This returns a Boolean depending on whether the List- or Set-type list is empty. If empty, the return value is true, if the attribute has content then false is returned.
	$MyList = [hello;world]; $MyBoolean = $MyList.empty; 
$MyBoolean is set to false as content is found. But
	$MyList = []; $MyBoolean = $MyList.empty; 
$MyBoolean is set to true as no content is found.","list.empty()
リスト.空
これは、List タイプまたは Set タイプのリストが空かどうかに応じてブール値を返します。空の場合、戻り値は true であり、属性にコンテンツがある場合は false が返されます。
$MyList = [hello;world];$MyBoolean = $MyList.empty;
コンテンツが見つかると、$MyBoolean が false に設定されます。しかし、
$MyList = [];$MyBoolean = $MyList.empty;
コンテンツが見つからないため、$MyBoolean は true に設定されます。"
"list.every(loopVar, expressionStr)",Function,List,Query Boolean,boolean test,false,8.1.0,Baseline,,,,2,true,true,false,true,false,false,false,false,false,,false,"list.every(loopVar, expressionStr)
This is true if every loopVar in the List- or Set-type list meets the query in expressionStr. Thus:
	$MyList.every(x,x>5) 
is true if every loopVar in $MyList is greater than 5.
The comparison may also be applied to literal lists:
	""apple; pear; plum"".every(x, x>""aardvark"") 
is true because every element follows ""aardvark"" in alphabetical (lexical sort) order.
If the target list or set is empty, .any() always returns false, and .every() always returns true.
The loopVar is a user-set case-sensitive string. ""x"", ""anItem"", etc., are equally applicable. Similar to a loop variable in .each(x){}, the point of the loopVar value, is to set a reference variable for each list element. This can then be used in the code provided by the expressionStr argument. Using a number for loopVar, e.g. '1' or '42' is not recommended. Choose a value that makes sense for your own style of work  
The expressionStr is any action code expression that is a test resolving to a Boolean true/false answer (i.e. a query). For example, to test if every item exactly matches the value stored in the $MyString of 'Some note':
	$MyBoolean = $MyList.every(anItem, anItem == $MyString(""Some Note"")); 
Or, every list value starts with the string 'Large':
	$MyBoolean = $MyList.every(Z, Z.contains(""^Large""));","list.every(loopVar、expressionStr)
これは、List 型リストまたは Set 型リスト内のすべてのloopVar がexpressionStr 内のクエリを満たす場合に当てはまります。したがって:
$MyList.every(x,x>5)
$MyList 内のすべてのloopVar が 5 より大きい場合は true です。
比較はリテラル リストにも適用できます。
""リンゴ; ナシ; プラム"".every(x, x>""ツチブタ"")
すべての要素がアルファベット順 (語彙ソート) で「ツチブタ」の後に続くため、これは true です。
ターゲットのリストまたはセットが空の場合、.any() は常に false を返し、.every() は常に true を返します。
LoopVar は、ユーザーが設定した大文字と小文字を区別する文字列です。「x」、「anItem」なども同様に適用できます。.each(x){} のループ変数と同様に、loopVar 値のポイントは、リスト要素ごとに参照変数を設定することです。これは、expressionStr 引数によって提供されるコードで使用できます。たとえば、loopVar に数値を使用します。「1」または「42」は推奨されません。自分の作業スタイルに適した値を選択してください
expressionStr は、ブール値の true/false 回答 (つまりクエリ) を解決するテストであるアクション コード式です。たとえば、すべての項目が「Some note」の $MyString に格納されている値と正確に一致するかどうかをテストするには、次のようにします。
$MyBoolean = $MyList.every(anItem, anItem == $MyString(""メモ""));
または、すべてのリスト値は文字列「Large」で始まります。
$MyBoolean = $MyList.every(Z, Z.contains(""^Large""));"
list.extend(aList),Function,List,Data manipulation,List,false,9.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.extend(aList)
for a List- or Set-type list, a nested list item is inserted as a new item at the end of the returned List. If passed back into a List, the order is maintained. If passed to a Set, the order of values may change.
The += increment operator, if passed a list as an argument, adds the arguments values to the existing list. By comparison, in the same scenario, list.extend() inserts the argument value as a nested list.
Long Tinderbox precedent holds that list addition adds each element of the two lists. For example
	$MyList = [1] + [2;3] 
resulst in the list 1;2;3 and not 1;[2;3]. So, to add a sublist to a list, use the list.extend() operator. Thus:
	$MyList = [1].extend( [2;3])  
results in the list [1;[2;3]].","list.extend(aList)
List タイプまたは Set タイプのリストの場合、ネストされたリスト項目は、返されたリストの最後に新しい項目として挿入されます。List に戻された場合、順序は維持されます。Set に渡される場合、値の順序が変更される可能性があります。
+= インクリメント演算子は、引数としてリストが渡された場合、引数の値を既存のリストに追加します。比較すると、同じシナリオで、 list.extend() は引数値をネストされたリストとして挿入します。
Tinderbox の長い前例では、リストの追加によって 2 つのリストの各要素が追加されると考えられています。たとえば
$MyList = [1] + [2;3]
結果はリスト 1;2;3 になり、1;[2;3] にはなりません。したがって、リストにサブリストを追加するには、list.extend() 演算子を使用します。したがって:
$MyList = [1].extend( [2;3])
結果はリスト [1;[2;3]] になります。"
list.first(),Property,List,"Dictionary, Set & List operations",source context dependent,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.first()
list.first
Returns the first item of a List- or Set-type list. If MyList is a 5-item list ""ant;bee;cow;dog;eel"":
	$MyString = $MyList.first; returns ""ant""
This is also the equivalent of $MyList[0] or $MyList.at(0).
list.first(N)
Returns a list of the first N items of a list. With the same list as above:
	$MyList2 = $MyList.first(2); returns ""ant;bee""
Testing for loop position
This operator can be used to test the current loop state, i.e. whether the currently processed item is the first in the list. Here the code in the commented section is run only when the first list item in $MyList is being processed:
	$MyList.each(anItem){
		if(anItem==$MyList.first){
			// some code here ...
		};
	};
Note that '$MyList.first' is not a test in itself. Rather, it supplies the value of the first list item which can be tested against the currently processed item.
See also list.last.","list.first()
リスト.最初
List 型または Set 型のリストの最初の項目を返します。MyList が「アリ、ミツバチ、ウシ、イヌ、ウナギ」の 5 項目リストの場合:
$MyString = $MyList.first;「アリ」を返します
これは、$MyList[0] または $MyList.at(0) と同等です。
list.first(N)
リストの最初の N 項目のリストを返します。上記と同じリストを使用すると、次のようになります。
$MyList2 = $MyList.first(2);「アリ;ハチ」を返します
ループ位置のテスト
この演算子は、現在のループ状態、つまり現在処理されている項目がリストの最初であるかどうかをテストするために使用できます。ここで、コメントされたセクションのコードは、$MyList の最初のリスト項目が処理されている場合にのみ実行されます。
$MyList.each(anItem){
if(anItem==$MyList.first){
// ここにいくつかのコード ...
};
};
「$MyList.first」自体はテストではないことに注意してください。むしろ、現在処理されている項目に対してテストできる最初のリスト項目の値を提供します。
list.last も参照してください。"
list.format(formatStr),Function,Item,Formatting,String,false,5.8.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.format(formatStr)
For a List- or Set-type list, returns the list as a String, with formatStr inserted between each discrete list element (so not after the last item. The process preserves original data; duplicate values in lists are maintained. For example:
	$MyString = $DisplayedAttributes.format("", ""); 
converts Displayed Attributes to a comma+space-separated list. To put each item on a separate line use this:
	$MyString = $DisplayedAttributes.format(""\n""); 
Doing the same for HTML export, you might want the rendered text to have each value on a new line so use: 
	$MyString = $DisplayedAttributes.format(""&lt;br>""); 
Thus $Text may be created from concatenation of other texts:
	$Text = (collect(children, $Text)).format(""\n""); 
Optionally, you may supply four arguments to format the list or set as an HTML list:
	$MyString = list.format(""listPrefix"",""itemPrefix"",""itemSuffix"",""listSuffix""); 
For example:
	$MyString = $Classes.format(""&lt;ul>"",""&lt;li>"",""&lt;/li>"",""&lt;/ul>""); 
will return HTML code for a bulleted list with each set member marked up as a list item. Note that the tags must be in double quotes. To have each element on a separate line and indent the items add tabs and line breaks:
	$MyString = $Classes.format(""&lt;ul>\n"",""\t&lt;li>"",""&lt;/li>\n"",""&lt;/ul>\n""); 
To make this easier to use in a code export context, you might pass the output of format into another attribute and call the latter within the template with a ^^value()^^ code. By a repeated use of format it is possible to export lists of links.
Other form of list-to-string join
In some data export contexts, tit may be necessary to add a join string while generating a string from an iterated list. See adding joins in loops.
Similar functions
This supplements the existing format() function.","list.format(formatStr)
List または Set タイプのリストの場合、リストを String として返します。formatStr は各個別のリスト要素の間に挿入されます (つまり、最後の項目の後ではありません。プロセスでは元のデータが保持され、リスト内の重複値は維持されます。例:
$MyString = $DisplayedAttributes.format("", "");
表示される属性をカンマ + スペース区切りのリストに変換します。各項目を別の行に配置するには、これを使用します。
$MyString = $DisplayedAttributes.format(""\n"");
HTML エクスポートでも同じことを行うと、レンダリングされたテキストの各値を新しい行に含めることができるため、次のように使用します。
$MyString = $DisplayedAttributes.format(""<br>"");
したがって、$Text は他のテキストの連結から作成できます。
$Text = (collect(children, $Text)).format(""\n"");
オプションで、リストをフォーマットするか、HTML リストとして設定する 4 つの引数を指定できます。
$MyString = list.format(""listPrefix"",""itemPrefix"",""itemSuffix"",""listSuffix"");
たとえば:
$MyString = $Classes.format(""<ul>"",""<li>"",""</li>"",""</ul>"");
は、各セットメンバーがリスト項目としてマークアップされた箇条書きリストの HTML コードを返します。タグは二重引用符で囲む必要があることに注意してください。各要素を個別の行に配置し、項目をインデントするには、タブと改行を追加します。
$MyString = $Classes.format(""<ul>\n"",""\t<li>"",""&lt;/li>\n"",""&lt;/ul>\n"");
コード エクスポート コンテキストでこれを使いやすくするには、format の出力を別の属性に渡し、テンプレート内で ^^value()^^ コードを使用して後者を呼び出すことができます。フォーマットを繰り返し使用することで、リンクのリストをエクスポートできます。
リストと文字列の結合の他の形式
一部のデータ エクスポート コンテキストでは、反復リストから文字列を生成するときに結合文字列を追加する必要がある場合があります。ループ内に結合を追加するを参照してください。
同様の機能
これは既存の format() 関数を補完します。"
list.icontains(matchStr),Function,Item,Query Boolean,boolean test,false,5.7.1,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"list.icontains(matchStr)
This operator tests whether the string matchStr matches a whole discrete value string within  the referenced List- or Set-type list. Unlike when used with a String, e.g. String.contains, there is no regex functionality. With lists the function behaves as if the chained list were being iterated and an equality (==) test was being run on each list item.
Matches are always case-insensitive, unlike list.contains() where the matches are always case-sensitive.
Used with a list (List or Set data types), .icontains() cannot match to granularity less than a single whole item in the chained list. Importantly, this differs from the operator's use with String data, e.g. String.icontains(), where regular expression matching is applied. If regex parsing is needed, e.g. to match a partial list value, coerce the list to a string and use to operator on that string—see below.
A match gives a numerical result which is the 1-based matched list position. That number coerces to the boolean result needed for use in queries: ) to false and 1 or more to true.
matchStr is one of:
* an action code expression (which includes just referencing a single attribute name')
* a quoted literal string (i.e. actual text). Important: do not omit the enclosing quotes. If omitted, Tinderbox will try to evaluate the string as an expression. Doing this may result in the expected result but this is actually a false positive. So, remember to enclose your literals in quotes.
N.B. Unlike with String-type attributes, regex cannot be used.
$MyList.icontains(matchStr)
The contains operator may also be used with both sets and lists, in which case it tests for set membership, i.e. matching to complete individual values rather than part of values. Thus:
	$MyList.icontains(""Tuesday"") 
	$MyList(parent).icontains(""Tuesday"") 
are both true if $MyList contains ""Monday;Tuesday;Friday"". A match can use an attribute value as the regexStr. Consider a single-value String-type attribute 'MyDay':
	$MyList.icontains($MyDay) 
is true if the value of $MyDay for a given note is any of ""Monday"", ""Tuesday or ""Friday"". Thus in an agent or find query, the regex varies by the source value in the currently-tested note.
The chained list may also be a literal list:
	""Saturday;Sunday"".icontains(""Sunday"") 
	""Saturday;Sunday"".icontains($MyDay) 
If the matchStr is found the function returns a number which is the 1-based matched list position. In the last example above the returned value will be 2, because 'Sunday' is the second item in the list. 
Testing a negative: ""does not contain""
Use a ! prefix to the query argument:
	!$MyList.icontains(""Tuesday"") 
Use of parentheses around the negated query term, can assist Tinderbox's parsing:
	(!$MyList.icontains(""Tuesday"")) 
Matching partial list values
As changing to list suppresses the normal string regex parsing, interposing the .asString() operator allows the list to be treats a a string so as to behave like a String.icontains() test. See the .asString() operator listing for more detail. This is a more elegant replacement for the old workaround of using List.format(""#"").icontains(""some match) as may be seen in some older code samples.","list.icontains(matchStr)
この演算子は、文字列 matchStr が、参照された List 型または Set 型のリスト内の離散値文字列全体と一致するかどうかをテストします。文字列で使用する場合とは異なります。String.contains には正規表現機能はありません。リストの場合、この関数は、連鎖リストが反復され、各リスト項目に対して等価 (==) テストが実行されているかのように動作します。
一致では常に大文字と小文字が区別される list.contains() とは異なり、一致では常に大文字と小文字が区別されます。
リスト (List データ型または Set データ型) で使用される .icontains() は、連鎖リスト内の 1 つの項目全体よりも小さい粒度に一致することはできません。重要なのは、これは演算子による文字列データの使用とは異なります。String.icontains()。正規表現一致が適用されます。正規表現解析が必要な場合、例:部分的なリスト値と一致させるには、リストを文字列に強制変換し、その文字列に対して to 演算子を使用します。以下を参照してください。
一致すると、1 から始まる一致リストの位置である数値結果が得られます。この数値は、クエリでの使用に必要なブール結果に強制的に変換されます: ) は false、1 以上は true です。
matchStr は次のいずれかです。
* アクション コード式 (単一の属性名の参照のみを含む)
* 引用符で囲まれたリテラル文字列 (つまり、実際のテキスト)。重要: 囲みの引用符を省略しないでください。省略した場合、Tinderbox は文字列を式として評価しようとします。これを実行すると期待どおりの結果が得られる可能性がありますが、これは実際には誤検知です。したがって、リテラルを引用符で囲むことを忘れないでください。
注：String 型の属性とは異なり、正規表現は使用できません。
$MyList.icontains(matchStr)
contains 演算子は、セットとリストの両方で使用することもできます。この場合、セットのメンバーシップをテストします。つまり、値の一部ではなく個々の値を完全に一致させるかどうかをテストします。したがって:
$MyList.icontains(""火曜日"")
$MyList(親).icontains(""火曜日"")
$MyList に「Monday; Tuesday; Friday」が含まれる場合、両方とも true になります。一致では属性値を regexStr として使用できます。単一値の文字列型属性「MyDay」について考えてみましょう。
$MyList.icontains($MyDay)
指定されたメモの $MyDay の値が「月曜日」、「火曜日」または「金曜日」のいずれかである場合は true です。したがって、エージェントまたは検索クエリでは、正規表現は現在テストされているメモのソース値によって異なります。
連鎖リストはリテラル リストである場合もあります。
""土曜日;日曜日"".icontains(""日曜日"")
""土曜日;日曜日"".icontains($MyDay)
matchStr が見つかった場合、関数は 1 から始まる一致リストの位置を示す数値を返します。上記の最後の例では、「Sunday」がリストの 2 番目の項目であるため、戻り値は 2 になります。
陰性のテスト:「含まれていない」
! を使用してください。クエリ引数の接頭辞:
!$MyList.icontains(""火曜日"")
否定されたクエリ用語を括弧で囲むと、Tinderbox の解析が容易になります。
(!$MyList.icontains(""火曜日""))
部分的なリスト値の一致
list に変更すると通常の文字列正規表現解析が抑制されるため、.asString() 演算子を挿入すると、リストを文字列として処理して String.icontains() テストのように動作できるようになります。詳細については、.asString() 演算子のリストを参照してください。これは、古いコード サンプルで見られるように、List.format(""#"").icontains(""some match) を使用する古い回避策をより洗練された代替策です。"
list.icontainsAnyOf(regexList),Function,Item,Query Boolean,boolean test,false,8.9.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"list.icontainsAnyOf(regexList)
The operator .icontainsAnyOf(regexList) is true if any of the words in a List- or Set-type list of words is contained in the chained-to target string. As shown below, the list may have only one entry. The test is case-insensitive. For example:
	$MyBoolean = $MyList.containsAnyOf(""emulate""); 
Will be true if the tested note's $Text contains the word ""emulate""; unlike with .contains() or .icontains() a partial value may be matched in the target list. If $MyList holds the values 'emulate', 'mimic' and 'simulate', the list is tested as if a literal string, i.e. with the semi-colon delimiters present:
	$MyBoolean = ""emulate;mimic;simulate"".icontainsAnyOf(""emulate""); 
A more applied example:
	$MyBoolean = $MyList.icontainsAnyOf(wordsRelatedTo(""emulate"")); 
Will be true if the tested note's $MyList contains the word ""emulate"".
regexList implies using a list of values (ideally with no dupes). This can be a literal list of 1 or more values—as in the example above, or an attribute reference holding a list of values, for instance:
	$MyBoolean = $MyList.containsAnyOf($MySet); 
It is important to note that .containsAnyOf() is always a case-insensitive test. Thus in the first example above, it will match both ""emulate"" and ""Emulate"" or any other case variant of the word.
Although the examples above use whole words the list in regexList is actually processed assuming they are regular expressions (which may of course be literal strings). Thus in the first example above, it will match both ""emulate"" and ""emulated"" but not ""emulating"". The test value ""emulate\b"", expecting a word break after the final 'e' would this match ""emulate"" but not ""emulated"".
For a case-sensitive version of this, see list.containsAnyOf().
Note the slightly different behaviour from that when chaining a String.","list.icontainsAnyOf(正規表現リスト)
演算子 .icontainsAnyOf(regexList) は、リスト型またはセット型の単語リスト内の単語のいずれかがチェーン先のターゲット文字列に含まれている場合に true になります。以下に示すように、リストにはエントリが 1 つだけ含まれる場合があります。テストでは大文字と小文字が区別されません。たとえば:
$MyBoolean = $MyList.containsAnyOf(""エミュレート"");
テストされたメモの $Text に「emulate」という単語が含まれている場合は true になります。.contains() や .icontains() とは異なり、部分的な値がターゲット リスト内で一致する可能性があります。$MyList が値「emulate」、「mimic」、および「simulate」を保持している場合、リストはリテラル文字列であるかのように、つまりセミコロン区切り文字が存在するかのようにテストされます。
$MyBoolean = ""エミュレート;模倣;シミュレート"".icontainsAnyOf(""エミュレート"");
より応用的な例:
$MyBoolean = $MyList.icontainsAnyOf(wordsManyTo(""エミュレート""));
テストされたノートの $MyList に「emulate」という単語が含まれている場合は true になります。
regexList は、値のリスト (理想的には重複のないもの) を使用することを意味します。これは、上記の例のように 1 つ以上の値のリテラル リストにすることも、値のリストを保持する属性参照にすることもできます。次に例を示します。
$MyBoolean = $MyList.containsAnyOf($MySet);
.containsAnyOf() は常に大文字と小文字を区別しないテストであることに注意することが重要です。したがって、上記の最初の例では、「emulate」と「Emulate」、または単語のその他の大文字と小文字の変形の両方に一致します。
上記の例では単語全体が使用されていますが、regexList 内のリストは実際には正規表現 (もちろんリテラル文字列の場合もあります) であると想定して処理されます。したがって、上記の最初の例では、「エミュレート」と「エミュレートされた」の両方に一致しますが、「エミュレート」には一致しません。テスト値「emulate\b」は、最後の「e」の後に単語の区切りがあると予想されますが、これは「emulate」には一致しますが、「emulated」には一致しません。
これの大文字と小文字を区別するバージョンについては、「list.containsAnyOf()」を参照してください。
String をチェーンする場合とは動作が若干異なることに注意してください。"
list.intersect(aSet),Function,List,Data manipulation,Set,false,5.10.2,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.intersect(aSet)
This calculates the intersection of two List- or Set-type lists, the chained list and the Set in the aSet argument. The .intersect() test is generally intended for use with Set-type data but will work with Lists, though the output result is always Set-type, even if then passed to be stored in a List:
	$MySet = $MySetA.intersect($MySetB); 
	$MySet = $MyList1.intersect($MyList2); 
The result is a Set of all items in both $MySetA and $MySetB, or in the second example in both $MyList1 and $MyList2. As the result is always a set, any source list items are de-duped in the output.
Non-intersect
No special code is needed to find items in one set but not the other:
	$MySetC = $MySetA - $MySetB; gives items only in $MySetA
	$MySetC = $MySetB - $MySetA; gives items only in $MySetB
Use with Lists
Subtracting a Set from a List results in only one instance of each Set item being removed. Subtracting a List from a List each instance of a value in the second list is removed so multiple source List entries may be removed.","list.intersect(aSet)
これは、2 つの List 型または Set 型のリスト、連鎖リストと aSet 引数の Set の共通部分を計算します。.intersect() テストは通常、Set 型のデータで使用することを目的としていますが、リストでも動作します。ただし、出力結果は、リストに格納するために渡された場合でも、常に Set 型になります。
$MySet = $MySetA.intersect($MySetB);
$MySet = $MyList1.intersect($MyList2);
結果は、$MySetA と $MySetB の両方のすべての項目のセット、または 2 番目の例では $MyList1 と $MyList2 の両方のセットになります。結果は常にセットであるため、ソース リスト項目は出力で重複排除されます。
非交差
一方のセット内の項目を検索し、もう一方のセット内の項目を検索しない場合に特別なコードは必要ありません。
$MySetC = $MySetA - $MySetB;$MySetA 内のアイテムのみを提供します
$MySetC = $MySetB - $MySetA;$MySetB 内のアイテムのみを提供します
リストで使用する
リストからセットを減算すると、各セット項目のインスタンスが 1 つだけ削除されます。リストからリストを減算すると、2 番目のリスト内の値の各インスタンスが削除されるため、複数のソース リスト エントリが削除される可能性があります。"
List.isort([attributeRef]),Function,Item,Data manipulation,List,false,5.0.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"List.isort([attributeRef])
List.isort()
For List-type list data, the basic form
	$MyList = $MyList.isort(); 
re-sorts the referenced list's values in lexical, case-insensitive order. This means sorting letters in alphabetical order ""a,b,c'"" with all upper case instances sorting after any lower case ones as in ""ant;Ant;bee;Bee;cow;Cow"". Lexical sort of numbers means '1,11,2' not 1,2,11' as might be expected.
Alternative sorts are a lexical case-sensitive List.sort(), and a numeric List.nsort() (the latter giving '1,2,11' not '1,11,2'). Or, if using $Name or $Path data, use the optional long from (below) and let the nominated attribute's data type set the form of sort, e.g. for date sorting, sort on a Date-type attribute.
The resulting sort order can be reversed overall by chaining the List.isort() and List.reverse() functions:
	$MyList = $MyList.isort().reverse(); 
List.sort(attributeRef)
Here the referenced List must be a list of note names or paths, i.e. a list of $Name data or $Path data (but not a mix of the two). If note names are not unique within the document, path values must be used to achieve correct sort. This is because the stipulated
The attributeRef argument is a $-prefixed attribute reference and indicates the attribute supplying the sorted value in each list item. As a result, this form of sort cannot be used with any other date type of list and cannot be applied to a literal list of values (as they have no attributes!), unlike the short un-argumented form above.
Thus, the sort order is based on the value of the stipulated attributeRef and that value is derived from the $Name or $Path of the list item being evaluated:	$MyList = $collect(children, $Name).isort($StartDate); 
	$MyList = $collect_if(find($Prototype==""pArticle""), $Fruit!="""",$Path).isort($Fruit); 
So, in the latter case, $MyList is a list of paths, but the paths are sorted in the order of each item's $Year value rather than the default $OutlineOrder of the source objects. Consider notes 'A', 'B', and 'C' in that existing on that $OutlineOrder. Without the sort, $MyList created above is the paths [/A;/B;/C]. If the notes' respective $Fruit values are ""Apple"",""apple"",""Pear"", then a $Year-based sort make the $MyList to be [/C;/A;/B] —whereas a normal .sort($Fruit) would result in [/A;/C;/B]. 
In this argument-based usage, the sort ordering is based on the data type of AttributeRef:
* Number-type: and Interval-type: numerical sort
* Date-type: sort on date (implied numerical)
* All other types lexical
But if attributeRef is Number-type, List.nsort() could be used instead.
With .isort() lexical sorts are always case-insensitive.
Legacy: Use of sorting with Set-type data
This operator does not apply to Set-type lists because, as from v9.0.0, Sets now auto-sort A–Z and cannot be (reliably) user-sorted to a different order. However, is passing the result to a List-type or to some other process—i.e. passing the sorted result, not the source Set—then sorted content is possible.","List.isort([属性参照])
List.isort()
List型リストデータの場合、基本形式
$MyList = $MyList.isort();
参照されたリストの値を、大文字と小文字を区別しない字句順に再ソートします。これは、「ant;Ant;bee;Bee;cow;Cow」のように、文字をアルファベット順「a、b、c'」にソートし、すべての大文字のインスタンスを小文字の後にソートすることを意味します。数字の語彙的な並べ替えは、予想されるとおり、「1,2,11」ではなく「1,11,2」を意味します。
代替ソートには、字句的に大文字と小文字を区別する List.sort() と数値 List.nsort() があります (後者は '1,11,2' ではなく '1,2,11' を返します)。または、$Name または $Path データを使用する場合は、オプションの long from (下記) を使用し、指定された属性のデータ型で並べ替えの形式を設定します。日付の並べ替えの場合は、Date タイプの属性に基づいて並べ替えます。
結果の並べ替え順序は、List.isort() 関数と List.reverse() 関数を連鎖させることで全体的に逆にすることができます。
$MyList = $MyList.isort().reverse();
List.sort(attributeRef)
ここで参照されるリストは、ノート名またはパスのリスト、つまり $Name データまたは $Path データのリスト (ただし、2 つの混合であってはなりません) でなければなりません。ドキュメント内でノート名が一意でない場合は、正しい並べ替えを行うためにパス値を使用する必要があります。と規定されているからである。
attributeRef 引数は、$ 接頭辞が付いた属性参照であり、各リスト項目の並べ替えられた値を提供する属性を示します。その結果、この形式の並べ替えは、上記の引数のない短い形式とは異なり、他の日付タイプのリストでは使用できず、値のリテラル リスト (属性がないため) にも適用できません。
したがって、並べ替え順序は規定されたattributeRefの値に基づき、その値は評価されるリスト項目の$Nameまたは$Pathから導出されます。 $MyList = $collect(children, $Name).isort($StartDate);
$MyList = $collect_if(find($Prototype==""pArticle""), $Fruit!="""",$Path).isort($Fruit);
したがって、後者の場合、$MyList はパスのリストですが、パスはソース オブジェクトのデフォルトの $OutlineOrder ではなく、各項目の $ Year 値の順序で並べ替えられます。その $OutlineOrder に存在するメモの「A」、「B」、「C」について考えてみましょう。ソートを行わない場合、上記で作成された $MyList はパス [/A;/B;/C] になります。メモのそれぞれの $Fruit 値が ""Apple""、""apple""、""Pear"" の場合、$year ベースの並べ替えでは $MyList は [/C;/A;/B] になりますが、通常の .sort($Fruit) の結果は [/A;/C;/B] になります。
この引数ベースの使用法では、並べ替え順序は AttributeRef のデータ型に基づきます。
* 数値型: および間隔型: 数値ソート
* 日付型: 日付でソート (暗黙の数値)
* 他のすべての型の語彙
ただし、attributeRef が Number 型の場合は、代わりに List.nsort() を使用できます。
.isort() を使用すると、字句ソートでは常に大文字と小文字が区別されません。
レガシー: Set タイプ データでの並べ替えの使用
v9.0.0 以降、Set は A ～ Z に自動ソートされ、ユーザーが別の順序に (確実に) ソートできないため、この演算子は Set タイプのリストには適用されません。ただし、結果をリスト型または他のプロセスに渡します。つまり、ソース Set ではなく、並べ替えられた結果を渡すと、並べ替えられたコンテンツが可能になります。"
list.last(),Property,List,"Dictionary, Set & List operations",source context dependent,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.last()
list.last
Returns the last item of a List- or Set-type list. If MyList is a 5-item list ""ant;bee;cow;dog;eel"":
	$MyString = $MyList.last; returns ""eel""
This is also the equivalent of $MyList[-1] or $MyList.at(-1).
list.last(N)
Returns a list of the last N items of a list. With the same list as above:
	$MyList2 = $MyList.last(2); returns ""dog;eel""
Testing for loop position
This operator can be used to test the current loop state, i.e. whether the currently processed item is the last in the list. Here the code in the commented section is run only when the last list item in $MyList is being processed:
	$MyList.each(anItem){
		if(anItem==$MyList.last){
			// some code here ...
		};
	};
Note that '$MyList.last' is not a test in itself. Rather, it supplies the value of the last list item which can be tested against the currently processed item.
See also list.first.","list.last()
リスト.最後
List または Set タイプのリストの最後の項目を返します。MyList が「アリ、ミツバチ、ウシ、イヌ、ウナギ」の 5 項目リストの場合:
$MyString = $MyList.last;「うなぎ」を返します
これは、$MyList[-1] または $MyList.at(-1) と同等です。
リスト.last(N)
リストの最後の N 項目のリストを返します。上記と同じリストを使用すると、次のようになります。
$MyList2 = $MyList.last(2);「犬; うなぎ」を返します
ループ位置のテスト
この演算子は、現在のループ状態、つまり現在処理されている項目がリストの最後であるかどうかをテストするために使用できます。ここで、コメントされたセクションのコードは、$MyList の最後のリスト項目が処理されている場合にのみ実行されます。
$MyList.each(anItem){
if(anItem==$MyList.last){
// ここにいくつかのコード ...
};
};
「$MyList.last」自体はテストではないことに注意してください。むしろ、現在処理されている項目に対してテストできる最後のリスト項目の値を提供します。
「list.first」も参照してください。"
list.lookup(keyStr),Function,List,"Dictionary, Set & List operations",source context dependent,false,8.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.lookup(keyStr)
The command .lookup() is intended for look-up tables (i.e. single dimension arrays) using a List- or Set-type list. For the key keyStr value is supplied, the matched key's value is return. We can set up an example listing, using a List-type attribute:
	$MyList = [ant:Wood ant;bee:Carder bee;cow:Jersey;dog:Labrador]; 
This creates a 4 item look-up list. The first list item has two parts - the key 'ant' and its paired value 'Wood ant'. Passing a key via .lookup, returns its key:
	$MyString = $MyList.lookup(""cow""); → ""Jersey"", as list item 3's key is matched.
If a key value with no match is passed, the result is an empty string
	$MyString = $MyList.lookup(""pig""); → """"
But if we add a 'default' key/value pair (anywhere in the list):
	$MyList = [ant:Wood ant;bee:Carder bee;cow:Jersey;dog:Labrador;default:animal]; 
and re-run the last example:
	$MyString = $MyList.lookup(""pig""); → ""animal""
There is still no match but as a default is defined, the default value of ""animal"" is returned.
More complex and nuanced use of .lookup() is described in the discussion of look-up tables.
Dictionary vs. Lookup
The newer Dictionary data-type offers a more efficient and feature rich way of working with lookup lists.
Legacy use (pre v8)
For look-up tables .lookup() is preferred to the older .at() for clarity, and to avoid ambiguity when the argument is numeric. Using the example list as above:
	$MyString = $MyList.at(3); → ""dog:Labrador"", the whole fourth element of the list (do not forget N is counted from zero).
	$MyString = $MyList.lookup(3) → ""animal"", the lookup result for key value 5 which doesn't exist, so we get the default.","list.lookup(keyStr)
コマンド .lookup() は、List 型または Set 型のリストを使用したルックアップ テーブル (つまり、1 次元配列) を対象としています。keyStr 値が指定されたキーの場合、一致したキーの値が返されます。List-type 属性を使用して、リストの例を設定できます。
$MyList = [アリ:キクアリ;蜂:カーダービー;牛:ジャージー;犬:ラブラドール];
これにより、4 項目のルックアップ リストが作成されます。最初のリスト項目には、キー 'ant' とそのペアの値 'Wood ant' の 2 つの部分があります。.lookup 経由でキーを渡すと、そのキーが返されます。
$MyString = $MyList.lookup(""牛"");→ リスト項目 3 のキーが一致するため、「ジャージ」。
一致しないキー値が渡された場合、結果は空の文字列になります。
$MyString = $MyList.lookup(""豚"");→「」
ただし、「デフォルト」のキーと値のペアを (リスト内の任意の場所に) 追加すると、次のようになります。
$MyList = [アリ:ウッドアリ;蜂:カーダービー;牛:ジャージー;犬:ラブラドール;デフォルト:動物];
そして最後の例を再実行します。
$MyString = $MyList.lookup(""豚"");→「動物」
まだ一致はありませんが、デフォルトが定義されているため、デフォルト値「animal」が返されます。
.lookup() のより複雑で微妙な使用方法については、ルックアップ テーブルの説明で説明します。
辞書と検索
新しい Dictionary データ型は、ルックアップ リストを操作するためのより効率的で機能豊富な方法を提供します。
レガシー使用 (v8 以前)
ルックアップ テーブルの場合、明確にするため、また引数が数値の場合のあいまいさを避けるために、古い .at() よりも .lookup() が優先されます。上記のリストの例を使用すると、次のようになります。
$MyString = $MyList.at(3);→ ""dog:Labrador""、リストの 4 番目の要素全体 (N がゼロから数えられることを忘れないでください)。
$MyString = $MyList.lookup(3) → ""animal""、キー値 5 の検索結果は存在しないため、デフォルトを取得します。"
list.max(),Property,List,Data manipulation,source context dependent,false,6.4.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.max()
list.max
The list.max() operator returns the largest item in a List- or Set-type list.
This is a replacement for/alternative to the max() operator.
Both the operators list.max() and list.min() use lexical comparison in most cases, but numeric comparison if the context is numeric (i.e. the reference is a Number-type attribute) and/or all list items are numbers. Thus:
	$Width=(""1;100;2"").max; 
Since ""Width"" is numeric, max() will be return 100. 
	$Name=(""1;100;2"").max; 
Since the attribute ""Name"" is a string, max() will return 2.
If without a list, create one on the fly:
	$MyMax = collect(all,$MyNumber).max; 
	$MyMax = collect(descendants,$Modified).max; 
This allows export via ^^value^^:
	^^value(collect(descendants,$Modified).max)^^ 
To use max() with a list of items that are attributes or expressions, use list():
	Works: $MyNumber = list(4+2,9+6).max; (output: 15)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Using lists of dates
When using Date-type data bear in mind that the defaults for an unset Date attribute is ""never"" and that ""never"" is treated as sorting always before (i.e. less than) any set date. So to use .min with dates, filter out the unset values, whereas with .max it is not needed:
	$MyMax = collect_if(descendants,$Modified).max; 
	$MyMin = collect_if(descendants,($Modified!=""never""),$Modified).min;","list.max()
list.max
list.max() 演算子は、List 型または Set 型のリスト内の最大の項目を返します。
これは、max() 演算子の代替/代替です。
演算子 list.max() と list.min() は両方とも、ほとんどの場合字句比較を使用しますが、コンテキストが数値 (つまり、参照が数値型属性である) の場合、および/またはすべてのリスト項目が数値の場合は数値比較を使用します。したがって:
$Width=(""1;100;2"").max;
「Width」は数値なので、max() は 100 を返します。
$Name=(""1;100;2"").max;
属性「Name」は文字列であるため、max() は 2 を返します。
リストがない場合は、その場でリストを作成します。
$MyMax = 収集(all,$MyNumber).max;
$MyMax = 収集(子孫,$Modified).max;
これにより、^^value^^ によるエクスポートが可能になります。
^^value(collect(descendants,$Modified).max)^^
属性または式である項目のリストで max() を使用するには、 list() を使用します。
動作: $MyNumber = list(4+2,9+6).max;(出力:15)
リスト項目がアクション コード式であるより複雑な例では、 eval() を使用して各リスト項目式をラップする必要がある場合があります。list(eval(式A),eval(式B))。
日付のリストの使用
日付型データを使用する場合、設定されていない日付属性のデフォルトは「なし」であり、「なし」は常に設定された日付よりも前 (つまり、日付よりも小さい) にソートされるものとして扱われることに注意してください。したがって、日付で .min を使用するには、未設定の値をフィルターで除外しますが、.max ではその必要はありません。
$MyMax =collect_if(descendants,$Modified).max;
$MyMin =collect_if(descendants,($Modified!=""never""),$Modified).min;"
list.min(),Property,List,Data manipulation,source context dependent,false,6.4.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.min()
list.min
The list.min() operator returns the smallest item in a List- or Set-type list.
This is a replacement for/alternative to the min() operator.
Both the operators list.min() and list.max() use lexical comparison in most cases, but numeric comparison if the context is numeric (i.e. the reference is a Number-type attribute) and/or all list items are numbers. Thus:
	$Width=(""100;2;70"").min; 
Since ""Width"" is numeric, min() will be return 2. 
	$Name=(""100;2;70"").min; 
Since the attribute ""Name"" is a string, .min will return 100.
If without a list, create one on the fly:
	$MyMin = collect_if(all,$MyNum>0,$MyNum).min; 
	$MyMin = collect(descendants,$Modified).min; 
This allows export via ^^value^^:
	^^value(collect(descendants,$Modified).min)^^ 
To use count() with a list of items that are attributes or expressions, use list():
	Works: $MyNumber = list(4+2,9+6).min; (output: 6)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Using lists of dates
When using Date-type data bear in mind that the defaults for an unset Date attribute is ""never"" and that ""never"" is treated as sorting always before (i.e. less than) any set date. So to use .min with dates, filter out the unset values, whereas with .max it is not needed:
	$MyMax = collect_if(descendants,$Modified).max; 
	$MyMin = collect_if(descendants,($Modified!=""never""),$Modified).min;","list.min()
list.min
list.min() 演算子は、List 型または Set 型のリスト内の最小の項目を返します。
これは、min() 演算子の代替/代替です。
演算子 list.min() と list.max() は両方とも、ほとんどの場合字句比較を使用しますが、コンテキストが数値 (つまり、参照が数値型属性である) の場合、および/またはすべてのリスト項目が数値の場合は数値比較を使用します。したがって:
$Width=(""100;2;70"").min;
「Width」は数値なので、min() は 2 を返します。
$Name=(""100;2;70"").分;
属性「Name」は文字列であるため、.min は 100 を返します。
リストがない場合は、その場でリストを作成します。
$MyMin =collect_if(all,$MyNum>0,$MyNum).min;
$MyMin = 収集(子孫,$Modified).min;
これにより、^^value^^ によるエクスポートが可能になります。
^^value(collect(descendants,$Modified).min)^^
属性または式である項目のリストで count() を使用するには、 list() を使用します。
動作: $MyNumber = list(4+2,9+6).min;(出力:6)
リスト項目がアクション コード式であるより複雑な例では、 eval() を使用して各リスト項目式をラップする必要がある場合があります。list(eval(式A),eval(式B))。
日付のリストの使用
日付型データを使用する場合、設定されていない日付属性のデフォルトは「なし」であり、「なし」は常に設定された日付よりも前 (つまり、日付よりも小さい) にソートされるものとして扱われることに注意してください。したがって、日付で .min を使用するには、未設定の値をフィルターで除外しますが、.max ではその必要はありません。
$MyMax =collect_if(descendants,$Modified).max;
$MyMin =collect_if(descendants,($Modified!=""never""),$Modified).min;"
List.nsort([attributeRef]),Function,Item,Data manipulation,List,false,5.8.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"List.nsort([attributeRefStr])
List.nsort()
For List-type list data, the basic form
	$MyList = $MyList.nsort(); 
	$MyList = $MyList.nsort().reverse(); 
re-sorts the referenced list's values in ascending numerical sort order. This means sorting '1,2,11' not 1,11,2' such as occurs with sort() and a lexical sort. A numerical sort is really only useful for numerical data. This implies:
* Numbers or Interval-type (but not Date-type data)
* Strings that begin with numbers
For most string (text) values and Date-type date, consider List.sort() or List.isort(), both of which give lexical sorts of differing case sensitivity. The resulting sort order can be reversed overall by chaining the List.nsort() and List.reverse() functions:
	$MyList = $MyList.nsort().reverse(); 
List.nsort(attributeRef)
Here the referenced list must be a list of note names or paths, i.e. list $Name data or $Path data (but not a mix of the two). If note names are not unique within the document, path values must be used to achieve correct sort. This form of sort cannot be used with any other sort of value list. This operator cannot be applied to any list of values, unlike the short form above.
In this form, the sort order can be based on the value of the stipulated attributeRef (a $-prefixed attribute name). The attribute's value is derived from the item identified by the $Name or $Path of the list item being evaluated:
	$MyList = $collect(children, $Name).nsort($PageNumber); 
	$MyList = $collect_if(find($Prototype==""pProduct""), $Price>0,$Path).nsort($Price); 
In this argument-based usage, .nsort() assumes the target attribute is Number-type. This the source list must comprise titles of paths but attributeRef must be a Number-type attribute.
Legacy: Use of sorting with Set-type data
This operator does not apply to Set-type lists because, as from v9.0.0, Sets now auto-sort A–Z and cannot be (reliably) user-sorted to a different order. However, is passing the result to a List-type or to some other process—i.e. passing the sorted result, not the source Set—then sorted content is possible.","List.nsort([attributeRefStr])
List.nsort()
List型リストデータの場合、基本形式
$MyList = $MyList.nsort();
$MyList = $MyList.nsort().reverse();
参照されたリストの値を数値の昇順で再ソートします。これは、sort() や字句ソートで発生するような 1,11,2' ではなく、'1,2,11' をソートすることを意味します。数値ソートは実際には数値データにのみ役立ちます。これは次のことを意味します:
* 数値または間隔型 (日付型のデータは除く)
* 数字で始まる文字列
ほとんどの文字列 (テキスト) 値と日付型の日付については、List.sort() または List.isort() を検討してください。どちらも、大文字と小文字の区別が異なる語彙の種類を提供します。結果の並べ替え順序は、List.nsort() 関数と List.reverse() 関数を連鎖させることで全体的に逆にすることができます。
$MyList = $MyList.nsort().reverse();
List.nsort(attributeRef)
ここで参照されるリストは、ノート名またはパスのリスト、つまり $Name データまたは $Path データのリスト (ただし、2 つの混合であってはなりません) である必要があります。ドキュメント内でノート名が一意でない場合は、正しい並べ替えを行うためにパス値を使用する必要があります。この形式の並べ替えは、他の種類の値リストと一緒に使用することはできません。上記の短い形式とは異なり、この演算子は値のリストには適用できません。
この形式では、並べ替え順序は、規定されたattributeRef ($で始まる属性名) の値に基づくことができます。属性の値は、評価されるリスト項目の $Name または $Path によって識別される項目から導出されます。
$MyList = $collect(children, $Name).nsort($PageNumber);
$MyList = $collect_if(find($Prototype==""pProduct""), $Price>0,$Path).nsort($Price);
この引数ベースの使用法では、.nsort() はターゲット属性が Number 型であると想定します。このソース リストはパスのタイトルで構成されている必要がありますが、attributeRef は Number タイプの属性である必要があります。
レガシー: Set タイプ データでの並べ替えの使用
v9.0.0 以降、Set は A ～ Z に自動ソートされ、ユーザーが別の順序に (確実に) ソートできないため、この演算子は Set タイプのリストには適用されません。ただし、結果をリスト型または他のプロセスに渡します。つまり、ソース Set ではなく、並べ替えられた結果を渡すと、並べ替えられたコンテンツが可能になります。"
list.randomItem(),Function,List,"Dictionary, Set & List operations",source context dependent,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.randomItem()
The .randomItem() returns a randomly-selected item from a List- or Set-type list:
	$MyString = $MyList.randomItem(); 
This replaces the extra coding needed for such a task if using rand().
This operator can be used not only on attributes but also literal lists using list():
	$MyString = list(""ant;bee;cow;dog"").randomItem(); 
list-based variables:
	var:list vList = ""ant;bee;cow;dog""; $MyString = vList.randomItem(); 
and list-creating operators:
	$MyString = collect(find($SomeAttribute==""xyz""),$Path).randomItem();","list.randomItem()
.randomItem() は、List 型または Set 型のリストからランダムに選択された項目を返します。
$MyString = $MyList.randomItem();
これにより、rand() を使用する場合にそのようなタスクに必要な追加のコーディングが置き換えられます。
この演算子は属性だけでなく、list() を使用してリテラル リストにも使用できます。
$MyString = list(""アリ;蜂;牛;犬"").randomItem();
リストベースの変数:
var:list vList = ""アリ;蜂;牛;犬"";$MyString = vList.randomItem();
およびリスト作成演算子:
$MyString =collect(find($SomeAttribute==""xyz""),$Path).randomItem();"
list.remove(matchValue),Function,List,Data manipulation,source context dependent,false,8.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"list.remove(matchValue)
This removes items from a List- or Set-type list. The argument matchValue may be of the desired data type for matching. For example,
	$MyList = $MyList.remove(0); 
returns a new list from which all elements equal to zero have been removed, and
	$MyList = $MyList.remove(""cat""); 
returns a new list from which call elements equal to ""cat"" have been removed.
	$MyList = $MyList.remove(""cat; dog; badger""); 
removes ""cats"", ""dogs"", and ""badgers"".","list.remove(matchValue)
これにより、リストまたはセットタイプのリストから項目が削除されます。引数 matchValue は、照合に必要なデータ型にすることができます。たとえば、
$MyList = $MyList.remove(0);
ゼロに等しいすべての要素が削除された新しいリストを返します。
$MyList = $MyList.remove(""猫"");
「cat」に等しい呼び出し要素が削除された新しいリストを返します。
$MyList = $MyList.remove(""猫; 犬; アナグマ"");
「猫」、「犬」、「アナグマ」を削除します。"
"list.replace(regexMatchStr, replacementStr)",Function,Item,Data manipulation,source context dependent,false,5.7.0,Baseline,,,,2,true,true,false,false,true,false,false,false,false,,false,"list.replace(regexMatchStr, replacementStr)
This operator allows simple text transformations of List- or Set-type list data. The result remains a List or Set as per the list of references supplied. Unlike in contains() type operators, some regex are not supported for either argument; regex use is discussed in more detail below.
Very often, a replace output is passed back to the calling list value, updating the source:
	$MyList = $MyList.replace(""Eggs"",""Ham); 
note how the output of the .replace() operator has to explicitly be passed back to the source list to overwrite its data (if this is thew desired intent!).
regexMatchStr and replacement are one of:
* an action code expression (which includes just referencing a single attribute name')
* a quoted string, which may be either:
** a literal string (i.e. actual text)
** a regular expression (regexMatchStr only)
list.replace(regexMatchStr, replacementStr)
List and set type attributes can use replace, though the scope of replacement is more limited than with strings. With listings, the match with and replacement of can only be for a complete list value and not part of a value.
A Replace action does not alter the original source
Using .replace() does not affect the source string unless the replacement output is used to overwrite the original source value. Thus if $MyString holds ""Hello World"" then:
	$MyStringA = $MyString.replace("" World""); 
$MyString remains ""Hello Word"" and $MyStringA has value ""Hello"". The source is unchanged. But, if we set the source to the output
	$MyString = $MyString.replace("" World""); 
Now $MyString becomes ""Hello"" and the original value is lost (overwritten by the new one.
Using regex (regular expressions)
Most basic regex expressions should work but string start (^^) and string end ($) matches work in an unexpected way. When .replace() is run it looks at the internal string value of the Set or List. 
Thus a list of values, like ant/bee/cow/dog/eel, is stored and matched as a single semi-colon delimited string ""ant;bee;cow;dog;eel"". Note Tinderbox does not create a final semi-colon after the last value, but will not complain if the user adds one, e.g. via manual input. Thus a ^^ regex matches only before the 'a' of 'ant' and not the start of other list values. Similarly, $ matches after the 'g' of dog and not the end of other list values. It might be thought of as '^^ant;bee;cow;dog;eel$' as opposed to '^^ant$;^^bee$;^^cow$;^^dog$;^^eel$'. 
So, in-list value boundaries still exist for regex matching but only as literal semicolons. Thus to change 'ee' to 'eet' in the above list but only for 'bee' and not 'eel':
	$MyListA = $MyList.replace(""ee;"",""eet;"").replace(""ee$"",""eet""); 
Note how two chained .replace() calls are needed, not one. The first is for inter-value boundaries and the second for the overall string end (had the data had a closing semi-colon the first match catches it so that scenario's still covered. To reverse the scenario and match the 'ee' at the start of a value:
	$MyListA = $MyList.replace("";ee"",""ree;"").replace(""^^ee"",""ree""); 
That changes 'eel' to 'reel' but leaves 'bee' unaltered.
It is possible to write back to the same attribute:
	$MyList = $MyList.replace(""ee;"",""eet;"").replace(""ee$"",""eet""); 
but, the former is a good idea whilst developing/testing code for this technique, only switching out latter once sure of the result.
Regex and Back-references
Regex can be used to set back-references in the regexMatchStr input string, as in an agent query, that can then be used in the replacementStr string. This is described in more detail here.
Trimming leading/trailing whitespace
	$MyList = $MyList.replace(""^ +"","""").replace("" +$"","""").replace("" *; *"","";""); 
The ' +' means one or more space characters. The first replace finds such a sub-string immediately following the start of the whole string ^), whilst the second does the same for a sub-string immediately before the end of the string ($). The third replace finds zero or more space characters either side of a semi-colon (the per-item list delimiter). The latter also matches a normal ';' delimiter but the test save writing separate regexs for space before and after the delimiter (e.g. "" +;"" and ""; +"") so the zero-or-more test (*) is used here instead of the one-or-more (+) used for the start/end of the overall string. Thus, using the code above, a lists like these with items having undesired leading/trailing space:
	"" ant ; bee ; cow ; dog "" 
	"" ant ;bee ;cow ; dog"" 
…both become…
	""ant;bee;cow;dog"" 
Dealing with inline quote characters
Because regexMatchStr is parsed for regular expressions, it may be possible to use the '\dnn' form described here to work around the lack of escaping from single double quotes within strings.","list.replace(regexMatchStr, replaceStr)
この演算子を使用すると、List 型または Set 型のリスト データの単純なテキスト変換が可能になります。結果は、提供された参照のリストに従ってリストまたはセットのままになります。contains() 型の演算子とは異なり、一部の正規表現はどちらの引数でもサポートされていません。正規表現の使用については、以下で詳しく説明します。
多くの場合、置換出力は呼び出しリストの値に戻され、ソースが更新されます。
$MyList = $MyList.replace(""卵"",""ハム);
データを上書きするには、 .replace() 演算子の出力を明示的にソース リストに戻す必要があることに注意してください (これが望ましい場合)。
regexMatchStr と置換は次のいずれかです。
* アクション コード式 (単一の属性名の参照のみを含む)
* 引用符で囲まれた文字列。次のいずれかになります。
** リテラル文字列 (つまり、実際のテキスト)
** 正規表現 (regexMatchStr のみ)
list.replace(regexMatchStr, replaceStr)
リスト型およびセット型の属性では replace を使用できますが、置換の範囲は文字列の場合よりも制限されます。リストの場合、 との一致と置換はリスト値全体に対してのみ可能であり、値の一部に対して行うことはできません。
置換アクションは元のソースを変更しません
.replace() を使用しても、置換出力を使用して元のソース値を上書きしない限り、ソース文字列には影響しません。したがって、$MyString が「Hello World」を保持している場合、次のようになります。
$MyStringA = $MyString.replace("" 世界"");
$MyString は「Hello Word」のままで、$MyStringA の値は「Hello」になります。ソースは変更されていません。ただし、ソースを出力に設定すると、
$MyString = $MyString.replace("" 世界"");
ここで、$MyString は ""Hello"" になり、元の値は失われます (新しい値によって上書きされます)。
regex (正規表現) の使用
ほとんどの基本的な正規表現は機能するはずですが、文字列の開始 (^^) と文字列の終了 ($) の一致は予期しない方法で機能します。.replace() が実行されると、Set または List の内部文字列値が調べられます。
したがって、ant/bee/cow/dog/eel のような値のリストは、セミコロンで区切られた単一の文字列「ant;bee;cow;dog;eel」として保存され、照合されます。注: Tinderbox は最後の値の後に最後のセミコロンを作成しませんが、ユーザーがセミコロンを追加しても文句を言いません。手動入力経由。したがって、^^ 正規表現は、「ant」の「a」の前にのみ一致し、他のリスト値の先頭には一致しません。同様に、$ は、他のリスト値の末尾ではなく、dog の「g」の後に一致します。これは、「^^ant$;^^bee$;^^cow$;^^dog$;^^eel$」ではなく、「^^ant;bee;cow;dog;eel$」と考えることができます。
したがって、リスト内の値の境界は、正規表現の一致では依然として存在しますが、リテラルのセミコロンとしてのみ存在します。したがって、上記のリストの「ee」を「eet」に変更しますが、「bee」のみを対象とし、「eel」は対象外です。
$MyListA = $MyList.replace(""ee;"",""eet;"").replace(""ee$"",""eet"");
1 つではなく 2 つの連鎖した .replace() 呼び出しが必要であることに注意してください。1 つ目は値間の境界用で、2 つ目は文字列全体の終わり用です (データに終了セミコロンがあった場合、最初の一致でそれがキャッチされるため、そのシナリオは引き続きカバーされます。シナリオを逆にして、値の先頭の 'ee' と一致させるには、次のようにします。
$MyListA = $MyList.replace("";ee"",""ree;"").replace(""^^ee"",""ree"");
これにより、「eel」が「reel」に変更されますが、「bee」は変更されません。
同じ属性に書き戻すことができます。
$MyList = $MyList.replace(""ee;"",""eet;"").replace(""ee$"",""eet"");
ただし、この手法のコードを開発/テストする際には前者を選択し、結果が確実になった場合にのみ後者を切り替えることをお勧めします。
正規表現と後方参照
正規表現を使用すると、エージェント クエリの場合と同様に、regexMatchStr 入力文字列に後方参照を設定でき、その後、replacementStr 文字列で使用できます。これについては、ここで詳しく説明します。
先頭/末尾の空白のトリミング
$MyList = $MyList.replace(""^ +"","""").replace("" +$"","""").replace("" *; *"","";"");
「+」は 1 つ以上のスペース文字を意味します。最初の置換では、文字列全体の先頭 ^) の直後にある部分文字列が検索されますが、2 番目の置換では、文字列 ($) の終わりの直前の部分文字列に対して同じことが行われます。3 番目の置換では、セミコロン (項目ごとのリスト区切り文字) の両側にある 0 個以上のスペース文字が検索されます。後者は通常の「;」にも一致します。ただし、テストでは区切り文字の前後のスペースに個別の正規表現を記述する必要がなくなるため (例: "" +;"" と ""; +"")、ここでは文字列全体の開始/終了に使用される 1 つ以上の (+) の代わりに、0 個以上のテスト (*) が使用されます。したがって、上記のコードを使用すると、先頭/末尾に不要なスペースがある項目を含む次のようなリストが作成されます。
「アリ、蜂、牛、犬」
「アリ、蜂、牛、犬」
…両方ともなる…
「アリ、蜂、牛、犬」
インライン引用符の扱い
regexMatchStr は正規表現として解析されるため、ここで説明する「\dnn」形式を使用して、文字列内の単一二重引用符からエスケープできない問題を回避できる可能性があります。"
list.reverse(),Function,Item,Data manipulation,List,false,5.8.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.reverse()
list.reverse
This function reverses the order of the referenced List-type list. The function does not reverse the individual list values, but rather reverses the exact order of the individual values. Trailing parentheses are optional for this function.
	$MyList = $MyList.reverse(); 
	$MyList = [ant;bee;cow].reverse(); 
The function may be chained with the list.sort() and list.isort() functions, noting that sorting can only be used with List-type and not Set-type data:
	$MyList = $MyList.sort().reverse(); 
	$MyList = $MyList.isort().reverse(); 
Reversing Set-type lists
As set-type lists are auto-sorted, this operator only makes sense to use when passing to that function/operator/type other that set data.","list.reverse()
リスト.リバース
この関数は、参照される List 型リストの順序を反転します。この関数は、個々のリスト値を逆にするのではなく、個々の値の正確な順序を逆にします。この関数の末尾の括弧はオプションです。
$MyList = $MyList.reverse();
$MyList = [アリ;蜂;牛].reverse();
この関数は list.sort() および list.isort() 関数と連鎖することができます。並べ替えは List 型のデータでのみ使用でき、Set 型のデータでは使用できないことに注意してください。
$MyList = $MyList.sort().reverse();
$MyList = $MyList.isort().reverse();
セットタイプのリストを反転する
セット型リストは自動ソートされるため、この演算子は、データを設定する他の関数/演算子/型に渡す場合にのみ使用するのが意味があります。"
list.select(),Function,Group,Data manipulation,source context dependent,false,9.6.0,Baseline,,,,1,true,true,false,false,false,true,false,false,false,,false,"list.select()
The list.select() operator allows the document's current (UI) focus to be shifted, to use the item(s)m defined in a List- or Set-type list. The list may be a literal string, or the value of an attribute or variable.
	[/Note A;/Note B].select(); 
	$MyList.select(); 
	vItems.select(); 
This specialist operator assist in the scenario where, whilst running action code, it is necessary to change the selection such that the locus of 'this' changes. Some action code operators only address the currently selected item(s). The select(scope) operator allows the selection to be changed on the fly without the user having to do so via the UI.
Because using select without arguments has a distinct and different function is it listed separately: select().","list.select()
list.select() 演算子を使用すると、ドキュメントの現在の (UI) フォーカスを移動して、List 型または Set 型のリストで定義された項目を使用できます。リストはリテラル文字列、または属性または変数の値である場合があります。
[/メモ A;/メモ B].select();
$MyList.select();
vItems.select();
この専門オペレーターは、アクション コードの実行中に、「this」の軌跡が変わるように選択を変更する必要があるシナリオを支援します。一部のアクション コード演算子は、現在選択されている項目のみを処理します。select(scope) 演算子を使用すると、ユーザーが UI を介して変更する必要がなく、オンザフライで選択内容を変更できます。
引数なしで select を使用すると、明確に異なる関数が使用されるため、select() として個別にリストされます。"
list.size(),Property,Item,Data manipulation,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.size()
list.size
This returns the Number of discrete values in a List- or Set-type list. The returned number can be coerced to a string. Trailing parentheses are optional for this property. Examples:
	$MyList = [hello;world]; $MyStringA = $MyList.size; 
$MyStringA is set to ""2"".
This property is the same evaluation as list.count or count(list).
This operator can also be used on other attribute data types that are string-like, URL, File, etc.","リスト.サイズ()
リストのサイズ
これは、List 型または Set 型のリスト内の離散値の数を返します。返された数値は文字列に強制的に変換できます。このプロパティの末尾の括弧はオプションです。例:
$MyList = [hello;world];$MyStringA = $MyList.size;
$MyStringA は「2」に設定されます。
このプロパティは list.count または count(list) と同じ評価になります。
この演算子は、文字列のような他の属性データ型、URL、ファイルなどにも使用できます。"
List.sort([attributeRef]),Function,Item,Data manipulation,List,false,5.8.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"List.sort([attributeRef])
List.sort()
The basic form
	$MyList = $MyList.sort(); 
This function re-sorts the referenced list's values in lexical, case-sensitive order. This means sorting all upper case letters before any lower case ones as in ""Ant;Bee;Cow;ant;bee;cow"". Users of non-accented languages (for the content of their notes) will likely find the case-insensitive List.isort() of more practical use.
A forced numerical sort (1,2,11 not 1,11,2) can be achieved by using List.nsort(). Or, if using $Name or $Path data, use the optional long from (below) and let the nominated attribute's data type set the form of sort, e.g. for date sorting, sort on a Date-type attribute.
The resulting sort order can be reversed overall by chaining the List.sort() and List.reverse() functions:
	$MyList = $MyList.sort().reverse(); 
Sets can be sorted, on the fly, so a sorted output can be passed to a List. Passing the sorted output of a Set to another Set has an unknown outcome, in terms of stored sort order.
List sorting can be used to process group designators. For example:
	$MyList=$Colors(children); 
finds a list of the colours of each child of the current note, and:
	$MyNumber=$Width(children).max;
will find the maximum width of the current container's children. When applied to the attribute $Text:
	$Text=$Text(children);
the texts of each child are appended, separated by paragraph breaks.
List.sort(attributeRef)
Here the referenced List must be a list of note names or paths, i.e. a list of $Name data or $Path data (but not a mix of the two). If note names are not unique within the document, path values must be used to achieve correct sort. This is because the stipulated
The attributeRef argument is a $-prefixed attribute reference and indicates the attribute supplying the sorted value in each list item. As a result, this form of sort cannot be used with any other date type of list and cannot be applied to a literal list of values (as they have no attributes!), unlike the short un-argumented form above.
Thus, the sort order is based on the value of the stipulated attributeRef and that value is derived from the $Name or $Path of the list item being evaluated:
	$MyList = collect(children, $Name).sort($StartDate); 
	$MyList = collect_if(find($Prototype==""pArticle""), $Year!="""",$Path).sort($Year); 
So, in the latter case, $MyList is a list of paths, but the paths are sorted in the order of each item's $Year value rather than the default $OutlineOrder of the source objects. Consider notes 'A', 'B', and 'C' in that existing on that $OutlineOrder. Without the sort, $MyList created above is the paths [/A;/B;/C]. If the notes' respective $Year values are ""1965"",""2010"",""1980"", then a $Year-based sort make the $MyList to be [/A;/C;/B] (i.e. by increasing year value). 
In this argument-based usage, the sort ordering is based on the data type of attributeRef:
* Number-type: and Interval-type: numerical sort
* Date-type: sort on date (implied numerical)
* All other types lexical
But if attributeRef is Number-type, List.nsort() could be used instead.
With .sort() lexical sorts are always case-insensitive.
Group designators are allowed in attribute references. For example:
	$MyList=$Colors(children); 
finds a list of the colours of each child of this note, and:
	$MyNumber=$Width(children).max; 
will find the maximum width of the container's children. When applied to the attribute $Text:
	$Text=$Text(children); 
the texts of each child are appended, separated by paragraph breaks.
Legacy: Use of sorting with Set-type data
This operator does not apply to Set-type lists because, as from v9.0.0, Sets now auto-sort A–Z and cannot be (reliably) user-sorted to a different order. However, is passing the result to a List-type or to some other process—i.e. passing the sorted result, not the source Set—then sorted content is possible.","List.sort([属性参照])
List.sort()
基本的な形
$MyList = $MyList.sort();
この関数は、参照されたリストの値を字句順、大文字と小文字を区別した順序で再ソートします。これは、「Ant;Bee;Cow;ant;bee;cow」のように、すべての大文字を小文字の前に並べ替えることを意味します。アクセントのない言語のユーザー (メモの内容に関して) は、大文字と小文字を区別しない List.isort() がより実用的であると思われるでしょう。
List.nsort() を使用すると、強制的な数値並べ替え (1,11,2 ではなく 1,2,11) を実行できます。または、$Name または $Path データを使用する場合は、オプションの long from (下記) を使用し、指定された属性のデータ型で並べ替えの形式を設定します。日付の並べ替えの場合は、Date タイプの属性に基づいて並べ替えます。
結果の並べ替え順序は、List.sort() 関数と List.reverse() 関数を連鎖させることで全体的に逆にすることができます。
$MyList = $MyList.sort().reverse();
セットはオンザフライで並べ替えることができるため、並べ替えられた出力をリストに渡すことができます。Set の並べ替えられた出力を別の Set に渡すと、格納された並べ替え順序の点で結果は不明です。
リストの並べ替えを使用して、グループ指定子を処理できます。たとえば:
$MyList=$Colors(子供);
現在のノートの各子の色のリストを検索し、次のようにします。
$MyNumber=$Width(children).max;
現在のコンテナの子の最大幅を見つけます。$Text 属性に適用すると、次のようになります。
$Text=$Text(子供);
各子のテキストが段落区切りで区切られて追加されます。
List.sort(attributeRef)
ここで参照されるリストは、ノート名またはパスのリスト、つまり $Name データまたは $Path データのリスト (ただし、2 つの混合であってはなりません) でなければなりません。ドキュメント内でノート名が一意でない場合は、正しい並べ替えを行うためにパス値を使用する必要があります。と規定されているからである。
attributeRef 引数は、$ 接頭辞が付いた属性参照であり、各リスト項目の並べ替えられた値を提供する属性を示します。その結果、この形式の並べ替えは、上記の引数のない短い形式とは異なり、他の日付タイプのリストでは使用できず、値のリテラル リスト (属性がないため) にも適用できません。
したがって、並べ替え順序は規定されたattributeRefの値に基づき、その値は評価されるリスト項目の$Nameまたは$Pathから導出されます。
$MyList =collect(children, $Name).sort($StartDate);
$MyList =collect_if(find($Prototype==""pArticle""), $year!="""",$Path).sort($year);
したがって、後者の場合、$MyList はパスのリストですが、パスはソース オブジェクトのデフォルトの $OutlineOrder ではなく、各項目の $ Year 値の順序で並べ替えられます。その $OutlineOrder に存在するメモの「A」、「B」、「C」について考えてみましょう。ソートを行わない場合、上記で作成された $MyList はパス [/A;/B;/C] になります。メモのそれぞれの $year 値が ""1965""、""2010""、""1980"" の場合、$year ベースの並べ替えにより、$MyList は [/A;/C;/B] になります (つまり、年の値が増加します)。
この引数ベースの使用法では、並べ替え順序はattributeRefのデータ型に基づきます。
* 数値型: および間隔型: 数値ソート
* 日付型: 日付でソート (暗黙の数値)
* 他のすべての型の語彙
ただし、attributeRef が Number 型の場合は、代わりに List.nsort() を使用できます。
.sort() を使用すると、字句ソートでは常に大文字と小文字が区別されません。
属性参照ではグループ指定子を使用できます。たとえば:
$MyList=$Colors(子供);
このメモの各子の色のリストを検索し、次のようにします。
$MyNumber=$Width(children).max;
コンテナの子の最大幅を見つけます。$Text 属性に適用すると、次のようになります。
$Text=$Text(子供);
各子のテキストが段落区切りで区切られて追加されます。
レガシー: Set タイプ データでの並べ替えの使用
v9.0.0 以降、Set は A ～ Z に自動ソートされ、ユーザーが別の順序に (確実に) ソートできないため、この演算子は Set タイプのリストには適用されません。ただし、結果をリスト型または他のプロセスに渡します。つまり、ソース Set ではなく、並べ替えられた結果を渡すと、並べ替えられたコンテンツが可能になります。"
"list.sum_if(loopVar, condition[, expressionStr])",Function,Group,Mathematical,Number,false,9.5.0,Baseline,,,,,true,false,false,true,false,false,true,true,false,,false,"list.sum_if(loopVar, condition[, expressionStr])
The dot-operator .sum_if() sums the values of members of a List- or Set-type list that satisfy a condition. Each item in the list is bound in turn to loopVar, and if condition is met, the items value is added to the retuned sum. Optionally, the expressionStr is evaluated, allowing a transform to be carried out on a matched list member's value before it is added to the overall returned sum.
loopVar is essentially the same as the loop variable used by the list.each() operator. In the examples below, for clarity the loopVar value ""anItem"" is used, but as with any loop variable a shorter less expressive values such a ""x"" can be used (e.g. by more expert users).
The condition argument is a conditional expression for which each tested item must return true or false.
The operator applies the action code expressionStr to only those list items for which condition is  true. For only list items meeting condition, the result of expressionStr on loopVar is returned as List-type data.
For example, if $MyList is ""1;2;3;4;5"", then
	$MyListA = $MyList.sum_if(aValue, aValue>3) 
returns the sum of all the members of $MyList that are greater than 3. 
An optional third argument expressionStr allows a matched values to be transformed before they are added to the sum. So:
	$MyListA = $MyList.sum_if(aValue, aValue>3, aValue*aValue)  
returns the sum of the squares of each member that is greater than 3.
list.sum_if() vs. sum_if()
Although the two appear similar. This operator works directly on the source list values, whereas sum_if() creates a list of $Path values and returns on an attribute value from each of those paths (where the item at the $Path meets the condition).","list.sum_if(ループ変数, 条件[, 式Str])
ドット演算子 .sum_if() は、条件を満たす List 型または Set 型のリストのメンバーの値を合計します。リスト内の各項目は、loopVar に順番にバインドされ、条件が満たされると、項目の値が返された合計に追加されます。オプションで、expressionStr が評価され、返された合計全体に加算される前に、一致したリスト メンバーの値に対して変換を実行できるようになります。
loopVar は、list.each() 演算子で使用されるループ変数と本質的に同じです。以下の例では、わかりやすくするために、loopVar 値「anItem」が使用されていますが、他のループ変数と同様に、「x」などのより短く表現力の低い値も使用できます (たとえば、より専門的なユーザーによって)。
条件引数は、テストされた各項目が true または false を返す必要がある条件式です。
演算子は、条件が true であるリスト項目のみにアクション コードexpressionStr を適用します。条件を満たすリスト項目のみ、loopVarのexpressionStrの結果をList型データとして返します。
たとえば、$MyList が ""1;2;3;4;5"" の場合、
$MyListA = $MyList.sum_if(aValue, aValue>3)
$MyList の 3 より大きいすべてのメンバーの合計を返します。
オプションの 3 番目の引数expressionStrを使用すると、一致した値を合計に加算する前に変換できます。それで:
$MyListA = $MyList.sum_if(aValue, aValue>3, aValue*aValue)
3 より大きい各メンバーの二乗和を返します。
list.sum_if() と sum_if()
両者は似ているように見えますが。この演算子はソース リストの値に直接作用しますが、sum_if() は $Path 値のリストを作成し、それらの各パスからの属性値 ($Path の項目が条件を満たす場合) を返します。"
list.sum(),Function,Item,Mathematical,Number,false,8.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"list.sum()
list.sum
For a list of List- or Set-type data, this adds up lists of numbers. If $MyList is 1;2;3;4, then for:
	$MyNumber = $MyList.sum; 
$MyNumber is 10, i.e. 1+2+3+4.
Non-numerical items
The general expectation is this operator is used for number-only lists. Non-numerical list items are ignored:
	""2; 4; 6; 12"".sum gives 24 
	""2; 8bees; 4; bee; 6; bee5; 12; bee2bee"" also gives 24 
However, be aware of note this edge case;
	2; 8 bees; 4; bee; 6; bee 5; 12; bee 2 bee gives 32 
Here, the original result of 24 is supplemented by the opening 8 from '8 bees' and the trailing 5 from 'bee5' to give 32. But, the 2 entirely within 'bee 2 bee' is not counted.","list.sum()
list.sum
リスト型またはセット型のデータのリストの場合、数値のリストが合計されます。$MyList が 1;2;3;4 の場合、次のようになります。
$MyNumber = $MyList.sum;
$MyNumber は 10、つまり 1+2+3+4 です。
数値以外の項目
一般に、この演算子は数値のみのリストに使用されることが予想されます。数値以外のリスト項目は無視されます。
""2; 4; 6; 12"".sum は 24 になります
「2; 8bees; 4; bee; 6; bee5; 12; bee2bee」でも 24 になります。
ただし、この特殊なケースには注意してください。
2;ミツバチ8匹。4;蜂;6;ハチ5;12;蜂 2 蜂は 32 を与えます
ここで、元の結果 24 は、「8 bees」の先頭の 8 と「bee5」の末尾の 5 で補われ、32 になります。ただし、「bee 2 bee」全体に含まれる 2 はカウントされません。"
"list.tr(inStr, outStr)",Function,Item,Data manipulation,source context dependent,false,5.7.0,Baseline,,,,2,true,true,false,false,false,false,false,false,false,,false,"list.tr(inStr, outStr)
This operator allows simple single character string manipulation on a List- or Set-type list. It computes a new list, copying each character of the source list but converting any characters in inStr to the corresponding characters in outStr. For example:
	$MyList = $MyList.tr(""a"",""A""); 
returns a copy of $MyList in which every ""a"" is converted to ""A"".
Backslash characters must be quoted and escaped:
	$MyList = $MyList(""c"",""\\r""); 
converts every ""c"" to a Macintosh newline characters (\r) . Note the need in this context for an extra backslash escape (so Tinderbox knows the intended swap value is ""\r"" and not ""r"").
For further information, see the macOS X man page for the UNIX tr command.","list.tr(inStr, outStr)
この演算子を使用すると、List 型または Set 型のリストに対する単純な 1 つの文字列操作が可能になります。新しいリストを計算し、ソース リストの各文字をコピーしますが、inStr 内の文字を outStr 内の対応する文字に変換します。たとえば:
$MyList = $MyList.tr(""a"",""A"");
すべての「a」が「A」に変換された $MyList のコピーを返します。
バックスラッシュ文字は引用符で囲んでエスケープする必要があります。
$MyList = $MyList(""c"",""\\r"");
すべての「c」を Macintosh の改行文字 (\r) に変換します。このコンテキストでは、追加のバックスラッシュ エスケープが必要であることに注意してください (そのため、Tinderbox は、意図されたスワップ値が ""r"" ではなく ""\r"" であることを認識します)。
詳細については、UNIX tr コマンドの macOS X マニュアル ページを参照してください。"
List.unique(),Function,Item,Data manipulation,List,false,5.8.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"List.unique()
List.unique
This returns List-type data of the unique values in the list, as a sorted but de-duped list. Hitherto, de-duping required passing data into a Set-type attribute and back. For the same reason this operator really only makes sense to use on List-type lists as a Set cannot support duplicate items. Trailing parentheses are optional for this function.
Be aware that this function results in a case insensitive A-Z sort, thus not 'bee;ant;cow' as might otherwise be assumed (to get such an outcome see further below). For example, if $MyList is 'bee;ant;cow;bee':
	$MyList = $MyList.unique; 
results in a list value 'ant;bee;cow'. 
The function can be chained with .sort-type actions and .reverse.
	$MyList = $MyList(""Another note"").unique; 
	$SomeList = collect(children, $MyNumberList).unique.nsort; 
	$MyList = collect(children, $MyList).unique.reverse; 
The last above sets $MyList to a list of all the unique, discrete, values to be found in $MyList in every child of the current note. Use with collect() or collect_if() to act on a particular attribute across a group of notes. If a collect() with query scope is the designator 'all' the result will be every discrete value for the referenced list attribute across the whole document.
This function does not apply to Set-type lists because Sets automatically de-duplicate items so are always a list of unique values.
De-duping a list whilst retaining original sort order
The basic method is this:
   $MyList.each(anItem){
      if(!$MyList2.contains(anItem)){
         $MyList2+=anItem;
      }
   };
If is it desired to de-dupe $MyList back to itself, use a list-type variable:
   var:list vList;
   $MyList.each(anItem){
      if(!vList.contains(anItem)){
         vList+=anItem;
      }
   };
   $MyList = vList;
A further consideration is whether the tested list's items are in varying case ('ant' vs. 'Ant' vs. 'ANT' etc.). For instance, to take a mixed case list with duplicates and end up with a de-duped all-lowercase version, use:
   var:list vList;
   $MyList.lowercase.each(anItem){
      if(!vList.contains(anItem)){
         vList+=anItem;
      }
   };
   $MyList = vList;
Resulting order
.unique() preserves the order of elements in a list. Originally, this operator forced an A-Z order, but this was not ideal as one feature of List-type lists is that they allow duplicates do not auto-sort—unlike Set-type lists). Thus now:
	""C:A;A;B"".unique;  
now returns ""C;A;B"" (previously it would have been ""A;B;C"", destroying the original ordering). The output retains the first-occurring item, by list order, of any list value. The underlying assumptions is dupes gat added to the end of the list so the first occurrence is the desired item.","List.unique()
リスト.ユニーク
これは、リスト内の一意の値のリスト型データを、ソート済みで重複を除外したリストとして返します。これまで、重複排除にはデータを Set タイプ属性に渡して戻す必要がありました。同じ理由で、Set は重複項目をサポートできないため、この演算子は実際には List タイプのリストでのみ使用するのが意味があります。この関数の末尾の括弧はオプションです。
この関数では、大文字と小文字を区別しない A ～ Z の並べ替えが行われるため、そうでない場合に想定されるような 'bee;ant;cow' ではないことに注意してください (このような結果を得るには、以下を参照してください)。たとえば、$MyList が 'bee;ant;cow;bee' の場合:
$MyList = $MyList.unique;
結果はリスト値「ant;bee;cow」になります。
この関数は、.sort-type アクションおよび .reverse と連鎖させることができます。
$MyList = $MyList(""別のメモ"").unique;
$SomeList =collect(children, $MyNumberList).unique.nsort;
$MyList =collect(children, $MyList).unique.reverse;
上記の最後の例では、$MyList を、現在のノートのすべての子の $MyList 内で見つかるすべての一意の離散値のリストに設定します。collect() またはcollect_if() と併用して、ノートのグループ全体の特定の属性に作用します。クエリスコープを持つcollect()が指定子「all」である場合、結果はドキュメント全体の参照リスト属性のすべての個別の値になります。
Set は項目の重複を自動的に除外するため、常に一意の値のリストになるため、この関数は Set タイプのリストには適用されません。
元の並べ替え順序を維持しながらリストの重複を排除する
基本的な方法は次のとおりです。
$MyList.each(anItem){
if(!$MyList2.contains(anItem)){
$MyList2+=アイテム;
}
};
$MyList の重複を除外してそれ自体に戻したい場合は、リスト型変数を使用します。
var:リストvList;
$MyList.each(anItem){
if(!vList.contains(anItem)){
vList+=アイテム;
}
};
$MyList = vList;
さらに考慮すべき点は、テストされたリストの項目が大文字と小文字が異なるかどうかです (「ant」対「Ant」対「ANT」など)。たとえば、重複を含む大文字と小文字の混合リストを取得し、最終的に重複を除去したすべて小文字のバージョンを作成するには、次のように使用します。
var:リストvList;
$MyList. lowercase.each(anItem){
if(!vList.contains(anItem)){
vList+=アイテム;
}
};
$MyList = vList;
結果の注文
.unique() はリスト内の要素の順序を保持します。元々、この演算子は A-Z の順序を強制していましたが、リスト型リストの特徴の 1 つは、セット型リストとは異なり、重複が自動ソートされないことであるため、これは理想的ではありませんでした。したがって、現在は次のようになります。
""C:A;A;B"".一意;
現在は「C;A;B」を返します（以前は「A;B;C」だったので、元の順序が壊れていました）。出力には、リストの順序に従って、リスト値の最初に出現する項目が保持されます。基礎となる仮定は、重複がリストの最後に追加されるため、最初に出現したものが目的の項目であるということです。"
list(expressionList),Function,Item,Data manipulation,List,false,5.10.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"list(expressionList)
This function returns a List as the evaluated format of each of its comma-delimited argument list of expressions.
Expression arguments can be:
* Literal values: Fred though there is little point in using these unless the list is subsequently to be concatenated to a String.
* Basic literal operations ""Fred""+"" "" +Smith"".
* Arithmetic operations: 6/2.
* Attributes (values) both system e.g. $Name and user attributes e.g. $MyNumber.
* Action operators sqrt(2).
* Action code expressions, as in whole code expressions ""Date: ""+date(""today"").format(""*"").
The function is also useful as a method of assembling lists of attributes or expressions for action functions using lists such as count(), max() and min():
	FAILS: $MyDate = max($MyDateA,$MyDateB,$MyDateC);
The latter fails as max() interprets the list as 3 literal strings ""$MyDateA"", etc., and does a lexical sort on those values. However:
	WORKS: $MyDate = max(list($MyDateA,$MyDateB,$MyDateC));
Functions creating lists (sum(), links(), collect(), etc.) do not have the same problems with the likes of max as the former output a valid list that can be used directly. For instance:
	WORKS: $MyDate = max(links.outbound.attended.$MyDate);
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression, e.g. list(eval(expressionA),eval(expressionB)).
Examples
This returns a list of numbers resulting from simple evaluations:
	Code: list(4+5,9-3,100/2.5)
	Output value, a list: ^value(list(4+5,9-3,100/2.5))^
This example, this makes a single evaluated string out of a list of two expressions:
	Code: list(""This note 's $Width is ""+$Width, ""the $Xpos is ""+$Xpos).format("" and "")+""!"")
	Output value, a string:  ^value(list(""This note's $Width is ""+$Width, ""the $Xpos is ""+$Xpos).format("" and "")+""!"")^
This example is not overly complex but points to how list() can be used in constructing output strings/lists that are otherwise difficult to create. The more complex the expressions passed to list() the greater the likelihood of getting no output, or an unexpected one. If complex inputs do not work consider using more parentheses to help TB figure the order of sub-task execution or else put the result of expressions into new attributes and then pass the value of the latter into list() as an argument.","リスト(式リスト)
この関数は、カンマで区切られた式の各引数リストの評価形式としてリストを返します。
式の引数は次のとおりです。
* リテラル値: Fred ただし、後でリストを文字列に連結しない限り、これらを使用する意味はほとんどありません。
* 基本的なリテラル演算 ""Fred""+"" "" +Smith""。
※算術演算：6/2。
* 両方のシステムの属性 (値) 例:$Name とユーザー属性 (例:$マイナンバー。
* アクション演算子 sqrt(2)。
* コード式全体「Date: ""+date(""today"").format(""*"") のようなアクション コード式。
この関数は、count()、max()、min() などのリストを使用してアクション関数の属性または式のリストを組み立てる方法としても役立ちます。
失敗: $MyDate = max($MyDateA,$MyDateB,$MyDateC);
後者は、max() がリストを 3 つのリテラル文字列「$MyDateA」などとして解釈し、それらの値に対して字句ソートを実行するため失敗します。ただし:
動作: $MyDate = max(list($MyDateA,$MyDateB,$MyDateC));
リストを作成する関数 (sum()、links()、collect() など) は、max などと同じ問題を抱えません。前者は直接使用できる有効なリストを出力するからです。たとえば:
動作: $MyDate = max(links.outbound.attended.$MyDate);
リスト項目がアクション コード式である、より複雑な例では、 eval() を使用して各リスト項目式をラップする必要がある場合があります。list(eval(式A),eval(式B))。
例
これは、単純な評価の結果として得られる数値のリストを返します。
コード: list(4+5,9-3,100/2.5)
出力値、リスト: ^value(list(4+5,9-3,100/2.5))^
この例では、2 つの式のリストから 1 つの評価文字列を作成します。
コード: list(""このメモの $Width は ""+$Width, ""$Xpos は ""+$Xpos).format("" および "")+""!"")
出力値、文字列: ^value(list(""このメモの $Width は ""+$Width, ""$Xpos は ""+$Xpos).format("" および "")+""!"")^
この例はそれほど複雑ではありませんが、他の方法では作成が難しい出力文字列/リストを構築する際に list() を使用する方法を示しています。list() に渡される式が複雑になればなるほど、出力が得られないか、または予期しない出力が得られる可能性が高くなります。複雑な入力が機能しない場合は、TB がサブタスクの実行順序を理解できるように括弧を追加するか、式の結果を新しい属性に入れてから、後者の値を引数として list() に渡すことを検討してください。"
list[itemNum],Function,List,"Dictionary, Set & List operations",source context dependent,false,9.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"list[itemNum]
sourceNum is the zero-based item number in the referenced List- or Set-type list.
Elements in lists, sets, may be extracted (referenced) with the bracket operator:
	$MyList[1] 
This has the same effect as list.at( ), but may be more convenient. Both 
	$MyList[1] 
	$MyList.at(1) 
Returns the second list item (as list item addresses are zero-based).
This syntax can also assign values to specific elements of lists. For example,
	$MyList=[apple; pear; plum; cherry]; 
	$MyList[1]=""persimmon""; 
Will replace ""pear"" with ""persimmon"".
Nested lists
	MyList = [cow;bee;[fish;whale];ant] 
	$MyList[2][1] gives ""whale""","リスト[項目番号]
sourceNum は、参照されるリスト型リストまたはセット型リスト内の 0 から始まる項目番号です。
リストやセット内の要素は、括弧演算子を使用して抽出 (参照) できます。
$MyList[1]
これは list.at( ) と同じ効果がありますが、より便利な場合があります。両方
$MyList[1]
$MyList.at(1)
2 番目のリスト項目を返します (リスト項目のアドレスは 0 から始まるため)。
この構文では、リストの特定の要素に値を割り当てることもできます。たとえば、
$MyList=[リンゴ;梨;梅;チェリー];
$MyList[1]=""柿"";
「梨」を「柿」に置き換えます。
入れ子になったリスト
MyList = [牛;蜂;[魚;クジラ];アリ]
$MyList[2][1] は「クジラ」を与えます"
locale([localeCodeStr]),Function,Document,Date-time,success boolean,false,6.0.0,Baseline,,,,1,false,false,false,false,false,false,false,false,false,,false,"locale(localeCodeStr)
locale(), allows changing of the locale used to translate dates. The same date can be written in a different format in different parts of the world. For example, in the USA a date is written 12/1/2006 to denote December 1, whereas in UK the same date is written 1/12/2006 and so on for variations around the world.
To read the current host OS' locale, call the operator with no argument:
	$MyString = locale(); 
To set a locale, e.g. here for 'British English', pass the desired locale's code value as localeCodeStr;
	locale(""en_GB"") 
Locale codes begin with a two-letter language code, followed by and underscore and a two-letter region code. These are ISO standards ISO-639 and ISO-3166 respectively. Code combinations are available for any language supported by macOS.
To read, or return to, the user's preferred locale, i.e. is derived from their Mac's OS account, use
	$MyString = locale(); 
You may also save the old locale in an attribute for subsequent use. For example:
	$OldLocale=locale(""en_GB""); 
	…do various things, and then reset the original locale…
	locale($OldLocale); 
	… if simple call locale() with no argument if the host OS locale had remained unchanged.
Note that changing the locale() can be fairly time-consuming, as lots of machinery must be torn down and rebuilt for each change.","ロケール(localeCodeStr)
locale() を使用すると、日付の変換に使用されるロケールを変更できます。同じ日付でも、世界の異なる地域では異なる形式で記述されることがあります。たとえば、米国では 12 月 1 日を示すために 12/1/2006 と書かれますが、英国では同じ日付が 1/12/2006 と書かれるなど、世界中で異なります。
現在のホスト OS のロケールを読み取るには、引数なしでオペレーターを呼び出します。
$MyString = ロケール();
ロケールを設定するには、例:ここでは「イギリス英語」の場合、目的のロケールのコード値を localeCodeStr として渡します。
ロケール(""en_GB"")
ロケール コードは 2 文字の言語コードで始まり、その後にアンダースコアと 2 文字の地域コードが続きます。これらはそれぞれ ISO 標準 ISO-639 と ISO-3166 です。コードの組み合わせは、macOS でサポートされているすべての言語で使用できます。
ユーザーの優先ロケール、つまり Mac の OS アカウントから派生したロケールを読み取る、または戻るには、次を使用します。
$MyString = ロケール();
後で使用できるように、古いロケールを属性に保存することもできます。たとえば:
$OldLocale=locale(""en_GB"");
…いろいろなことをして、元のロケールをリセットします…
ロケール($OldLocale);
… ホスト OS のロケールが変更されていない場合は、単純に引数なしで locale() を呼び出します。
locale() の変更には、変更のたびに多くの機械を破壊して再構築する必要があるため、かなり時間がかかる場合があることに注意してください。"
log(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"log(sourceNum)
The operator log() computes the natural logarithm of its sourceNum number, which should be a number, a numeric attribute, or an expression that can be interpreted as a number.
	$MyNumber = log(3); 
returns '1.098612289' for an input of 3.","ログ(ソース番号)
演算子 log() は、sourceNum 数値の自然対数を計算します。この数値は、数値、数値属性、または数値として解釈できる式である必要があります。
$MyNumber = log(3);
入力が 3 の場合、「1.098612289」を返します。"
lowercase(dataStr),Function,Item,Formatting,String,false,4.6.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"lowercase(dataStr)
The contents of text dataStr are returned entirely in lower case.
If $MyString is ""Hello World"":
	$MyString = lowercase($MyString); 
would set $MyString to ""hello world"".
Functionally equivalent to String.lowercase().","小文字(dataStr)
テキスト dataStr の内容はすべて小文字で返されます。
$MyString が「Hello World」の場合:
$MyString = 小文字($MyString);
$MyString を「hello world」に設定します。
機能的には String. lowercase() と同等です。"
max(numberList),Function,List,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"max(numberList)
The max() operator returns the largest item in a list or the values or a List or Set data type attribute. As it operates off a list it may be more convenient to use the newer list.max() chained operator.
Both the operators max() and min() use lexical comparison in most cases, but numeric comparison if the context is numeric (i.e. the reference is a Number-type attribute) and/or all list items are numbers. Thus:
	$Width=max(""1;100;2""); 
Since ""Width"" is numeric, max() will be return 100. 
	$Name=max(""1;100;2""); 
Since the attribute ""Name"" is a string, max() will return 2.
If without a list, create one on the fly using list(), collect() or collect_if():
	$MyMax = max(list($DateA,$DateB,$DateC)); 
	$MyMax = max(collect(descendants,$Modified)); 
	$MyMax = max(collect_if(all,$MyNum>0,$MyNum)); 
This allows export via ^^value^^:
	^^value(max(collect(descendants,$Modified)))^^ 
To use max() with a list of expressions, use list():
	Works: $MyNumber = max(list(4+2,9+6)); (output: 15)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Using lists of dates
When using Date-type data bear in mind that the defaults for an unset Date attribute is ""never"" and that ""never"" is treated as sorting always before (i.e. less than) any set date. So to use min() with dates, filter out the unset values, whereas with max() it is not needed:
	$MyMax = max(collect_if(descendants,$Modified)); 
	$MyMin = min(collect_if(descendants,($Modified!=""never""),$Modified));","max(数値リスト)
max() 演算子は、リスト内の最大の項目、値、またはリストまたはセットのデータ型属性を返します。リストに基づいて動作するため、新しい list.max() 連鎖演算子を使用する方が便利な場合があります。
演算子 max() と min() は両方とも、ほとんどの場合字句比較を使用しますが、コンテキストが数値である場合 (つまり、参照が数値型属性である場合)、および/またはすべてのリスト項目が数値である場合は数値比較を使用します。したがって:
$Width=max(""1;100;2"");
「Width」は数値なので、max() は 100 を返します。
$Name=max(""1;100;2"");
属性「Name」は文字列であるため、max() は 2 を返します。
リストがない場合は、list()、collect()、またはcollect_if()を使用してその場でリストを作成します。
$MyMax = max(list($DateA,$DateB,$DateC));
$MyMax = max(collect(descendants,$Modified));
$MyMax = max(collect_if(all,$MyNum>0,$MyNum));
これにより、^^value^^ によるエクスポートが可能になります。
^^value(max(collect(descendants,$Modified)))^^
式のリストで max() を使用するには、 list() を使用します。
動作: $MyNumber = max(list(4+2,9+6));(出力:15)
リスト項目がアクション コード式であるより複雑な例では、 eval() を使用して各リスト項目式をラップする必要がある場合があります。list(eval(式A),eval(式B))。
日付のリストの使用
日付型データを使用する場合、設定されていない日付属性のデフォルトは「なし」であり、「なし」は常に設定された日付よりも前 (つまり、日付よりも小さい) にソートされるものとして扱われることに注意してください。したがって、日付で min() を使用するには、未設定の値をフィルターで除外しますが、max() ではその必要はありません。
$MyMax = max(collect_if(descendants,$Modified));
$MyMin = min(collect_if(descendants,($Modified!=""never""),$Modified));"
min(numberList),Function,List,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"min(numberList)
The min() operator returns the smallest item in a list or the values of a List or Set data type attribute. As it operates off a list it may be more convenient to use the newer list.min() chained operator.
Both the operators max() and min() use lexical comparison in most cases, but numeric comparison if the context is numeric (i.e. the reference is a Number-type attribute) and/or all list items are numbers. Thus:
	$Width=min(""100;2;70""); 
Since ""Width"" is numeric, min() will be return 2. 
	$Name=min(""100;2;70""); 
Since the attribute ""Name"" is a string, min() will return 100.
If without a list, create one on the fly using list(), collect() or collect_if():
	$FistDate = min(list($DateA,$DateB,$DateC)); 
	$MyMin = min(collect(descendants, $Modified)); 
	$MyMin = min(collect_if(all,$MyNum>0,$MyNum)); 
This allows export via ^^value^^:
	^^value(min(collect(descendants,$Modified)))^^ 
To use min() with a list of items that are attributes or expressions, use list():
	Works: $MyNumber = min(list(4+2,9+6)); (output: 6)
For more complex examples, where list items are action code expressions, it may be necessary to use eval() to wrap each list item expression e.g. list(eval(expressionA),eval(expressionB)).
Using lists of dates
When using Date-type data bear in mind that the defaults for an unset Date attribute is ""never"" and that ""never"" is treated as sorting always before (i.e. less than) any set date. So to use min() with dates, filter out the unset values, whereas with max() it is not needed:
	$MyMax = max(collect_if(descendants,$Modified)); 
	$MyMin = min(collect_if(descendants,($Modified!=""never""),$Modified));","min(数値リスト)
min() 演算子は、リスト内の最小の項目、または List または Set データ型属性の値を返します。リストに基づいて動作するため、新しい list.min() 連鎖演算子を使用する方が便利な場合があります。
演算子 max() と min() は両方とも、ほとんどの場合字句比較を使用しますが、コンテキストが数値である場合 (つまり、参照が数値型属性である場合)、および/またはすべてのリスト項目が数値である場合は数値比較を使用します。したがって:
$Width=min(""100;2;70"");
「Width」は数値なので、min() は 2 を返します。
$Name=min(""100;2;70"");
属性「Name」は文字列であるため、min() は 100 を返します。
リストがない場合は、list()、collect()、またはcollect_if()を使用してその場でリストを作成します。
$FistDate = min(list($DateA,$DateB,$DateC));
$MyMin = min(collect(descendants, $Modified));
$MyMin = min(collect_if(all,$MyNum>0,$MyNum));
これにより、^^value^^ によるエクスポートが可能になります。
^^value(min(collect(descendants,$Modified)))^^
属性または式である項目のリストで min() を使用するには、 list() を使用します。
動作: $MyNumber = min(list(4+2,9+6));(出力:6)
リスト項目がアクション コード式であるより複雑な例では、 eval() を使用して各リスト項目式をラップする必要がある場合があります。list(eval(式A),eval(式B))。
日付のリストの使用
日付型データを使用する場合、設定されていない日付属性のデフォルトは「なし」であり、「なし」は常に設定された日付よりも前 (つまり、日付よりも小さい) にソートされるものとして扱われることに注意してください。したがって、日付で min() を使用するには、未設定の値をフィルターで除外しますが、max() ではその必要はありません。
$MyMax = max(collect_if(descendants,$Modified));
$MyMin = min(collect_if(descendants,($Modified!=""never""),$Modified));"
"minute(aDate, minutesNum)",Function,Item,Date-time,Date,false,5.7.0,Baseline,,,,2,true,false,true,false,false,false,false,false,false,,false,"minute(aDate, minutesNum)
creates a new date based on the aDate expression, but in which the minute is minutesNum. The source Date is not changed unless aDate is an attribute and the attribute is re-setting itself:
	$MyDateA = minute($MyDate,14); $MyDate is not changed
	$MyDate = minute($MyDate,14); $MyDate is changed
Examples. If $MyDate is 4 July 2009 09:30, then 
	$MyDateA=minute($MyDate,5); 
will change $MyDate to 4 July 2009 19:05 whilst leaving $MyDate as 4 July 2009 09:30. However, if the code is self-referring:
	$MyDate=minute($MyDate,5); 
will change $MyDate to 4 July 2009 19:05.
Take care using the later self-referring form in a $Rule or agent as it fires every agent update cycle adding 5 minutes each time! Make sure you use a guard agent or conditional query to make the action out of scope after the first application. Or, consider using a Stamp, which only fires once per (manual) application.
The single-argument method that reads the minutes value is documented separately: see minute(Date).","分(日付、分番号)
aDate 式に基づいて新しい日付を作成しますが、分は minutesNum です。aDate が属性であり、属性自体が再設定されない限り、ソース Date は変更されません。
$MyDateA = 分($MyDate,14);$MyDateは変更されません
$MyDate = 分($MyDate,14);$MyDate が変更されました
例。$MyDate が 2009 年 7 月 4 日 09:30 の場合、
$MyDateA=分($MyDate,5);
$MyDate を 2009 年 7 月 4 日 09:30 のままにし、$MyDate を 2009 年 7 月 4 日 19:05 に変更します。ただし、コードが自己参照の場合は次のようになります。
$MyDate=分($MyDate,5);
$MyDate を 2009 年 7 月 4 日 19:05 に変更します。
$Rule またはエージェントで後の自己参照フォームを使用すると、エージェントの更新サイクルが開始されるたびに 5 分が追加されるため、注意してください。最初の適用後にアクションを範囲外にするために、必ずガード エージェントまたは条件付きクエリを使用してください。または、(手動) アプリケーションごとに 1 回だけ起動するスタンプの使用を検討してください。
分の値を読み取る単一引数メソッドについては、個別に文書化されています。「minute(Date)」を参照してください。"
minute(aDate),Function,Item,Date-time,Number,false,5.7.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"minute(aDate)
returns the hour element from the aDate date/time expression, which may simply be a date-type attribute value.
Alternatively, use Date.minute.
The two-argument method used to set Dates is documented separately: see minute(aDate, minutesNum).","分(日付)
aDate 日付/時刻式から時間要素を返します。これは単に日付タイプの属性値である場合もあります。
あるいは、Date. minutes を使用します。
日付の設定に使用される 2 つの引数メソッドについては、別途文書化されています: minutes(aDate, minutesNum) を参照してください。"
"minutes(startDate, endDate)",Function,Item,Date-time,Number,false,5.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"minutes(startDate, endDate) 
returns the Number of whole minutes that elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA has time 12:30 and $DateB has time 14:00, then:
	$MyNumber = minutes($DateA,$DateB); 
sets $MyNumber to 90.
Also see days(date1,date2).","分(開始日、終了日)
startDate と endDate の間に経過した分数を返します。endDate が startDate より前の場合、結果は負になります。
$DateA の時刻が 12:30、$DateB の時刻が 14:00 の場合、次のようになります。
$MyNumber = 分($DateA,$DateB);
$MyNumber を 90 に設定します。
days(date1,date2) も参照してください。"
"mod(sourceNum, modulusNum)",Function,Item,Mathematical,Number,false,4.0.1,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"mod(sourceNum, moduloNum)
mod() returns modulo of a number sourceNum as set by number modulusNum, i.e. the integer remainder of sourceNum divided by modulusNum. Thus:
	$MyNumber = mod(11,3); 
sets $MyNumber to 2.","mod(sourceNum, moduloNum)
mod() は、数値 modulusNum で設定された数値 sourceNum の剰余、つまり、sourceNum を modulusNum で割った整数の剰余を返します。したがって:
$MyNumber = mod(11,3);
$MyNumber を 2 に設定します。"
modifierKeys,Variable,Item,Data manipulation,List,false,11.5.0,11.5.0,,11.5.0,,,false,false,false,false,false,false,false,false,false,,false,"modifierKeys
When processing a stamp, the local variable modifierKeys is set to a list of strings representing the modifier keys the user was pressing when the stamp is executed. For example, a value of  [control;option] indicates that the control and option keys were pressed, and that neither the shift nor the command keys were pressed.","修飾キー
スタンプを処理するとき、ローカル変数 modifierKeys は、スタンプの実行時にユーザーが押していた修飾キーを表す文字列のリストに設定されます。たとえば、値 [control;option] は、Ctrl キーと Option キーが押され、Shift キーも Command キーも押されなかったことを示します。"
"month(aDate, monthsNum)",Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"month(aDate[, monthsNum])
Alternatively, use Date.month.
month(aDate)
returns the month from the aDate date/time expression, which may simply be a date-type attribute value.
month(aDate,monthsNum) 
creates a new date based on the aDate date/time expression, but in which the month is monthsNum. The source Date is not changed unless theDate is an attribute and the attribute is re-setting itself:
	$MyDateA = month($MyDate,14); 
$MyDate is unaltered
	$MyDate = month($MyDate,14); 
$MyDate is changed
Examples. If $MyDate is July 4,2009, then 
	$MyDate=month($MyDate,5); 
will change $MyDate to May 4, 2009.
The single-argument method that reads the months value is documented separately: see month(aDate).","month(aDate[, monthsNum])
あるいは、Date.month を使用します。
月(日付)
aDate 日付/時刻式から月を返します。これは単に日付型の属性値である場合もあります。
month(aDate,monthsNum)
aDate 日付/時刻式に基づいて新しい日付を作成しますが、月は monthsNum です。theDate が属性であり、属性自体が再設定されない限り、ソース Date は変更されません。
$MyDateA = 月($MyDate,14);
$MyDate は変更されません
$MyDate = month($MyDate,14);
$MyDate が変更されました
例。$MyDate が 2009 年 7 月 4 日の場合、
$MyDate=month($MyDate,5);
$MyDate を 2009 年 5 月 4 日に変更します。
月の値を読み取る単一引数メソッドについては、別途文書化されています。「month(aDate)」を参照してください。"
month(aDate),Function,Item,Date-time,Number,false,4.0.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"month(aDate)
returns the month from the aDate date/time expression, which may simply be a date-type attribute value.
Alternatively, use Date.month.
The two-argument form used to set Dates is documented separately: see month(aDate, monthsNum).","月(日付)
aDate 日付/時刻式から月を返します。これは単に日付型の属性値である場合もあります。
あるいは、Date.month を使用します。
日付の設定に使用される 2 つの引数形式については、別途文書化されています。「month(aDate, monthsNum)」を参照してください。"
"months(startDate, endDate)",Function,Item,Date-time,Number,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"months(startDate, endDate) 
returns the Number of whole months that have elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA is 3 January 2016 and $DateB is 9 April 2016, then:
	$MyNumber = months($DateA,$DateB); 
sets $MyNumber to 4.
Also see days(date1,date2).","months(開始日、終了日)
startDate と endDate の間に経過した月数を返します。endDate が startDate より前の場合、結果は負になります。
$DateA が 2016 年 1 月 3 日、$DateB が 2016 年 4 月 9 日の場合、次のようになります。
$MyNumber = months($DateA,$DateB);
$MyNumber を 4 に設定します。
days(date1,date2) も参照してください。"
"neighbors(scope, distanceNum[, linkTypeStr])",Function,Group,Data manipulation,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"neighbors(scope, distanceNum)
Returns a list of the path(s) of all those notes that can be reached by following exactly distanceNum links outward from the designated note or notes. Only the shortest possible path between two notes is considered. The operator will report links from the source node to itself, i.e. self-links. Prototype-type links are ignored. For example:
	$MyList  = neighbors(this, 3); 
Returns the set of notes that are connected from this note by exactly three (outbound) links.
neighbors(scope, distanceNum, linkTypeStr)
Returns the set of notes that are connected by exactly distanceNum links outward from the designated note or notes, but within those links considering only links of the specified link type linkTypeStr to filter on unnamed links use the type ""*untitled"".For example:
	$MyList  = neighbors(children, 2, ""example""); 
Returns the set of notes that are connected from any of this note's children by exactly two (outbound) links of the link type ""example"".
Different variations of 'neighbor' operators
There are essentially two different subtypes within the 4 operators:
* Direction. If the operator name includes a '2' the direction of connecting links are ignored. Otherwise, only outbound links are assessed.
* Distance. If the operator name includes 'Within' then all notes at distances between 1 and distanceNum are considered. Otherwise, only notes at exactly distanceNum are considered.","近傍(スコープ、距離Num)
指定された 1 つまたは複数のノートから外側に、正確に distanceNum リンクをたどることで到達できるすべてのノートのパスのリストを返します。2 つのノート間の可能な最短パスのみが考慮されます。オペレーターは、ソースノードからそれ自体へのリンク、つまり自己リンクを報告します。プロトタイプタイプのリンクは無視されます。たとえば:
$MyList = 隣人(this, 3);
このノートからちょうど 3 つの (アウトバウンド) リンクによって接続されているノートのセットを返します。
近隣(スコープ、距離Num、linkTypeStr)
指定された 1 つまたは複数のノートから外側に正確に distanceNum リンクで接続されているノートのセットを返します。ただし、それらのリンク内では、指定されたリンク タイプ linkTypeStr のリンクのみを考慮して、名前のないリンクをフィルタリングするためにタイプ ""*untitled"" が使用されます。次に例を示します。
$MyList = neighbors(children, 2, ""example"");
リンク タイプ「example」の 2 つの (送信) リンクによってこのノートの子のいずれかから接続されているノートのセットを返します。
「近隣」演算子のさまざまなバリエーション
4 つの演算子には基本的に 2 つの異なるサブタイプがあります。
* 方向。演算子名に「2」が含まれる場合、接続リンクの方向は無視されます。それ以外の場合は、送信リンクのみが評価されます。
* 距離。オペレータ名に「Within」が含まれている場合は、1 から distanceNum までの距離にあるすべてのノートが考慮されます。それ以外の場合は、正確に distanceNum にあるノートのみが考慮されます。"
"neighbors2(scope, distanceNum[, linkTypeStr])",Function,Group,Data manipulation,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"neighbors2(scope, distanceNum)
Returns a list of the path(s) of all those notes that can be reached by following exactly distanceNum links from the designated note or notes, regardless of the direction of those links (i.e. whether inbound or outbound). Only the shortest possible path between two notes is considered. The operator will report links from the source node to itself, i.e. self-links. Prototype-type links are ignored. For example:
	$MyList  = neighbors2(this, 3); 
Returns the set of notes that are connected from this note by exactly three links of either direction.
neighbors2(scope, distanceNum, linkTypeStr)
Returns the set of notes that are connected by exactly distanceNum links from the designated note or notes, regardless of the direction of a link (i.e. whether inbound or outbound) and within those links considering only links of the specified link type linkTypeStr. Unnamed links are specified as the type ""*untitled"". For example:
	$MyList  = neighbors2(children, 2, ""example""); 
Returns the set of notes that are connected from any of this note's children by exactly two links of any direction but also of the link type ""example"".
Different variations of 'neighbor' operators
There are essentially two different subtypes within the 4 operators:
* Direction. If the operator name includes a '2' the direction of connecting links are ignored. Otherwise, only outbound links are assessed.
* Distance. If the operator name includes 'Within' then all notes at distances between 1 and distanceNum are considered. Otherwise, only notes at exactly distanceNum are considered.","neighbors2(スコープ、距離Num)
リンクの方向 (つまり、インバウンドかアウトバウンドか) に関係なく、指定された 1 つまたは複数のノートから正確に distanceNum のリンクをたどることで到達できるすべてのノートのパスのリストを返します。2 つのノート間の可能な最短パスのみが考慮されます。オペレーターは、ソースノードからそれ自体へのリンク、つまり自己リンクを報告します。プロトタイプタイプのリンクは無視されます。たとえば:
$MyList = neighbors2(this, 3);
このノートからいずれかの方向のちょうど 3 つのリンクによって接続されているノートのセットを返します。
neighbors2(scope, distanceNum, linkTypeStr)
リンクの方向 (つまり、インバウンドかアウトバウンドか) に関係なく、指定されたリンク タイプ linkTypeStr のリンクのみを考慮したそれらのリンク内で、指定された 1 つまたは複数のノートから正確に distanceNum リンクによって接続されているノートのセットを返します。名前のないリンクはタイプ「*untitled」として指定されます。たとえば:
$MyList = neighbors2(children, 2, ""example"");
任意の方向の 2 つのリンクだけでなく、リンク タイプが「example」であることによって、このノートの子のいずれかから接続されているノートのセットを返します。
「近隣」演算子のさまざまなバリエーション
4 つの演算子には基本的に 2 つの異なるサブタイプがあります。
* 方向。演算子名に「2」が含まれる場合、接続リンクの方向は無視されます。それ以外の場合は、送信リンクのみが評価されます。
* 距離。オペレータ名に「Within」が含まれている場合は、1 から distanceNum までの距離にあるすべてのノートが考慮されます。それ以外の場合は、正確に distanceNum にあるノートのみが考慮されます。"
"neighbors2Within(scope, distanceNum[, linkTypeStr])",Function,Group,Data manipulation,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"neighbors2Within(scope, distanceNum)
Returns a list of the path(s) of all those notes that can be reached by following between 1 and distanceNum links from the designated note or notes, regardless of the direction of those links (i.e. whether inbound or outbound). Only the shortest possible path between two notes is considered. The operator will report links from the source node to itself, i.e. self-links. Prototype-type links are ignored.
The starting note or notes are considered to be connected to themselves.
For example:
	$MyList  = neighbors2Within(this, 3); 
Returns the set of notes that are connected from this note by between 1–3 (outbound) links.
neighbors2Within(scope, distanceNum, linkType)
Returns the set of notes that are connected by following between 1 and distanceNum links from the designated note or notes, regardless of the direction of those links (i.e. whether inbound or outbound), but within those links considering only links of the specified link type linkTypeStr. 
The starting note or notes are considered to be connected to themselves. To filter on unnamed links use the type ""*untitled"". For example:
	$MyList  = neighbors2Within(children, 2, ""example""); 
Returns the set of notes that are connected from any of this note's children by between 1–2 (outbound) links of the link type ""example"".
Different variations of 'neighbor' operators
There are essentially two different subtypes within the 4 operators:
* Direction. If the operator name includes a '2' the direction of connecting links are ignored. Otherwise, only outbound links are assessed.
* Distance. If the operator name includes 'Within' then all notes at distances between 1 and distanceNum are considered. Otherwise, only notes at exactly distanceNum are considered.","neighbors2Within(範囲、距離数)
リンクの方向 (つまり、インバウンドかアウトバウンドか) に関係なく、指定されたノートから 1 から distanceNum までのリンクをたどることで到達できるすべてのノートのパスのリストを返します。2 つのノート間の可能な最短パスのみが考慮されます。オペレーターは、ソースノードからそれ自体へのリンク、つまり自己リンクを報告します。プロトタイプタイプのリンクは無視されます。
開始ノートはそれ自体に接続されているとみなされます。
たとえば:
$MyList = neighbors2Within(this, 3);
1 ～ 3 (アウトバウンド) リンクによってこのノートから接続されているノートのセットを返します。
neighbors2Within(スコープ、距離番号、リンクタイプ)
リンクの方向 (つまり、インバウンドかアウトバウンドか) に関係なく、指定されたノートから 1 から distanceNum までのリンクをたどることによって接続されているノートのセットを返します。ただし、それらのリンク内では、指定されたリンク タイプ linkTypeStr のリンクのみが考慮されます。
開始ノートはそれ自体に接続されているとみなされます。名前のないリンクをフィルターするには、「*untitled」タイプを使用します。たとえば:
$MyList = neighbors2Within(children, 2, ""例"");
リンク タイプ「example」の 1 ～ 2 (アウトバウンド) リンクによってこのノートの子のいずれかから接続されているノートのセットを返します。
「近隣」演算子のさまざまなバリエーション
4 つの演算子には基本的に 2 つの異なるサブタイプがあります。
* 方向。演算子名に「2」が含まれる場合、接続リンクの方向は無視されます。それ以外の場合は、送信リンクのみが評価されます。
* 距離。オペレータ名に「Within」が含まれている場合は、1 から distanceNum までの距離にあるすべてのノートが考慮されます。それ以外の場合は、正確に distanceNum にあるノートのみが考慮されます。"
"neighborsWithin(scope, distanceNum[, linkTypeStr])",Function,Group,Data manipulation,List,false,9.0.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"neighborsWithin(scope, distanceNum)
Returns a list of the path(s) of all those notes that can be reached by following between 1 and distanceNum links outward from the designated note or notes. Only the shortest possible path between two notes is considered. The operator will report links from the source node to itself, i.e. self-links. Prototype-type links are ignored.
The starting note or notes are considered to be connected to themselves.
For example:
	$MyList  = neighborsWithin(this, 3); 
Returns the set of notes that are connected from this note by between 1–3 (outbound) links.
neighborsWithin(scope, distanceNum, linkTypeSTr)
Returns the set of notes that are connected by following between 1 and distanceNum links outward from the designated note or notes, but considering only links of the specified link type linkTypeStr. 
The starting note or notes are considered to be connected to themselves. To filter on unnamed links use the type ""*untitled"". For example:
	$MyList  = neighborsWithin(children, 2, ""example""); 
Returns the set of notes that are connected from any of this note's children by between 1–2 (outbound) links of the link type ""example"".
Different variations of 'neighbor' operators
There are essentially two different subtypes within the 4 operators:
* Direction. If the operator name includes a '2' the direction of connecting links are ignored. Otherwise, only outbound links are assessed.
* Distance. If the operator name includes 'Within' then all notes at distances between 1 and distanceNum are considered. Otherwise, only notes at exactly distanceNum are considered.","neighborsWithin(範囲, 距離数)
指定された 1 つまたは複数のノートから外側に 1 から distanceNum までのリンクをたどることで到達できる、すべてのノートのパスのリストを返します。2 つのノート間の可能な最短パスのみが考慮されます。オペレーターは、ソースノードからそれ自体へのリンク、つまり自己リンクを報告します。プロトタイプタイプのリンクは無視されます。
開始ノートはそれ自体に接続されているとみなされます。
たとえば:
$MyList = neighborsWithin(this, 3);
1 ～ 3 (アウトバウンド) リンクによってこのノートから接続されているノートのセットを返します。
neighborsWithin(スコープ、距離番号、リンクタイプSTr)
指定された 1 つまたは複数のノートから外側に 1 から distanceNum までのリンクをたどることによって接続されているノートのセットを返します。ただし、指定されたリンク タイプ linkTypeStr のリンクのみが考慮されます。
開始ノートはそれ自体に接続されているとみなされます。名前のないリンクをフィルターするには、「*untitled」タイプを使用します。たとえば:
$MyList = neighborsWithin(children, 2, ""example"");
リンク タイプ「example」の 1 ～ 2 (アウトバウンド) リンクによってこのノートの子のいずれかから接続されているノートのセットを返します。
「近隣」演算子のさまざまなバリエーション
4 つの演算子には基本的に 2 つの異なるサブタイプがあります。
* 方向。演算子名に「2」が含まれる場合、接続リンクの方向は無視されます。それ以外の場合は、送信リンクのみが評価されます。
* 距離。オペレータ名に「Within」が含まれている場合は、1 から distanceNum までの距離にあるすべてのノートが考慮されます。それ以外の場合は、正確に distanceNum にあるノートのみが考慮されます。"
"notify(headlineStr[, detailsStr, deliveryDateTime ])",Function,Item,Data manipulation,success boolean,false,6.0.0,Baseline,,,,3,true,false,false,false,false,false,false,true,false,,false,"notify(headlineStr[, details, deliveryTime ])
notify() lets notes post notifications to the host Mac's User Notification Center.
headlineStr is a string or string expression, and will be the headline of the notification.
	notify(""Hello world""); 
The optional detailsStr is another string or string expression, and provides an explanation of the notification. 
	notify(""Hello world"", ""Some descriptive text""); 
The optional deliveryDateTime is a date or date expression that represents a delivery time in the future; if this argument is omitted or is already past, the notification is shown immediately.
	notify(""Hello world"", ""Some descriptive text"",date(""now + 1 hour""));","Notice(headlineStr[, 詳細,deliveryTime ])
Notice() を使用すると、Notes はホスト Mac のユーザー通知センターに通知を投稿できます。
headerStr は文字列または文字列式であり、通知の見出しになります。
通知(""Hello world"");
オプションのdetailsS​​trは別の文字列または文字列式であり、通知の説明を提供します。
Notice(""Hello world"", ""説明文"");
オプションのdeliveryDateTimeは、将来の配達時間を表す日付または日付式です。この引数が省略されているか、すでに過去になっている場合、通知はすぐに表示されます。
Notice(""Hello world"", ""説明文"",date(""現在 + 1 時間""));"
Number.ceil(),Function,Item,Mathematical,Number,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Number.ceil()
Number.ceil() rounds the source number value of sourceNum up to next whole integer.","Number.ceil()
Number.ceil() は、sourceNum のソース数値を次の整数に丸めます。"
Number.floor(),Function,Item,Mathematical,Number,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Number.floor()
Number.floor() rounds the source number value of sourceNum down to previous whole integer. This is a dot-operator
See also Number.ceil() and Number.round().
If $MyNumber is 3.9 then:
	$MyNumber = $MyNumber.floor(); 
sets $MyNumber to 3. Note unlike normal rounding the value is set downwards to the next integer (i.e. whole number).","Number.floor()
Number.floor() は、sourceNum のソース番号の値を前の整数に切り捨てます。これはドット演算子です
Number.ceil() および Number.round() も参照してください。
$MyNumber が 3.9 の場合:
$MyNumber = $MyNumber.floor();
$MyNumber を 3 に設定します。通常の四捨五入とは異なり、値は次の整数 (つまり、整数) に下方に設定されることに注意してください。"
"Number.format(decimalsNum[, widthNum, padStr]|formatStr)",Function,Item,Formatting,String,false,5.8.0,Baseline,,,,3,true,true,false,false,false,false,false,true,false,,false,"Number.format(decimalsNum[, widthNum, padStr]|formatStr)
Number.format(decimalsNum, widthNum, padStr)
Returns Number as a String, formatted to decimalsN decimal places.
If widthNum is supplied, Number returned additionally left padded with spaces so that widthNum equals the sum of: [padding spaces]+[minus sign]+integer number(s)+decimal point+[decimal numbers]. Note that with widthNum, decimal character is not counted as part of the number. The presence of a minus sign is allowed for.
This function supplements the existing format() and Number.precision() functions.
For example, if $MyNumber is 3.1415927, then
	$MyString = $MyNumber.format(2); is ""3.14""
	$MyString = $MyNumber.format(0); is ""3""
 	$MyString = $MyNumber.format(2,7); is ""&nbsp;&nbsp;&nbsp;3.14"" (3 left padding spaces + 1 integer number + decimal point + 3 decimal numbers = 7)
But if $MyNumber is negative, e.g. -3.1415927, then
 	$MyString = $MyNumber.format(2,7) is ""&nbsp;&nbsp;-3.14"" (2 left padding spaces + minus sign + 1 integer number + decimal point + 3 decimal numbers = 7)
Literal numbers, e.g. 3.1415927, can also be worked with:
	$MyString = 5.1415927.format(2); is ""5.14""
The above works but the following syntax may seem less ambiguous by using parentheses to delimit the literal number:
	$MyString = (5.1415927).format(2); is ""5.14""
	$MyString = (5.1415927).format(1,5); is '&nbsp;&nbsp;5.1' (two left padding spaces + 1 integer number + decimal point + 1 decimal number = 5)
If a group of numbers are being formatted so as to vertically decimal-point align as a column figures, e.g. financial data, it is necessary to know the widthN of 'longest' number to be used, remembering that a negative number adds one to its width count; 45 is width 2, -45 is width 3. In the example below the longest (widthNum) number in a set of currency figures has been worked out stored in a user Number attribute $MaxNumLen. Being currency, 2 decimal places will be enforced, and each number can be evaluated by a common formatting: 
 	[the number].format(2,$MaxLenNum) 
If the widthN for a set of numbers cannot easily be assessed, an alternate option is simply to use a number known to be bigger than all likely width valid. Thus every number, including the longest, gets left-padded but all end up correctly aligned. In the latter example if all numbers are always likely to be less than 20, then $MaxLenNumber could be set to 20, or simply used directly:
 	[the number].format(2,$MaxLenNum) 
There is no easy way to sort a list of numbers on size (i.e. their widthNum), other than by looping the list via List.each() transforming each to a string (using zero decimal places!), saving the String.size of each of these as a number in a new list, then List.nsort and take the last item, .at(-1). As .nsort() sorts on ascending numerical order, the latter will be the size of the longest string (including negative numbers) in the original list. Assuming $MySizeList has all the size strings:
	$MaxLenNumber = ($MySizeList.nsort).at(-); 
Why leave out decimal places when coercing the numbers to strings? 1234.56 is a bigger number than 12.34567, but the latter is the bigger size. However, 1234 is both bigger and 'wider' than 12.
As can be seen, just setting a large arbitrary widthNum might save a lot of messing about!
If the optional padStr is given, this specifies the character used for padding: use of a widthNum argument is expected. The default is a space:
	$MyString = 7.format(0,3); gives ""  7"" 
	$MyString = 7.format(0,3,""0""); gives ""007""
	$MyString = 7.format(0,3,""#""); gives ""##7""
Number.format(""formatString"")
An alternate usage is to supply a quoted formatString argument that is always enclosed in double quotes. 
Supported formatString values (described in more detail further below) are:
* ""l"" (lowercase letter 'L') gives Number as a string using (OS) locale-dependent group and decimal delimiters.
* ""$"" formats Number to a string in the local currency to two decimal points.
* ""$0"" formats Number to a string in the local currency rounded to the nearest whole major unit (i.e. whole dollars only not dollars.cents.)
* ""X"" converts Number to a string in Roman numerals
* ""o"" (lowercase letter 'O') converts Number to a string in the localised ordinal
Localised, locale-dependent, numbers. Using formatString ""l"" (lowercase letter 'L') will return a string of the source Number formatted with (OS) locale-dependent group & decimal delimiters. For example, for the US locale these are a comma and a period; in other locales they may vary. For example, if $MyNumber is 4562781.4, and it is desired to display it as a string with thousands delimited:
	$MyString = $MyNumber.format(""l""); gives ""4,562,781.4""
Of course, depending on the users local, the delimiter may be something else. For instance in a German locale setting, it would be ""4.562.781,4"". For more on such difference see Wikipedia's article on 'Decimal Separators'.
Currency formatting. Two currency-related format strings that can be used, again locale-based, to turn a Number into number string with a currency symbol prefix. Using formatString ""$"" formats the number to the local currency to two decimal points. Thus if $MyNumber is 1246.878:
	$MyString = $MyNumber.format(""$"");  
sets $MyString to ""$1,246.88"" isn the US, ""£1,246.88"" in UK, ""€1,246.88"" in France, etc. Note how the format also respects the local thousands separate, adding a comma after the initial digit.
Use format string ""$0"" if the currency string is needed rounded to the neared whole major unit, e.g. whole dollars and not dollars.cents, :
	$MyString = $MyNumber.format(""$0"");  
which sets $MyString to ""$1,247"" isn the US, ""£1,247"" in UK, ""€1,247"" in France, etc.
Roman Numerals. formatString ""X"" converts Number to a string in Roman numerals. For example, if $MyNumber is 3:
	 $MyString = $MyNumber.format(""X"") 
gives a $MyString value of ""III"".
Ordinals. formatString ""o"" (lowercase letter 'O') converts Number to a string of localised ordinal value. For example, if $MyNumber is 3:
	$MyString = $MyNumber.format(""o"") 
gives a $MyString value of ""3rd"" in English but ""3e"" in French, etc.",
Number.precision(decimalsNum),Function,Item,Formatting,Number,false,5.7.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"Number.precision(decimalsNum)
This function makes it easier to format numbers. The function returns the associated Number-type attributes value rounded to decimalsNum decimal places as Number-type data.. If $MyNumber is 268.3289 then:
	$MyNumber.precision(2); 
…sets $MyNumber to 268.33, whilst:
	$SomeNumber = $MyNumber.precision(2); 
…sets $OtherNumber to 268.33. The above examples are the equivalent of the older syntax using format():
	format($MyNumber,2); 
Literal numbers, e.g. 3.1415927, can also be worked with:
	$MyNumber = 5.1415927.precision(2); is 5.14
The above works but the following syntax may seem less ambiguous by using parentheses to delimit the literal number:
	$MyNumber =(5.1415927).precision(2); is 5.14
Since Number.precision() was added, format() has been supplemented by a Number.format(). The latter, in single input version equates to Number.precision(). However that Number.format() outputs a String-type, even if that can be coerced back to a number .
The .precision() function can be used to add trailing zeroes to a decimal. If $MyNumber is 214.40, it will display as 214.4 which can be unhelpful if this actually represents £214.40. $MyNumber.precision(2) will return 214.40 but be careful about under-the-hood number/string coercion such as can happen in contexts like $DisplayExpression.
	$MyOtherNumber = $MyNumber.precision(2); gives 214.4
	$MyString = $MyNumber.precision(2); gives ""214.40""
In a $DisplayExpression:
	$MyNumber.precision(2); gives ""214.40""
	 $Name+"" : ""+$MyNumber.precision(2); gives ""214.40""
	$Name+ "" : "" + sum(children,$MyNumber).precision(2); 
It may still be easier to use format() as no extra parentheses are required:
	$Name+ "" : "" + format(sum(children,$MyNumber),2);","数値.精度(小数点以下)
この関数を使用すると、数値の書式設定が簡単になります。この関数は、関連付けられた Number タイプの属性値を 10 進数に丸めた小数点以下の桁数を Number タイプのデータとして返します。 $MyNumber が 268.3289 の場合、次のようになります。
$MyNumber.precision(2);
…$MyNumber を 268.33 に設定しますが、次のようになります。
$SomeNumber = $MyNumber.precision(2);
…$OtherNumber を 268.33 に設定します。上記の例は、format() を使用した古い構文と同等です。
フォーマット($MyNumber,2);
リテラル数値、例:3.1415927、以下でも使用できます。
$MyNumber = 5.1415927.precision(2);5.14です
上記は機能しますが、次の構文は、括弧を使用してリテラル数値を区切ることにより、曖昧さが軽減されるように見えます。
$MyNumber =(5.1415927).precision(2);5.14です
Number.precision() が追加されたため、format() は Number.format() によって補完されました。後者は、単一入力バージョンでは Number.precision() と同等です。ただし、 Number.format() は、強制的に数値に戻すことができる場合でも、 String 型を出力します。
.precision() 関数を使用すると、小数点に末尾のゼロを追加できます。$MyNumber が 214.40 の場合、214.4 と表示されますが、これが実際に £214.40 を表す場合は役に立たない可能性があります。$MyNumber.precision(2) は 214.40 を返しますが、$DisplayExpression などのコンテキストで発生する可能性がある内部的な数値/文字列の強制に注意してください。
$MyOtherNumber = $MyNumber.precision(2);214.4を与える
$MyString = $MyNumber.precision(2);「214.40」となります
$DisplayExpression 内:
$MyNumber.precision(2);「214.40」となります
$Name+"" : ""+$MyNumber.precision(2);「214.40」となります
$Name+ "" : "" + sum(children,$MyNumber).precision(2);
余分な括弧が必要ないため、format() を使用するほうが簡単かもしれません。
$Name+ "" : "" + format(sum(children,$MyNumber),2);"
Number.round(),Function,Item,Mathematical,Number,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"Number.round()
Number.round() rounds the value of its chained source number argument to the nearest integer. A partial integer over .50 always round up, everything else rounds down.
See round() for a fuller explanation of the logic and possible usage.
See also Number.ceil() and Number.floor().","Number.round()
Number.round() は、連鎖ソース番号引数の値を最も近い整数に丸めます。.50 を超える部分整数は常に切り上げられ、それ以外は切り捨てられます。
ロジックと可能な使用法の詳細な説明については、round() を参照してください。
Number.ceil() および Number.floor() も参照してください。"
"originalLinkedFrom(scope[, linkTypeStr])",Function,Item,Query Boolean,boolean test,false,8.0.0,Baseline,,,,1,true,false,false,false,false,true,false,true,false,true,false,"originalLinkedFrom(scope[,linkTypeStr])
A test for inbound links. This returns true if the current note corresponding to this is linked from the designated scope, i.e. an item or group of items (defining scope); this is optionally filtered to only links of type linkTypeStr. Put another way, ""Does an inbound link exist to the original current note from item(s)?"". This is especially useful in agents, where this is bound to an alias owned by the agent but the user is interested in links to the original note.
This is effectively only a query term, it returns a Boolean. If you are trying to collect data about the linked note(s), use links() instead.
Ways to define item. The item argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString.
Ways to define group. In group scope, a wildcard ""*"" designator matches all notes and replaces the normal ""all"" group designator.
Links of type 'prototype' are ignored. If using linkType, you must use the value ""*untitled"" to match an 'untitled' type link (rather than """" or ""untitled"").
Thus, to test if any original note using the 'Event' prototype has an inbound link of the 'untitled' link type the agent query would be:
	$Prototype==""Event"" & originalLinkedFrom(""*"", ""*untitled"");  
The logical opposite of this test is originalLinkedTo().","オリジナルLinkedFrom(スコープ[,linkTypeStr])
インバウンドリンクのテスト。これに対応する現在のメモが指定されたスコープ、つまりアイテムまたはアイテムのグループ (スコープを定義) からリンクされている場合、これは true を返します。これはオプションで、linkTypeStr タイプのリンクのみにフィルタリングされます。別の言い方をすると、「アイテムからの元の現在のメモへのインバウンドリンクは存在しますか?」ということです。これは、エージェントが所有するエイリアスにバインドされているが、ユーザーが元のメモへのリンクに興味がある場合、エージェントで特に役立ちます。
これは事実上単なるクエリ用語であり、ブール値を返します。リンクされたノートに関するデータを収集しようとしている場合は、代わりに links() を使用してください。
項目を定義する方法。item 引数は、属性参照でない限り引用符で囲む必要があります。「メモ」と $MyString の比較。
グループを定義する方法。グループスコープでは、ワイルドカード「*」指定子がすべてのノートに一致し、通常の「すべて」グループ指定子を置き換えます。
「プロトタイプ」タイプのリンクは無視されます。linkType を使用する場合は、値「*untitled」を使用して (「」または「untitled」ではなく)「untitled」タイプのリンクと一致させる必要があります。
したがって、「イベント」プロトタイプを使用する元のメモに「無題」リンク タイプの受信リンクがあるかどうかをテストするには、エージェント クエリは次のようになります。
$Prototype==""イベント"" &originalLinkedFrom(""*"", ""*無題"");
このテストの論理的逆は、originalLinkedTo() です。"
"originalLinkedTo(scope[, linkTypeStr])",Function,Item,Query Boolean,boolean test,false,8.0.0,Baseline,,,,1,true,false,false,false,false,true,false,true,false,true,false,"originalLinkedTo(scope[,linkTypeStr])
A test for outbound links. This returns true if the current note corresponding to this is linked from the designated scope, i.e. an item or group of items (defining scope); this is optionally filtered to only links of type linkTypeStr. Put another way, ""Does an outbound link exist from the original current note to item(s)?"". This is especially useful in agents, where this is bound to an alias owned by the agent but the user is interested in links to the original note.
This is effectively only a query term, it returns a Boolean. If you are trying to collect data about the linked note(s), use links() instead.
Ways to define item. The item argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString.
Ways to define group. In group scope, a wildcard ""*"" designator matches all notes and replaces the normal ""all"" group designator.
Links of type 'prototype' are ignored. If using linkType, you must use the value ""*untitled"" to match an 'untitled' type link (rather than """" or ""untitled"").
Thus, to test if any original note using the 'Event' prototype has an outbound link of the 'untitled' link type the agent query would be:
	$Prototype==""Event"" & originalLinkedTo(""*"", ""*untitled"");  
The logical opposite of this test is originalLinkedFrom().","オリジナルLinkedTo(スコープ[,linkTypeStr])
アウトバウンドリンクのテスト。これに対応する現在のメモが指定されたスコープ、つまりアイテムまたはアイテムのグループ (スコープを定義) からリンクされている場合、これは true を返します。これはオプションで、linkTypeStr タイプのリンクのみにフィルタリングされます。別の言い方をすると、「元の現在のメモからアイテムへの外部リンクは存在しますか?」ということです。これは、エージェントが所有するエイリアスにバインドされているが、ユーザーが元のメモへのリンクに興味がある場合、エージェントで特に役立ちます。
これは事実上単なるクエリ用語であり、ブール値を返します。リンクされたノートに関するデータを収集しようとしている場合は、代わりに links() を使用してください。
項目を定義する方法。item 引数は、属性参照でない限り引用符で囲む必要があります。「メモ」と $MyString の比較。
グループを定義する方法。グループスコープでは、ワイルドカード「*」指定子がすべてのノートに一致し、通常の「すべて」グループ指定子を置き換えます。
「プロトタイプ」タイプのリンクは無視されます。linkType を使用する場合は、値「*untitled」を使用して (「」または「untitled」ではなく)「untitled」タイプのリンクと一致させる必要があります。
したがって、「イベント」プロトタイプを使用する元のメモに「無題」リンク タイプの送信リンクがあるかどうかをテストするには、エージェント クエリは次のようになります。
$Prototype==""イベント"" &originalLinkedTo(""*"", ""*無題"");
このテストの論理的逆は、originalLinkedFrom() です。"
paste(),Function,Document,Data manipulation,String,false,11.5.0,11.5.0,,11.5.0,,,false,false,false,false,false,false,false,false,false,,false,"paste()
The operator paste() returns the String contents of the OS' clipboard.
For example:
	$MyString = paste();","ペースト()
演算子 past() は、OS のクリップボードの文字列の内容を返します。
たとえば:
$MyString = ペースト();"
play(soundNameStr),Function,Item,Data manipulation,success boolean,false,7.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"play(soundNameStr)
This causes the stated OS alert sound to be played, the sound name being supplied as soundNameStr. To play the default error sound:
	play(""Basso""); 
The soundNameStr name is case-sensitive.","play(サウンド名Str)
これにより、指定された OS アラート サウンドが再生され、サウンド名が soundNameStr として指定されます。デフォルトのエラー音を再生するには:
play(""バッソ"");
soundNameStr 名では大文字と小文字が区別されます。"
"pow(sourceNum, powerNum)",Function,Item,Mathematical,Number,false,5.10.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"pow(sourceNum, powerNum)
pow() returns the sourceNum raised to the powerNum.
	$MyNumber = pow(3,4); 
returns 81.","pow(sourceNum, powerNum)
pow() は、powerNum まで引き上げられたsourceNum を返します。
$MyNumber = pow(3,4);
81を返します。"
radians(degreesNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"radians(degreesNum)
radians() converts its degreesNum, in degrees, to radians.
See also degrees() which converts an angle in radians to degrees.
	$MyNumber = radians(90); 
returns '1.570796327' for an input of 90.","ラジアン(度Num)
radians() は、degreeNum を度単位でラジアンに変換します。
ラジアン単位の角度を度に変換するdegrees()も参照してください。
$MyNumber = ラジアン(90);
90 の入力に対して「1.570796327」を返します。"
rand([maxNumber]),Function,Item,Mathematical,Number,false,4.0.0,Baseline,9.5.2,,,1,false,false,false,false,false,false,false,true,false,,false,"rand([maxNumber])
rand()
rand
rand() returns a pseudo-random number between 0 and 1. No argument is required.
rand([maxNumber])
Supplying an optional parameter maxNumber, which must be an integer, returns a random integer between 0 and maxNumber-1. This can be useful when wanting random list items, noting that list items are addressed using zero-based integers.
N.B. if working with list-based items, consider the list.randomItem() operator, which abstracts away the need to know the size of the list. Essentially it encapsulates calling list.at(rand(list.count)), so much easier to write/use
Getting 1-based ranges vs. zero-based ranges of values
Consider the original round() method:
	$MyNumber=round(rand()*10); 
$MyNumber will be set to one of eleven integers in the range 0 through to 10. But, what if the '10' argument about is actually a child count:
	$MyNumber=round(rand()*$ChildCount); 
If the $ChildCount was 10 and $MyNumber were used to fetch a random child using $SiblingOrder($MyNum) the process would fail if $MyNumber were zero as $SiblingOrder numbers from 1. Indeed, in this case the need is for ten integers, one through to ten.
Previously, 1-based range can be achieved:
	$MyNumber=round(rand()*(10-1))+1; 
	$MyNumber=round(rand()*($ChildCount-1))+1; 
If the main input is 10, by subtracting 1 the process returns a randomised integer in in the range 0-9 (ten numbers) and then adding back 1 shifts the value range to 1-10.
Using the newer rand(maxNumber) method the above becomes:
	$MyNumber=round(rand($ChildCount-1))+1; 
This is why the list.randomItem() may be an easier clear approach.","rand([最大数値])
ランド()
ランド
rand() は 0 から 1 までの擬似乱数を返します。引数は必要ありません。
rand([最大数値])
オプションのパラメータ maxNumber (整数である必要があります) を指定すると、0 から maxNumber-1 までのランダムな整数が返されます。これは、リスト項目がゼロから始まる整数を使用してアドレス指定されることに注意して、ランダムなリスト項目が必要な場合に役立ちます。
注：リストベースの項目を扱う場合は、リストのサイズを知る必要性を抽象化する list.randomItem() 演算子を検討してください。基本的に list.at(rand(list.count)) の呼び出しをカプセル化するので、記述/使用がはるかに簡単になります。
1 から始まる値の範囲と 0 から始まる値の範囲の取得
元のround()メソッドを考えてみましょう。
$MyNumber=round(rand()*10);
$MyNumber は、0 ～ 10 の範囲の 11 個の整数のいずれかに設定されます。しかし、引数 '10' が実際には子の数である場合はどうなるでしょうか。
$MyNumber=round(rand()*$ChildCount);
$ChildCount が 10 で、$MyNumber が $SiblingOrder($MyNum) を使用してランダムな子をフェッチするために使用された場合、$MyNumber が 1 からの $SiblingOrder 番号として 0 の場合、プロセスは失敗します。実際、この場合、1 から 10 までの 10 個の整数が必要です。
以前は、1 ベースの範囲を実現できました。
$MyNumber=round(rand()*(10-1))+1;
$MyNumber=round(rand()*($ChildCount-1))+1;
メイン入力が 10 の場合、1 を減算することで、プロセスは 0 ～ 9 (10 個の数値) の範囲のランダム化された整数を返し、その後 1 を加算して値の範囲を 1 ～ 10 にシフトします。
新しい rand(maxNumber) メソッドを使用すると、上記は次のようになります。
$MyNumber=round(rand($ChildCount-1))+1;
これが、 list.randomItem() の方が簡単で明確なアプローチである理由です。"
require(featureName),Function,Document,Document configuration,success boolean,false,9.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"require(featureName)
The require() operator adds the /Hints container and its subsidiary containers. It is equivalent to selecting Built In Hints from the File menu. If any of the containers already exists, that container is left unchanged. For example:
	require(""Hints""); 
featureName is a mandatory argument. It is a literal string and case-sensitive.
""Hints"" is currently the only featureName value recognised by require(). But, this method allows for other values to be added in the future as need arises.
require() accepts four case-sensitive arguments:
* require(""Templates"") adds the built-in configuration /Templates container. It is equivalent to the container created when first adding a built-in template from the File menu.
* require(""Prototypes"") adds the /Prototypes container. It is equivalent to the container created when first adding a built-in prototype from the File menu.
* require(""Preview"") displays the text pane sub-tab selector above the text pane (the new document default is to hide the selector).
* require(""NoPreview"") hides the text pane selector, i.e. the reverse of the above and the default for a new TBX document.","require(機能名)
require() オペレーターは、/Hints コンテナーとその補助コンテナーを追加します。これは、「ファイル」メニューから「組み込みヒント」を選択するのと同じです。いずれかのコンテナがすでに存在する場合、そのコンテナは変更されません。たとえば:
require(""ヒント"");
featureName は必須の引数です。これはリテラル文字列であり、大文字と小文字が区別されます。
""Hints"" は現在、require() によって認識される唯一の featureName 値です。ただし、この方法では、将来、必要に応じて他の値を追加できます。
require() は、大文字と小文字を区別する 4 つの引数を受け入れます。
* require(""Templates"") は、組み込み構成 /Templates コンテナーを追加します。これは、最初に [ファイル] メニューから組み込みテンプレートを追加したときに作成されるコンテナと同等です。
* require(""Prototypes"") は /Prototypes コンテナを追加します。これは、最初に [ファイル] メニューから組み込みプロトタイプを追加したときに作成されるコンテナーと同等です。
* require(""Preview"") は、テキスト ペインの上にテキスト ペインのサブタブ セレクターを表示します (新しいドキュメントのデフォルトでは、セレクターは非表示になります)。
* require(""NoPreview"") はテキスト ペイン セレクターを非表示にします。つまり、上記の逆で、新しい TBX ドキュメントのデフォルトです。"
return,Statement,Document,Data manipulation,declaration,false,9.1.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,true,"return
return() never use trailing parentheses with this operator!
The return statement is only used inside a function, and indicates the value to be passed back to the code calling the function at which point the function stops. Atypically, trailing empty parentheses must not used with return. The value passed by return is defined by the rest of code line following the return statement
See further explanation of the use of return within functions, including how the returned value is coded.","戻る
return() では、この演算子で末尾括弧を使用しないでください。
return ステートメントは関数内でのみ使用され、関数を呼び出すコードに返される値を示し、その時点で関数が停止します。通常は、末尾の空の括弧を return と一緒に使用しないでください。return によって渡される値は、return ステートメントに続くコード行の残りの部分によって定義されます。
戻り値のコード化方法など、関数内での return の使用に関する詳細な説明を参照してください。"
"rgb(redNum, greenNum, blueNum)",Function,Item,Color,String,false,4.0.0,Baseline,,,,,true,false,false,false,false,false,false,false,false,,false,"rgb(redNum, greenNum, blueNum)
Creates a Color type: its arguments are integers ranging from 0 to 255 or an expression or attribute reference resolving to a number in this range. The value set is in hex form. For example:
	$MyColor = rgb(255,0,0); sets a value of ""#ff0000""
The individual channels of an RGB colour can be set or read using the '.red', '.green' and '.blue' Color-type data operators.","rgb(赤の数、緑の数、青の数)
Color タイプを作成します。その引数は 0 ～ 255 の範囲の整数、またはこの範囲の数値に解決される式または属性参照です。値セットは 16 進形式です。たとえば:
$MyColor = rgb(255,0,0);「#ff0000」の値を設定します
RGB カラーの個々のチャネルは、「.red」、「.green」、および「.blue」カラータイプのデータ演算子を使用して設定または読み取りできます。"
round(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,,true,false,true,false,false,false,false,false,false,,false,"round(sourceNum)
round() rounds the value of its sourceNum argument to the nearest integer. Note that there is now a dot-operator version (with the same behaviour) Number.round().
The Number.format, Number.precision and format() functions all round numbers in this manner when shortening numbers during formatting. A partial integer over .50 always round up, everything else rounds down. Thus:
	$MyNumber = round(4.0); gives 4
	$MyNumber = round(4.2); gives 4
	$MyNumber = round(4.5); gives 5
	$MyNumber = round(4.7); gives 5
The round function with work on string literal or String attribute values that are just numbers:
	$MyNumber = round(""4.2""); gives 4
	$MyNumber = round(""4.7""); gives 5
	$MyString = round(4.2); gives ""4""
	$MyString = round(4.7); gives ""5""
	$MyString = round(""4.2""); gives ""4""
	$MyString = round(""4.7""); gives ""5""
There are also functions to always force rounding upwards (ceiling)—see ceil(), or to force rounding downwards (floor)—see floor().
For a practical example, assume you would like to round you calculation (upward) to the nearest 100, so if the calculation output is 167 it should be 200, for a result of 540 a result of 600, and so on. This can be done like so:
	$MyNumber = 100*ceil($MyNumber/100); 
whereas if you used round(), as in:
	$MyNumber = 100*round($MyNumber/100); 
the result would vary depending on whether $MyNumber started above or below the nearest 50. An opposite of the first example, i.e. where everything rounds downwards to the nearest 100 can be done using floor():
	$MyNumber = 100*floor($MyNumber/100);","ラウンド(ソース番号)
round() は、sourceNum 引数の値を最も近い整数に丸めます。現在、ドット演算子バージョン (同じ動作) Number.round() があることに注意してください。
Number.format、Number.precision、および format() 関数は、書式設定中に数値を短縮するときにこの方法で数値を丸めます。.50 を超える部分整数は常に切り上げられ、それ以外は切り捨てられます。したがって:
$MyNumber = ラウンド(4.0);4を与える
$MyNumber = ラウンド(4.2);4を与える
$MyNumber = ラウンド(4.5);5を与える
$MyNumber = ラウンド(4.7);5を与える
単なる数値である文字列リテラルまたは文字列属性値を処理するラウンド関数:
$MyNumber =round(""4.2"");4を与える
$MyNumber =round(""4.7"");5を与える
$MyString = ラウンド(4.2);「4」を与える
$MyString = ラウンド(4.7);「5」を与える
$MyString =round(""4.2"");「4」を与える
$MyString =round(""4.7"");「5」を与える
また、常に上向きの丸めを強制する関数 (ceil() を参照) や、強制的に下向きの丸めを行う関数 (floor() を参照) もあります (floor() を参照)。
実際の例として、計算を最も近い 100 に四捨五入するとします。つまり、計算出力が 167 の場合は 200、結果が 540 の場合は 600 というようになります。これは次のようにして実行できます。
$MyNumber = 100*ceil($MyNumber/100);
一方、round() を使用した場合は、次のようになります。
$MyNumber = 100*round($MyNumber/100);
結果は、$MyNumber が最も近い 50 より上か下かによって異なります。最初の例の逆、つまり、すべてを最も近い 100 に切り下げる場合は、floor() を使用して実行できます。
$MyNumber = 100*フロア($MyNumber/100);"
"runCommand(commandStr[, inputsStr, dirStr])",Function,Item,Data manipulation,source context dependent,false,4.0.0,Baseline,,,,3,true,false,false,false,true,false,false,true,false,,false,"runCommand(commandStr, inputStr)
runCommand(commandStr, inputStr, dirStr) /runCommand(commandStr, , dirStr)
The operator, runCommand(), lets rules and actions use the command line with an assumed working directory of the users OS home folder: see below for using dirStr for setting a different context of execution. The full detail of command line is out of scope for aTbRef and should be researched online. For novices, a good approach is to make a command line work in the macOS Terminal and only then try to use it via runCommand(). Similarly, leave customising the input via attribute/variable values until after a fixed string is working as this makes it much easier to troubleshoot the correct issue.
Understanding the latter can help avoid trying to echo data into a command within the 'commandStr' string. See the 'quotify' example further below.
runCommand(commandStr)
The operator passes commandStr to the OS's Unix shell. The new shell processes commandStr. The process's standard output (stdout) is returned as the result of calling runCommand(). However, there is no requirement for a left-side argument if the output of runCommand() is needed, e.g. if it is just a true/false success/fail message. 
For example, to set the $Text of a note to a listing of all files/folders in the users home directory ~, run this code as a stamp:
	$Text = runCommand(""ls -a""); 
Whereas a stamp:
	runCommand(""ls -a""); 
would run the same code but the listing would not be used. Not useful in this example but if the need it just to run a script where the reult is not of interest, runCommand() can called on its own.
runCommand(commandStr, inputStr)
The operator passes commandStr to the OS's Unix shell. The new shell process receives inputsStr, if any, as its standard input stdin. The process's standard output (stdout) is returned as the result of calling runCommand(). The above syntax, in one-line command line usage, can also be thought of as: runCommand(command, stdIn).
For example, the wc (word count) command can take a file or literal string as an input. On the command line, an echo command would be needed to pipe the literal string to wc, like so:
	echo ""hello world"" | wc -w 
to get the result '2' (two words in the input string) in Terminal. To do this via runCommand():
	runCommand(""wc -w"",""hello world""); 
But, you don't see the returned value unless you pass the output of the command to something. a number is expected here so $MyNumber is sensible start:
	$MyNumber = runCommand(""wc -w"",""hello world""); 
and $MyNumber will now have the value '2'.
Or, if using attributes or variables to pass in the data:
	var:string vCmd = ""wc -w"";
	var:string vArgs= $MyString; // which has the text whose word count we want
	$MyNumber = runCommand(vCmd, vArgs);
Whether the desired command line tool accepts inputs on stdIn is something the user needs to understand before using this command.
IMPORTANT: Note that if using inputsStr, to pass arguments otherwise normally passed as part of commandStr, it is necessary to prefix the command used in commandStr with 'xargs' so that the arguments passed via stdin are correctly handled. Thus if using the command ""mv"" in commandStr with arguments in inputStr, the commandStr needs to be ""xargs mv"". This is shown in examples further below under heading ""Working around using literal strings as inputs"".
Setting the working directory using dirStr
runCommand(commandStr, inputStr, dirStr)
Where is the working directory location assumed for executing scripts?
If the optional dirStr is specified as a POSIX path, it sets the working directory in which commandStr is executed. Otherwise, by default, the working directory is the user's home folder , i.e. ~ or /Users/[shortusername] or in full form.
If using dirStr, an inputStr must be provided even if only an empty string: runCommand(commandStr, """", dirStr).
dirStr can be passed either as a full path from drive root or using the tilde (~) notation. dirStr should not include a forward slash at the end: e.g. ""~/test"" not ""~/test/"". The last part of the supplied path should be the folder which is to be the context of execution. Thus ""~/test"" implies a folder test that is a child folder of the users home folder.
Working around using literal strings as inputs
Any or all of commandStr, inputsStr, or dirStr may use attribute or variable values in place of literal strings. Thus:
	runCommand(""xargs mv"", '""x/tb 1.png"" ""y/tb 1.png""', ""~/test"") 
will move file 'tb 1.png' from sub-folder 'x' at path '~/test' to sub-folder 'y'. (Note: the source and target paths need quoting because the file 'tb 1.png' has a space in its name and the paths would otherwise be mis-parsed by the shell. If the various strings.). Placing the start and end relative paths into $SourcePath and $TargetPath, the command above could also be written clearly/verbosely as:
	var:string vCmd = ""mv"";
	var:string vCmd += '""'+$SourcePath+'"" ""'+$TargetPath+'""';
	vFolder = ""~/test"";
	runCommand(vCmd, """", vFolder);
or, the same but passing some of the arguments as inputs using the xargs method:
	var:string vCmd = ""xargs mv"";
	var:string vArgs = '""'+$SourcePath+'"" ""'+$TargetPath+'""';
	vFolder = ""~/test"";
	runCommand(vCmd, vArgs, vFolder);
Further examples
If a note called ""Jane Doe"" is dropped on a container with this OnAdd action:
	$MyResult = runCommand(""sendmail -f ""+$Email+"" ""+$Email(parent), ""Subject:""+$Name+""\nHello\n."") 
This assumes both dropped and container notes have a valid email address in Email. If so, Jane Doe will get an email with subject line ""Jane Doe"" and body text ""Hello""; the email will be from the dropped note's $Email address and to the container's $Email address. In the above example:
	commandStr: sendmail - f jade@doe.com someone@other.com' 
	inputsStr (i.e. via stdin): ""Subject: Jane Doe\nHello\n."" 
User attribute 'MyResult' will receive any message back from standard output.
The runCommand() operator does not require a left-side to the expression where the result of the command line is not needed by Tinderbox. Thus the same example as above can run as:
	runCommand(""sendmail -f ""+$Email+"" ""+$Email(parent), ""Subject:""+$Name+""\nHello\n."") 
Bear in mind that in this latter case there is no way of knowing if the command executed successfully.
To use external commands like above you may need to check the encoding of the strings you extract from your TBX attributes. Do not forget to allow for characters like spaces/quotes/apostrophes in attribute values; these will invariably need escaping for safe use in a command line using operators like urlEncode():
	$MyResult=runCommand(""/usr/bin/curl -d 'status=""+urlEncode($Name)+""' -u myusername:mypassword https://twitter.com/statuses/update.atom""); 
In the above, if the value of $Name were ""Mark's project"", the use of urlEncode() will ensure the string passed to the command line is actually ""Mark%27s%20project"".
exportedString() can also help with ensuring the necessary encoding, allowing a template to be used to help with formatting the string passed into the command.
Exactly where you do/do not need to encode attribute values will depend on the syntax of the particular operation you are performing.
To help get around issues of quoting, a note's text (or other string attribute) can be used for either or both arguments. Consider a note called 'quotify' holding this command line:
	sed 's:""\([^""]*\)"":“\1”:g' 
A stamp might then hold this code:
	$Text = runCommand($Text(""quotify""),$Text); 
This effectively adds a menu item to the Stamps to change ordinary double quotes to their 'smart form', allowing the process to be run once, on demand, avoiding repeat use every agent cycle as would happen if using a rule or agent action.
Dealing with inline quote characters
Because input arguments are parsed for regular expressions (by the OS, not Tinderbox), it may be possible to use the '\dnn' form described here to work around the lack of escaping from single double quotes within strings.
Slow running target processes
This operator was designed for rapid call+response, not as a call-and-wait process so should not be used for process that are slow to return data. There is no fixed timeout but it is probably c.30 seconds. Slow to complete processes should be set to write to disk and the data subsequently read from disk, using two separate actions.
Debugging runCommand() calls
See the dubugging section article on Use of the Command Line.
Legacy only
Using just command on its own is akin to using the back-tick action syntax.",
"seconds(startDate, endDate)",Function,Item,Date-time,Number,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"seconds(startDate, endDate) 
returns the Number of whole seconds that elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA has time 12:30:00 and $DateB has time 12:31:30, then:
	$MyNumber = seconds($DateA,$DateB); 
sets $MyNumber to 90.","秒(開始日、終了日)
startDate と endDate の間に経過した整数の秒数を返します。endDate が startDate より前の場合、結果は負になります。
$DateA の時刻が 12:30:00、$DateB の時刻が 12:31:30 の場合、次のようになります。
$MyNumber = 秒($DateA,$DateB);
$MyNumber を 90 に設定します。"
select(),Function,Group,Data manipulation,n/a - no return,false,9.6.0,Baseline,,,,1,true,false,false,false,false,true,false,false,false,,false,"select()
The select() operator de-selects all items currently selected in the document. The usage is simple:
	select(); 
Because using select with arguments has a distinct and different function is it listed separately: select(scope).","選択()
select() 演算子は、ドキュメント内で現在選択されているすべての項目の選択を解除します。使い方は簡単です:
選択();
引数を指定して select を使用すると、明確に異なる機能があるため、select(scope) として個別にリストされます。"
select(scope),Function,Group,Data manipulation,List,false,9.6.0,Baseline,,,,1,true,false,true,false,false,true,false,false,false,,false,"select(scope)
The select(scope) operator allows the document's current (UI) focus to be shifted. The scope argument defines a list of one or more notes. The argument may be a literal string, or the value of an attribute or variable.
	select([/Note A;/Note B]); 
	select($MyList); 
	select(vItems); 
This specialist operator assist in the scenario where, whilst running action code, it is necessary to change the selection such that the locus of 'this' changes. Some action code operators only address the currently selected item(s). The select(scope) operator allows the selection to be changed on the fly without the user having to do so via the UI.
Because using select without arguments has a distinct and different function is it listed separately: select().","選択(スコープ)
select(scope) 演算子を使用すると、ドキュメントの現在の (UI) フォーカスを移動できます。スコープ引数は、1 つ以上のメモのリストを定義します。引数はリテラル文字列、または属性または変数の値です。
select([/メモ A;/メモ B]);
選択($MyList);
select(vItems);
この専門オペレーターは、アクション コードの実行中に、「this」の軌跡が変わるように選択を変更する必要があるシナリオを支援します。一部のアクション コード演算子は、現在選択されている項目のみを処理します。select(scope) 演算子を使用すると、ユーザーが UI を介して変更する必要がなく、オンザフライで選択内容を変更できます。
引数なしで select を使用すると、明確に異なる関数が使用されるため、select() として個別にリストされます。"
"show(msgString[, backgroundColor[, colorString, [durationNum]]])",Function,Item,Data manipulation,success boolean,false,9.5.2,Baseline,,,,3,true,false,true,false,false,false,false,false,false,,false,"show(msgString)
show(msgString, backgroundColor)
show(msgString, backgroundColor, colorString)
show(message[ foreground, background, duration)
The show(msgString) function allows a plain-text message to be shown in the front window's message placard. The source text, msgString, may be a literal string, variable or a String-type attribute value.
show() allows 3 further optional arguments.
The optional backgroundColor argument may be used on its own with or without the optional third colorString argument. But if the colorString argument is used, then the backgroundColor argument must be given as well. The same holds for the optional durationNum argument. If passed, durationNum specifies the number of seconds for which to display the message. Setting a duration can be useful if wanted to show a series of short messages, each in a discrete manner.
The full features and limitations of messages sent to the placard are described separately under the Message placards article.
The String.show() operator offers a dot-operator alternative.","show(msgString)
show(msgString、backgroundColor)
show(msgString、backgroundColor、colorString)
show(メッセージ[前景、背景、継続時間)
show(msgString) 関数を使用すると、フロント ウィンドウのメッセージ プラカードにプレーンテキスト メッセージを表示できます。ソース テキスト msgString は、リテラル文字列、変数、または文字列タイプの属性値にすることができます。
show() では、さらに 3 つのオプションの引数を使用できます。
オプションのbackgroundColor引数は、オプションの3番目のcolorString引数の有無にかかわらず、単独で使用できます。ただし、colorString 引数を使用する場合は、backgroundColor 引数も指定する必要があります。オプションのdurationNum引数にも同じことが当てはまります。渡された場合、durationNum はメッセージを表示する秒数を指定します。一連の短いメッセージを個別に表示したい場合は、期間を設定すると便利です。
プラカードに送信されるメッセージの完全な機能と制限については、「メッセージ プラカード」の記事で別途説明します。
String.show() 演算子は、ドット演算子の代替手段を提供します。"
"similarTo(item[, notesNum])",Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,2,true,false,false,false,false,false,false,true,false,,true,"similarTo(item,notesNum)
Returns Boolean true if item is amongst the (optionally notesNum notes) most similar to the current note.
The item argument must be quoted unless an attribute reference. Ways to define item.
Similarity is based on several factors, including:
* the text of the note
* the note title
* any text contained in user attributes
In addition, weighting is applied for:
* notes having the same prototype
* notes having roughly similar amounts of text
This data replicates that seen in the similar tab of Get Info and in the export code ^^similarTo()^^.
Legacy issues
This operator replaces the legacy #similarTo query operator and what in old version's agent query creation pop-ups and Find dialogs was listed as ""is similar to"".","類似先(項目,メモ番号)
項目が現在のノートに最も似ている (オプションでnotesNum ノート) 内にある場合、ブール値 true を返します。
item 引数は、属性参照でない限り引用符で囲む必要があります。項目を定義する方法。
類似性は、次のようないくつかの要因に基づいています。
* メモのテキスト
* ノートのタイトル
* ユーザー属性に含まれる任意のテキスト
さらに、重み付けは以下に適用されます。
* 同じプロトタイプを持つメモ
* ほぼ同じ量のテキストを含むメモ
このデータは、「情報を見る」の同様のタブとエクスポート コード ^^similarTo()^^ に見られるものを再現しています。
従来の問題
この演算子は、従来の #similarTo クエリ演算子と、古いバージョンのエージェント クエリ作成ポップアップおよび検索ダイアログで「類似している」としてリストされていたものを置き換えます。"
sin(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"sin(sourceNum)
sin() converts its sourceNum, in radians, to the sine of that value.
	$MyNumber = sin(3) 
returns '0.1411200081' for an input of 3 radians.","sin(ソース番号)
sin() は、そのsourceNum (ラジアン単位) をその値のサインに変換します。
$MyNumber = sin(3)
3 ラジアンの入力に対して「0.1411200081」を返します。"
"speak(MessageStr[, voiceNameStr])",Function,Item,Data manipulation,success boolean,false,9.5.0,Baseline,,,,2,true,false,true,false,false,false,false,true,false,,false,"speak(MessageStr[, voiceNameStr])
speaks a MessageStr string using Mac text-to-speech. If another string is being spoken, the new phrase is spoken after the current phrase is complete:
	speak(""Hello""); 
MessageStr can be a variable or attribute reference:
	speak($Text); 
An optional second argument voiceNameStr identifies the voice the speech synthesiser should use. If the nominated voiceNameStr is not present no sound is played. The closing parentheses are only needed if the extra argument is being passed:
	speak($Text.,""Tessa""); 
See also String.speak().","speech(MessageStr[, voiceNameStr])
Mac のテキスト読み上げを使用して MessageStr 文字列を読み上げます。別の文字列が話されている場合は、現在のフレーズが完了した後に新しいフレーズが読み上げられます。
話す(「こんにちは」);
MessageStr には変数または属性参照を指定できます。
話す($Text);
オプションの 2 番目の引数 voiceNameStr は、音声合成装置が使用する音声を識別します。指定された voiceNameStr が存在しない場合、サウンドは再生されません。右括弧は、追加の引数が渡される場合にのみ必要です。
speech($Text.,""テッサ"");
String.speak() も参照してください。"
sqrt(sourceNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"sqrt(sourceNum)
sqrt() computes the square root of its sourceNum.
	$MyNumber = sqrt(9); 
sets $MyNumber to 3.","sqrt(ソース番号)
sqrt() は、sourceNum の平方根を計算します。
$MyNumber = sqrt(9);
$MyNumber を 3 に設定します。"
"stamp([scope, ]stampName)",Function,Group,Data manipulation,success boolean,false,8.1.0,Baseline,9.0.0,,,2,true,false,false,false,false,false,false,true,false,,false,"stamp([scope, ]stampName)
stamp(stampName)
This operator applies the stamp stampName is applied to the this note, i.e. the current note. So:
	stamp(""Do Stuff""); 
runs the stamp called ""Do Stuff"" on the current note.
stamp(scope, stampName)
scope is an optional argument that can be a single note or a group or designator defined in any of the normal methods (literal, designator, expression).
If a scope argument is supplied the stamp named stampName is applied discretely to each of scope items (defining scope). So:
	stamp(""SomeNote"",""Do Stuff""); 
runs the stamp called ""Do Stuff"" on the note with the unique $Name ""Some Note"". Or:
 	stamp($MyList,""Do Stuff""); 
runs the stamp called ""Do Stuff"" on every note described by an item in the list stored in the value of $MyList for this note.","スタンプ([スコープ, ]スタンプ名)
スタンプ(スタンプ名)
この演算子は、スタンプ stampName をこのノート、つまり現在のノートに適用します。それで:
stamp(""Do Stuff"");
現在のノートに「Do Stuff」というスタンプを実行します。
スタンプ(スコープ、スタンプ名)
スコープはオプションの引数で、単一のメモ、または通常のメソッド (リテラル、指定子、式) のいずれかで定義されたグループまたは指定子にすることができます。
スコープ引数が指定されている場合、stampName という名前のスタンプがスコープ項目 (スコープの定義) のそれぞれに個別に適用されます。それで:
stamp(""SomeNote"",""Do Stuff"");
は、一意の $Name ""Some Note"" を持つノートに ""Do Stuff"" というスタンプを実行します。または:
スタンプ($MyList,""Do Stuff"");
このノートの $MyList の値に格納されているリスト内の項目によって記述されるすべてのノートに対して、「Do Stuff」というスタンプを実行します。"
String.beginsWith(matchStr),Function,Item,Data manipulation,boolean test,false,6.4.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.beginsWith(matchStr)
String.beginsWith() returns Boolean true if the chained string begins with the literal string matchStr. Note that matchStr cannot be a regular expression, only literal string values are allowed.
For example, if $MyString is ""I do not like green eggs and ham"":
	$MyString.beginsWith(""I do"")  returns true 
	$MyString.beginsWith(""Hello"")  returns false 
Also, with string literals:
	(""There are gentlemen now abed."").beginsWith(""There are"")  returns true 
	(""There are gentlemen now abed."").beginsWith(""Hello"")  returns false 
This operator searches for literal strings, not regular expressions. Matches are case sensitive
	(""There are gentlemen now abed."").beginsWith(""there are"")  returns false 
See also String.endsWith(). If you need to search a String for a regular expression, use String.contains().","String.beginsWith(matchStr)
String.beginsWith() は、連鎖文字列がリテラル文字列 matchStr で始まる場合、ブール値 true を返します。matchStr には正規表現を使用できません。リテラル文字列値のみが許可されることに注意してください。
たとえば、$MyString が「緑色の卵とハムは好きではありません」の場合:
$MyString.beginsWith(""I do"") は true を返します
$MyString.beginsWith(""Hello"") は false を返します
また、文字列リテラルの場合:
(「今寝ている紳士がいます。」).beginsWith(""そこにいます"") は true を返します
(「今、紳士たちが寝ています。」).beginsWith(""こんにちは"") は false を返します
この演算子は、正規表現ではなく、リテラル文字列を検索します。一致では大文字と小文字が区別されます
(「今、寝ている紳士がいます。」).beginsWith(「そこにいます」) は false を返します
String.endsWith() も参照してください。正規表現の文字列を検索する必要がある場合は、String.contains() を使用します。"
String.capitalize(),Function,Item,Formatting,String,false,5.9.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.capitalize()
String.capitalize
Returns the referenced string, transforming the initial letter of each word to a capital letter and leaving all other characters unchanged.
The function can be chained both to string data and to string literals:
	$MyString.capitalize() 
	""my new title"".capitalize() 
The latter gives ""My New Title"".
The trailing parentheses may be omitted:
	$MyString.capitalize 
If 'title case' is required from a mixed case string, chain with .lowercase():
	$MyString = ""my nEW title"".lowercase.capitalize; 
sets $MyString to ""My New Title"".
Bear in mind the latter will not deal with all capital acronyms (UPS, UNHCR) or CamelCase words (AstroTurf, FedEx).
Functionally equivalent to capitalize().
The .capitalize() method may also be used on Lists or Sets. Consider the list [Ant;BEE;Cow] when stored in $MyList:
	$MyList = $MyList.capitalize; 
… giving [Ant;Bee;Cow].","String.capitalize()
文字列.大文字化
各単語の最初の文字を大文字に変換し、他の文字はすべて変更せずに、参照された文字列を返します。
この関数は、文字列データと文字列リテラルの両方にチェーンできます。
$MyString.capitalize()
「私の新しいタイトル」.capitalize()
後者は「私の新しい称号」を与えます。
末尾の括弧は省略できます。
$MyString.capitalize
大文字と小文字が混合された文字列から「タイトルの大文字」が必要な場合は、. lowercase() でチェーンします。
$MyString = ""私の新しいタイトル"". lowercase.capitalize;
$MyString を「私の新しいタイトル」に設定します。
後者は、すべての大文字の頭字語 (UPS、UNHCR) やキャメルケースの単語 (AstroTurf、FedEx) を扱うわけではないことに注意してください。
機能的にはcapitalize()と同等です。
.capitalize() メソッドはリストまたはセットでも使用できます。$MyList に保存されるリスト [Ant;BEE;Cow] を考えてみましょう。
$MyList = $MyList.capitalize;
… [アリ;ミツバチ;ウシ] を与えます。"
String.captureJson(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,11.5.0,11.5.0,,,false,true,false,false,false,false,false,false,false,,false,"String.captureJson()
String.captureJson
From v11.5.0, the .captureJson() operator is deprecated. That proved to be a wrong step; embedding json in $Text (or within other text) is not useful and better solutions are available.

Attempts to parse the string as fully/partially JSON and fails if unsuccessful. The parsed JSON is saved as the current JSON (stream) object. 
Essentially, this re-scopes the current stream so that it contains only the contents of the first section of JSON detected within the original stream. The focus of the stream parsing is set to the beginning of the extracted JSON code.
Only one JSON object may be current at any time. If the source stream contains multiple discrete JSON code sections, only the first is detected/used.
To actually work with the JSON data's values, use JSON.json[] and its sibling operators.
In the most likely scenario, working on $Text, .captureJson() is needed only if $Text contains both JSON and other text:
	$MyResult = $Text.captureJson().json[""somekey""]; 
But, if the whole of $Text is a single block of (complete) JSON, use .json[] directly. So:
	$MyResult = $Text.json[""somekey""]; 
Legacy usage
Prior to v10.0.2, the operator used the casing .captureJSON(). This version is still silently supported (and is coloured in supported input boxes). However, .captureJson() is not the approved casing and existing code should be updated to this as legacy support may stop at any time.","String.captureJson()
String.captureJson
v11.5.0 以降、.captureJson() 演算子は非推奨になりました。それは間違ったステップであることが判明しました。$Text (または他のテキスト内) に json を埋め込むことは役に立たず、より良い解決策が利用可能です。

文字列を完全または部分的に JSON として解析しようとしますが、失敗すると失敗します。解析された JSON は、現在の JSON (ストリーム) オブジェクトとして保存されます。
基本的に、これにより現在のストリームのスコープが変更され、元のストリーム内で検出された JSON の最初のセクションの内容のみが含まれるようになります。ストリーム解析のフォーカスは、抽出された JSON コードの先頭に設定されます。
常に 1 つの JSON オブジェクトのみが最新になります。ソース ストリームに複数の個別の JSON コード セクションが含まれている場合、最初のコード セクションのみが検出/使用されます。
実際に JSON データの値を操作するには、JSON.json[] とその兄弟演算子を使用します。
最も可能性の高いシナリオでは、$Text で作業する場合、$Text に JSON と他のテキストの両方が含まれる場合にのみ .captureJson() が必要になります。
$MyResult = $Text.captureJson().json[""somekey""];
ただし、$Text 全体が (完全な) JSON の単一ブロックである場合は、.json[] を直接使用します。それで:
$MyResult = $Text.json[""somekey""];
従来の使用法
v10.0.2 より前では、オペレーターは .captureJSON() のケーシングを使用していました。このバージョンは引き続きサイレント サポートされています (サポートされている入力ボックスには色が付けられています)。ただし、 .captureJson() は承認されたケースではなく、レガシー サポートがいつでも終了する可能性があるため、既存のコードをこれに更新する必要があります。"
String.captureLine([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureLine(targetAttributeStr)
String.captureLine()
String.captureLine
Optionally stores the rest of the line (paragraph) in the specified targetAttributeStr, a quoted name of an attribute, and returns the string that follows this line and the String moves forwards to the end of the current line.
If the targetAttributeStr is omitted the String is advanced to the next line without any data being saved.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the stream is three paragraphs ""Goodbye cruel world.\nHello again.\nFinal text."" (the \n is a line break):
	$MyString = $Text.captureLine(""SomeAttribute"").captureLine(vString); 
results in attribute $SomeAttribute holding the value ""Goodbye cruel world."" and the variable vString holding the value ""Hello again."". $MyString holds ""Final text."", it being the remainder of the unconsumed stream.","String.captureLine(targetAttributeStr)
String.captureLine()
String.captureLine
オプションで、行の残りの部分 (段落) を指定された targetAttributeStr (引用符で囲まれた属性の名前) に格納し、この行に続く文字列を返し、その文字列は現在の行の末尾に進みます。
targetAttributeStr が省略された場合、文字列はデータが保存されずに次の行に進みます。
targetAttributeSt に指定できる値は次のとおりです。
* 引用符で囲まれたリテラル文字列、例:(""テキスト"") $Text の場合。
* 引用符で囲まれていない変数/ループ変数。例:(vString) 変数「vString」の場合。
たとえば、ストリームが 3 つの段落である場合、「さようなら残酷な世界。\nこんにちは。\n最後のテキスト。」(\n は改行です):
$MyString = $Text.captureLine(""SomeAttribute"").captureLine(vString);
その結果、属性 $SomeAttribute が値「さようなら残酷な世界」を保持します。そして値「Hello again.」を保持する変数 vString。$MyString には、未消費のストリームの残りの部分である「最終テキスト」が保持されます。"
String.captureNumber([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureNumber(""targetAttribute"")
String.captureNumber()
String.captureNumber
Searches forward from the start of String and matches the a detected number up to the first non-number character, optionally storing that number in the attribute specified targetAttributeStr, a quoted name of an attribute. It then returns the string that follows that number (to any left side recipient) whilst the String is advanced to a position after the number. The operator fails if the match is empty or entirely white space, with no result. 
A number is assumed to be any character continuous sequence of one or more number characters between 0–9 (zero through nine). Formatted numbers will not be fully matched. Any further text after the number is ignored, both for the capture and advancing the String.
If the targetAttributeStr is omitted the String is advanced to after the number without any data being saved.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the string is ""1234 items"":
$Result = $Result=$Text.captureNumber(""SomeAttribute""); 
The value of $SomeAttribute is ""1234"" $Result holds "" items"". But if the stream is ""1,234 items"", $Result holds ""1"" and $SomeAttribute holds "",234 items"" as the comma means the first detected number stops at '1'.","String.captureNumber(""ターゲット属性"")
String.captureNumber()
文字列.captureNumber
文字列の先頭から順方向に検索し、検出された数値を最初の非数値文字まで照合します。オプションで、その数値を、targetAttributeStr で指定された属性 (属性の引用符で囲まれた名前) に格納します。次に、その数値に続く文字列を (左側の受信者に) 返しますが、その文字列は数値の後の位置に進められます。一致が空または完全に空白の場合、演算子は失敗し、結果はありません。
数値は、0 ～ 9 (0 ～ 9) の 1 つ以上の数字文字の連続した文字シーケンスとみなされます。フォーマットされた数値は完全には一致しません。数値の後のテキストは、文字列のキャプチャと前進の両方で無視されます。
targetAttributeStr が省略された場合、文字列はデータが保存されずに数値の後に進みます。
targetAttributeSt に指定できる値は次のとおりです。
* 引用符で囲まれたリテラル文字列、例:(""テキスト"") $Text の場合。
* 引用符で囲まれていない変数/ループ変数。例:(vString) 変数「vString」の場合。
たとえば、文字列が「1234 項目」の場合:
$Result = $Result=$Text.captureNumber(""SomeAttribute"");
$SomeAttribute の値は ""1234"" $Result は "" items"" を保持します。ただし、ストリームが「1,234 項目」の場合、カンマは最初に検出された数値が「1」で停止することを意味するため、$Result には「1」が保持され、$SomeAttribute には「,234 項目」が保持されます。"
String.captureRest([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureRest(targetAttributeStr)
String.captureRest()
String.captureRest
Stores all of the String from the current position to its end into the specified targetAttributeStr, which is a quoted name of an attribute, and returns an empty string.
If the targetAttributeStr is omitted the String is advanced to the end so processing ceases.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the stream is ""Goodbye cruel world.\nHello again."":
	vString = $Text.captureWord(""SomeAttribute"").captureRest(vRest); 
results in attribute $SomeAttribute holding the value ""Goodbye"" and the variable vRest holding the value "" cruel world.\nHello again"".","String.captureRest(targetAttributeStr)
String.captureRest()
String.captureRest
現在の位置から末尾までのすべての文字列を、指定された targetAttributeStr (属性の引用符で囲まれた名前) に格納し、空の文字列を返します。
targetAttributeStr が省略された場合、文字列は最後まで進められるため、処理は停止します。
targetAttributeSt に指定できる値は次のとおりです。
* 引用符で囲まれたリテラル文字列、例:(""テキスト"") $Text の場合。
* 引用符で囲まれていない変数/ループ変数。例:(vString) 変数「vString」の場合。
たとえば、ストリームが「さようなら、残酷な世界。\nこんにちは。」の場合:
vString = $Text.captureWord(""SomeAttribute"").captureRest(vRest);
その結果、属性 $SomeAttribute には値「Goodbye」が保持され、変数 vRest には値「残酷な世界。\nHello again」が保持されます。"
"String.captureTo(matchStr[, targetAttributeStr])",Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,2,true,true,false,false,true,false,false,true,false,,false,"String.captureTo(matchStr, targetAttributeStr)
String.captureTo(matchStr)
Stores the source text string up to, but not including, the designated literal matchStr into the specified targetAttributeStr, a quoted name of an attribute,  and returns the string that follows matchStr. Note that matchStr is not a regular expression and can only be a literal string.
If the targetAttributeStr is omitted the String is advanced to the end so processing ceases.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the stream is ""Piglet, a friend of Pooh"" and if wishing to capture only the name 'Piglet' into $SomeAttribute:
	$Result = $Text.captureTo("", "",""SomeAttribute""); 
Now, the value of $Result is ""a friend of Pooh"" and that of $SomeAttribute is ""Piglet"".","String.captureTo(matchStr, targetAttributeStr)
String.captureTo(matchStr)
指定されたリテラル matchStr までのソース テキスト文字列を、指定された targetAttributeStr (引用符で囲まれた属性の名前) に格納し、matchStr に続く文字列を返します。matchStr は正規表現ではなく、リテラル文字列のみであることに注意してください。
targetAttributeStr が省略された場合、文字列は最後まで進められるため、処理は停止します。
targetAttributeSt に指定できる値は次のとおりです。
* 引用符で囲まれたリテラル文字列、例:(""テキスト"") $Text の場合。
* 引用符で囲まれていない変数/ループ変数。例:(vString) 変数「vString」の場合。
たとえば、ストリームが「プーさんの友達のピグレット」で、「ピグレット」という名前だけを $SomeAttribute にキャプチャしたい場合は、次のようになります。
$Result = $Text.captureTo("", "",""SomeAttribute"");
ここで、$Result の値は「プーさんの友達」、$SomeAttribute の値は「Piglet」です。"
String.captureToken([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureToken(targetAttributeStr)
String.captureToken()
String.captureToken
Captures a sequence of non-whitespace characters ('tokens'), the matched token string is passed to the specified targetAttributeStr, a quoted name of an attribute. The String stream is not advanced and any chained parsing continues from the same point. Punctuation (notably @) is part of a token but *not* part of a word.
If the targetAttributeStr is omitted the String is advanced to the end so processing ceases.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, with a source a stream of ""5. Hello world"":
	vString = $Text.captureToken(""SomeAttribute""); 
results in attribute $SomeAttribute holding ""5."" and the variable vText hosing the value "" Hello world""—note the space after the full stop is passed to the text stream as it is not a captured 'token'.
Iif the source stream is ""John Doe&lt;johndoe@example.com>"":
	vText = $Text.captureToken(vString) 
results in variable vText holding "" Doe&lt;johndoe@example.com>"" whilst variable vString holds ""John"".
Thus .captureToken() might be considered akin to a more permissive form of String.captureWord() where the first 'word' in the stream contains non-normal word characters (as long as not a space).","String.captureToken(targetAttributeStr)
String.captureToken()
String.captureToken
一連の非空白文字 (「トークン」) をキャプチャし、一致したトークン文字列が、指定された targetAttributeStr (引用符で囲まれた属性の名前) に渡されます。String ストリームは進められず、連鎖解析は同じポイントから続行されます。句読点 (特に @) はトークンの一部ですが、単語の一部ではありません。
targetAttributeStr が省略された場合、文字列は最後まで進められるため、処理は停止します。
targetAttributeSt に指定できる値は次のとおりです。
* 引用符で囲まれたリテラル文字列、例:(""テキスト"") $Text の場合。
* 引用符で囲まれていない変数/ループ変数。例:(vString) 変数「vString」の場合。
たとえば、ソースが「5. Hello world」のストリームの場合:
vString = $Text.captureToken(""SomeAttribute"");
その結果、属性 $SomeAttribute は「5」を保持します。値「Hello world」を格納する変数 vText — キャプチャされた「トークン」ではないため、ピリオドの後のスペースがテキスト ストリームに渡されることに注意してください。
ソース ストリームが「John Doe<johndoe@example.com>」の場合:
vText = $Text.captureToken(vString)
その結果、変数 vText は「Doe<johndoe@example.com>」を保持し、変数 vString は「John」を保持します。
したがって、 .captureToken() は、ストリーム内の最初の「単語」に (スペースでない限り) 非通常の単語文字が含まれる、より寛容な形式の String.captureWord() に似ていると考えることができます。"
String.captureWord([targetAttributeStr]),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.captureWord(targetAttributeStr)
String.captureWord()
String.captureWord
Matches a word character at the start of String up to the first non-word character and stores the word in the specified targetAttributeStr, a quoted name of an attribute, and returns the string that follows this word. Fails if the string is empty or entirely white space.
What constitutes a word? This operator captures text from the current position up to (but not including) the next character that is a digit, whitespace, or punctuation.
If the targetAttributeStr is omitted the String is advanced to the end so processing ceases.
The value given for targetAttributeSt can be:
* a quoted literal string, e.g. (""Text"") for $Text. 
* an unquoted variable/loopVariable, e.g. (vString) for a variable 'vString'.
For example, if the stream is ""Hello world"":
	vString = $Text.captureWord(""SomeAttribute""); 
results in attribute $SomeAttribute holding the value ""Hello"" and the variable vText holding the value "" world"". If the stream does not start with a word, the operator fails. So, for a stream of ""5. Hello world"":
	vString = $Text.captureWord(""SomeAttribute""); 
results in attribute $SomeAttribute holding no value and the variable vString hosing the value ""5. Hello world"".","String.captureWord(targetAttributeStr)
String.captureWord()
String.captureWord
String の先頭にある単語文字を最初の単語以外の文字まで照合し、その単語を指定された targetAttributeStr (引用符で囲まれた属性の名前) に格納し、この単語に続く文字列を返します。文字列が空か完全に空白の場合は失敗します。
単語を構成するものは何ですか?この演算子は、現在の位置から次の文字 (数字、空白、または句読点) までのテキストをキャプチャします。
targetAttributeStr が省略された場合、文字列は最後まで進められるため、処理は停止します。
targetAttributeSt に指定できる値は次のとおりです。
* 引用符で囲まれたリテラル文字列、例:(""テキスト"") $Text の場合。
* 引用符で囲まれていない変数/ループ変数。例:(vString) 変数「vString」の場合。
たとえば、ストリームが「Hello world」の場合:
vString = $Text.captureWord(""SomeAttribute"");
その結果、属性 $SomeAttribute には値「Hello」が保持され、変数 vText には値「world」が保持されます。ストリームが単語で始まらない場合、オペレーターは失敗します。したがって、「5. Hello world」のストリームの場合は次のようになります。
vString = $Text.captureWord(""SomeAttribute"");
その結果、属性 $SomeAttribute には値が保持されず、変数 vString には値「5. Hello world」が保持されます。"
String.captureXML(),Operator,Item,Stream parsing,,false,9.1.0,,,,,,false,true,false,false,false,false,false,false,false,,false,"String.captureXML()
String.captureXML
Attempts to parse the string as fully/partially XML and fails if unsuccessful. The parsed XML is saved as the current XML (stream) object. 
Essentially, this re-scopes the current stream so that it contains only the contents of the first section of XML detected within the original stream. The focus of the stream parsing is set to the beginning of the extracted XML code.
Only one XML object may be current at any time. If the source stream contains multiple discrete XML code sections, only the first is detected/used.","String.captureXML()
String.captureXML
文字列を完全または部分的に XML として解析しようとしますが、失敗すると失敗します。解析された XML は、現在の XML (ストリーム) オブジェクトとして保存されます。
基本的に、これにより現在のストリームのスコープが変更され、元のストリーム内で検出された XML の最初のセクションの内容のみが含まれるようになります。ストリーム解析のフォーカスは、抽出された XML コードの先頭に設定されます。
常に 1 つの XML オブジェクトのみが最新になります。ソース ストリームに複数の個別の XML コード セクションが含まれている場合、最初のコード セクションのみが検出/使用されます。"
String.contains(regexStr),Function,Item,Query Boolean,boolean test,false,5.7.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.contains(regexStr)
This operator tests whether regular expression pattern regexStr matches the referenced string attribute's value in whole or part. Matches are always case-sensitive, unlike String.icontains(). The match gives a coerced boolean result: if regexStr is matched (literally or via regex) the function returns the match offset+1 in the source string, where offset is the distance from the start of the string to the start of the matched regex. No match, coerces to false. The +1 works around the fact the match is zero-based, so a match at position 0 (the start of the string), returns as 1 (0+1) and a value of 1 or more coerces to a boolean true. The boolean allows queries' normal true/false to evaluate as normal.
If concerned over unwanted case-sensitivity, use String.icontains() which is always case-insensitive.
regexStr is one of:
* an unquoted action code expression, which includes just referencing a single attribute name e.g. MyString
* a quoted string; quoted strings may be either:
** a literal string (i.e. actual text)
** a regular expression.
Important: do not omit the enclosing quotes for literal strings or regex. If omitted, Tinderbox will try to evaluate the string as an expression. Doing this may result in the expected result but this is actually a false positive. So, remember to enclose your regex or literals in quotes.
For example:
	$MyString.contains(""regex"") 
is true if $MyString matches regexStr's pattern. Other more complex usage:
	$MyString.contains($MyMatchText) 
	$MyString.contains($MyString(agent)) 
	$MyString(parent).contains(""Tuesday"") 
	""Any day like Saturday is good"".contains($MyDay) 
	""Any day like Saturday is good"".contains(""Saturday"") 
Note that regex/literal strings are quoted whilst action expressions are not.
Getting the offset of the (first) regex match
If the regular expression regexStr is found the function returns the match offset+1, where offset is the distance from the start of the string to the start of the matched regex. If there is more than one match, the offset of the first match is returned. Formerly, .contains() returned true if the regex was found. The '+1' modifier ensures that a match at position zero return a number higher than zero which would otherwise coerce tofalse. Since 1+offset is always true, no changes are required in existing documents but the function also gives usable offset information. Thus, if $MyString is ""abcdefgehEi"":
	$MyNumber = $MyString.contains(""e""); returns 5.
	$MyNumber = $MyString.contains(""E""); returns 10.
	$MyNumber = $MyString.contains(""eh""); returns 8.
Testing ""does not contain""
Use a ! prefix to the query argument:
	!$MyString.contains(""Tuesday"") 
Use of parentheses around the negated query term, can assist Tinderbox's parsing:
	(!$MyString.contains(""Tuesday"")) 
Using back-references
In an agent query or if() conditions the function can return back-references to matches of (sub-)strings.
String.contains() clears the list of back references from previous processes, so $0 and $1 correspond to its own results, not those from prior expressions.
Dealing with inline quote characters
Because regex is parsed for regular expressions, it may be possible to use the '\xNN' form described here to work around the lack of escaping from single double quotes within strings.
Legacy format
This operator is the replacement of the older form of AttributeName(regex) which is deprecated and should not be used in new work (legacy support may fall away). Apart from anything else, the current syntax should remove the confusion over whether/when to use the $ prefix with attribute names in queries.","String.contains(regexStr)
この演算子は、正規表現パターン regexStr が、参照された文字列属性の値の全体または一部と一致するかどうかをテストします。String.icontains() とは異なり、一致では常に大文字と小文字が区別されます。一致により、強制されたブール値の結果が得られます。regexStr が (リテラルまたは正規表現経由で) 一致した場合、関数はソース文字列内の一致オフセット + 1 を返します。ここで、オフセットは文字列の先頭から一致した正規表現の先頭までの距離です。一致しないため、強制的に false に設定されます。+1 は、一致が 0 ベースであるという事実を回避するため、位置 0 (文字列の先頭) での一致は 1 (0+1) として返され、1 以上の値はブール値 true に強制されます。ブール値を使用すると、クエリの通常の true/false を通常どおり評価できます。
不要な大文字と小文字の区別が気になる場合は、常に大文字と小文字を区別しない String.icontains() を使用してください。
regexStr は次のいずれかです。
* 引用符で囲まれていないアクション コード式。これには、単一の属性名を参照するだけが含まれます。MyString
* 引用符で囲まれた文字列;引用符で囲まれた文字列は次のいずれかになります。
** リテラル文字列 (つまり、実際のテキスト)
** 正規表現。
重要: リテラル文字列または正規表現を囲む引用符を省略しないでください。省略した場合、Tinderbox は文字列を式として評価しようとします。これを実行すると期待どおりの結果が得られる可能性がありますが、これは実際には誤検知です。したがって、正規表現またはリテラルを引用符で囲むことを忘れないでください。
たとえば:
$MyString.contains(""正規表現"")
$MyString が regexStr のパターンと一致する場合は true です。その他のより複雑な使用法:
$MyString.contains($MyMatchText)
$MyString.contains($MyString(エージェント))
$MyString(parent).contains(""火曜日"")
「土曜日などいつでも良いです」.contains($MyDay)
「土曜日のような日が良いです。」.contains(""土曜日"")
正規表現/リテラル文字列は引用符で囲まれますが、アクション式は引用符で囲まれないことに注意してください。
(最初の) 正規表現一致のオフセットの取得
正規表現 regexStr が見つかった場合、関数は一致の offset+1 を返します。ここで、offset は文字列の先頭から一致した正規表現の先頭までの距離です。複数の一致がある場合は、最初の一致のオフセットが返されます。以前は、正規表現が見つかった場合、 .contains() は true を返しました。「+1」修飾子を使用すると、位置 0 での一致により、そうでない場合は強制的に false となる、0 より大きい数値が返されることが保証されます。1+offset は常に true であるため、既存のドキュメントを変更する必要はありませんが、この関数は使用可能なオフセット情報も提供します。したがって、$MyString が「abcdefgehEi」の場合:
$MyNumber = $MyString.contains(""e"");5を返します。
$MyNumber = $MyString.contains(""E"");10を返します。
$MyNumber = $MyString.contains(""eh"");8を返します。
「を含まない」テスト
! を使用してください。クエリ引数の接頭辞:
!$MyString.contains(""火曜日"")
否定されたクエリ用語を括弧で囲むと、Tinderbox の解析が容易になります。
(!$MyString.contains(""火曜日""))
後方参照の使用
エージェント クエリまたは if() 条件では、関数は一致する (サブ) 文字列への逆参照を返すことができます。
String.contains() は前のプロセスからの後方参照のリストをクリアするため、$0 と $1 は前の式の結果ではなく、独自の結果に対応します。
インライン引用符の扱い
regex は正規表現として解析されるため、ここで説明する「\xNN」形式を使用して、文字列内の単一二重引用符からエスケープできない問題を回避できる可能性があります。
レガシー形式
この演算子は、廃止された古い形式の AttributeName(regex) を置き換えるものであり、新しい作業では使用しないでください (レガシー サポートは廃止される可能性があります)。他のことは別として、現在の構文では、クエリ内の属性名に $ プレフィックスを使用するかどうか、またはいつ使用するかについての混乱が解消されるはずです。"
String.containsAnyOf(regexList),Function,List,Query Boolean,boolean test,false,8.9.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.containsAnyOf(regexList)
The operator .containsAnyOf(regexList) is true if any of the words in a set of words (i.e. list) is contained in the chained-to target string. As shown below, the list may have only one entry. The test is case-sensitive (previously it was case-insensitive). For example:
	$MyBoolean = $Text.containsAnyOf(""emulate""); 
Will be true if the tested note's $Text contains the word ""emulate"". A more applied example:
	$MyBoolean = $Text.containsAnyOf(wordsRelatedTo(""emulate"")); 
Will be true if the tested note's $Text contains the word ""aspire"".
regexList implies using a list of values (ideally with no dupes). This can be a literal list of 1 or more values—as in the example above, or an attribute reference holding a list of values, for instance:
	$MyBoolean = $Text.containsAnyOf($MySet); 
It is important to note that .containsAnyOf() is always a case-insensitive test. Thus in the first example above, it will match ""emulate"" but not ""Emulate"" or any other case variant of the word.
Although the examples above use whole words the list in regexList is actually processed assuming they are regular expressions (which may of course be literal strings). Thus in the first example above, it will match both ""emulate"" and ""emulated"" but not ""emulating"". The test value ""emulate\b"", expecting a word break after the final 'e' would this match ""emulate"" but not ""emulated"".
For a case-insensitive version of this operator see String.icontainsAnyOf().
If wishing to test a List or Set, chain to list.asString():
	$MyBoolean = $MyList.asString.containsAnyOf(wordsRelatedTo(""emulate""));","String.containsAnyOf(regexList)
演算子 .containsAnyOf(regexList) は、単語のセット (つまりリスト) 内のいずれかの単語が連鎖先のターゲット文字列に含まれている場合に true になります。以下に示すように、リストにはエントリが 1 つだけ含まれる場合があります。テストでは大文字と小文字が区別されます (以前は大文字と小文字が区別されませんでした)。たとえば:
$MyBoolean = $Text.containsAnyOf(""エミュレート"");
テストされたメモの $Text に「emulate」という単語が含まれている場合は true になります。より応用的な例:
$MyBoolean = $Text.containsAnyOf(wordsManyTo(""emulate""));
テストされたメモの $Text に「aspire」という単語が含まれている場合は true になります。
regexList は、値のリスト (理想的には重複のないもの) を使用することを意味します。これは、上記の例のように 1 つ以上の値のリテラル リストにすることも、値のリストを保持する属性参照にすることもできます。次に例を示します。
$MyBoolean = $Text.containsAnyOf($MySet);
.containsAnyOf() は常に大文字と小文字を区別しないテストであることに注意することが重要です。したがって、上記の最初の例では、「エミュレート」には一致しますが、「エミュレート」やその他の大文字と小文字が異なる単語には一致しません。
上記の例では単語全体が使用されていますが、regexList 内のリストは実際には正規表現 (もちろんリテラル文字列の場合もあります) であると想定して処理されます。したがって、上記の最初の例では、「エミュレート」と「エミュレートされた」の両方に一致しますが、「エミュレート」には一致しません。テスト値「emulate\b」は、最後の「e」の後に単語の区切りがあると予想されますが、これは「emulate」には一致しますが、「emulated」には一致しません。
この演算子の大文字と小文字を区別しないバージョンについては、String.icontainsAnyOf() を参照してください。
List または Set をテストしたい場合は、list.asString() にチェーンします。
$MyBoolean = $MyList.asString.containsAnyOf(wordsManyTo(""emulate""));"
String.countOccurrencesOf(literalStr),Function,Item,Data manipulation,Number,false,6.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.countOccurrencesOf(literalStr)
This function returns the Number of times that the literal argument 'literalStr' appears in the String. If $MyString contains the word ""aardvark"", then:
	$MyNumber = $MyString.countOccurrencesOf(""a""); returns 3
	$MyNumber = $MyString.countOccurrencesOf(""aa""); returns 1
	$MyNumber = $MyString.countOccurrencesOf(""r""); returns 2
literalStr is literal and must not be a regular expression. If the latter is needed use String.contains() or String.icontains().","String.countOccurrencesOf(literalStr)
この関数は、リテラル引数 'literalStr' が文字列内に出現する回数を返します。$MyString に「ツチブタ」という単語が含まれている場合、次のようになります。
$MyNumber = $MyString.countOccurrencesOf(""a"");3を返します
$MyNumber = $MyString.countOccurrencesOf(""aa"");1を返します
$MyNumber = $MyString.countOccurrencesOf(""r"");2を返します
literalStr はリテラルであり、正規表現であってはなりません。後者が必要な場合は、String.contains() または String.icontains() を使用します。"
String.deleteCharacters(characterSet),Function,Item,Data manipulation,String,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.deleteCharacters(characterSet)
Returns a copy of the string from which all instances of every discrete character in the quoted literal string-based set characterSet have been removed. For example:, if $MyString is ""1Hello1 2world3"";
	$MyStringA = $MyString.deleteCharacters(""1234567890""); 
would remove any digits from the target string, thus $MyStringA will be ""Hello world"", having removed two instances of '1', and a single instance of '2' and of '3'.
But were $MyString ""Hello world: 45"";
	$MyStringA = $MyString.deleteCharacters(""1234567890""); 
the result would be ""Hello world: "". Importantly, note the trailing space as only the digits (i.e. characters in characterSet) have been removed.","String.deleteCharacters(characterSet)
引用符で囲まれたリテラル文字列ベースのセットcharacterSet内の各個別文字のすべてのインスタンスが削除された文字列のコピーを返します。例: $MyString が ""1Hello1 2world3"" の場合;
$MyStringA = $MyString.deleteCharacters(""1234567890"");
これはターゲット文字列から数字を削除するため、$MyStringA は「1」の 2 つのインスタンスと、「2」と「3」の 1 つのインスタンスを削除した「Hello world」になります。
しかし、$MyString ""Hello world: 45"" でした。
$MyStringA = $MyString.deleteCharacters(""1234567890"");
結果は「Hello world:」になります。重要なのは、数字 (つまり、characterSet 内の文字) のみが削除されているため、末尾のスペースに注意してください。"
String.eachLine(loopVar[:condition]){actions},Function,List,Stream parsing,iterator,false,9.1.0,Baseline,,,,2,true,true,false,true,false,false,true,true,false,,false,"String.eachLine(loopVar[:condition]){ action(s) }
The .eachLine() operator, iterates through each line of a steam, where a line is one or more characters ending in a carriage return, line feed, unicode paragraph separator, or the end of the string (so in $Text, it means discrete paragraphs).
Each line, in turn, is bound to a temporary variable loopVar, and the action is then performed. The name of the variable is set by the user when writing the code, i.e. it is whatever string is entered where loopVar is shown above. Something like 'aLine' might be a more useful variable name.
If the optional condition is specified, only lines that satisfy the condition are processed using the action.
For example:
$MyNumber=0;
$Text.eachLine(aLine){
   $MyNumber=$MyNumber+1;
};
will set $MyNumber to the number of lines (paragraphs!) in the $Text of this note.
$MyNumber=0;
$Text.eachLine(aLine:aLine.contains(""@"")){
   $MyNumber=$MyNumber+1;
};
will set $MyNumber to the number of lines in the $Text that contain the ""@"" symbol.
When parsing text paragraphs, this operator can substitute for the older method of chaining .paragraphList.each(){}.","String.eachLine(loopVar[:condition]){ アクション }
.eachLine() 演算子は、ストリームの各行を反復処理します。ここで、行とは、復帰、改行、Unicode 段落区切り文字、または文字列の終わりで終わる 1 つ以上の文字です (したがって、$Text では、個別の段落を意味します)。
各行は、一時変数loopVarにバインドされ、アクションが実行されます。変数の名前は、コードを記述するときにユーザーによって設定されます。つまり、上で示したloopVarの場所に入力される文字列です。「aLine」のような変数名のほうが便利かもしれません。
オプションの条件が指定されている場合、条件を満たす行のみがアクションを使用して処理されます。
たとえば:
$MyNumber=0;
$Text.eachLine(aLine){
$MyNumber=$MyNumber+1;
};
$MyNumber は、このメモの $Text の行数 (段落!) に設定されます。
$MyNumber=0;
$Text.eachLine(aLine:aLine.contains(""@"")){
$MyNumber=$MyNumber+1;
};
$MyNumber は、$Text 内の「@」記号を含む行数に設定されます。
テキスト段落を解析するとき、この演算子は .paragraphList.each(){} を連鎖する古いメソッドの代わりに使用できます。"
String.empty(),Property,Item,Non-query Boolean,boolean test,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.empty()
String.empty
This returns a Boolean depending on whether the string is empty. If empty, the return value is true, if the attribute has content then false is returned.
	$MyString = """"; $MyBoolean = $MyString.empty; $MyBoolean is set to true.
	$MyString = ""hello""; $MyBoolean = $MyString.empty; $MyBoolean is set to true.
This operator can also be used on other attribute data types that are string-like, URL, File, Action, Color, etc., and which have no value at all by default. However, for a Number or Date, the default values of 0 or never, coerce to a literal string of ""0"" or ""never"" so the .empty() test does not work the same way. For the latter types, use the short Boolean test form, !AttributeName.","String.empty()
文字列.空
これは、文字列が空かどうかに応じてブール値を返します。空の場合、戻り値は true であり、属性にコンテンツがある場合は false が返されます。
$MyString = """";$MyBoolean = $MyString.empty;$MyBoolean は true に設定されます。
$MyString = ""こんにちは"";$MyBoolean = $MyString.empty;$MyBoolean は true に設定されます。
この演算子は、URL、ファイル、アクション、カラーなどの文字列のような他の属性データ型にも使用でき、デフォルトでは値がまったくありません。ただし、数値または日付の場合、デフォルト値の 0 またはneverは、リテラル文字列「0」または「never」に強制されるため、.empty() テストは同じようには機能しません。後者のタイプの場合は、短いブール テスト フォーム !AttributeName を使用します。"
String.endsWith(matchStr),Function,Item,Data manipulation,boolean test,false,6.4.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.endsWith(matchStr)
String.endsWith() returns Boolean true if the chained string ends with the literal string matchStr. Note that matchStr cannot be a regular expression, only literal string values are allowed.
For example, if $MyString is ""I do not like green eggs and ham"":
	$MyString.endsWith(""ham"")  returns true
	$MyString.endsWith(""eggs"")  returns false
Also, with string literals:
	(""There are gentlemen now abed."").endsWith(""abed"")  returns true 
	(""There are gentlemen now abed."").endsWith(""night"")  returns false 
This operator searches for literal strings, not regular expressions. Matches are case sensitive:
	(""There are gentlemen now abed."").endsWith(""Abed"")  returns false 
See also String.beginsWith(). If you need to search a String for a regular expression, use String.contains().","String.endsWith(matchStr)
String.endsWith() は、連鎖文字列がリテラル文字列 matchStr で終わる場合にブール値 true を返します。matchStr には正規表現を使用できません。リテラル文字列値のみが許可されることに注意してください。
たとえば、$MyString が「緑色の卵とハムは好きではありません」の場合:
$MyString.endsWith(""ham"") は true を返します
$MyString.endsWith(""eggs"") は false を返します
また、文字列リテラルの場合:
(「今、紳士たちが寝ています。」).endsWith(""寝ている"") は true を返します
(「紳士たちは今寝ています。」).endsWith(""夜"") は false を返します
この演算子は、正規表現ではなく、リテラル文字列を検索します。一致では大文字と小文字が区別されます。
(「今、寝ている紳士がいます。」).endsWith(""寝ている"") は false を返します
String.beginsWith() も参照してください。正規表現の文字列を検索する必要がある場合は、String.contains() を使用します。"
String.expect(matchStr),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.expect(matchStr)
The operator tests if the String begins with the matchStr string with the following results:
* success: operator returns the rest of string that follows matchStr.
* failure: nothing is returned
Note that matchStr is not a regular expression and can only be a literal string.
For example:
	vText = $Text.expect(""abc""); 
Tests that the next characters in the stream read from $Text is the sequence abc, and advances the stream beyond ""abc"". Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .expect() unless a failure occurs in which case chained operators are not processed.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.expect(matchStr)
演算子は、文字列が matchStr 文字列で始まるかどうかをテストし、次の結果が得られます。
* 成功: 演算子は matchStr に続く文字列の残りを返します。
* 失敗: 何も返されません
matchStr は正規表現ではなく、リテラル文字列のみであることに注意してください。
たとえば:
vText = $Text.expect(""abc"");
$Text から読み取られるストリーム内の次の文字がシーケンス abc であることをテストし、ストリームを ""abc"" より先に進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合でも、変数 vText は、エラーが発生しない限り、.expect() に連鎖した他の演算子と同様に、結果のテキスト ストリームを受け取ります。この場合、連鎖した演算子は処理されません。
この演算子の使用は、キャプチャされるコンテンツが正しく検出されることを保証するための補助として使用されます。基本的に、これは「if」スタイルのテストです。テストが正しければ続行し、そうでない場合は、チェーンされたストリーム解析演算子が存在する可能性があるため、カーソルはその位置に留まります。"
String.expectNumber(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.expectNumber()
String.expectNumber
If the string begins with one or more contiguous character(s) that could be interpreted as a number, the String stream cursor skips to the end of that number sequence and parsing continues.
For example:
	vText = $Text.expectNumber(); 
Tests that the next characters in the stream read from $Text is a sequence of digits, and advances the stream past a continuous runs of digits. Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .expectNumber() unless a failure occurs in which case chained operators are not processed.
If the input stream passes in ""1234 items"" the cursor advances past '1234' such that the remaining stream is "" items"".
If the input stream passes in ""1,234 items"" the cursor advances past '1' such that the remaining stream is ""234 items"". Notice how number formatting delimiters like a comma (or other locale-specific delimiters) used in string representations of  numbers may confuse this operator is used without care.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.expectNumber()
文字列.expectNumber
文字列が数値として解釈できる 1 つ以上の連続した文字で始まる場合、文字列ストリーム カーソルはその数値シーケンスの末尾までスキップし、解析が続行されます。
たとえば:
vText = $Text.expectNumber();
$Text から読み取られるストリーム内の次の文字が一連の数字であることをテストし、一連の数字を超えてストリームを進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合でも、変数 vText は、エラーが発生しない限り、.expectNumber() に連鎖した他の演算子と同様に、結果のテキスト ストリームを受け取ります。この場合、連鎖した演算子は処理されません。
入力ストリームが「1234 アイテム」を渡す場合、カーソルは「1234」を超えて進み、残りのストリームは「アイテム」になります。
入力ストリームが「1,234 項目」を渡す場合、カーソルは「1」を超えて進み、残りのストリームは「234 項目」になります。数値の文字列表現で使用されるカンマ (またはその他のロケール固有の区切り文字) などの数値書式設定区切り文字が、この演算子が不注意に使用されるとどのように混乱するかに注意してください。
この演算子の使用は、キャプチャされるコンテンツが正しく検出されることを保証するための補助として使用されます。基本的に、これは「if」スタイルのテストです。テストが正しければ続行し、そうでない場合は、チェーンされたストリーム解析演算子が存在する可能性があるため、カーソルはその位置に留まります。"
String.expectWhitespace(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.expectWhitespace()
String.expectWhitespace
If the string begins the whitespace, skips the whitespace and succeeds. Otherwise, it fails.
For example:
	vText = $Text.expectWhitespace(); 
Tests that the next characters in the stream are non-word, and advances the stream beyond the detected  whitespaces characters. Otherwise, it fails and the cursor does not advance. Either way, the variable vText receives the resulting text stream as would any operator chained to .expectWhitespace() unless a failure occurs in which case chained operators are not processed. 
If the stream passed in is ""  Hello world"" (note the leading spaces) then the spaces are detected and the cursor returns ""Hello world"". But if the stream passed in is ""Hello world"" a word is detected and the cursor does not advance.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.expectWhitespace()
String.expectWhitespace
文字列が空白で始まる場合は、空白をスキップして成功します。それ以外の場合は失敗します。
たとえば:
vText = $Text.expectWhitespace();
ストリーム内の次の文字が単語ではないことをテストし、検出された空白文字を超えてストリームを進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合でも、変数 vText は、エラーが発生しない限り、.expectWhitespace() に連鎖した他の演算子と同様に、結果のテキスト ストリームを受け取ります。この場合、連鎖演算子は処理されません。
渡されたストリームが「Hello world」(先頭のスペースに注意) の場合、スペースが検出され、カーソルは「Hello world」を返します。ただし、渡されたストリームが「Hello world」の場合、単語が検出され、カーソルは進みません。
この演算子の使用は、キャプチャされるコンテンツが正しく検出されることを保証するための補助として使用されます。基本的に、これは「if」スタイルのテストです。テストが正しければ続行し、そうでない場合は、チェーンされたストリーム解析演算子が存在する可能性があるため、カーソルはその位置に留まります。"
String.expectWord(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.expectWord()
String.expectWord
If the string begins with one or more contiguous character(s) that could be interpreted as a word the String stream cursor skips to the end of that sequence and parsing continues.
What constitutes a word? This operator captures text from the current position up to (but not including) the next character that is a digit, whitespace, or punctuation.
For example:
	vText = $Text.expectWord(); 
Tests that the next characters in the stream are not non-word, and advances the stream beyond the detected word. Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .expectWord() unless a failure occurs in which case chained operators are not processed. 
If the stream passed in is ""Hello world"" then 'Hello' is detected and the cursor returns "" world"" (note the leading space). But if the stream passed in is "" Hello world"" (note the leading space), no word is detected and the cursor does not advance.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.expectWord()
String.expectWord
文字列が単語として解釈できる 1 つ以上の連続した文字で始まる場合、文字列ストリーム カーソルはそのシーケンスの末尾までスキップし、解析が続行されます。
単語を構成するものは何ですか?この演算子は、現在の位置から次の文字 (数字、空白、または句読点) までのテキストをキャプチャします。
たとえば:
vText = $Text.expectWord();
ストリーム内の次の文字が単語ではないことをテストし、検出された単語を超えてストリームを進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合でも、変数 vText は、エラーが発生しない限り、.expectWord() に連鎖した他の演算子と同様に、結果のテキスト ストリームを受け取ります。この場合、連鎖演算子は処理されません。
渡されたストリームが「Hello world」の場合、「Hello」が検出され、カーソルは「world」を返します（先頭のスペースに注意してください）。ただし、渡されたストリームが「Hello world」(先頭のスペースに注意) の場合、単語は検出されず、カーソルは進みません。
この演算子の使用は、キャプチャされるコンテンツが正しく検出されることを保証するための補助として使用されます。基本的に、これは「if」スタイルのテストです。テストが正しければ続行し、そうでない場合は、チェーンされたストリーム解析演算子が存在する可能性があるため、カーソルはその位置に留まります。"
"String.extract(regexStr[, caseInsensitiveBln])",Function,Item,Data manipulation,String,false,9.1.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.extract(regexStr)
The operator returns the first matched subexpression of a quote-enclosed regular expression regexStr in the source String. If the regular expression has no subexpressions, the entire match is returned up to the end of the current line/paragraph, i.e. the first line break character encountered.
For example, take a String which is the $Text ""We are very tired, Harrison! #things #Memes #August"":
	$MyString = $Text.extract(""[A-Z][A-Za-z+]""); 
this returns ""We"" as that is the first match (although there are others). This sort of use is the presumed most likely used of this operator.
If we amend the regex
	$MyString = $Text.extract(""#([A-Z][A-Za-z+])""); 
it now returns ""Memes"" (the first hash tag starts with a lowercase letter does not match). 
If multiple matches are expected/wanted, see String.extractAll().
String.extract(regex[, caseInsensitiveBln]) 
String.extract() now accepts an optional boolean second argument caseInsensitiveBln. If that argument is true, the regex argument's regular expression search is case-insensitive. The default value is false respecting the pre-existing behaviour.
String.extract() recognises ^^ and $ regex codes as applying to the start and end of a line within a multiline string. Therefore, ^^ and $ can apply to line boundaries within a multiline string.","文字列.extract(regexStr)
演算子は、ソース文字列内の引用符で囲まれた正規表現 regexStr の最初に一致した部分式を返します。正規表現に部分式がない場合は、現在の行/段落の終わり、つまり最初に見つかった改行文字までの一致全体が返されます。
たとえば、$Text「とても疲れています、ハリソン! #things #Memes #August」という文字列を考えます。
$MyString = $Text.extract(""[A-Z][A-Za-z+]"");
これが最初の一致であるため、「We」が返されます (他にも一致しますが)。この種の使用法は、この演算子の最も可能性の高い使用法であると考えられます。
正規表現を修正すると
$MyString = $Text.extract(""#([A-Z][A-Za-z+])"");
「Memes」を返すようになりました（小文字で始まる最初のハッシュタグは一致しません）。
複数の一致が期待または必要な場合は、String.extractAll() を参照してください。
String.extract(regex[, caseInsensitiveBln])
String.extract() は、オプションのブール値の 2 番目の引数 caseInsensitiveBln を受け入れるようになりました。その引数が true の場合、regex 引数の正規表現検索では大文字と小文字が区別されません。既存の動作を考慮すると、デフォルト値は false です。
String.extract() は、^^ および $ 正規表現コードを、複数行の文字列内の行の先頭と末尾に適用されるものとして認識します。したがって、^^ と $ は複数行の文字列内の行の境界に適用できます。"
"String.extractAll(regexStr[, caseInsensitiveBln])",Function,Item,Data manipulation,List,false,9.1.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.extractAll(regexStr)
The operator returns a (semi-colon delimited) list of all matches for a quote-enclosed regexStr found in the source String.
For example:
	$MyList = $Text.extractAll(""#[A-Za-z]+""); 
would return a list of all discrete tag instances in the source String such as: ""#Tinderbox;#Stuff;#Thing;#tinderbox;#Tinderbox;#Cars"".
To get a de-duped list, without the hashes we can chain other operators:
	$MyList = $Text.extractAll(""#[A-Za-z]+"").unique.replace(""#"",""""); 
That refines the returned list: ""Cars;Stuff;Thing;Tinderbox;tinderbox"". Note the extra operators also sort the list too.
String.extractAll(regexStr[, caseInsensitiveBln])
String.extractAll() now accepts an optional boolean second argument caseInsensitiveBln. If that argument is true, the regex argument's regular expression search is case-insensitive. The default value is false respecting the pre-existing behaviour.","String.extractAll(regexStr)
演算子は、ソース文字列内で見つかった引用符で囲まれた regexStr に一致するすべての (セミコロン区切りの) リストを返します。
たとえば:
$MyList = $Text.extractAll(""#[A-Za-z]+"");
「#Tinderbox;#Stuff;#Thing;#tinderbox;#Tinderbox;#Cars」など、ソース文字列内のすべての個別のタグ インスタンスのリストが返されます。
重複排除リストを取得するには、ハッシュを使用せずに他の演算子を連鎖させます。
$MyList = $Text.extractAll(""#[A-Za-z]+"").unique.replace(""#"","""");
これにより、返されるリスト「Cars;Stuff;Thing;Tinderbox;tinderbox」が絞り込まれます。追加の演算子もリストを並べ替えることに注意してください。
String.extractAll(regexStr[, caseInsensitiveBln])
String.extractAll() は、オプションのブール値の 2 番目の引数 caseInsensitiveBln を受け入れるようになりました。その引数が true の場合、regex 引数の正規表現検索では大文字と小文字が区別されません。既存の動作を考慮すると、デフォルト値は false です。"
String.failed(),Function,Item,Stream parsing,boolean test,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,true,"String.failed()
String.failed
.failed tests for a failed Stream processing action String.try{}, including an explicit fail() call. It returns true if the current operation has failed, and false otherwise.
When processing a string, it may be that the string is not what was expected. Thus the .failed operator raises a flag to say this process did not work.
A .failed flag is reset to false when the current try{} expires, or when the current action is complete.
For example, to test if a 'try' sequence has failed:
	if ( $MyString.try{ … }.failed() ) {
		$Color=""bright red"";
	}","String.failed()
文字列.失敗
.failed は、明示的なfail()呼び出しを含む、失敗したストリーム処理アクションString.try{}をテストします。現在の操作が失敗した場合は true を返し、それ以外の場合は false を返します。
文字列を処理するときに、その文字列が予期したものと異なる場合があります。したがって、.failed オペレーターは、このプロセスが機能しなかったことを示すフラグを立てます。
.failed フラグは、現在の try{} の有効期限が切れたとき、または現在のアクションが完了したときに false にリセットされます。{}
たとえば、「try」シーケンスが失敗したかどうかをテストするには、次のようにします。
if ( $MyString.try{ … }.failed() ) {
$Color=""明るい赤"";
}"
String.find(matchStr),Function,Item,Data manipulation,Number,false,6.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.find(matchStr)
This operator returns a Number with the location of the first occurrence of a literal (not regex) substring matchStr within the source string. Thus, the operator searches for literal strings, not regular expressions. Matches are case sensitive. The offset is zero-based (position 1 is zero). If the string is not found, String.find(matchStr) returns -1.
For example, if $MyString is ""I do not like green eggs and ham"":
	$MyNumber = $MyString.find(""not""); returns 5
	$MyNumber = $MyString.find(""blue""); returns -1 (not found in match string)
	$MyNumber = $MyString.find(""Not""); returns -1 (not found, due to case-sensitive matching)","文字列.find(一致文字列)
この演算子は、ソース文字列内でリテラル (正規表現ではない) 部分文字列 matchStr が最初に出現する位置を示す Number を返します。したがって、演算子は正規表現ではなくリテラル文字列を検索します。一致では大文字と小文字が区別されます。オフセットはゼロベースです (位置 1 はゼロです)。文字列が見つからない場合、String.find(matchStr) は -1 を返します。
たとえば、$MyString が「緑色の卵とハムは好きではありません」の場合:
$MyNumber = $MyString.find(""not"");5を返します
$MyNumber = $MyString.find(""青"");-1 を返します (一致文字列に見つかりません)
$MyNumber = $MyString.find(""Not"");-1 を返します (大文字と小文字を区別して一致するため、見つかりません)"
String.following(matchStr),Function,Item,Data manipulation,String,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.following(matchStr)
The .following( ) operator extracts information from one or more paragraphs of a string using a literal quoted string as the match (i.e. no regex support). If matchStr appears in a line, then whatever follows after the matchStr is the result. If matchStr appears in more than one line, the return value is a list of results.
For example, if the text of a note is:
	From: Mark
	To: Clotilde
	Subject: Mignardise
Then:
	$MyString = $Text.following(""To:""); 
 would return ""Clotilde"".
	$MyString = $Text.following("":""); 
would return ""Mark;Clotilde:Mignardise"".
In addition, the .following() operator binds any text that precedes the matchStr string to $0. If the matchStr appears several times, the first prefix is bound to $0, the second to $1, and so forth.
The .following() operator's argument is interpreted as a sequence of characters, not a regular expression. If the flexibility of regular expressions is needed, use .find() instead.
The .following() operator is useful for extracting formal and semi-formal data from free text and simple interchange formats like email and RIS.
The .following() operator does not skip Tinderbox action code comments starting with // as this confounds working with URLs.","String.following(matchStr)
.following( ) 演算子は、引用符で囲まれたリテラル文字列を一致として使用して、文字列の 1 つ以上の段落から情報を抽出します (つまり、正規表現はサポートされていません)。matchStr が行内にある場合は、matchStr の後に続くものが結果となります。matchStr が複数の行にある場合、戻り値は結果のリストです。
たとえば、メモのテキストが次の場合:
差出人: マーク
宛先: クロティルデ
件名: ミニャルディーズ
次に:
$MyString = $Text.following(""宛先:"");
「クロチルド」を返します。
$MyString = $Text.following("":"");
「Mark;Clotilde:Mignardise」を返します。
さらに、.following() 演算子は、matchStr 文字列の前にあるテキストを $0 にバインドします。matchStr が複数回出現する場合、最初のプレフィックスは $0 にバインドされ、2 番目のプレフィックスは $1 にバインドされます。
.following() 演算子の引数は、正規表現ではなく、一連の文字として解釈されます。正規表現の柔軟性が必要な場合は、代わりに .find() を使用してください。
.following() 演算子は、フリー テキストや電子メールや RIS などの単純な交換形式から正式および準形式のデータを抽出するのに役立ちます。
.following() 演算子は、URL の操作を混乱させるため、// で始まる Tinderbox アクション コード コメントをスキップしません。"
String.highlights([aColor]),Property,Item,Data manipulation,List,false,9.1.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.highlights(aColor)
String.highlights
The expression returns a list of strings that have been highlighted in the $Text using Format ▸ Highlight. 
	$MyList = $Text.highlights; 
Note: aColor can only be the value of a named colour as listing in the menu Format ▸ Style ▸ Highlight.
String.highlights(aColor)
The result may be limited to strings highlighted in a specific colour by supplying aColor as an argument. aColor may be any of the currently supported highlight colours: ""red"", ""green"", ""blue"", ""yellow"", or ""magenta"". Thus:
	$MyList = $Text.highlights(""red"");
would return only those highlighted $Text portions using a red highlight colour.","String.highlights(aColor)
文字列.ハイライト
この式は、[形式] ▸ [ハイライト] を使用して $Text 内でハイライトされた文字列のリストを返します。
$MyList = $Text.ハイライト;
注: aColor は、[形式] ▸ [スタイル] ▸ [ハイライト] メニューにリストされている名前付き色の値のみにすることができます。
String.highlights(aColor)
aColor を引数として指定すると、結果を特定の色で強調表示された文字列に限定できます。aColor は、現在サポートされているハイライト カラー「赤」、「緑」、「青」、「黄」、または「マゼンタ」のいずれかです。したがって:
$MyList = $Text.highlights(""red"");
赤いハイライト色を使用してハイライトされた $Text 部分のみを返します。"
String.icontains(regexStr),Function,Item,Query Boolean,boolean test,false,5.7.1,Baseline,9.0.0,,,1,true,true,false,false,true,false,false,false,false,,false,"String.icontains(regexStr)
This operator tests whether regular expression pattern regexStr matches the referenced string attribute's value in whole or part. Matches are always case-insensitive, unlike String.contains(). The match gives a coerced boolean result: if regexStr is matched (literally or via regex) the function returns the match offset+1 in the source string, where offset is the distance from the start of the string to the start of the matched regex. No match, coerces to false. The +1 works around the fact the match is zero-based, so a match at position 0 (the start of the string), returns as 1 (0+1) and a value of 1 or more coerces to a boolean true. The boolean allows queries' normal true/false to evaluate as normal.
If needing case-sensitivity, use String.contains() which is always case-sensitive
regexStr is one of:
* an unquoted action code expression, which includes just referencing a single attribute name e.g. MyString
* a quoted string; quoted strings may be either:
** a literal string (i.e. actual text)
** a regular expression.
Important: do not omit the enclosing quotes for literal strings or regex. If omitted, Tinderbox will try to evaluate the string as an expression. Doing this may result in the expected result but this is actually a false positive. So, remember to enclose your regex or literals in quotes.
For example:
	$MyString.icontains(""regex"") 
is true if $MyString matches regexStr's pattern. Other more complex usage:
	$MyString.icontains($MyMatchText) 
	$MyString.icontains($MyString(agent)) 
	$MyString(parent).icontains(""Tuesday"") 
	""Any day like Saturday is good"".icontains($MyDay) 
	""Any day like Saturday is good"".icontains(""Saturday"") 
Note that regex/literal strings are quoted whilst action expressions are not.
Getting the offset of the (first) regex match
If the regular expression regexStr is found the function returns the match offset+1, where offset is the distance from the start of the string to the start of the matched regex. If there is more than one match, the offset of the first match is returned. Formerly, .contains() returned true if the regex was found. The '+1' modifier ensures that a match at position zero return a number higher than zero which would otherwise coerce to false. Since 1+offset is always true, no changes are required in existing documents but the function also gives usable offset information. Thus, if $MyString is ""abcdefgehEi"":
	$MyNumber = $MyString.icontains(""e""); returns 5.
	$MyNumber = $MyString.icontains(""E""); returns 5.
	$MyNumber = $MyString.icontains(""eh""); returns 8.
Testing ""does not contain""
Use a ! prefix to the query argument:
	!$MyString.icontains(""Tuesday"") 
Use of parentheses around the negated query term, can assist Tinderbox's parsing:
	(!$MyString.icontains(""Tuesday"")) 
Using back-references
In an agent query or if() conditions the function can return back-references to matches of (sub-)strings.
String.icontains() clears the list of back references from previous processes, so $0 and $1 correspond to its own results, not those from prior expressions.
Dealing with inline quote characters
Because regex is parsed for regular expressions, it may be possible to use the '\xNN' form described here to work around the lack of escaping from single double quotes within strings.
Legacy format
This operator is the replacement of the older form of AttributeName(regex) which is deprecated and should not be used in new work (legacy support may fall away). Apart from anything else, the current syntax should remove the confusion over whether/when to use the $ prefix with attribute names in queries.","String.icontains(regexStr)
この演算子は、正規表現パターン regexStr が、参照された文字列属性の値の全体または一部と一致するかどうかをテストします。String.contains() とは異なり、一致では常に大文字と小文字が区別されません。一致により、強制されたブール値の結果が得られます。regexStr が (リテラルまたは正規表現経由で) 一致した場合、関数はソース文字列内の一致オフセット + 1 を返します。ここで、オフセットは文字列の先頭から一致した正規表現の先頭までの距離です。一致しないため、強制的に false に設定されます。+1 は、一致が 0 ベースであるという事実を回避するため、位置 0 (文字列の先頭) での一致は 1 (0+1) として返され、1 以上の値はブール値 true に強制されます。ブール値を使用すると、クエリの通常の true/false を通常どおり評価できます。
大文字と小文字を区別する必要がある場合は、常に大文字と小文字を区別する String.contains() を使用してください。
regexStr は次のいずれかです。
* 引用符で囲まれていないアクション コード式。これには、単一の属性名を参照するだけが含まれます。MyString
* 引用符で囲まれた文字列;引用符で囲まれた文字列は次のいずれかになります。
** リテラル文字列 (つまり、実際のテキスト)
** 正規表現。
重要: リテラル文字列または正規表現を囲む引用符を省略しないでください。省略した場合、Tinderbox は文字列を式として評価しようとします。これを実行すると期待どおりの結果が得られる可能性がありますが、これは実際には誤検知です。したがって、正規表現またはリテラルを引用符で囲むことを忘れないでください。
たとえば:
$MyString.icontains(""正規表現"")
$MyString が regexStr のパターンと一致する場合は true です。その他のより複雑な使用法:
$MyString.icontains($MyMatchText)
$MyString.icontains($MyString(エージェント))
$MyString(parent).icontains(""火曜日"")
「土曜日のような日が良いです。」.icontains($MyDay)
「土曜日のような日が良いです。」.icontains(""土曜日"")
正規表現/リテラル文字列は引用符で囲まれますが、アクション式は引用符で囲まれないことに注意してください。
(最初の) 正規表現一致のオフセットの取得
正規表現 regexStr が見つかった場合、関数は一致の offset+1 を返します。ここで、offset は文字列の先頭から一致した正規表現の先頭までの距離です。複数の一致がある場合は、最初の一致のオフセットが返されます。以前は、正規表現が見つかった場合、 .contains() は true を返しました。「+1」修飾子を使用すると、位置 0 での一致により、そうでない場合は false に強制されるゼロより大きい数値が返されることが保証されます。1+offset は常に true であるため、既存のドキュメントを変更する必要はありませんが、この関数は使用可能なオフセット情報も提供します。したがって、$MyString が「abcdefgehEi」の場合:
$MyNumber = $MyString.icontains(""e"");5を返します。
$MyNumber = $MyString.icontains(""E"");5を返します。
$MyNumber = $MyString.icontains(""え"");8を返します。
「を含まない」テスト
! を使用してください。クエリ引数の接頭辞:
!$MyString.icontains(""火曜日"")
否定されたクエリ用語を括弧で囲むと、Tinderbox の解析が容易になります。
(!$MyString.icontains(""火曜日""))
後方参照の使用
エージェント クエリまたは if() 条件では、関数は一致する (サブ) 文字列への逆参照を返すことができます。
String.icontains() は前のプロセスからの後方参照のリストをクリアするため、$0 と $1 は前の式の結果ではなく、独自の結果に対応します。
インライン引用符の扱い
regex は正規表現として解析されるため、ここで説明する「\xNN」形式を使用して、文字列内の単一二重引用符からエスケープできない問題を回避できる可能性があります。
レガシー形式
この演算子は、廃止された古い形式の AttributeName(regex) を置き換えるものであり、新しい作業では使用しないでください (レガシー サポートは廃止される可能性があります)。他のことは別として、現在の構文では、クエリ内の属性名に $ プレフィックスを使用するかどうか、またはいつ使用するかについての混乱が解消されるはずです。"
String.icontainsAnyOf(regexList),Function,List,Query Boolean,boolean test,false,8.9.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.icontainsAnyOf(regexList"")
The operator .icontainsAnyOf(""regexList) is true if any of the words in a set of words (i.e. list) is contained in the chained-to target string. As shown below, the list may have only one entry. The test is case-insensitive. For example:
	$MyBoolean = $Text.icontainsAnyOf(""emulate""); 
Will be true if the tested note's $Text contains the word ""emulate"". A more applied example:
	$MyBoolean = $Text.icontainsAnyOf(wordsRelatedTo(""emulate"")); 
Will be true if the tested note's $Text contains the word ""aspire"".
regexList implies using a list of values (ideally with no dupes). This can be a literal list of 1 or more values—as in the example above, or an attribute reference holding a list of values, for instance:
	$MyBoolean = $Text.icontainsAnyOf($MySet); 
It is important to note that .containsAnyOf() is always a case-insensitive test. Thus in the first example above, it will match both ""emulate"" and ""Emulate"" or any other case variant of the word.
Use of regular expressions
Although the examples above use whole words the list in regexList is actually processed assuming they are regular expressions (which may of course be literal strings). Thus in the first example above, it will match both ""emulate"" and ""emulated"" but not ""emulating"". The test value ""emulate\b"", expecting a word break after the final 'e' would this match ""emulate"" but not ""emulated"".
For a case-sensitive version of this operator see String.containsAnyOf().
If wishing to test a List or Set, chain to list.asString():
	$MyBoolean = $MyList.asString.icontainsAnyOf(wordsRelatedTo(""emulate""));","String.icontainsAnyOf(regexList"")
演算子 .icontainsAnyOf(""regexList) は、単語セット (つまりリスト) 内のいずれかの単語がチェーンされたターゲット文字列に含まれている場合に true になります。以下に示すように、リストにはエントリが 1 つだけ含まれる場合があります。テストでは大文字と小文字が区別されません。たとえば:
$MyBoolean = $Text.icontainsAnyOf(""エミュレート"");
テストされたメモの $Text に「emulate」という単語が含まれている場合は true になります。より応用的な例:
$MyBoolean = $Text.icontainsAnyOf(wordsManyTo(""emulate""));
テストされたメモの $Text に「aspire」という単語が含まれている場合は true になります。
regexList は、値のリスト (理想的には重複のないもの) を使用することを意味します。これは、上記の例のように 1 つ以上の値のリテラル リストにすることも、値のリストを保持する属性参照にすることもできます。次に例を示します。
$MyBoolean = $Text.icontainsAnyOf($MySet);
.containsAnyOf() は常に大文字と小文字を区別しないテストであることに注意することが重要です。したがって、上記の最初の例では、「emulate」と「Emulate」、または単語のその他の大文字と小文字の変形の両方に一致します。
正規表現の使用
上記の例では単語全体が使用されていますが、regexList 内のリストは実際には正規表現 (もちろんリテラル文字列の場合もあります) であると想定して処理されます。したがって、上記の最初の例では、「エミュレート」と「エミュレートされた」の両方に一致しますが、「エミュレート」には一致しません。テスト値「emulate\b」は、最後の「e」の後に単語の区切りがあると予想されますが、これは「emulate」には一致しますが、「emulated」には一致しません。
この演算子の大文字と小文字を区別するバージョンについては、String.containsAnyOf() を参照してください。
List または Set をテストしたい場合は、list.asString() にチェーンします。
$MyBoolean = $MyList.asString.icontainsAnyOf(wordsManyTo(""emulate""));"
String.json(),Function,Item,Formatting,String,false,5.7.0,Baseline,v9.1.0,,,,false,true,false,false,false,false,false,false,false,,true,"IMPORTANT: if looking for reading JSON see JSON.json[] and associated operators


LEGACY ONLY
Operator Deprecated in v9.1.0+ - use String.jsonEncode() instead
String.json()
String.json
This operator returns a JSON-encoded UTF-8 version of a string attribute's value. The apostrophe (straight single quote), straight double quote, solidus (forward slash) and backslash characters are all escaped by a preceding backslash character.
Now, use jsonEncode().","重要: JSON の読み取りを探している場合は、JSON.json[] および関連する演算子を参照してください。


レガシーのみ
v9.1.0 以降で廃止された演算子 - 代わりに String.jsonEncode() を使用してください
String.json()
文字列.json
この演算子は、文字列属性の値の JSON エンコードされた UTF-8 バージョンを返します。アポストロフィ (まっすぐな一重引用符)、まっすぐな二重引用符、塗りつぶし (スラッシュ)、およびバックスラッシュ文字はすべて、前にバックスラッシュ文字を置くことでエスケープされます。
次に、jsonEncode() を使用します。"
String.jsonEncode(),Function,Item,Formatting,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.jsonEncode()
String.jsonEncode
The .jsonEncode() operator returns a JSON-encoded UTF-8 version of the chained source String's value. Forbidden characters such as the apostrophe (straight single quote), straight double quote, solidus (forward slash) and backslash characters are all escaped by a preceding backslash character.
The general expectation is String will be a quoted literal string or a String-type attribute or variable, e.g. $Text:
	var:string vEncoded = $Text.jsonEncode() 
	^^value(""Apostrophe's are often wrongly used"".jsonEncode())^^ 
This operator was formerly know as .json, and is effectively a replacement for that operator. The naming also better reflects the non dot-operator jsonEncode().
Using the latter, the same outcome can be encoded as:
	var:string vEncoded = jsonEncode($Text) 
	^^value(jsonEncode(""Apostrophe's are often wrongly used""))^^ 
For attributes, variables and very long literal string, the chained dot-operator seems more helpful when coding, whereas the older form may be more intuitive with short literal strings (as shown in the last example above.)","String.jsonEncode()
String.jsonEncode
.jsonEncode() 演算子は、連鎖されたソース文字列の値の JSON エンコードされた UTF-8 バージョンを返します。アポストロフィ (まっすぐな一重引用符)、まっすぐな二重引用符、塗りつぶし文字 (スラッシュ)、およびバックスラッシュ文字などの禁止された文字はすべて、前にあるバックスラッシュ文字によってエスケープされます。
一般に、文字列は引用符で囲まれたリテラル文字列、または文字列型の属性または変数であることが期待されます。$Text:
var:string vEncoded = $Text.jsonEncode()
^^value(""アポストロフィは誤って使用されることがよくあります"".jsonEncode())^^
この演算子は以前は .json として知られており、事実上その演算子の代替品です。名前付けも、非ドット演算子の jsonEncode() をより適切に反映しています。
後者を使用すると、同じ結果を次のようにエンコードできます。
var:string vEncoded = jsonEncode($Text)
^^value(jsonEncode(""アポストロフィは誤って使用されることがよくあります""))^^
属性、変数、および非常に長いリテラル文字列の場合、コード化する際には連鎖ドット演算子の方が便利に見えますが、短いリテラル文字列の場合は古い形式の方が直感的である可能性があります (上記の最後の例に示すように)。"
String.lowercase(),Function,Item,Formatting,String,false,5.9.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.lowercase()
String.lowercase
Returns the referenced string, transforming all uppercase letters to lowercase.
The function can be chained to both string data and to string literals:
	$MyString.lowercase() 
	""My NEW Title"".lowercase() 
The latter results in ""my new title"".
The trailing parentheses may be omitted:
	$MyString.lowercase 
Functionally equivalent to lowercase().
If $MyString is ""Hello World"":
	$MyString = $MyString.lowercase; 
$MyString is set to ""hello world"".
The .lowercase() method may also be used on Lists or Sets. Consider [Ant;BEE;Cow] stored in $MyList:
	$MyList = $MyList.lowercase; 
… giving [ant;bee;cow].","文字列.小文字()
文字列.小文字
すべての大文字を小文字に変換して、参照された文字列を返します。
この関数は、文字列データと文字列リテラルの両方にチェーンできます。
$MyString. lowercase()
「私の新しいタイトル」. lowercase()
後者は「私の新しいタイトル」になります。
末尾の括弧は省略できます。
$MyString.小文字
機能的には lowercase() と同等です。
$MyString が「Hello World」の場合:
$MyString = $MyString. lowercase;
$MyString は「hello world」に設定されます。
. lowercase() メソッドは、リストまたはセットでも使用できます。$MyList に保存されている [Ant;BEE;Cow] について考えてみましょう。
$MyList = $MyList. lowercase;
… [アリ、ミツバチ、ウシ] を与えます。"
String.next(),Function,Item,Data manipulation,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.next()
String.next
The operator .next generates convenient note names and other strings in a sequence. For example:
	$MyString = ""footnote"".next ; → ""footnote 1""
	$MyString = ""footnote 1"".next; → ""footnote 2""
Specifically, .next searches a string for its last run of digits. If no digits are found, .next returns the string followed by "" 1"". Otherwise, the number is increments and placed in the same position in the string.
	$MyString = ""Agent 007 (active)"".next; → ""Agent 008 (active)""","String.next()
String.next
演算子 .next は、便利な音名とその他の文字列をシーケンス内に生成します。たとえば:
$MyString = ""脚注"".next ;→「脚注1」
$MyString = ""脚注 1"".next;→「脚注2」
具体的には、.next は文字列内で最後の一連の数字を検索します。数字が見つからない場合、.next は文字列の後に「1」を返します。それ以外の場合、数値は増分され、文字列内の同じ位置に配置されます。
$MyString = ""エージェント 007 (アクティブ)"".next;→「エージェント008（アクティブ）」"
String.nounList(),Property,Item,Data manipulation,List,false,9.0.0,Baseline,,,10.14,,false,true,false,false,false,false,false,false,false,,false,"String.nounList()
String.nounList
This returns a list of each noun in the supplied string, excepting those recognised as pronouns and proper names. Note that the output list is all lowercase, regardless of source case. This operator requires running on macOS 10.14 and later.
	$MyList = ""I am the very model of a modern Major-General."".nounList; 
then MyList holds ""model;major;general"".","String.nounList()
文字列.名詞リスト
これは、代名詞および固有名として認識されるものを除く、指定された文字列内の各名詞のリストを返します。ソースの大文字と小文字に関係なく、出力リストはすべて小文字であることに注意してください。このオペレーターは macOS 10.14 以降で実行する必要があります。
$MyList = ""私はまさに現代の少将のモデルです。"".nounList;
この場合、MyList には「モデル;メジャー;一般」が保持されます。"
String.paragraph(paraNum),Function,Item,Data manipulation,String,false,7.5.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.paragraph(paraNum)
returns the text of the paraNum paragraph in the source string. paraNum is zero-based, i.e. the first paragraph is .paragraph(0); empty paragraphs are ignored. If the string does not contain paraNum paragraphs, the result is an empty string. 
If paraNum is negative, Tinderbox counts from the last paragraph. Thus, $Text.paragraph(-1) is the last paragraph in the text.
For example:
	$MyString = $Text.paragraph(2); 
sets $MyString the the contents of the third paragraph of $Text—recall at N is zero-based, so counting 0/1/2 means 2 is #3 in the sequence.","文字列.段落(paraNum)
ソース文字列内の paraNum 段落のテキストを返します。paraNum はゼロベースです。つまり、最初の段落は .paragraph(0) です。空の段落は無視されます。文字列に paraNum 段落が含まれていない場合、結果は空の文字列になります。
paraNum が負の場合、Tinderbox は最後の段落からカウントします。したがって、$Text.paragraph(-1) はテキストの最後の段落になります。
たとえば:
$MyString = $Text.paragraph(2);
$MyString に $Text の 3 番目の段落の内容を設定します。N での呼び出しは 0 から始まるため、0/1/2 をカウントすることは、2 がシーケンスの 3 番目であることを意味します。"
String.paragraphCount(),Property,Item,Data manipulation,Number,false,7.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.paragraphCount()
String.paragraphCount
returns the Number of paragraphs in a string; empty paragraphs are ignored. Thus, $Text.paragraphCount is the number of paragraphs in the text of the currently selected note.
	$MyNumber = $Text.paragraphCount; 
sets $MyNumber to the number of discrete paragraphs within $Text.","String.paragraphCount()
文字列.段落数
文字列内の段落数を返します。空の段落は無視されます。したがって、$Text.paragraphCount は、現在選択されているメモのテキストの段落数になります。
$MyNumber = $Text.paragraphCount;
$MyNumber は、$Text 内の個別の段落の数を設定します。"
String.paragraphList(),Property,Item,Data manipulation,List,false,9.0.0,Baseline,,,10.14,,false,true,false,false,false,false,false,false,false,,false,"String.paragraphList()
String.paragraphList
The .paragraphList operator returns a list of paragraphs contained in a string. This operator requires running on macOS 10.14 and later. For example, to get a list of the discrete paragraphs in $Text:
		$MyList = $Text.paragraphList; 
To set a string to the third paragraph of $Text (recall the .at(N) operator is zero-based):
		$MyString = $Text.paragraphList.at(2); 
If wanting to iterate and test paragraphs, rather than chain $Text.paragraphList.each(){}, use the newer stream parsing method $Text.eachLine(){}. In both instance a line—or paragraph—is a substring—delimited by one of more successive line breaks.
Source paragraphs containing semicolons
As .paragraphList returns a List, if any source paragraph containing a semicolon it will create more than one item in the returned list. In such circumstances, in may be better to use .eachLine() instead. Or, if encountered, a technique is to first sanitise the source by changing semicolons to another string and then back:
    var:string vSource = $Text.replace("";"",""@@@"");
    $MyList = vSource.paragraphList;
    $MyString = $MyList.at(4)replace(""@@@"","";"");","String.paragraphList()
文字列.段落リスト
.paragraphList 演算子は、文字列に含まれる段落のリストを返します。このオペレーターは macOS 10.14 以降で実行する必要があります。たとえば、$Text 内の個別の段落のリストを取得するには、次のようにします。
$MyList = $Text.paragraphList;
$Text の 3 番目の段落に文字列を設定するには (.at(N) 演算子がゼロベースであることを思い出してください):
$MyString = $Text.paragraphList.at(2);
段落を反復してテストしたい場合は、$Text.paragraphList.each(){} を連鎖させるのではなく、新しいストリーム解析メソッド $Text.eachLine(){} を使用してください。どちらの場合も、行 (または段落) は、連続する改行の 1 つで区切られた部分文字列です。
セミコロンを含むソース段落
.paragraphList はリストを返すため、ソース段落にセミコロンが含まれている場合、返されたリストに複数の項目が作成されます。このような状況では、代わりに .eachLine() を使用する方がよい場合があります。または、セミコロンが見つかった場合は、最初にセミコロンを別の文字列に変更してから元に戻すことでソースをサニタイズするという手法もあります。
var:string vSource = $Text.replace("";"",""@@@"");
$MyList = vSource.paragraphList;
$MyString = $MyList.at(4)replace(""@@@"","";"");"
String.paragraphs(parasNum),Function,Item,Data manipulation,String,false,5.8.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.paragraphs(parasNum)
This function extracts the first parasNum paragraphs of the referenced string or String-type attribute. Examples:
	$MyString = ""Paragraph 1\nParagraph 2"".paragraphs(1); 
In the example the ""\n"" simulates a line break. The code would set $MyString to the string ""Paragraph 1"". A more real example:
	$Text = $Text(""Some note"").paragraphs(2); 
In the second example the current note's $Text would be set to the first 2 paragraphs of note ""Some note"".
To get a single given paragraph of a multi line/paragraph string, such as $Text, see String.split() (beware of semicolons in the source string being misinterpreted as list item delimiters, as discussed in that article).
This function respects existing rich text styling.
To get all paragraphs as a list, e.g. in order to iterate against them using list.each(), then use string.split(), e.g.:
	$MyList = $Text.split(""\n+""); 
Or from a different note, e.g. 'another note':
	$MyList = $Text(""another note"").split(""\n+""); 
The \n+ implies to split on and remove sub-strings of one or more consecutive line breaks, thus avoiding the creation of unwanted creating blank list items in the output where there are several line breaks between paragraphs.
Working with styled text
This operator is capable of worthing with StyledString operators: StyledString.bold, StyledString.fontSize(), StyledString.italic and StyledString.strike.","String.paragraphs(parasNum)
この関数は、参照された文字列または String 型属性の最初の parasNum 段落を抽出します。例:
$MyString = ""段落 1\n段落 2"".paragraphs(1);
この例では、「\n」は改行をシミュレートします。コードは $MyString を文字列「Paragraph 1」に設定します。より実際的な例:
$Text = $Text(""メモ"").paragraphs(2);
2 番目の例では、現在のノートの $Text がノート「Some note」の最初の 2 段落に設定されます。
$Text などの複数行/段落文字列の指定された 1 つの段落を取得するには、String.split() を参照してください (この記事で説明されているように、ソース文字列内のセミコロンがリスト項目の区切り文字として誤って解釈されることに注意してください)。
この関数は、既存のリッチ テキスト スタイルを尊重します。
すべての段落をリストとして取得するには、例:list.each() を使用してそれらに対して反復するには、 string.split() を使用します。例:
$MyList = $Text.split(""\n+"");
または別のメモから、たとえば「別のメモ」:
$MyList = $Text(""別のメモ"").split(""\n+"");
\n+ は、1 つ以上の連続した改行の部分文字列を分割して削除することを意味します。これにより、段落間に複数の改行がある出力で、不要な空のリスト項目が作成されるのを回避します。
スタイル付きテキストの操作
この演算子は、StyledString 演算子: StyledString.bold、StyledString.fontSize()、StyledString.italic、および StyledString.strike と併用できます。"
"String.replace(regexMatchStr, replacementStr)",Function,Item,Data manipulation,String,false,5.7.0,Baseline,,,,2,true,true,false,false,true,false,false,false,false,,false,"String/List.replace(regexMatchStr, replacementStr)
This operator allows simple text transformations without use of runCommand as was hitherto required.
regexMatchStr and replacement are one of:
* an action code expression (which includes just referencing a single attribute or variable name)
* a quoted string, which may be either:
** a literal string (i.e. actual text)
** a regular expression (regexMatchStr only)
$MyString.replace(regexMatchStr, replacementStr)
In its simplest form, the operator creates a new string in which each occurrence of regex is replaced by the string replacement, i.e. global replacement. The source string is not changed by replace; if you wish to change the string itself, write back over the source attribute:
	$MyString = $MyString.replace(""Hello"",""Goodbye""); 
transforms a $MyString value of ""Hello World"" to ""Goodbye World"".
Where regexMatchStr is a regular expression, and may contain wildcard characters such as ""."" (which matches any character) or ""*"" (which matches 0 or more occurrences of the preceding character). Thus "".*"" matches zero or more instances of any character.
Where parentheses in regexMatchStr create multiple back-references, replacementStr strings can include $1, $2, etc., to insert the relevant back-reference matched string ($1 through $9 allowed, and with $0 being the entire match).
The replacement replacementStr preserves styles in the source String.
Examples:
	$MyString.replace(""Spenser"",""Spencer""); 
changes all instance of ""Spenser"" to ""Spencer"".
	$MyString.replace(""(a|e|i|o|u)"",""""); 
deletes all vowels
	$MyString = ""I do not like green eggs"".replace(""(green) (eggs)"",""$2 $1""); 
returns ""I do not like eggs green"". Or:
	$Text=$Text.replace(""From: (.+)@(.*)"",""——$1——\n$2""); 
Will replace
	From: mark@example.com 
with
	——mark——
	example.com
Note that if the source text is part of a larger text, e.g. a whole email's plain text, consider using stream parsing methods.
A replace action does not alter the original source
Using .replace() does not affect the source string unless the replacement output is used to overwrite the original source value. Thus if $MyString holds ""Hello World"" then:
	$MyStringA = $MyString.replace("" World""); 
$MyString remains ""Hello Word"" and $MyStringA has value ""Hello"". The source is unchanged. But, if we set the source to the output
	$MyString = $MyString.replace("" World""); 
Now $MyString becomes ""Hello"" and the original value is lost (overwritten by the new one). This distinction is one to bear in mind when using .replace() with $Text.
Using .replace() with $Text and formatting operators
When applied to $Text, .replace() allows style operators to be applied to the replacement argument. For example,
	replace(""^From: .*"",$0.bold) 
will embolden all lines beginning with “From:”.
If using style operators, do not place operator-modified back-reference within quotes. To re-use the example from above, consider $Text containing ""I do not like green eggs and ham"":
	$Text = ""$Text.replace(""(green) (eggs)"",$2.bold+"" ""+ $1.strike); 
gives ""I do not like eggs green and ham"".
Multiple, but differing replacements
Although multiple matches can be replaced with the same string, to replace multiple matches with different strings requires chained .replace() calls. Consider formatting a large number to Continental style. This means inserting spaces as the group delimiter and a comma for the decimal delimiter. Assume $MyNumber's value is 1234567.89:
	$MyString = $MyNumber.replace(""(\d)(?=(?:\d{3})+([^\d]))"",""$1 "").replace(""\."","",""); 
Now, 1234567.89 becomes ""1 234 567,89"".
Some comma-delimited formats use straight double quotes for all/some values and demand that if this character appears in a value that is it escaped by doubling the character. If $Text is
	He shouted ""Hello!"" at the top of his voice. 
Then it could be escaped for CSV export like so:
	…,""^^value($Text.replace('""','""""'))^^"",… 
That exports:
	…,""He shouted """"Hello!"""" at the top of his voice."",… 
Note that in this instance using a single straight quote (instead of the more normal straight double quote) to contain the find and replace regexs works just fine. Also, there is no need to escape typographic double quotes, i.e. 'smart' or 'curly' quotes in this context.
This function respects existing rich text styling.
Short form for deletions
If the replacement string is omitted, the one-argument form $MyString.replace(regex) returns a copy of $MyString in which every occurrence of the regex is removed.
Trimming leading/trailing whitespace
	$MyString = $MyString.replace(""^^ +"","""").replace("" +$"",""""); 
The ' +' means one or more space characters. The first replace finds such a sub-string immediately following the start of the whole string ^), whilst the second does the same for a sub-string immediately before the end of the string ($). If applied to multi-paragraph string, e.g. with line breaks such as in $Text, every paragraph is trimmed. Likely this is what is desired, but care is needed in more specialist situations. So, testing sample strings/texts is a good idea before changing actual data of value. If working with List or Sets a slightly different code is needed.
Trimming leading/trailing quotes
Because Tinderbox cannot escape quote characters (i.e. \"" or \' do not escape the quote), use String.substr() to trim enclosing quotes on a string. Note that the latter, working on location in the string and not character type, cannot work on paragraphs within a string, such as in the example above.
Dealing with inline quote characters
Because regex is parsed for regular expressions, it may be possible to use the '\xNN' form of character encoding described here to work around the lack of escaping from single double quotes within strings.
Handling changes to $Text including link anchors
When using .replace is used on a note's $Text, the replaced text also updates the position of pre-existing text link anchor text.
Working with styled text
This operator is capable of worthing with StyledString operators: StyledString.bold, StyledString.fontSize(), StyledString.italic and StyledString.strike.",
String.reverse(),Function,Item,Data manipulation,String,false,5.8.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.reverse()
String.reverse
This function reverses the order of the referenced string or string literal. Trailing parentheses are optional for this function.
	$MyString = $MyString.reverse(); 
	$MyString = $MyString.reverse; 
	$MyString = ""man bites dog"".reverse(); 
The latter gives ""god setib nam"" not ""dog bites man"". It is the order of characters that is reversed, not words within it.","文字列.reverse()
文字列.reverse
この関数は、参照された文字列または文字列リテラルの順序を逆にします。この関数の末尾の括弧はオプションです。
$MyString = $MyString.reverse();
$MyString = $MyString.reverse;
$MyString = ""男が犬を噛む"".reverse();
後者は「犬が人を噛む」ではなく「神セティブ・ナム」を与えます。逆になるのは文字の順序であり、その中の単語ではありません。"
String.sentence([sentenceNum]),Function,Item,Data manipulation,String,false,9.5.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.sentence([sentenceNum])
String.sentence()
String.sentence
The dot-operator .sentence(sentenceNum) extracts the sentenceNumth sentence from the source String, which most likely will be $Text. For example, if $Text contains the passage ""Mr. Smith went to Washington. He shook hands. He kissed babies."", then""
	$MyString = $Text.sentence(0); 
returns 'Mr. Smith went to Washington.' and
	$Text.sentence(2) 
returns ""He kissed babies.""
If the sentenceNum argument is omitted, the initial sentence is returned. This is sentence 0 (zero) as sentenceNum is a zero-based index.
The definition of a 'sentence' is heuristic, and varies depending on the locale. In the example above, notice Tinderbox (in en-US locale) recognises that the period following ""Mr."" ends an abbreviation, not a sentence. The locale is derived from the users macOS settings but can also be set contextually using locale().","String.sentence([sentenceNum])
文字列.sentence()
文字列.文
ドット演算子 .sentence(sentenceNum) は、ソース String から SentenceNumth 文を抽出します。これはおそらく $Text です。たとえば、$Text に「スミス氏はワシントンに行きました。握手しました。赤ちゃんにキスしました。」という一節が含まれている場合、""
$MyString = $Text.sentence(0);
「ミスター」を返します。スミスはワシントンへ行った。そして
$Text.sentence(2)
「彼は赤ちゃんにキスをしました。」と返します。
textNum 引数を省略した場合は、最初の文が返されます。SentenceNum はゼロから始まるインデックスであるため、これはセンテンス 0 (ゼロ) です。
「文」の定義はヒューリスティックであり、ロケールによって異なります。上の例では、Tinderbox (en-US ロケール) が「Mr.」に続くピリオドを認識していることに注目してください。文ではなく略語で終わります。ロケールはユーザーの macOS 設定から派生しますが、locale() を使用して状況に応じて設定することもできます。"
String.sentences(),Operator,Item,Data manipulation,List,false,9.7.3,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.sentences()
String.sentences() returns a list of sentences in the source String. Sentences are formed by natural language analysis of the text, which reduces the likelihood of errors cause by abbreviations, decimals, and quoted interjections. 
The operator takes no arguments so the trailing parentheses may be omitted if desired.
Note: 
* any/every semicolon in the sentences are replaced by an underscore character (_). This is because list-based Tinderbox attributes use semicolons to delimit the list's items.
* any leading/trailing whitespace (including tabs, line breaks, etc.) is trimmed from the sentence.
Example:
	$MyList = $Text.sentences(); -","String.sentences()
String.sentences() は、ソース String 内の文のリストを返します。文はテキストの自然言語分析によって形成され、略語、小数点、引用符で囲まれた挿入詞によって引き起こされるエラーの可能性が軽減されます。
演算子は引数を取らないため、必要に応じて末尾の括弧を省略できます。
注:
* 文中のセミコロンはすべてアンダースコア文字 (_) に置き換えられます。これは、リストベースの Tinderbox 属性がリストの項目を区切るためにセミコロンを使用するためです。
* 先頭/末尾の空白 (タブ、改行などを含む) は文から削除されます。
例:
$MyList = $Text.sentences();-"
"String.show([backgroundColor[, colorString, [durationNum]]])",Function,Item,Data manipulation,success boolean,false,9.5.2,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.show([backgroundColor[,colorString]])
String.show()
String.show
The String.show() function allows a plain-text message to be shown in the front window's message placard. The source text may be a literal string, variable or a String-type attribute value. The trailing parentheses are optional.
String.show() allows a further three optional arguments.
The optional backgroundColor argument may be used on its own with or without the optional third colorString argument. But if the colorString argument is used, then the backgroundColor argument must be given as well. The same holds for the optional durationNum argument. If passed, durationNum specifies the number of seconds for which to display the message. Setting a duration can be useful if wanted to show a series of short messages, each in a discrete manner.
The features and limitations of messages sent to the placard are described separately under the Message placards article.
The show(MsgString) operator offers a non-dot-operator alternative.
From v10.1.1, .show() takes an additional optional Number argument duration:
	String.show(foreground, background, duration])
If passed, duration specifies the number of seconds for which to display the message. If not specified, the display duration is 3 seconds. Setting a duration can be useful if wanted to show a series of short messages, each in a discrete manner.","String.show([背景色[,colorString]])
String.show()
文字列.show
String.show() 関数を使用すると、フロント ウィンドウのメッセージ プラカードにプレーン テキスト メッセージを表示できます。ソース テキストは、リテラル文字列、変数、または文字列型の属性値の場合があります。末尾の括弧はオプションです。
String.show() では、さらに 3 つのオプションの引数を使用できます。
オプションのbackgroundColor引数は、オプションの3番目のcolorString引数の有無にかかわらず、単独で使用できます。ただし、colorString 引数を使用する場合は、backgroundColor 引数も指定する必要があります。オプションのdurationNum引数にも同じことが当てはまります。渡された場合、durationNum はメッセージを表示する秒数を指定します。一連の短いメッセージを個別に表示したい場合は、期間を設定すると便利です。
プラカードに送信されるメッセージの機能と制限については、「メッセージ プラカード」の記事で別途説明します。
show(MsgString) 演算子は、ドット演算子以外の代替手段を提供します。
v10.1.1 以降、.show() は追加のオプションの Number 引数の期間を受け取ります。
String.show(前景、背景、継続時間])
渡された場合、duration はメッセージを表示する秒数を指定します。指定しない場合、表示時間は 3 秒です。一連の短いメッセージを個別に表示したい場合は、期間を設定すると便利です。"
String.size(),Property,Item,Data manipulation,Number,false,5.7.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.size()
String.size
This returns the Number of characters in a string value. The returned number can be coerced to a string. Examples:
	$MyString = ""hello world""; $MyNumber = $MyString.size; $MyStringA = $MyString.size; 
The value of $MyNumber will be the number 11, $MyStringA will be the string ""11"".
This operator can also be used on other attribute data types that are string-like, URL, File, etc.
The 'size' of $Text is pre-computed and accessed via the read-only system attribute $TextLength. 
More detail on how character counts are made.","文字列.size()
文字列のサイズ
これは、文字列値の文字数を返します。返された数値は文字列に強制的に変換できます。例:
$MyString = ""こんにちは"";$MyNumber = $MyString.size;$MyStringA = $MyString.size;
$MyNumber の値は数値 11 になり、$MyStringA は文字列「11」になります。
この演算子は、文字列のような他の属性データ型、URL、ファイルなどにも使用できます。
$Text の「サイズ」は事前に計算され、読み取り専用のシステム属性 $TextLength を介してアクセスされます。
文字カウントの方法について詳しく説明します。"
String.skip(charsNum),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.skip(charsNum)
Moves the current stream position charsNum characters forward (right). A failure occurs if charsNum reaches past the end of the String stream.
For example, for stream ""It was the best of times, it was the worst of times"":
	vText = $Text.skip(20); 
Advances the cursor forward 20 characters, returning the stream ""imes, it was the worst of times"". Otherwise, if the end of the string is detected, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .expect() unless a failure occurs in which case chained operators are not processed.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.skip(charsNum)
現在のストリーム位置を charsNum 文字前方 (右) に移動します。charsNum が String ストリームの終わりを超えると、エラーが発生します。
たとえば、ストリーム「最高の時代でしたが、最悪の時代でした」の場合:
vText = $Text.skip(20);
カーソルを 20 文字進めて、ストリーム「imes、最悪の時代でした」を返します。それ以外の場合、文字列の終わりが検出された場合、処理は失敗し、カーソルは進みません。いずれの場合でも、変数 vText は、エラーが発生しない限り、.expect() に連鎖した他の演算子と同様に、結果のテキスト ストリームを受け取ります。この場合、連鎖した演算子は処理されません。
この演算子の使用は、キャプチャされるコンテンツが正しく検出されることを保証するための補助として使用されます。基本的に、これは「if」スタイルのテストです。テストが正しければ続行し、そうでない場合は、チェーンされたストリーム解析演算子が存在する可能性があるため、カーソルはその位置に留まります。"
String.skipLine(),Function,Item,Stream parsing,String,false,9.5.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.skipLine()
String.skipLine
The dot-operator String.skipLine skips forward to the next carriage return or to the end of the String stream. String.skipLine fails if the string is exhausted, i.e. the stream cursor remains where it was before the call.
The sort of scenario with which this helps is where the desired line(s) has no identifiable label but is preceded by a separate area of the stream that can be found. Thus in a raw email transcript the content includes labels like 'To:' and 'Subject:' but has nothing for the main body copy, which simply forms all content after the Subject line.
Most stream operators work up to the end of the current line but exclude the line break characters (\n) that separates each line. In the above scenario, where the needed line cannot be detected but the preceding line can be, .skipLine allows code like this:
	$Source.captureTo(""Subject:"").skipLine.captureRest(""Text"")","String.skipLine()
文字列.skipLine
ドット演算子 String.skipLine は、次の復帰または String ストリームの最後までスキップします。文字列が使い果たされると、String.skipLine は失敗します。つまり、ストリーム カーソルは呼び出し前の位置に残ります。
これが役立つシナリオは、目的の行に識別可能なラベルがないものの、その前にストリームの別の領域が存在する場合です。したがって、生の電子メールのトランスクリプトでは、コンテンツには「To:」や「Subject:」などのラベルが含まれますが、本文のコピーには何も含まれず、単に件名行の後のすべてのコンテンツが形成されます。
ほとんどのストリーム演算子は現在の行の末尾まで機能しますが、各行を区切る改行文字 (\n) は除外されます。上記のシナリオでは、必要な行は検出できないが、その前の行は検出できる場合、 .skipLine では次のようなコードが許可されます。
$Source.captureTo(""件名:"").skipLine.captureRest(""テキスト"")"
String.skipTo(matchStr),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.skipTo(matchStr)
Looks for the matchStr (N.B. this is not a regular expression) in the source String stream. If not found, it returns nothing. If found, it returns the string that follows matchStr.
For example:
	vText = $Text.skipTo(""abc""); 
Tests that the next characters in the stream read from $Text is the sequence abc, and advances the stream beyond ""abc"". Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream as would any operator chained to .skipTo() unless a failure occurs in which case chained operators are not processed.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.skipTo(matchStr)
ソース String ストリームで matchStr (注意: これは正規表現ではありません) を探します。見つからない場合は何も返しません。見つかった場合は、matchStr に続く文字列を返します。
たとえば:
vText = $Text.skipTo(""abc"");
$Text から読み取られるストリーム内の次の文字がシーケンス abc であることをテストし、ストリームを ""abc"" より先に進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合でも、変数 vText は、エラーが発生しない限り、.skipTo() に連鎖した他の演算子と同様に、結果のテキスト ストリームを受け取ります。この場合、連鎖した演算子は処理されません。
この演算子の使用は、キャプチャされるコンテンツが正しく検出されることを保証するための補助として使用されます。基本的に、これは「if」スタイルのテストです。テストが正しければ続行し、そうでない場合は、チェーンされたストリーム解析演算子が存在する可能性があるため、カーソルはその位置に留まります。"
String.skipToNumber(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.skipToNumber()
String.skipToNumber
Advances the String stream to the next number (i.e. one of more continuous number characters). A failure occurs if the stream is exhausted.
For example:
	vText = $Text.skipToNumber(); 
Tests that the next characters in the stream read from $Text is a sequence of digits, and advances the stream past a continuous runs of digits. Otherwise, it fails and the cursor does not advance. Either way, variable vText receives the resulting text stream (as would any operator chained to .skipToNumber() unless a failure occurs in which case chained operators are not processed.
If the input stream passes in ""1234 items"" the cursor advances past '1234' such that the remaining stream is "" items"".
If the input stream passes in ""1,234 items"" the cursor advances past '1' such that the remaining stream is ""234 items"". Notice how number formatting delimiters like a comma (or other locale-specific delimiters) used in string representations of  numbers may confuse this operator is used without care.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.skipToNumber()
String.skipToNumber
文字列ストリームを次の数値 (つまり、1 つ以上の連続した数値文字) に進めます。ストリームが使い果たされると、障害が発生します。
たとえば:
vText = $Text.skipToNumber();
$Text から読み取られるストリーム内の次の文字が一連の数字であることをテストし、一連の数字を超えてストリームを進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合でも、変数 vText は結果のテキスト ストリームを受け取ります (エラーが発生しない限り、.skipToNumber() に連鎖した演算子と同様に、連鎖した演算子は処理されません。
入力ストリームが「1234 アイテム」を渡す場合、カーソルは「1234」を超えて進み、残りのストリームは「アイテム」になります。
入力ストリームが「1,234 項目」を渡す場合、カーソルは「1」を超えて進み、残りのストリームは「234 項目」になります。数値の文字列表現で使用されるカンマ (またはその他のロケール固有の区切り文字) などの数値書式設定区切り文字が、この演算子が不注意に使用されるとどのように混乱するかに注意してください。
この演算子の使用は、キャプチャされるコンテンツが正しく検出されることを保証するための補助として使用されます。基本的に、これは「if」スタイルのテストです。テストが正しければ続行し、そうでない場合は、チェーンされたストリーム解析演算子が存在する可能性があるため、カーソルはその位置に留まります。"
String.skipWhitespace(),Function,Item,Stream parsing,String,false,9.1.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.skipWhitespace()
String.skipWhitespace
Advances the String stream to the first character that is not whitespace. A failure occurs if the stream is exhausted.
For example:
	vText = $Text.skipWhitespace(); 
Tests that the next characters in the stream are non-word, and advances the stream beyond the detected  whitespaces characters. Otherwise, it fails and the cursor does not advance. Either way, the variable vText receives the resulting text stream as would any operator chained to .skipWhitespace() unless a failure occurs in which case chained operators are not processed. 
If the stream passed in is ""  Hello world"" (note the leading spaces) then the spaces are detected and the cursor returns ""Hello world"". But if the stream passed in is ""Hello world"" a word is detected and the cursor does not advance.
The presumption for use of this operator is as an assist to help ensure to-be-captured content is correctly detected. Essentially, this is a 'if' style test: if the test is correct proceed, else the cursor remains where it is for any possible chained stream parsing operators.","String.skipWhitespace()
String.skipWhitespace
String ストリームを空白ではない最初の文字まで進めます。ストリームが使い果たされると、障害が発生します。
たとえば:
vText = $Text.skipWhitespace();
ストリーム内の次の文字が単語ではないことをテストし、検出された空白文字を超えてストリームを進めます。それ以外の場合は失敗し、カーソルは進みません。いずれの場合でも、変数 vText は、エラーが発生しない限り、.skipWhitespace() に連鎖した他の演算子と同様に、結果のテキスト ストリームを受け取ります。この場合、連鎖した演算子は処理されません。
渡されたストリームが「Hello world」(先頭のスペースに注意) の場合、スペースが検出され、カーソルは「Hello world」を返します。ただし、渡されたストリームが「Hello world」の場合、単語が検出され、カーソルは進みません。
この演算子の使用は、キャプチャされるコンテンツが正しく検出されることを保証するための補助として使用されます。基本的に、これは「if」スタイルのテストです。テストが正しければ続行し、そうでない場合は、チェーンされたストリーム解析演算子が存在する可能性があるため、カーソルはその位置に留まります。"
String.speak([voiceNameStr]),Function,Item,Data manipulation,success boolean,false,6.0.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.speak([voiceNameStr])
speaks a string using Mac text-to-speech. If another string is being spoken, the new phrase is spoken after the current phrase is complete.
	$Text.speak(); 
An optional second argument voiceNameStr identifies the voice the speech synthesiser should use. If the nominated voiceNameStr is not present no sound is played. The closing parentheses are only needed if the extra argument is being passed:
	$Text.speak(""Tessa""); 
Quoted literal strings can be chained to .speak():
	""Look on my Works, ye Mighty, and despair"".speak(); 
	'Look on my Works, ye Mighty, and despair'.speak(); 
See also speak().","String.speak([voiceNameStr])
Mac のテキスト読み上げを使用して文字列を読み上げます。別の文字列が話されている場合は、現在のフレーズが完了した後に新しいフレーズが読み上げられます。
$Text.speak();
オプションの 2 番目の引数 voiceNameStr は、音声合成装置が使用する音声を識別します。指定された voiceNameStr が存在しない場合、サウンドは再生されません。右括弧は、追加の引数が渡される場合にのみ必要です。
$Text.speak(""テッサ"");
引用符で囲まれたリテラル文字列は .speak() にチェーンできます。
「私の作品を見てください、力ある者よ、そして絶望してください。」.speak();
「私の作品を見てください、力ある者よ、そして絶望してください。」.speak();
「speak()」も参照してください。"
String.split(regexStr),Function,Item,Data manipulation,List,false,5.7.1,Baseline,,,,1,true,true,false,false,true,false,false,false,false,,false,"String.split(regexStr)
This operator splits a string into a List, as divided by instances of regular expression pattern regexStr in the original string. Source characters matched by regexStr are not passed to the list. The source string itself is not affected.
regexStr is one of:
* an action code expression (which includes just referencing a single attribute name')
* a quoted string; quoted strings may be either:
** a literal string (i.e. actual text)
** a regular expression
Useful regex values are:
* ""\W+"". This splits the source at word boundaries removing spaces and punctuation.
* ""\n"". This divides the string into discrete paragraphs, ignoring blank lines and/or lines/paragraphs with only spaces but no textual content.
* ""\."". This divides on sentences ending with a period. It will strip the terminating punctuation.
* ""[\.\?\!]"". As above but the sentence may end with any of full stop, question mark or exclamation mark.
The result of the operator is a List-type attribute value, i.e. the data should be passed to a list. Passing the output to a Set-type attribute will de-dupe any list values in the output with the first instance of any duplicates forming its set entry.
For example:
	$MyList = ""ant bee ant cow"".split("" ""); gives list [ant;bee;ant;cow]
	$MySet = ""ant bee ant cow"".split("" ""); gives list [ant;bee;cow]
	$MyList = ""ant, bee, cow"".split(""\W+ ""); gives  list [ant;bee;cow]
	$MyList = ""ant, bee, cow"".split("" ""); gives list [ant,;bee,;cow]
	$MyList = $MyString.split($MyString(agent)); 
	$MyList = $MyString(parent).split(""and""); 
If the string, stored in $MyString, is multi-line:
ant
bee
cow
…then: 
	$MyList = $MyString.split(""\n""); 
gives list [ant;bee;cow]. 
This approach can be useful if trying to retrieve a specific paragraph of $Text, perhaps from notes exploded from a larger consistently formatted text source. To get a string holding just paragraph #3 of the source $Text (or other multi-line string data):
	$MyString = $Text.split(""\n"").at(2); 
Do not overlook the fact that that List.at() is zero-based. That means the first list item is .at(0) and so the third list item is '2' and not '3' as might otherwise be assumed the last item is '-1':
	$MyString = $Text.split(""\n"").at(-1); 
There is one limitation of this approach to working with $Text or multi-line strings. The issue is that blank lines or lines with only spaces, are ignored; lists do not hold 'empty' items. So if the string $MyString is multi-line and contains blank lines, like so:
ant
  
bee
cow
…then:
	$MyList = $MyString.split(""\n""); 
still gives [ant;bee;cow]. 
It does not matter if the blank is just two successive line returns or actually contains some white space, no list item is created for it.
Luckily there is a simple workaround is to seed empty lines with a single hyphen (or whatever placeholder you prefer, e.g. ""N/A"" or such). Thus:
	$MyList = $Text.replace(""\n\n"",""\n-\n"").split(""\n""); 
…now gives $MyList [ant;-;bee;cow] such that ""bee"" is still paragraph #3 of the new list, as in the original text. If you wanted to make a deliberate review of such data you might use a more distinctive marker string:
	$MyList = $Text.replace(""\n\n"",""\n#####\n"").split(""\n""); 
You could then query for $MyList.contains(""#####"").
Dealing with inline quote characters
Because regex is parsed for regular expressions, it may be possible to use the '\dnn' form described here to work around the lack of escaping from single double quotes within strings.
Dealing with inline semi-colons
As this function outputs a list, where values are semi-colon delimited, if the source string—such as $Text—has semicolons in it they act as extra (unexpected!) splits when viewing the outcome. To get around this, escape the semicolons on the fly:
	$MyList = $Text.replace("";"",""\\;"").split(""\n""); 
However, the surviving inline semicolons in the resulting List items will get misread, when interrogating the List, as item delimiters. In such cases, first replace inline semicolons with another character(s) before using the split-generated list and then reverse the replacement before actual use of the text. For example:
    var:string vSource = $Text.replace("";"",""@@@"");
    $MyList = vSource.paragraphList;
    $MyString = $MyList.at(4)replace(""@@@"","";"");","文字列.split(regexStr)
この演算子は、元の文字列内の正規表現パターン regexStr のインスタンスによって分割された文字列を List に分割します。regexStr と一致するソース文字はリストに渡されません。ソース文字列自体は影響を受けません。
regexStr は次のいずれかです。
* アクション コード式 (単一の属性名の参照のみを含む)
* 引用符で囲まれた文字列;引用符で囲まれた文字列は次のいずれかになります。
** リテラル文字列 (つまり、実際のテキスト)
** 正規表現
有用な正規表現値は次のとおりです。
*「\W+」。これにより、単語の境界でソースが分割され、スペースと句読点が削除されます。
*「\n」。これにより、文字列が個別の段落に分割され、空行やスペースのみでテキスト内容のない行/段落は無視されます。
*「\.」。これは、ピリオドで終わる文で分割されます。終了句読点が削除されます。
* 「[\.\?\!]」。上記と同様ですが、文はピリオド、疑問符、感嘆符のいずれかで終わる場合があります。
演算子の結果はリスト型の属性値です。つまり、データはリストに渡される必要があります。出力を Set-type 属性に渡すと、セット エントリを形成する重複の最初のインスタンスを使用して、出力内のリスト値の重複が排除されます。
たとえば:
$MyList = ""アリ蜂アリ牛"".split("" "");リストを与える [アリ;ミツバチ;アリ;ウシ]
$MySet = ""アリ蜂アリ牛"".split("" "");リストを与える [アリ;蜂;牛]
$MyList = ""アリ、ハチ、ウシ"".split(""\W+ "");リストを与える [アリ;蜂;牛]
$MyList = ""アリ、ハチ、ウシ"".split("" "");リストを与える [アリ,;蜂,;牛]
$MyList = $MyString.split($MyString(agent));
$MyList = $MyString(parent).split(""and"");
$MyString に格納されている文字列が複数行の場合:
アリ
蜂
牛
…その後:
$MyList = $MyString.split(""\n"");
リスト [アリ;ミツバチ;ウシ] を与えます。
このアプローチは、$Text の特定の段落 (おそらく、より大きな一貫した形式のテキスト ソースから展開されたメモから) を取得しようとする場合に役立ちます。ソース $Text (または他の複数行文字列データ) の段落 #3 だけを保持する文字列を取得するには、次のようにします。
$MyString = $Text.split(""\n"").at(2);
List.at() がゼロベースであるという事実を見落とさないでください。これは、最初のリスト項目が .at(0) であるため、3 番目のリスト項目は '2' であり、最後の項目が '-1' であると想定される '3' ではないことを意味します。
$MyString = $Text.split(""\n"").at(-1);
$Text または複数行の文字列を操作する場合、このアプローチには 1 つの制限があります。問題は、空白行またはスペースのみの行が無視されることです。リストには「空」の項目は保持されません。したがって、文字列 $MyString が複数行であり、空白行が含まれている場合は、次のようになります。
アリ

蜂
牛
…その後:
$MyList = $MyString.split(""\n"");
まだ[蟻;蜂;牛]を与えます。
空白が単なる 2 つの連続した改行であるか、実際に空白が含まれているかは関係なく、その空白に対してリスト項目は作成されません。
幸いなことに、空の行に 1 つのハイフン (または「N/A」などの任意のプレースホルダー) をシードするという簡単な回避策があります。したがって:
$MyList = $Text.replace(""\n\n"",""\n-\n"").split(""\n"");
…今度は $MyList [ant;-;bee;cow] を与え、元のテキストと同様に、「bee」が新しいリストの段落 #3 になるようにします。このようなデータを慎重にレビューしたい場合は、より特徴的なマーカー文字列を使用できます。
$MyList = $Text.replace(""\n\n"",""\n#####\n"").split(""\n"");
その後、$MyList.contains(""#####"") をクエリできます。
インライン引用符の扱い
regex は正規表現として解析されるため、ここで説明する「\dnn」形式を使用して、文字列内の単一二重引用符からエスケープできない問題を回避できる可能性があります。
インラインセミコロンの扱い
この関数は値がセミコロンで区切られたリストを出力するため、$Text などのソース文字列にセミコロンが含まれている場合、結果を表示するときに余分な (予期しない!) 分割として機能します。これを回避するには、その場でセミコロンをエスケープします。
$MyList = $Text.replace("";"",""\\;"").split(""\n"");
ただし、結果のリスト項目に残っているインライン セミコロンは、リストを問い合わせるときに項目区切り文字として誤って読み取られます。このような場合は、分割生成リストを使用する前に、まずインラインのセミコロンを別の文字に置き換えてから、テキストを実際に使用する前に置換を元に戻します。たとえば:
var:string vSource = $Text.replace("";"",""@@@"");
$MyList = vSource.paragraphList;
$MyString = $MyList.at(4)replace(""@@@"","";"");"
"String.substr(startNum[, lengthNum])",Function,Item,Data manipulation,String,false,5.7.0,Baseline,,,,2,true,true,false,false,false,false,false,true,false,,false,"String.substr(startNum[, lengthNum])
This operator allows extraction of a substring from a string attribute. The source string is not affected.
	$MyString.substr(startN) 
returns the substring of $MyString beginning startNum characters from the beginning. The numbers for startN and lengthN are 0-based, i.e. zero is character position #1. A negative startNum value counts back from the end of the string .Negative values are 1-based, i.e. the -1 represents the last character in the string.
In the examples below assume $MyString's value is ""Hello World"". Examples:
	$MyString = ""abcde"".substr(2); returns ""cde""
	$MyString = ""abcde"".substr(-2); returns ""de""
	$MyString = $MyString.substr(6); returns ""World""
If the string does not contain at least startNum characters, the empty string is returned.
A second argument lengthNum specifies the length of the returned string. If unspecified, the entire remaining string is returned.
	$MyString = ""abcde"".substr(2,2); returns ""cd""
	$MyString = ""abcde"".substr(-3,2); returns ""cd""
	$MyString = $MyString.substr(0,5); returns ""Hello""
If the length of the substring is negative, it is treated as an offset from the end of the string.
	$MyString = ""Hello"".substr(1,-1); → ""ell""
Besides strings and string literals, this operator can also be used on other attribute data types that are string-like, URL, File, etc. Although the operator also works on lists/sets, the source data is all the values as a single semi-colon-joined string literal so there is less point in its use in this context.
This function respects existing rich text styling.
Incorrect argument values
If .substr() is asked to address parts of the string before its start or after its end, .substr() returns the empty string. This can arise through poor selection of input argument values. For instance, if $MyString is 5 characters long, $MyString.substr(0-7) is impossible, so this returns an empty string.
Trimming leading/trailing quotes
See String.trim().
Working with styled text
This operator is capable of worthing with StyledString operators: StyledString.bold, StyledString.fontSize(), StyledString.italic and StyledString.strike.","String.substr(開始番号[, 長さ番号])
この演算子を使用すると、文字列属性から部分文字列を抽出できます。ソース文字列は影響を受けません。
$MyString.substr(startN)
$MyString の先頭から startNum 文字で始まる部分文字列を返します。startN と lengthN の数値は 0 から始まります。つまり、0 は文字位置 #1 です。負の startNum 値は、文字列の末尾から逆にカウントされます。負の値は 1 から始まります。つまり、-1 は文字列の最後の文字を表します。
以下の例では、$MyString の値が「Hello World」であると想定しています。例:
$MyString = ""abcde"".substr(2);「cde」を返します
$MyString = ""abcde"".substr(-2);「で」を返します
$MyString = $MyString.substr(6);「世界」を返します
文字列に少なくとも startNum 文字が含まれていない場合は、空の文字列が返されます。
2 番目の引数 lengthNum は、返される文字列の長さを指定します。指定しない場合は、残りの文字列全体が返されます。
$MyString = ""abcde"".substr(2,2);「cd」を返します
$MyString = ""abcde"".substr(-3,2);「cd」を返します
$MyString = $MyString.substr(0,5);「こんにちは」を返します
部分文字列の長さが負の場合、文字列の末尾からのオフセットとして扱われます。
$MyString = ""こんにちは"".substr(1,-1);→「エル」
文字列と文字列リテラルに加えて、この演算子は文字列のような他の属性データ型、URL、ファイルなどにも使用できます。この演算子はリスト/セットでも機能しますが、ソース データはすべての値がセミコロンで結合された単一の文字列リテラルであるため、このコンテキストで使用する意味はあまりありません。
この関数は、既存のリッチ テキスト スタイルを尊重します。
引数の値が正しくありません
.substr() が文字列の開始前または終了後の部分をアドレス指定するように要求された場合、.substr() は空の文字列を返します。これは、入力引数の値の選択が不適切な場合に発生する可能性があります。たとえば、$MyString の長さが 5 文字の場合、$MyString.substr(0-7) は不可能であるため、空の文字列が返されます。
先頭/末尾の引用符のトリミング
String.trim() を参照してください。
スタイル付きテキストの操作
この演算子は、StyledString 演算子: StyledString.bold、StyledString.fontSize()、StyledString.italic、および StyledString.strike と併用できます。"
String.toNumber(),Function,Item,Data manipulation,Number,false,5.8.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.toNumber()
String.toNumber
Used for explicit coercion of numbers in strings to Number type data. Examples:
	$MyNumber = $MyString.toNumber; 
	$MyNumberA = ""40"".toNumber; 
This can be useful if default type coercion is not working as expected.","String.toNumber()
文字列.to数値
文字列内の数値を数値型データに明示的に強制するために使用されます。例:
$MyNumber = $MyString.toNumber;
$MyNumberA = ""40"".toNumber;
これは、デフォルトの型強制が期待どおりに機能しない場合に役立ちます。"
"String.tr(inStr[, outStr])",Function,Item,Data manipulation,String,false,5.7.0,Baseline,,,,2,true,true,false,false,false,false,false,true,false,,false,"String.tr(inStr[, outStr])
$MyString.tr(inStr, outStr)
This operator allows simple single character string manipulation. It computes a new string, copying each character of $MyString but converting any characters in inStr to the corresponding characters in dataOut. For example:
	$MyString = $MyString.tr(""a"",""A""); 
returns a copy of MyString in which every ""a"" is converted to ""A"".
Backslash characters must be quoted and escaped:
	$MyString = $MyString.tr(""c"",""\\r""); 
converts every ""c"" to a Macintosh newline characters (\r). Note the need in this context for an extra backslash escape (so Tinderbox knows the intended swap value is ""\r"" and not ""r"").
Multiple characters can be replaced:
	$MyString = ""Hello, world"".tr(""aeiou"",""AEIOU""); gives ""HEllO, wOrld""
Note that in the later example the number of characters in inStr and outStr must match and pairs must list in order, otherwise unmatched characters will act as for the syntax below.
$MyString.tr(inStr)
If outStr is omitted or left empty, any matches to inStr are deleted from the referenced string.
	$MyString = ""Hello, world"".tr(""aeiou""); 
gives ""Hll, wrld""
For further information, see the macOS man page for the UNIX tr command.
Performance
If using actions with a lot of .tr() calls, based on some testing in large complex docs, it may—counter-intuitively—be faster using .replace() instead.","String.tr(inStr[, outStr])
$MyString.tr(inStr, outStr)
この演算子を使用すると、単純な単一文字列の操作が可能になります。$MyString の各文字をコピーし、inStr 内の文字を dataOut 内の対応する文字に変換して、新しい文字列を計算します。たとえば:
$MyString = $MyString.tr(""a"",""A"");
すべての「a」が「A」に変換された MyString のコピーを返します。
バックスラッシュ文字は引用符で囲んでエスケープする必要があります。
$MyString = $MyString.tr(""c"",""\\r"");
すべての「c」を Macintosh の改行文字 (\r) に変換します。このコンテキストでは、追加のバックスラッシュ エスケープが必要であることに注意してください (そのため、Tinderbox は、意図されたスワップ値が ""r"" ではなく ""\r"" であることを認識します)。
複数の文字を置換できます。
$MyString = ""Hello, world"".tr(""aeiou"",""AEIOU"");「こんにちは、世界」と言う
後の例では、inStr と outStr の文字数が一致する必要があり、ペアが順番にリストされている必要があります。そうでない場合、一致しない文字は以下の構文のように動作することに注意してください。
$MyString.tr(inStr)
outStr が省略されるか空のままの場合、inStr に一致するものは参照文字列から削除されます。
$MyString = ""こんにちは、世界"".tr(""aeiou"");
「うーん、ワールド」と言う
詳細については、UNIX tr コマンドの macOS マニュアル ページを参照してください。
パフォーマンス
大量の .tr() 呼び出しを伴うアクションを使用する場合、大規模で複雑なドキュメントでのテストに基づくと、直感に反して、代わりに .replace() を使用した方が高速になる可能性があります。"
String.trim([filterStr]),Function,Item,Data manipulation,String,false,9.0.0,Baseline,,,,1,false,true,false,false,false,false,false,true,false,,false,"String.trim([filterStr])
String.trim()
String.trim
The .trim operator removes unwanted characters from the start and end of a string. With no arguments, .trim() removes whitespace and end of line characters.
	""Hello world     "".trim; → ""Hello world""
It may also be used with a literal string argument filterStr. The only accepted value for filterStr is ""punctuation"", in which case the operator also removes punctuation marks.
	""[tab] Hello world?!     "".trim(""punctuation"") → ""Hello world""
The resulting string retains any stying in the source string.","String.trim([フィルターStr])
String.trim()
文字列.トリム
.trim 演算子は、文字列の先頭と末尾から不要な文字を削除します。引数を指定しないと、.trim() は空白文字と行末文字を削除します。
「Hello world」.trim;→「ハローワールド」
リテラル文字列引数 filterStr と一緒に使用することもできます。filterStr で受け入れられる値は「punctuation」のみです。この場合、演算子は句読点も削除します。
""[タブ] Hello world?! "".trim(""punctuation"") → ""Hello world""
結果の文字列には、ソース文字列内のすべての文字列が保持されます。"
String.try{actions}[.thenTry{actions}],Function,Item,Stream parsing,boolean test,false,9.1.0,Baseline,,,,,true,true,false,false,false,false,false,true,false,,false,"String.try{ action(s) }[.thenTry{ action(s) }]
If the first test action fails, they restore the string and allow you to process it a different way. The current success/failure state can be tested using the .failed() operator.
Saves the value of an attribute (the steam source) and attempts an action. If the action fails because one of its operators fails or the fail() operator is performed, the original value of String stream source is restored.
A .try{} may be followed by one or more .thenTry{} clauses. If the original .try{} succeeds, all subsequent .thenTry{} clauses are ignored. If the original .try{} fails, then each .thenTry{} is attempted in turn. Once a .thenTry{} clause succeeds, subsequent .thenTry{} clauses are ignored.
For example:
$MyString.try{
   $MyString=$MyString.skipToWord(""To:"").captureWord;
}.thenTry{
   fail(); //signal an explicit failure and return a 'false' value to an enclosing expression
};

looks for strings such as ""To:John Doe""
If the string ""To:"" is not found, $MyString will be unchanged. If found, $MyString's value is set to the word that follows, up to the next whitespace character or the end of the string, i.e. ""John"".","String.try{ アクション }[.thenTry{ アクション }]
最初のテスト アクションが失敗した場合は、文字列が復元され、別の方法で処理できるようになります。現在の成功/失敗状態は、.failed() 演算子を使用してテストできます。
属性 (蒸気ソース) の値を保存し、アクションを試行します。いずれかの演算子が失敗するか、fail() 演算子が実行されたためにアクションが失敗した場合、String ストリーム ソースの元の値が復元されます。
.try{} の後に 1 つ以上の .thenTry{} 句が続く場合があります。元の .try{} が成功した場合、後続の .thenTry{} 句はすべて無視されます。元の .try{} が失敗した場合は、各 .thenTry{} が順番に試行されます。.thenTry{} 句が成功すると、後続の .thenTry{} 句は無視されます。
たとえば:
$MyString.try{
$MyString=$MyString.skipToWord(""To:"").captureWord;
}.then試してください{
失敗();//明示的な失敗を通知し、囲んでいる式に「false」値を返します。
};

「To:John Doe」のような文字列を検索します。
文字列「To:」が見つからない場合、$MyString は変更されません。見つかった場合、$MyString の値は、次の空白文字または文字列の終わりまでの単語、つまり「John」に設定されます。"
String.uppercase(),Function,Item,Formatting,String,false,5.9.0,Baseline,,,,,false,true,false,false,false,false,false,false,false,,false,"String.uppercase()
String.uppercase
Returns the referenced String, transforming all uppercase letters to lowercase.
The function can be chained to both string data and to string literals:
	$MyString.uppercase() 
	""my new title"".uppercase() 
The latter gives ""MY NEW TITLE"".
The trailing parentheses may be omitted:
	$MyString.uppercase 
Functionally equivalent to uppercase().
If $MyString is ""hello world"":
	$MyString = $MyString.uppercase; 
$MyString is set to ""HELLO WORLD"".
The .uppercase() method may also be used on Lists or Sets. Consider [Ant;BEE;Cow] stored in $MyList:
	$MyList = $MyList.uppercase; 
… giving [ANT;BEE;COW].","String.uppercase()
文字列.大文字
すべての大文字を小文字に変換して、参照された文字列を返します。
この関数は、文字列データと文字列リテラルの両方にチェーンできます。
$MyString.uppercase()
「私の新しいタイトル」.uppercase()
後者は「MY NEW TITLE」になります。
末尾の括弧は省略できます。
$MyString.uppercase
機能的には uppercase() と同等です。
$MyString が「hello world」の場合:
$MyString = $MyString.uppercase;
$MyString は「HELLO WORLD」に設定されます。
.uppercase() メソッドはリストまたはセットでも使用できます。$MyList に保存されている [Ant;BEE;Cow] について考えてみましょう。
$MyList = $MyList.uppercase;
… [ANT;BEE;COW] を与えます。"
String.wordCount(),Property,Item,Data manipulation,Number,false,9.5.2,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"String.wordCount()
String.wordCount
String.wordCount returns the number of words in a string. The string is first scanned to determine its dominant language, and the word count is based on the conventions of that language (q.v. $WordCount). If the language cannot be determined or if it is not known to macOS, the conventions of English are used.","String.wordCount()
文字列.wordCount
String.wordCount は、文字列内の単語の数を返します。まず文字列がスキャンされて主な言語が決定され、単語数はその言語の規則に基づいて計算されます ($WordCount を参照)。言語が特定できない場合、または macOS で認識されない場合は、英語の規則が使用されます。"
String.wordList(),Property,Item,Data manipulation,List,false,9.0.0,Baseline,,,10.14,,false,true,false,false,false,false,false,false,false,,false,"String.wordList()
String.wordList
This returns a list of each noun in the supplied string, excepting those recognised as pronouns and proper names. Note that the output list is all lowercase, regardless of source case. This operator requires running on macOS 10.14 and later.
	$MyList = ""I am the very model of a modern Major-General."".wordList; 
then MyList holds ""i;am;the;very;model;of;a;modern;major;general"".","String.wordList()
文字列.wordList
これは、代名詞および固有名として認識されるものを除く、指定された文字列内の各名詞のリストを返します。ソースの大文字と小文字に関係なく、出力リストはすべて小文字であることに注意してください。このオペレーターは macOS 10.14 以降で実行する必要があります。
$MyList = ""私はまさに現代の少将のモデルです。"".wordList;
次に、MyList には「i;am;the;very;model;of;a;modern;major;general」が保持されます。"
String.words(wordsNum),Function,Item,Data manipulation,String,false,6.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"String.words(wordsNum)
returns the first number words of a string. If the string has fewer than wordsNum words, returns the entire string. If wordsNum is negative, it returns a negative -wordsNum words from the end of the string. If $MyString is ""Romans, they go house?"".
	$MyString = $MyString.words(2); 
returns ""Romans, they"". 
	$MyString = $MyString.words(-1); 
returns ""house?"". Note that punctuation contiguous to words gets passed through as part of the returned word(s).","文字列.words(wordsNum)
文字列の最初の単語数を返します。文字列の単語数が WordsNum よりも少ない場合は、文字列全体を返します。WordsNum が負の場合、文字列の末尾から負の -wordsNum 単語を返します。$MyString が「ローマ人、彼らは家に帰りますか?」の場合。
$MyString = $MyString.words(2);
「ローマ人、彼ら」と返します。
$MyString = $MyString.words(-1);
「家?」と返します。単語に隣接する句読点は、返される単語の一部として渡されることに注意してください。"
string(argStr),String,Item,Data manipulation,,false,11.5.0,11.5.0,,11.5.0,,1,true,false,false,false,false,false,false,false,false,,false,"string(argStr)
The operator string(argStr) returns its argument as explicitly String-type data. This is useful when neither single nor double quotes will achieve the desired result. The string result must not contain a closing parenthesis, i.e. a ')' character.","文字列(argStr)
演算子 string(argStr) は、その引数を明示的に String 型データとして返します。これは、一重引用符でも二重引用符でも望ましい結果が得られない場合に便利です。文字列の結果には、閉じ括弧、つまり「)」文字を含めることはできません。"
StyledString.bold(),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,true,,false,"StyledString.bold()
StyledString.bold
The function sets the referenced string's styled text to bold text.
	$Text = $Text + ""This is "" + ""some"".bold + "" text"".plain; 
adds ""this is some text"" to the end of $Text. The '.plain' command reasserts no style is to be applied.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.bold()
StyledString.bold
この関数は、参照された文字列のスタイル付きテキストを太字テキストに設定します。
$Text = $Text + ""これは "" + ""some"".bold + "" text"".plain;
$Text の末尾に「これはテキストです」を追加します。「.plain」コマンドは、スタイルが適用されないことを再度表明します。
現在、スタイル付きテキストを保持できる属性は $Text だけであることに注意してください。文字列属性とアクション コード変数 (var など) には、スタイル付きテキストを保存できません。スタイル付きテキストが渡された場合、後者は渡されたテキストのスタイルなしバージョンを保存します。より詳しい説明をご覧ください。
StyledString 演算子を尊重する文字列演算子
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.fontSize(pointSizeNum),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,1,true,true,false,false,false,false,false,false,true,,false,"StyledString.fontSize(pointSizeNum)
The function sets the referenced string's styled text to font size pointSizeNum, where pointSizeNum is the desired font size in points.
	$Text = $Text + ""some bigger text"".fontSize(N); 
adds test ""some bigger text"" in 24pt to the end of $Text.
It is also a good automatic way to reset $Text containing old (or accidental) size-based auto-headings. Code like this can be used as a stamp or other action to reset multiple selected notes:
	$Text = $Text.fontSize($TextFontSize); 
This will make each (selected) note use it's own $TextFontSize (which might differ) to reset the size of the entire $Text of the note.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.fontSize(pointSizeNum)
この関数は、参照文字列のスタイル付きテキストをフォント サイズ pointSizeNum に設定します。ここで、pointSizeNum はポイント単位の希望のフォント サイズです。
$Text = $Text + ""もう少し大きなテキスト"".fontSize(N);
$Text の末尾に 24pt のテスト「大きなテキスト」を追加します。
これは、古い (または偶然の) サイズベースの自動見出しを含む $Text を自動的にリセットする良い方法でもあります。次のようなコードは、選択した複数のノートをリセットするスタンプまたはその他のアクションとして使用できます。
$Text = $Text.fontSize($TextFontSize);
これにより、各 (選択された) ノートが独自の $TextFontSize (異なる場合があります) を使用して、ノートの $Text 全体のサイズがリセットされます。
現在、スタイル付きテキストを保持できる属性は $Text だけであることに注意してください。文字列属性とアクション コード変数 (var など) には、スタイル付きテキストを保存できません。スタイル付きテキストが渡された場合、後者は渡されたテキストのスタイルなしバージョンを保存します。より詳しい説明をご覧ください。
StyledString 演算子を尊重する文字列演算子
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.italic(),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,true,,false,"StyledString.italic()
StyledString.italic
The function sets the referenced string's styled text to italic.
	$Text = $Text + ""This is "" + ""some"".italic + "" text"".plain; 
adds ""this is some text"" to the end of $Text. The '.plain' command reasserts no style is to be applied.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.italic()
StyledString.italic
この関数は、参照された文字列のスタイル付きテキストを斜体に設定します。
$Text = $Text + ""これは "" + ""some"".italic + "" text"".plain;
$Text の末尾に「これはテキストです」を追加します。「.plain」コマンドは、スタイルが適用されないことを再度表明します。
現在、スタイル付きテキストを保持できる属性は $Text だけであることに注意してください。文字列属性とアクション コード変数 (var など) には、スタイル付きテキストを保存できません。スタイル付きテキストが渡された場合、後者は渡されたテキストのスタイルなしバージョンを保存します。より詳しい説明をご覧ください。
StyledString 演算子を尊重する文字列演算子
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.plain(),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,true,,false,"StyledString.plain()
StyledString.plain
The function (re-)sets the referenced string's styled text to the default face.
	$Text = $Text + ""This is "" + ""some"".italic + "" text"".plain; 
adds ""this is some text"" to the end of $Text. The '.plain' command reasserts no style is to be applied.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
Re-setting a note's $Text styling to defaults via code or stamp
The Format ▸ Style menu allows the user to reset the default $TextFont/$TextSize and (ruler) styles. To replicate all those defaults for all the existing $Text, use:
	$Text = $Text.plain;
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.plain()
StyledString.plain
この関数は、参照された文字列のスタイル付きテキストをデフォルトの文字列に (再) 設定します。
$Text = $Text + ""これは "" + ""some"".italic + "" text"".plain;
$Text の末尾に「これはテキストです」を追加します。「.plain」コマンドは、スタイルが適用されないことを再度表明します。
現在、スタイル付きテキストを保持できる属性は $Text だけであることに注意してください。文字列属性とアクション コード変数 (var など) には、スタイル付きテキストを保存できません。スタイル付きテキストが渡された場合、後者は渡されたテキストのスタイルなしバージョンを保存します。より詳しい説明をご覧ください。
コードまたはスタンプを使用してメモの $Text スタイルをデフォルトに再設定する
[形式] ▸ [スタイル] メニューを使用すると、デフォルトの $TextFont/$TextSize および (ルーラー) スタイルをリセットできます。既存のすべての $Text に対してこれらすべてのデフォルトを複製するには、次を使用します。
$Text = $Text.plain;
StyledString 演算子を尊重する文字列演算子
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.strike(),Function,Item,Formatting,String,false,9.0.0,Baseline,,,,,false,true,false,false,false,false,false,false,true,,false,"StyledString.strike()
StyledString.strike
The function sets the referenced string's styled text to stuck-through text.
	$Text = $Text + ""This is "" + ""some"".strike + "" text"".plain; 
adds ""this is some text"" to the end of $Text. The '.plain' command reasserts no style is to be applied.
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
String operators respecting StyledString operators
String.paragraphs(), String.replace() and String.substr().","StyledString.strike()
StyledString.strike
この関数は、参照された文字列のスタイル付きテキストをスタックスルーテキストに設定します。
$Text = $Text + ""これは "" + ""some"".strike + "" text"".plain;
$Text の末尾に「これはテキストです」を追加します。「.plain」コマンドは、スタイルが適用されないことを再度表明します。
現在、スタイル付きテキストを保持できる属性は $Text だけであることに注意してください。文字列属性とアクション コード変数 (var など) には、スタイル付きテキストを保存できません。スタイル付きテキストが渡された場合、後者は渡されたテキストのスタイルなしバージョンを保存します。より詳しい説明をご覧ください。
StyledString 演算子を尊重する文字列演算子
String.paragraphs()、String.replace()、および String.substr()。"
StyledString.textColor(aColor),Function,Item,Data manipulation,String,false,9.0.0,Baseline,,,,,true,true,false,false,false,false,false,false,true,,false,"StyledString.textColor(aColor)
The operator .textColor(aColor), when applied to styled text, sets the foreground colour of the text. The color argument can be either a named colour or a hexadecimal string. For example, both of these examples add 'example' in bright red text to the current note's $Text.
	$Text = $Text + ""example"".textColor(""#FF0000"") 
Note that $Text is currently the only attribute capable of holding styled text. String attributes and action code variables, i.e. var, cannot store styled text. If passed styled text the latter will store the unstyled version of the text being passed. See a more detailed explanation.
.textColor() respects the current text font, e.g. if set to a non-default colour.","StyledString.textColor(aColor)
演算子 .textColor(aColor) をスタイル付きテキストに適用すると、テキストの前景色が設定されます。color 引数には、名前付きの色または 16 進文字列を指定できます。たとえば、これらの例は両方とも、現在のメモの $Text に明るい赤色のテキストで「example」を追加します。
$Text = $Text + ""例"".textColor(""#FF0000"")
現在、スタイル付きテキストを保持できる属性は $Text だけであることに注意してください。文字列属性とアクション コード変数 (var など) には、スタイル付きテキストを保存できません。スタイル付きテキストが渡された場合、後者は渡されたテキストのスタイルなしバージョンを保存します。より詳しい説明をご覧ください。
.textColor() は現在のテキスト フォントを尊重します。デフォルト以外の色に設定されている場合。"
"substr(dataStr, startNum[, lengthNum])",Function,Item,Data manipulation,String,false,5.0.0,Baseline,,,,3,true,false,true,false,false,false,false,true,false,,false,"substr(dataStr, startNum, lengthNum)
Where dataStr is a string literal, string attribute or expression evaluating to a string.
Where startNum is the zero-based position to start the substring. Negative startNum values are not supported, though String.substring() does so and may be used instead.
Where lengthNum is the length of the returned string. If not specified, the entire string from (or back from) startNum is returned.
Extracts a substring of data. For example:
	$MyString = substr(""test"",0,1); 
returns ""t"", while
	$MyString = substr(""test"",1,2); 
returns ""es"". All arguments are evaluated; if the designated characters do not exist, an empty string is returned.
If the length of the substring is negative, it is treated as an offset from the end of the string.
	$MyString = substr(""Hello"",1,-1); → ""ell""
Note that in expressions like
	$Initial=substr($Name,0,1); 
the value of $Name is not changed.","substr(dataStr, startNum, lengthNum)
ここで、dataStr は文字列リテラル、文字列属性、または文字列として評価される式です。
startNum は、部分文字列を開始するゼロから始まる位置です。負の startNum 値はサポートされていませんが、String.substring() はサポートしており、代わりに使用できます。
ここで、lengthNum は返される文字列の長さです。指定しない場合は、startNum からの (または startNum からの) 文字列全体が返されます。
データの部分文字列を抽出します。たとえば:
$MyString = substr(""テスト"",0,1);
「t」を返しますが、
$MyString = substr(""テスト"",1,2);
「es」を返します。すべての引数が評価されます。指定された文字が存在しない場合は、空の文字列が返されます。
部分文字列の長さが負の場合、文字列の末尾からのオフセットとして扱われます。
$MyString = substr(""Hello"",1,-1);→「エル」
次のような式では注意してください。
$Initial=substr($Name,0,1);
$Name の値は変更されません。"
"sum_if(scope, condition, expressionStr)",Function,Conditional Group,Mathematical,Number,false,4.0.0,Baseline,,,,3,true,false,true,false,true,true,true,false,false,,false,"sum_if(scope, condition, expressionStr)
This computes the Number sum of every expressionStr value in each scope item (defining scope), as filtered by a condition expression. See sum() for a related non-conditional operator.
scope describes the notes to be examined and may be any group designator including a find() query. sum_if() omits notes for which $Searchable is false.
In addition, where may be argument that designates a particular (single) note other than this.
condition is action code forming a valid conditional query test, i.e. it equates to true when matched. Some query-style operators terms may allow use of regular expressions.
expressionStr can be an expression, but is typically a Number-attribute value or a List or Set holding a list of numbers. It can also be a literal number 1, i.e. if the test is true from that item then add one to the retuned value of sum_if().
For example,
	$MyNumber = sum_if(children,$Prototype==""p_Problem"",1); 
sums the number of children of the current note whose prototype is 'p_Prototype'. If tested value is a string with spaces, e.g. ""p Prototype"" vs. ""p_Prototype"" then use double quotes around the value.
The newer count_if() offers a more intuitive method of counting matches rather than the value of matched items.","sum_if(スコープ、条件、式Str)
これは、条件式でフィルターされた各スコープ項目 (スコープを定義) 内のすべてのexpressionStr 値の Number 合計を計算します。関連する非条件演算子については、sum() を参照してください。
スコープは検査するメモを記述し、find() クエリを含む任意のグループ指定子にすることができます。sum_if() は、$Searchable が false のメモを省略します。
また、where はこれ以外の特定の (単一の) 音符を指定する引数になる場合があります。
条件は、有効な条件付きクエリ テストを形成するアクション コードです。つまり、一致すると true と同等になります。一部のクエリ スタイルの演算子の用語では、正規表現の使用が許可されている場合があります。
expressionStr は式にすることもできますが、通常は Number 属性値、または数値のリストを保持する List または Set です。リテラル数値 1 にすることもできます。つまり、その項目からのテストが true の場合、sum_if() の返された値に 1 を加算します。
たとえば、
$MyNumber = sum_if(children,$Prototype==""p_問題"",1);
プロトタイプが「p_Prototype」である現在のノートの子の数を合計します。テストされた値がスペースを含む文字列の場合、例:「p Prototype」と「p_Prototype」の場合は、値を二重引用符で囲みます。
新しい count_if() は、一致した項目の値ではなく、一致をカウントするより直感的な方法を提供します。"
"sum(scope, expressionStr)",Function,Group,Mathematical,Number,false,4.0.0,Baseline,,,,2,true,false,true,false,false,true,false,false,false,,false,"sum(scope, expressionStr)
This computes the arithmetic Number of every expressionStr value in each in-scope item (defining scope). See sum_if() for a related conditional operator.
The sum() operator omits notes for which $Searchable is false.
expressionStr can be an expression, but is typically a Number-attribute value or a List or Set holding a list of numbers. It can also be a literal number 1, i.e. if the test is true from that item then add one to the retuned value of sum(). The latter is less likely than with the sibling operator sum_if().
For example,
	$MyNumber = sum(children,$WordCount); 
constructs the current word count of the children of the note.
See also list.sum().","sum(スコープ, 式Str)
これにより、スコープ内の各項目 (スコープを定義) 内のすべてのexpressionStr 値の算術 Number が計算されます。関連する条件演算子については、sum_if() を参照してください。
sum() 演算子は、$Searchable が false であるノートを省略します。
expressionStr は式にすることもできますが、通常は Number 属性値、または数値のリストを保持する List または Set です。リテラル数値 1 にすることもできます。つまり、その項目のテストが true の場合は、sum() の返された値に 1 を加えます。後者は兄弟演算子 sum_if() よりも可能性が低くなります。
たとえば、
$MyNumber = sum(children,$WordCount);
ノートの子の現在の単語数を構築します。
list.sum() も参照してください。"
tan(radiansNum),Function,Item,Mathematical,Number,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"tan(radiansNum)
tan() converts its radiansNum, in radians, to the tangent of that value.
	$MyNumber = tan(3) 
returns '-0.1425465431' for an input of 3 radians.","タン(ラジアン数値)
Tan() は、ラジアン単位の radiansNum をその値のタンジェントに変換します。
$MyNumber = タン(3)
3 ラジアンの入力に対して「-0.1425465431」を返します。"
"time(aDate, hoursNum, minutesNum[, secondsNum])",Function,Item,Date-time,Date,false,4.0.0,Baseline,,,,4,true,false,false,false,false,false,false,false,false,,false,"time(aDate, hoursNum, minutesNum[, secondsNum])
creates a new Date based on the aDate expression, but in which the time is set by hoursNum, minutesNum, and secondsNumDate is not changed. Only positive values are allowed. If needing to alter a Date's time towards or backwards by a certain amount, consider using interval(dataStr).
time() accepts an optional fourth argument secondsNum, representing the seconds component of the time.
For example, to make a stamp or rule that sets the time element of all event start/end dates in a timeline to 12:00:00 AM (midday) use this code:
   $StartDate=time($StartDate,12,0,0);
   if($EndDate){
      $EndDate=time($EndDate,12,0,0)
   };

Parsing of time inputs
When any/all of hoursNum, minutesNum, and secondsNumDate are provided in a value larger then their normal limit, Tinderbox adjusts the containing limit accordingly. Thus > 60 seconds adds minute to aDate, > 60 minutes adds an hour, >24 hours adds a day. Therefore:
	$StartDate=time($StartDate,12,30,0); 
results in a time of 12:30:00, but:
	$StartDate=time($StartDate,12,90,0); 
results in a time of 13:30:00, as 90 minutes is parsed as being 1 hour + 30 minutes and as if this code were being used:
	$StartDate=time($StartDate,13,30,0);","time(日付, 時間数, 分数[, 秒数])
aDate 式に基づいて新しい Date を作成しますが、時間は hoursNum、 minutesNum、秒NumDate によって設定されますが、Date は変更されません。正の値のみが許可されます。日付の時刻を一定量前後に変更する必要がある場合は、interval(dataStr) の使用を検討してください。
time() は、時間の秒部分を表すオプションの 4 番目の引数 SecondsNum を受け取ります。
たとえば、タイムライン内のすべてのイベントの開始日/終了日の時間要素を午前 12:00:00 (正午) に設定するスタンプまたはルールを作成するには、次のコードを使用します。
$StartDate=time($StartDate,12,0,0);
if($EndDate){
$EndDate=時間($EndDate,12,0,0)
};

時間入力の解析
hoursNum、 minutesNum、secsNumDate のいずれかまたはすべてが通常の制限より大きい値で指定された場合、Tinderbox はそれに応じて含まれる制限を調整します。したがって、60 秒を超えると aDate に分が追加され、60 分を超えると 1 時間が追加され、24 時間を超えると 1 日が追加されます。したがって:
$StartDate=time($StartDate,12,30,0);
結果は 12:30:00 になりますが、
$StartDate=time($StartDate,12,90,0);
90 分は 1 時間 + 30 分として解析され、次のコードが使用されているかのように解析されるため、結果は 13:30:00 になります。
$StartDate=time($StartDate,13,30,0);"
time(aDate),Function,Item,Date-time,String,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"time(aDate) 
returns a string of the hours/minutes/seconds time part the aDate date/time expression, which may simply be a date-type attribute value. For instance:
	$MyString = time($StartDate); 
If the time of $StartTime is 14:20:30 then $MyString will be ""14:20:30"". Passing to a string will elide leading zeroes, so a time of 05:08 will return ""5:08"".","時間(日付)
aDate 日付/時刻式の時/分/秒の時刻部分の文字列を返します。これは単に日付型の属性値である場合もあります。たとえば:
$MyString = 時間($StartDate);
$StartTime の時刻が 14:20:30 の場合、$MyString は「14:20:30」になります。文字列に渡すと先頭のゼロが省略されるため、時刻が 05:08 の場合は「5:08」が返されます。"
"twitter(usernameStr, statusStr)",n/a - success boolean,Item,Data manipulation,source context dependent,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"twitter(usernameStr,statusStr)
NOW DEPRECATED and no longer working - for info only
allows posting to the user's twitter account (usernameStr) of a tweet (statusStr).
Tinderbox will request permission to use your Twitter account, and will send the tweet to that account.
	twitter(""myusername"",""my test tweet"") 
The twitter() action is no longer supported (reflecting changes to Twitter API).","twitter(ユーザー名Str,ステータスStr)
現在は非推奨となっており、機能しなくなりました - 情報提供のみ
ユーザーの Twitter アカウント (usernameStr) へのツイート (statusStr) の投稿を許可します。
Tinderbox はあなたの Twitter アカウントの使用許可を要求し、ツイートをそのアカウントに送信します。
twitter(""ユーザー名"",""私のテストツイート"")
twitter() アクションはサポートされなくなりました (Twitter API への変更を反映)。"
type(attributeNameStr),Function,Document,Document configuration,String,false,9.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"type(attributeNameStr)
This operator may be replaced by the more flexible attribute() operator.
The operator type(attributeNameStr) returns a string representing the type of the designated attribute. The attribute may simply be the attribute name (without quotes or a preceding ""$"") or an expression that, when evaluated, yields an attribute name.
	$MyString = type(Width); → ""number""
	$MyString = type(""AccentColor""); → ""color""
	$MyString=""Modified""; type($MyString); → ""date""
Note that type($MyString) returns the type of the attribute who name is stored in $MyString, while type(""MyString"") or  type(MyString) returns the type of the attribute MyString.
If no such attribute exists in the document, the operator returns the empty string.","タイプ(属性名Str)
この演算子は、より柔軟なattribute()演算子に置き換えることができます。
演算子 type(attributeNameStr) は、指定された属性のタイプを表す文字列を返します。属性は、単純に属性名 (引用符や先頭の ""$"" なし)、または評価時に属性名を生成する式の場合があります。
$MyString = タイプ(幅);→「数字」
$MyString = type(""アクセントカラー"");→「カラー」
$MyString=""変更されました"";タイプ($MyString);→「デート」
type($MyString) は $MyString に保存されている名前の属性の型を返し、type(""MyString"") または type(MyString) は属性 MyString の型を返すことに注意してください。
ドキュメントにそのような属性が存在しない場合、演算子は空の文字列を返します。"
"unlink(source,destination[,linkType])",Function,Group,Linking,success boolean,false,10.2.0,Baseline,,,,3,true,false,false,false,false,true,false,true,false,true,false,"unlink(source,destination[,linkType])
unlink(source,destination[,linkType]) removes all links between an explicit source and destination note. If linkType is omitted, the linkType is assumed to be *untitled. If linkType is *, all links are deleted regardless of their linkType.
No expression left side is needed (the operator returns a true/false success boolean value. This removes a link from note ""A note"" to ""Some note"" that uses the ""agree"" link type.
	$MyBoolean = unlink(""A note"", ""Some note"",""agree""); 
The same but removing all links from ""A note"" to ""Some note"" (here with no left-side to the expression:
	unlink(""A note"", ""Some note"",""*""); 
The asterisk is functioning as a wildcard.","unlink(ソース,宛先[,リンクタイプ])
unlink(source,destination[,linkType]) は、明示的なソースと宛先ノート間のすべてのリンクを削除します。linkType が省略された場合、linkType は *untitled とみなされます。linkType が * の場合、linkType に関係なくすべてのリンクが削除されます。
左側の式は必要ありません (演算子は true/false の成功ブール値を返します。これにより、「同意する」リンク タイプを使用するノート「A note」から「Some note」へのリンクが削除されます。
$MyBoolean = unlink(""メモ"", ""メモ"",""同意"");
同じですが、「A note」から「Some note」までのすべてのリンクを削除します (ここでは式の左側がありません:
unlink(""メモ"", ""メモ"",""*"");
アスタリスクはワイルドカードとして機能します。"
"unlinkFrom(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"unlinkFrom(scope[, linkTypeStr])
This removes all basic links from scope to the current note (i.e. inbound links). unlinkFrom() does not delete prototype links.
Both arguments are evaluated. This operator does not require a left-side argument, simply calling effects a result. No change occurs if the described link does not exist.
scope argument
The scope argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString. Ways to define scope. Note that here, unlike other scope uses, $Path can not be used.
scope may be group scoped including use of group designators and operators like find,() collect and links().
linkTypeStr argument
linkTypeStr (string). Optionally, link deletion can be constrained to one type supplied as literal string value for linkTypeStr:
* If no linkTypeStr argument is supplied, only untitled (i.e. no link type) links are deleted. 
* If a valid link type name, e.g. ""agree"", is supplied only links of the specified type are deleted.
* To delete all links of any type or none use the wildcard value ""*"" (an asterisk). Also note:
** This method does not affect prototype links.
** This wildcard linkTypeStr option only applies to unlinking, and not to linking).
linkTypeStr is evaluated as a literal string (previously a pattern match was undertaken).
Examples
Unlinking from a note ""Some note"":
	all link types: unlinkFrom(""Some note""); 
	only link type 'agree': unlinkFrom(""Some note"",""agree""); 
	either of 2 link types: unlinkFrom(""Some note"", ""example|disagree""); 
Unlinking the first child (via a designator):
	unlinkFrom(child); 
	unlinkFrom(child,""agree""); 
See further below for group-scope references.
Relevant similar operators: linkTo, linkFrom, unlinkTo.
Use of this action does not shift note focus; in addition if scope contains operators (brackets, plus, minus, etc.) Tinderbox will first look for a match to the literal scope string and only if there is no match will the app try evaluating to operators and testing the resulting string. For example:
	unlinkFrom(""Example 1 (a test)""); 
will unlink the note named 'Example 1 (a test)'. If no note matches this string, Tinderbox will attempt to evaluate the string. Thus for:
	unlinkFrom(""2+2""); 
will unlink the note named '2+2' but if there is no match Tinderbox will look for a note named '4'.
This function can unlink an alias as opposed to an original (if the logical choice) and can also accept a group scope. An example of group scope is the following code that could be used in a rule or stamp to remove in/bound footnote links from one or more selected notes. Use of the 'all' designator removes the need to know the name of the notes for which the selection are footnotes:
	unlinkFrom(all,""note"");unlinkTo(all,""note+""); 
Use in agents
Beware that the action is working on an alias of the current note and note the current note itself. As originals and aliases support discrete basic links this function should not generally be used in an agent. The best way to use the function is by using a prototype and apply a $Rule to it thus running the code in all notes using the prototype.
An alternative unlinkFromOriginal() code will ensure any link deleted is between two original notes regardless of whether an alias is the context of execution of the code.","unlinkFrom(scope[, linkTypeStr])
これにより、現在のノートへのすべての基本リンク (つまり、受信リンク) がスコープから削除されます。unlinkFrom() はプロトタイプ リンクを削除しません。
両方の引数が評価されます。この演算子は左側の引数を必要とせず、単に結果としてエフェクトを呼び出します。記述されたリンクが存在しない場合は、何も変化しません。
スコープ引数
属性参照でない限り、スコープ引数は引用符で囲む必要があります。「メモ」と $MyString の比較。スコープを定義する方法。ここでは、他のスコープの使用とは異なり、$Path は使用できないことに注意してください。
スコープは、グループ指定子や find,()collect や links() などの演算子の使用を含めて、グループ スコープにすることができます。
linkTypeStr 引数
linkTypeStr (文字列)。オプションで、リンクの削除を、linkTypeStr のリテラル文字列値として指定された 1 つのタイプに制限できます。
* linkTypeStr 引数が指定されていない場合は、無題 (リンク タイプがない) リンクのみが削除されます。
* 有効なリンク タイプ名、例:「同意する」を指定すると、指定されたタイプのリンクのみが削除されます。
* 任意のタイプのリンクをすべて削除するか、まったく削除しない場合は、ワイルドカード値 ""*"" (アスタリスク) を使用します。次の点にも注意してください。
** このメソッドはプロトタイプのリンクには影響しません。
** このワイルドカード linkTypeStr オプションはリンク解除にのみ適用され、リンクには適用されません)。
linkTypeStr はリテラル文字列として評価されます (以前はパターン一致が行われていました)。
例
メモ「Some note」からリンクを解除する:
すべてのリンク タイプ: unlinkFrom(""メモ"");
リンクタイプ「同意する」のみ: unlinkFrom(""メモ"",""同意する"");
2 つのリンク タイプのいずれか: unlinkFrom(""Some note"", ""example|disagree"");
最初の子のリンクを解除します (デジグネータ経由):
unlinkFrom(子);
unlinkFrom(child,""同意する"");
グループスコープのリファレンスについては、以下を参照してください。
関連する同様の演算子: linkTo、linkFrom、unlinkTo。
このアクションを使用してもノートのフォーカスは移動しません。さらに、スコープに演算子 (括弧、プラス、マイナスなど) が含まれている場合、Tinderbox はまずリテラルのスコープ文字列との一致を探し、一致がない場合にのみ、アプリは演算子を評価して結果の文字列をテストします。たとえば:
unlinkFrom(""例 1 (テスト)"");
「例 1 (テスト)」という名前のメモのリンクを解除します。この文字列に一致するメモがない場合、Tinderbox は文字列の評価を試みます。したがって、次のようになります。
unlinkFrom(""2+2"");
「2+2」という名前のメモのリンクが解除されますが、一致するものがない場合、Tinderbox は「4」という名前のメモを探します。
この関数は、元のエイリアスではなくエイリアスのリンクを解除でき (論理的な選択の場合)、グループ スコープも受け入れることができます。グループ スコープの例は、ルールまたはスタンプで使用して、1 つまたは複数の選択したメモから内/バインド脚注リンクを削除する次のコードです。「all」指定子を使用すると、選択範囲が脚注となる注記の名前を知る必要がなくなります。
unlinkFrom(all,""note"");unlinkTo(all,""note+"");
エージェントでの使用
このアクションは現在のノートのエイリアスに対して動作していることと、現在のノート自体に注意してください。オリジナルとエイリアスは個別の基本リンクをサポートしているため、この関数は通常エージェントでは使用しないでください。この関数を使用する最良の方法は、プロトタイプを使用し、それに $Rule を適用して、プロトタイプを使用してすべてのノートでコードを実行することです。
代替の unlinkFromOriginal() コードでは、エイリアスがコード実行のコンテキストであるかどうかに関係なく、削除されたリンクが 2 つの元のノートの間にあることが保証されます。"
"unlinkFromOriginal(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,6.4.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"unlinkFromOriginal(scope[, linkTypeStr])
This function works exactly as the same as unlinkFrom(), except for one important difference that the link deleted is always between two originals even if either/both the evaluated source or destination are an alias. unlinkFromOriginal() does not delete prototype links.
For more detail of use, see unlinkFrom().
Unlinking from an original note ""Some note"" (and not an alias of it):
	all link types: unlinkFromOriginal(""Some note""); 
	only link type 'agree': unlinkFromOriginal(""Some note"",""agree""); 
	either of 2 link types: unlinkFromOriginal(""Some note"", ""example|disagree""); 
See also linkFromOriginal(), linkToOriginal(), unlinkToOriginal().","unlinkFromOriginal(scope[, linkTypeStr])
この関数は unlinkFrom() とまったく同じように機能しますが、評価されるソースまたは宛先のどちらかまたは両方がエイリアスであっても、削除されるリンクは常に 2 つのオリジナルの間であるという重要な違いが 1 つあります。unlinkFromOriginal() はプロトタイプ リンクを削除しません。
使用方法の詳細については、unlinkFrom() を参照してください。
元のノート「Some note」(そのエイリアスではない) からのリンクを解除します。
すべてのリンク タイプ: unlinkFromOriginal(""Some note"");
リンクタイプ「同意する」のみ: unlinkFromOriginal(""メモ"",""同意する"");
2 つのリンク タイプのいずれか: unlinkFromOriginal(""Some note"", ""example|disagree"");
linkFromOriginal()、linkToOriginal()、unlinkToOriginal()も参照してください。"
"unlinkTo(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,4.6.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"unlinkTo(scope[, linkTypeStr])
This removes all basic links to scope from the current note (i.e. outbound links). unlinkTo() does not delete prototype links.
Both arguments are evaluated. This operator does not require a left-side argument, simply calling effects a result. No change occurs if the described link does not exist.
scope argument
The scope argument must be quoted unless an attribute reference, e.g. ""Some note"" vs. $MyString. Ways to define scope. Note that here, unlike other scope uses, $Path may not be used.
The scope may be group scoped including use of group designators and operators like find,() collect() and links().
linkTypeStr argument
linkTypeStr (string). Optionally, link deletion can be constrained to one type supplied as literal string value for linkTypeStr:
* If no linkTypeStr argument is supplied, only untitled (i.e. no link type) links are deleted. 
* If a valid link type name, e.g. ""agree"", is supplied only links of the specified type are deleted.
* To delete all links of any type or none use the wildcard value ""*"" (an asterisk). Also note:
** This method does not affect prototype links.
linkTypeStr is evaluated as a literal string (previously a pattern match was undertaken).
Examples
Unlinking to a note ""Some note"":
	all link types: unlinkTo(""Some note""); 
	only link type 'agree': unlinkTo(""Some note"",""agree""); 
	either of 2 link types: unlinkTo(""Some note"", ""agree|disagree""); 
Matching the first child (via a designator):
	unlinkTo(child); 
	unlinkTo(child,""agree""); 
See further below for group-scope references.
Relevant similar operators: linkTo, linkFrom, unlinkFrom.
Use of this action does not shift note focus; in addition if scope contains operators (brackets, plus, minus, etc.) Tinderbox will first look for a match to the literal scope string and only if there is no match will the app try evaluating to operators and testing the resulting string. For example:
	unlinkTo(""Example 1 (a test)""); 
will unlink the note named 'Example 1 (a test)'. If no note matches this string, Tinderbox will attempt to evaluate the string. Thus for:
	unlinkTo(""2+2""); 
will unlink the note named '2+2' but if there is no match Tinderbox will look for a note named '4'.
This function can unlink an alias as opposed to an original (if the logical choice) and can also accept a group scope. An example of group scope is the following code that could be used in a rule or stamp to remove in/bound footnote links from one or more selected notes. Use of the 'all' designator removes the need to know the name of the notes for which the selection are footnotes:
	unlinkFrom(all,""note"");unlinkTo(all,""note+""); 
Use in agents
Beware that the action is working on an alias of the current note and note the current note itself. As originals and aliases support discrete basic links this function should not generally be used in an agent. The best way to use the function is by using a prototype and apply a $Rule to it thus running the code in all notes using the prototype.
An alternative unlinkToOriginal() code will ensure any link deleted is between two original notes regardless of whether an alias is the context of execution of the code.","unlinkTo(スコープ[, linkTypeStr])
これにより、現在のノートからスコープへのすべての基本リンク (つまり、送信リンク) が削除されます。unlinkTo() はプロトタイプ リンクを削除しません。
両方の引数が評価されます。この演算子は左側の引数を必要とせず、単に結果としてエフェクトを呼び出します。記述されたリンクが存在しない場合は、何も変化しません。
スコープ引数
属性参照でない限り、スコープ引数は引用符で囲む必要があります。「メモ」と $MyString の比較。スコープを定義する方法。ここでは、他のスコープの使用とは異なり、$Path は使用できないことに注意してください。
スコープは、グループ指定子や find、()、collect()、links() などの演算子の使用を含めて、グループ スコープにすることができます。
linkTypeStr 引数
linkTypeStr (文字列)。オプションで、リンクの削除を、linkTypeStr のリテラル文字列値として指定された 1 つのタイプに制限できます。
* linkTypeStr 引数が指定されていない場合は、無題 (リンク タイプがない) リンクのみが削除されます。
* 有効なリンク タイプ名、例:「同意する」を指定すると、指定されたタイプのリンクのみが削除されます。
* 任意のタイプのリンクをすべて削除するか、まったく削除しない場合は、ワイルドカード値 ""*"" (アスタリスク) を使用します。次の点にも注意してください。
** このメソッドはプロトタイプのリンクには影響しません。
linkTypeStr はリテラル文字列として評価されます (以前はパターン一致が行われていました)。
例
メモ「Some note」へのリンクを解除する:
すべてのリンク タイプ: unlinkTo(""メモ"");
リンクタイプ「同意する」のみ: unlinkTo(""メモ"",""同意する"");
2 つのリンク タイプのいずれか: unlinkTo(""Some note"", ""agree|disagree"");
最初の子との一致 (指定子を介して):
unlinkTo(子);
unlinkTo(child,""同意する"");
グループスコープのリファレンスについては、以下を参照してください。
関連する同様の演算子: linkTo、linkFrom、unlinkFrom。
このアクションを使用してもノートのフォーカスは移動しません。さらに、スコープに演算子 (括弧、プラス、マイナスなど) が含まれている場合、Tinderbox はまずリテラルのスコープ文字列との一致を探し、一致がない場合にのみ、アプリは演算子を評価して結果の文字列をテストします。たとえば:
unlinkTo(""例 1 (テスト)"");
「例 1 (テスト)」という名前のメモのリンクを解除します。この文字列に一致するメモがない場合、Tinderbox は文字列の評価を試みます。したがって、次のようになります。
unlinkTo(""2+2"");
「2+2」という名前のメモのリンクが解除されますが、一致するものがない場合、Tinderbox は「4」という名前のメモを探します。
この関数は、元のエイリアスではなくエイリアスのリンクを解除でき (論理的な選択の場合)、グループ スコープも受け入れることができます。グループ スコープの例は、ルールまたはスタンプで使用して、1 つまたは複数の選択したメモから内/バインド脚注リンクを削除する次のコードです。「all」指定子を使用すると、選択範囲が脚注となる注記の名前を知る必要がなくなります。
unlinkFrom(all,""note"");unlinkTo(all,""note+"");
エージェントでの使用
このアクションは現在のノートのエイリアスに対して動作していることと、現在のノート自体に注意してください。オリジナルとエイリアスは個別の基本リンクをサポートしているため、この関数は通常エージェントでは使用しないでください。この関数を使用する最良の方法は、プロトタイプを使用し、それに $Rule を適用して、プロトタイプを使用してすべてのノートでコードを実行することです。
代替の unlinkToOriginal() コードを使用すると、エイリアスがコードの実行コンテキストであるかどうかに関係なく、削除されたリンクが 2 つの元のノートの間にあることが保証されます。"
"unlinkToOriginal(scope[, linkTypeStr])",Function,Group,Linking,success boolean,false,6.4.0,Baseline,,,,2,true,false,false,false,false,true,false,true,false,true,false,"unlinkToOriginal(scope[, linkTypeStr])
This function works exactly as the same as unlinkTo(), except for one important important difference that the link deleted is always between two originals even if either/both the evaluated source or destination are an alias. unlinkToOriginal() does not delete prototype links.
For more detail of use, see unlinkTo().
Unlinking to an original note ""Some note"" (and not an alias of it):
	all link types: unlinkToOriginal(""Some note""); 
	only link type 'agree': unlinkToOriginal(""Some note"",""agree""); 
	either of 2 link types: unlinkToOriginal(""Some note"", ""agree|disagree""); 
See also linkFromOriginal(), linkToOriginal(), unlinkFromOriginal().","unlinkToOriginal(scope[, linkTypeStr])
この関数は unlinkTo() とまったく同じように機能しますが、評価されるソースまたは宛先のいずれかまたは両方がエイリアスであっても、削除されるリンクは常に 2 つの元のリンクの間であるという重要な違いが 1 つあります。unlinkToOriginal() はプロトタイプ リンクを削除しません。
使用方法の詳細については、unlinkTo() を参照してください。
元のノート「Some note」(そのエイリアスではない) へのリンクを解除します。
すべてのリンク タイプ: unlinkToOriginal(""Some note"");
リンクタイプ「同意する」のみ: unlinkToOriginal(""メモ"",""同意する"");
2 つのリンク タイプのいずれか: unlinkToOriginal(""Some note"", ""agree|disagree"");
linkFromOriginal()、linkToOriginal()、unlinkFromOriginal() も参照してください。"
update(),Function,List,Data manipulation,List,false,9.1.0,Baseline,11.0.0,11.0.0,,,false,false,false,false,false,false,false,false,false,,false,"update() 
This returns a list of updated notes. This allow the user, to check, if necessary, which notes have actually been updated.
Note also that we can use update() at the start of an action to be sure we are ready to work, and we can also use update() after an action if we know some other note will want to respond to our new values.
On the whole, update() is envisaged an esoteric command for unusual cases, but may prove popular for some users with demanding applications. For light/occasional use, a need to use update() is likely an indication that some review of current code use is needed.
The method of update() using an argument is documented separately: see update(scope).
From v11.0.0 update() updates smart adornments as well as agents.","更新()
これにより、更新されたメモのリストが返されます。これにより、ユーザーは必要に応じて、どのメモが実際に更新されたかを確認できます。
また、アクションの開始時に update() を使用して作業の準備が整っていることを確認できます。また、他のメモが新しい値に応答する必要があることがわかっている場合は、アクションの後に update() を使用することもできます。
全体として、update() は特殊なケースに対応した難解なコマンドであると考えられていますが、要求の厳しいアプリケーションを使用する一部のユーザーにとっては人気があることが判明する可能性があります。軽い/たまに使用する場合、update() を使用する必要がある場合は、現在のコードの使用方法を見直す必要があることを示している可能性があります。
引数を使用した update() のメソッドについては、別途文書化されています。「update(scope)」を参照してください。
v11.0.0 から、 update() はエー​​ジェントだけでなくスマート装飾品も更新します。"
update(scope),Function,List,Data manipulation,success boolean,false,9.1.0,Baseline,11.0.0,11.0.0,,1,true,false,false,false,false,true,false,false,false,,false,"update(scope)
The action update(scope) asks Tinderbox to update one or more notes defined in the list scope by evaluating both their rule and edict of each listed note (defining scope). If the note has been evaluated recently, Tinderbox will not evaluate it again. 
For example, suppose there is a note 'INSTALL DISHWASHER', which has a rule saying that the dishwasher cannot start to be installed until the task of note 'FLOOR' is finished.
if($StartDate 
This rule works best if the 'FLOOR' note is up to date. So, before doing anything else, the 'FLOOR' note is updated:
update(""FLOOR"");
if($StartDate 
Note that, if note 'FLOOR' has been updated recently (a duration as decided by the app), it will not be updated again; the prevents Tinderbox from doing lots of unwanted and unnecessary work.
On the whole, update(scope) is envisaged an esoteric command for unusual cases, but may prove popular for some users with demanding applications. For light/occasional use, a need to use update() is likely an indication that some review of current code use is needed.
The non-argument form of update() is documented separately: see update().
If update() is called on a note inside /Hints/Library, any functions in the text of that note will be recompiled and the actions in the text of the note will be performed.
When applied to an agent, update() updates the agent as well as performing its rule and edict.
From v11.0.0 update() updates smart adornments as well as agents.","更新(スコープ)
アクション update(scope) は、リストされた各ノート (スコープを定義) のルールと布告の両方を評価することによって、リスト スコープで定義された 1 つ以上のノートを更新するように Tinderbox に要求します。メモが最近評価された場合、Tinderbox はそれを再度評価しません。
たとえば、「食器洗い機の設置」というメモがあり、「床」というメモのタスクが完了するまで食器洗い機の設置を開始できないというルールがあるとします。
if($開始日
このルールは、「FLOOR」メモが最新の場合に最適に機能します。したがって、他の作業を行う前に、「FLOOR」ノートが更新されます。
update(""フロア"");
if($開始日
メモ「FLOOR」が最近（アプリによって決定された期間）更新された場合、再度更新されることはないことに注意してください。これにより、Tinderbox が多くの望ましくない不必要な作業を実行するのを防ぎます。
全体として、update(scope) は特殊なケースに対応した難解なコマンドであると考えられていますが、要求の厳しいアプリケーションを使用する一部のユーザーには人気があることが判明する可能性があります。軽い/たまに使用する場合、update() を使用する必要がある場合は、現在のコードの使用方法を見直す必要があることを示している可能性があります。
update() の非引数形式については別途文書化されています: update() を参照してください。
/Hints/Library 内のノートで update() が呼び出された場合、そのノートのテキスト内の関数はすべて再コンパイルされ、ノートのテキスト内のアクションが実行されます。
エージェントに適用されると、update() はエージェントを更新し、そのルールと命令を実行します。
v11.0.0 から、 update() はエージェントだけでなくスマート装飾品も更新します。"
uppercase(dataStr),Function,Item,Formatting,String,false,4.6.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"uppercase(dataStr)
The contents of dataStr are returned entirely in upper case.
If $MyString is ""hello world"":
	$MyString = uppercase($MyString); 
$MyString is set to ""HELLO WORLD"".
Functionally equivalent to String.uppercase().","大文字(dataStr)
dataStr の内容はすべて大文字で返されます。
$MyString が「hello world」の場合:
$MyString = 大文字($MyString);
$MyString は「HELLO WORLD」に設定されます。
機能的には String.uppercase() と同等です。"
urlEncode(dataStr),Function,Item,Formatting,String,false,4.0.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"urlEncode(dataStr)
urlEncode() converts a dataStr string to 'urlEncoded' form for the web, in accordance with RFC1738. URLs should not contain spaces, control characters, or non-ASCII characters. Characters that are illegal in URLs are encoded as '%' followed by the corresponding hexadecimal character code, e.g. space = %20.
Thus:
	$MyString = urlEncode(""Hello world""); 
sets $MyString to 'Hello%20world'.
dataStr should be a quoted literal string or a reference to a string value.
The characters ? and / are percent-encoded by urlEncode(), e.g. as %3F and %2F. Even though these are now permitted in the query portion of URLs, the Apple NSURL used by Tinderbox balks at their presence.","urlEncode(dataStr)
urlEncode() は、RFC1738 に従って、dataStr 文字列を Web 用の「urlEncoded」形式に変換します。URL にはスペース、制御文字、または非 ASCII 文字を含めないでください。URL 内で無効な文字は、「%」の後に対応する 16 進文字コードが続いてエンコードされます。スペース = %20。
したがって:
$MyString = urlEncode(""Hello world"");
$MyString を「Hello%20world」に設定します。
dataStr は、引用符で囲まれたリテラル文字列または文字列値への参照である必要があります。
登場人物は？と / は urlEncode() によってパーセントエンコードされます。%3F および %2F として。これらは現在では URL のクエリ部分で許可されていますが、Tinderbox で使用される Apple NSURL はそれらの存在を躊躇しています。"
"values([scope, ]attributeNameStr)",Function,Group,"Dictionary, Set & List operations",List,false,5.10.1,Baseline,,,,2,true,false,false,false,false,true,false,true,false,,false,"values([scope, ]attributeNameStr)
values(attributeNameStr)
This returns a Set of unique values for the attribute attributeNameStr. As the output is a of Set data type, the list of possible values is de-duped thus giving a list of unique values, and should be sorted. Any suggested values not actually used by at least one note are omitted from the list return by values().
If the named attributeNameStr is a set or list, values() returns a list of all the unique discrete list item values that occur. If the named attribute is a string, values() returns all the unique strings.
attributeNameStr is evaluated in case it is something like a variable holding the desired target attribute name. The change is that, if the argument is not an attribute name, and if the argument trimmed of its $ is still not an attribute name, we now see if the evaluated expression turns out to be an attribute name.
Important: unlike other operators, be aware that values($MyString) returns a list of values found for $MyString, not a list of the values of the attribute whose name is stored in $MyString. This is unique to values(), and arises because writing values($MyString) instead of values(""MyString"") was a very common mistake. If needing to pass a value holding an attribute name, use an action code variable and not as a value stored in another attribute.
The returned set is sorted in lexical order.
If a document has a user List-Type attribute $SomeList, then to get a a list of all the unique values for $SomeList in the whole document:
	$MyList = values(""SomeList""); 
The attributeNameStr argument is evaluated so may be:
* A quoted attribute name without $-prefix: values(""MyList"").
* A string attribute name, whose current value is the name of an attribute (without a dollar prefix). If $MyString has the value ""MyList"", then values($MyString) will evaluate the unique values for $MyList (and output the same result as values(""MyList"") above).
* An expression resolving to an attribute name.
Thus if the document has a user List-Type attribute $SomeList and $MyString has the value ""SomeList"", then these are functionally equivalent:
	$MyList = values(""SomeList""); 
	$MyList = values($MyString); 
It is envisaged that the first method (the quoted, un-prefixed, attribute name) will be the most usual method of using values().
Sorting. The data is returned in case-sensitive lexical sort order (i.e. all capitals sort before lower case letters, and numbers sorting textually not numerically) so chaining .isort() may often be the desired 'default', or use .nsort() if the list is entirely composed of numbers. Assume, the intention is to get a note whose $Text has one value per line. It could be coded thus:
	$Text=values(""MyList"").format(""\n""); 
This is a very useful way of making a set of per-value notes. Use values() to collect the values, pass them to a note's $Text as a one-value-per-line string and then explode the $Text.
However, a value list of [aardvark;amber;Ant] would actually list in this order: [Ant;aardvark;amber]. That is due to the Set's auto-sort using case-sensitive lexical sorting, whereas a case-insensitive sort would be more appropriate. Thus:
	$Text=values(""MyList"").isort.format(""\n""); 
Similarly the default sort would order 1/2/10 and 1/10/2, so a numerical sort would be more sensible:
	$Text=values(""MyList"").isort.format(""\n""); 
De-duplication. values() differs from collect() in that values() returns Set-type data and collect() returns List-type data. For a list $MyList, the following are functionally equivalent in output:
	$MyList = collect(all,$SomeList).unique; 
	$MyList = values(""SomeList""); 
	$MyList = values($MyString); (where $MyString has the value ""SomeList"")
values(scope, attributeNameStr)
If an optional first scope argument is provided, the value(s) returned are drawn only from notes in that scope (defining scope). If no first argument is supplied, as in the short form above, the default scope-defined group is assumed as 'all' and thus at whole document scope.The reference point for groups like 'children' or 'siblings' is this note. Thus:
	$MyList = values(children,""Subtitle""); 
will return all the discrete subtitles (i.e. values of $Subtitle) for children of this note, i.e. the note in which context the action is being evaluated.","値([スコープ, ]属性名Str)
値(属性名Str)
これにより、属性attributeNameStrの一意の値のセットが返されます。出力は Set データ型であるため、可能な値のリストの重複が排除され、一意の値のリストが得られるため、並べ替える必要があります。少なくとも 1 つのノートで実際に使用されていない推奨値は、values() によって返されるリストから除外されます。
名前付きのattributeNameStrがセットまたはリストの場合、values()は、出現するすべての一意の離散リスト項目値のリストを返します。名前付き属性が文字列の場合、values() はすべての一意の文字列を返します。
attributeNameStr は、目的のターゲット属性名を保持する変数のような場合に評価されます。変更点は、引数が属性名ではなく、$ を削除した引数がまだ属性名でない場合、評価された式が属性名であることが判明するかどうかを確認するようになりました。
重要: 他の演算子とは異なり、values($MyString) は、$MyString に名前が保存されている属性の値のリストではなく、$MyString で見つかった値のリストを返すことに注意してください。これは、values() に固有のもので、values(""MyString"") の代わりに value($MyString) を記述することがよくある間違いであるために発生します。属性名を保持する値を渡す必要がある場合は、別の属性に格納された値としてではなく、アクション コード変数を使用します。
返されたセットは字句順にソートされます。
ドキュメントにユーザー List-Type 属性 $SomeList がある場合、ドキュメント全体の $SomeList の一意の値すべてのリストを取得するには、次のようにします。
$MyList = value(""SomeList"");
attributeNameStr 引数は次のように評価されます。
* $-prefix のない引用符で囲まれた属性名:values(""MyList"")。
* 文字列属性名。現在の値は属性名 (ドル接頭語なし) です。$MyString に値 ""MyList"" がある場合、values($MyString) は $MyList の一意の値を評価します (そして、上記の value(""MyList"") と同じ結果を出力します)。
* 属性名に解決される式。
したがって、ドキュメントにユーザー List-Type 属性 $SomeList があり、$MyString の値が ""SomeList"" である場合、これらは機能的に同等です。
$MyList = value(""SomeList"");
$MyList = 値($MyString);
最初の方法 (引用符で囲まれ、プレフィックスのない属性名) が、values() を使用する最も一般的な方法になることが想定されています。
並べ替え中。データは、大文字と小文字を区別した字句ソート順で返されるため (つまり、すべての大文字が小文字の前にソートされ、数値が数値ではなくテキストでソートされます)、そのため、連鎖する .isort() が望ましい「デフォルト」になることがよくあり、リストが完全に数値で構成されている場合は .nsort() を使用します。$Text が 1 行に 1 つの値を持つメモを取得することが目的だとします。次のようにコード化できます。
$Text=values(""MyList"").format(""\n"");
これは、値ごとのメモのセットを作成するのに非常に便利な方法です。value() を使用して値を収集し、それらを 1 行に 1 つの値の文字列としてメモの $Text に渡し、$Text を展開します。
ただし、値リスト [aardvark;amber;Ant] は、実際には [Ant;aardvark;amber] の順序でリストされます。これは、Set の自動ソートが大文字と小文字を区別する字句ソートを使用しているためですが、大文字と小文字を区別しないソートの方が適切です。したがって:
$Text=values(""MyList"").isort.format(""\n"");
同様に、デフォルトのソートでは 1/2/10 および 1/10/2 の順序になるため、数値ソートの方が賢明です。
$Text=values(""MyList"").isort.format(""\n"");
重複排除。value() は、values() が Set タイプのデータを返し、collect() がリスト タイプのデータを返すという点で、collect() とは異なります。リスト $MyList の場合、次の出力は機能的に同等です。
$MyList =collect(all,$SomeList).unique;
$MyList = value(""SomeList"");
$MyList = 値($MyString);($MyString の値は「SomeList」です)
値(スコープ、attributeNameStr)
オプションの最初のスコープ引数が指定されている場合、返される値は、そのスコープ (スコープを定義) 内のメモからのみ抽出されます。上記の短い形式のように、最初の引数が指定されていない場合、デフォルトのスコープ定義グループは「all」とみなされ、ドキュメントのスコープ全体になります。「children」や「siblings」などのグループの参照点は、このメモです。したがって:
$MyList = value(children,""字幕"");
このノート、つまりアクションが評価されているコンテキストのノートの子のすべての個別のサブタイトル (つまり $Subtitle の値) を返します。"
var,Statement,Item,Data manipulation,declaration,false,5.10.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"var
var:type
The var statement declares the local variable. No trailing parentheses are used. Occasionally, an action may find it convenient to declare a local variable in which to save intermediate results. In the past, the only choice was to use a user attribute as a temporary store, with the attendant issues of deciding if it is necessary to reset the attribute at the end of the expression.
Depending on how the operator is being used it may be used without parentheses.
Try to use variable names that will not be mistaken for something else. Avoid using a 'var' prefix for variable names, such as 'varX', as this will confuse Tinderbox's parser. In such a case 'vX' might be a better choice and a 'v' prefix is the convention adopted in aTbRef (though there is no requirement to use such naming as it is used for explanatory reasons only).
A local variable acts in most ways like a user attribute. Local variables exist for the duration of the action or, when they are declared inside curly brackets { … }, e.g. an an .each() loop, their scope is the rest of the clause, i.e. the remaining individual statements within the {}.
Locally set Set-type variables, e.g. var:set s=[a;b;a;c]; remove duplicates at initialisation.
String variables cannot store styles text (i.e. 'rich' text).
Declaring a variable
So, the var statement declares the local variable:
	var x; declares a variable 'x', but with no value
More sensible is to use a name indicating purpose:
	var vNum; declares a variable 'vNum' with no value.
	var vNum(5); declares a variable 'vNum' and gives it an initial value of 5.
	var vText(""this is note ""+$Name); declares a variable 'vText' and gives it a calculated string value.
A variable can also be declared and assigned a value is a single expression:
		var vCost = 5; 
… defines a temporary variable 'vCost' and then assigns it the value '5'. It is equivalent to the following original syntax, note the explicit use of operator argument parentheses in this case:
	var vCost(5); 
In effect, the first form collapses the older two-step method of declaring an empty var before then giving it a value:
	var vCost; 
	vCost=5; 
Local variables must be declared before first use. If not explicitly initialised, their initial value is the empty string """". Within scope, a variable maybe reset in the same manner as an attribute. Thus, YY=; resets variable 'YY' to no value.
Setting a variable's data type
A var can optionally be given a data type on creation, by colon-appending the data-type to the var operator. Thus:
	var:number vCost(5); 
This generates a variable 'vCost' of (expected) data type Number and sets an initial value of '5'.
Available data types include
* boolean
* color
* date
* dictionary
* interval
* number
* list
* set
* string
Note that data type labels are all-lowercase. Other existing attribute data types that are not listed here will be provisioned as a string, as they are strings with a special, contextually different, form of use. Important: defining a date type without an initial value does not set that types value:
	var:number vNum; → values is undefined (i.e. """")
	var:number vNum = 0; → values is zero (0)
Providing an explicit type helps Tinderbox to understand the user's intent, especially if a default value is applied (though for string-based attributes it is moot). For example, the same numerical value number might react to subsequent operations in various ways:
	var:number vCost(5); vCost = vCost + 5; $MyString= vCost; gives '10'
	var:list vCost((5); vCost =vCost + 5; $MyString = vCost; gives a 2-member list, '5;5'
	var:string x(5); vCost =vCost + 5; $MyString = vCost; gives '55'
Further usage Examples
	$MyNumber = 0; var  vNum = 2; $MyNumber = vNum; 
	$MyNumber = 0; var vNum; vNum = 2; $MyNumber = vNum; 
	$MyNumber = 0; var vNum(2); $MyNumber = vNum; 
In all cases $MyNumber is set to 2. In the second example the variable is defined and given a value using a single code expression. Here is a scoped example within a single action the { and } marking the scope:
	$MyNumber = 0;
	{
		var vNum = 2;
		$MyNumber = vNum;
		vNum = 6;
	};
	$MyNumber = vNum;
$MyNumber is set to 0 (nothing) as 'vNum' has no meaning outside the code inside the braces {}. By analogy a variable created inside a loop or function, (i.e. within { } sections of code) cannot be read outside that scope, but variables created outside such scope can be read/set within a loop or function.
Using variable values declared outside loops or functions
A variable declared using var may be altered from within the scope of a list.each() loop or a function. This includes nested loops or functions. The reverse does not hold. In-loop a new value would be to be stored in an attribute or variable declared outside the loop. In a function, this value could be (part of) the return data.
Passing variables into export code
^^value()^^ can be used, within the context a single template, to insert a var() variable declared within an ^^action()^^ code. Note that the variable must be declared before use, i.e. before as in reading template code top to bottom.
Beware name collisions
Assume for a moment you have an actual attribute $vNum, then:
	$MyNumber = 0;
	{
		var vNum(2);
		$MyNumber = vNum;
		vNum = 6;
	};
	vNum = 4;
	$MyNumber = vNum;
$MyNumber is 4, rather than 0, because the vNum = 4 is interpreted as the deprecated legacy syntax of $vNum = 4. So, be careful that a local variable's name does not match existing attributes, note names or string literals that you use in your project.
Remember the local variable does not take a $ prefix. It is a value reference but not to an attribute.",
version(),Property,Document,Data manipulation,String,false,8.8.0,Baseline,,,,,false,false,false,false,false,false,false,false,false,,false,"version()
version
The action operator version() returns information about the version of Tinderbox. With no argument, it returns a complete version string such as ""8.7.2b472"".
version(""part"") An optional single argument can be supplied. Possible values are: major, minor, fix, and build, each returning a specific part of the overall version.
For example, in Tinderbox 8.7.2b472:
	version() returns: 8.7.2b472 
	version(major) returns: 8 
	version(minor) returns: 7 
	version(fix) returns: 2 
	version(build) returns: b472 
These arguments may be used with or without enclosing quotes. Thus, usage:
	$MyString = version(major); 
or 
	$MyString = version(""fix"");","バージョン()
バージョン
アクション演算子 version() は、Tinderbox のバージョンに関する情報を返します。引数を指定しないと、「8.7.2b472」などの完全なバージョン文字列が返されます。
version(""part"") オプションの 1 つの引数を指定できます。可能な値はメジャー、マイナー、修正、およびビルドで、それぞれがバージョン全体の特定の部分を返します。
たとえば、Tinderbox 8.7.2b472 の場合:
version() の戻り値: 8.7.2b472
バージョン(メジャー)は8を返します。
バージョン(マイナー)が返す値: 7
バージョン(修正)が返す値: 2
バージョン(ビルド)が返す値: b472
これらの引数は、引用符で囲んでも、引用符で囲まなくても使用できます。したがって、使用法は次のようになります。
$MyString = バージョン(メジャー);
または
$MyString = version(""修正"");"
"weeks(startDate, endDate)",Function,Item,Date-time,Number,false,7.5.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"weeks(startDate, endDate)
This returns the Number of (7-day weeks) weeks between two dates, startDate and endDate. If the dates are within seven days of each other, the result is zero. 
If $DateA is 3 January 2016 and $DateB is 20 January 2016, then:
	$MyNumber = weeks($DateA,$DateB); 
sets $MyNumber to 2.
If endDate is before startDate the result is negative.","週(開始日、終了日)
これは、startDate と endDate の 2 つの日付の間の (7 日週) の週数を返します。日付が互いに 7 日以内にある場合、結果はゼロになります。
$DateA が 2016 年 1 月 3 日、$DateB が 2016 年 1 月 20 日の場合、次のようになります。
$MyNumber = 週($DateA,$DateB);
$MyNumber を 2 に設定します。
endDate が startDate より前の場合、結果は負になります。"
while(condition){},Operator,Conditional Group,Data manipulation,boolean test,false,9.5.0,Baseline,,,,1,false,false,false,false,false,false,true,false,false,,false,"The operator while(condition){…} performs an action repeatedly until the condition expression evaluates as false. Put another way, the code in the curly brackets will continue to be run again and again, until condition expression evaluates as false. This operator addresses the scenario where:
-  it is known a task needs to be done multiple times but,
_ the exact number of times to repeat the task is not known
Using while() it is possible to define the a test (condition) to ascertain when the task is done and the repeating/looping action can stop.
For those less used to coding, consider a generalised analogy—the task of filling a bucket with water. Before adding anything to the bucket we might sensibly ask if the bucket is full and only if it is not, do we add another scoop of water. But if the bucket is full, we stop adding water. It can be summarised thus:
* Is the bucket full?
** No?  We add another scoop of water and start over with the original check (i.e. continue the loop).
** Yes? We're done—exit and finish.
Examples
Consider the case where it is desired to process a note's $Text, of unknown size, one sentence at a time. Thus (code commenting is for explanation only, and is not needed in actual code):
	// make a variable holding $Text, so $Text itself is not affected
	var:str vText = $Text;
	// start the loop using vText
	while(vText!=""""){
		// get the first sentence in vText
		var:string vStr = $Text.sentence(0);
		// pass that sentence to function fProcessText() to do whatever task with it ...
		fProcessText(vStr);
		// remove the sentence vStr from vText *before* the loop runs again
		// so that vStr is different in the next loop, i.e. each sentence is used only once
		vText = vText.substr(vStr.size).trim();
	};
This will read $Text and process it to call the user-defined function fProcessText() passing it one sentence at a time. Each loop removes the just-processed sentence, so the text considered in the next loop is one sentence shorter, until eventually vText is empty at which point the while() operator completes and the next action after it, if any, is read.
A programmer might write the same as above more tersely:
	var vt=$Text;while(vt){var:string s=vt.sentence;vt=vt.substr(s.size).trim(); process(s);} 
But, importantly, both do the same thing and the different code has no effect on Tinderbox performance. As long as the code is valid, users are free to choose their style.
Prior to this, it would be necessary to first count the number of discrete sentences and store that in a variable, then make a list of discrete sentences, then iterate this list using a loop counter and checking in each loop to see if the counter figure was below the stored count before taking any per-item action; while() wraps all that up into a simple operator.  
Preventing against infinite loops
An infinite loop occurs when condition always remains false and thus the code loop never stops running. To guard against this unintended scenario while() loops are limited to 10,000 iterations, i.e. if the loop has run 10,000 time it automatically stops regardless of the state of condition.","演算子 while(condition){…} は、条件式が false と評価されるまでアクションを繰り返し実行します。別の言い方をすると、中括弧内のコードは、条件式が false と評価されるまで何度も実行され続けます。この演算子は、次のようなシナリオに対応します。
- タスクは複数回実行する必要があることがわかっていますが、
_ タスクを繰り返す正確な回数は不明です
while() を使用すると、タスクがいつ完了し、繰り返し/ループ アクションが停止するかを確認するテスト (条件) を定義できます。
コーディングにあまり慣れていない人のために、一般化された例え、つまりバケツに水を入れる作業を考えてみましょう。バケツに何かを加える前に、私たちは賢明にもバケツがいっぱいかどうかを尋ね、満杯でない場合にのみ水をもう一杯追加します。しかし、バケツがいっぱいになったら、水を足すのをやめます。それは次のように要約できます。
* バケツはいっぱいですか?
** いいえ？さらに水を一さじ追加し、元のチェックからやり直します (つまり、ループを継続します)。
** はい？完了です。終了して終了します。
例
サイズが不明なメモの $Text を一度に 1 文ずつ処理したい場合を考えてみましょう。したがって (コードのコメントは説明のみを目的としており、実際のコードでは必要ありません):
// $Text を保持する変数を作成するため、$Text 自体は影響を受けません
var:str vText = $Text;
// vText を使用してループを開始します
while(vText!=""""){
// vText の最初の文を取得します
var:string vStr = $Text.sentence(0);
// その文を関数 fProcessText() に渡して、それを使って何らかのタスクを実行します ...
fProcessText(vStr);
// ループが再度実行される *前に * vText から vStr という文を削除します
// 次のループでは vStr が異なるようにします。つまり、各文は 1 回だけ使用されます。
vText = vText.substr(vStr.size).trim();
};
これは $Text を読み取り、それを処理してユーザー定義関数 fProcessText() を呼び出し、一度に 1 文ずつ渡します。各ループでは処理されたばかりの文が削除されるため、次のループで考慮されるテキストは 1 文短くなり、最終的に vText が空になり、その時点で while() 演算子が完了し、その後の次のアクション (存在する場合) が読み取られます。
プログラマは上記と同じことをもっと簡潔に書くかもしれません:
var vt=$Text;while(vt){var:string s=vt.sentence;vt=vt.substr(s.size).trim();プロセス;}
ただし重要なのは、両方とも同じことを行うため、コードが異なっていても Tinderbox のパフォーマンスに影響を与えることはありません。コードが有効である限り、ユーザーはスタイルを自由に選択できます。
これに先立って、まず個別の文の数を数えてそれを変数に保存し、次に個別の文のリストを作成し、ループ カウンタを使用してこのリストを繰り返し、アイテムごとのアクションを実行する前にカウンタの数値が保存された数を下回っているかどうかを各ループで確認する必要があります。while() は、これらすべてを単純な演算子にまとめます。
無限ループの防止
無限ループは、条件が常に false のままであるため、コード ループの実行が停止しない場合に発生します。この意図しないシナリオを防ぐために、while() ループの反復回数は 10,000 回に制限されています。つまり、ループが 10,000 回実行されると、条件の状態に関係なく自動的に停止します。"
word(dataStr),Function,Item,Query Boolean,boolean test,false,4.6.0,Baseline,,,,1,true,false,false,false,false,false,false,false,false,,false,"word(dataStr)
Returns Boolean true if the string dataStr (of for or more characters) is contained in the current note's text or title. This operator is quicker for matching whole words than using a regular expression. The function matches all notes that contain a single word matching (case-insensitively) any complete word in:
* the title OR
* the text OR
* any user String data-type attribute(s). This does not include other data types based on strings (List, URL, Set, File, Action, etc.)
The matching is case-insensitive. Note that word() is stricter in its matching than the .contains() function as it looks only for entire words and does not match regular expressions. Although word() examines several different fields, the result is that word() is much faster than .contains().
The word dataStr must be a quoted string containing:
* a single word (no hyphenated words)
* contain only upper or lower case letters, so no white space, digits, or punctuation
* 4 characters or more (values less than 4 characters or fewer are ignored by Tinderbox).
In the query creation pop-ups of agent and Find dialogs this function is listed as ""contains word"".
Example
This query finds any note where the word 'confusion' occurs (in any case variant) in either $Text or $Name :
	word(""Confusion"") 
Note how dataStr is case-insensitive.
Legacy issues
This operator replaces the legacy #word query operator.","ワード(データ文字列)
文字列 dataStr (for 文字以上) が現在のノートのテキストまたはタイトルに含まれている場合、ブール値 true を返します。この演算子は、正規表現を使用するよりも単語全体を高速に照合します。この関数は、次の完全な単語に (大文字と小文字を区別せずに) 一致する 1 つの単語を含むすべてのノートと一致します。
* タイトルまたは
* テキストまたは
* 任意のユーザーの文字列データ型属性。これには、文字列に基づく他のデータ型 (リスト、URL、セット、ファイル、アクションなど) は含まれません。
照合では大文字と小文字は区別されません。word() は単語全体のみを検索し、正規表現と一致しないため、.contains() 関数よりも一致が厳密であることに注意してください。word() はいくつかの異なるフィールドを検査しますが、結果として word() は .contains() よりもはるかに高速です。
dataStr という単語は、次の内容を含む引用符で囲まれた文字列である必要があります。
* 単一の単語 (ハイフンでつながれた単語は含まない)
* 大文字または小文字のみが含まれるため、空白、数字、句読点は含まれません
※4文字以上（4文字以下の値はTinderboxでは無視されます）。
エージェントのクエリ作成ポップアップと検索ダイアログでは、この関数は「単語を含む」としてリストされます。
例
このクエリは、 $Text または $Name のいずれかで 'confusion' という単語が出現するメモを検索します (いずれの場合も変化します)。
word(「混乱」)
dataStr では大文字と小文字が区別されないことに注意してください。
従来の問題
この演算子は、従来の #word クエリ演算子を置き換えます。"
"wordsRelatedTo(dataStr[, wordsNum])",Function,Item,Data manipulation,Set,false,8.8.0,Baseline,,,10.15,2,true,false,false,false,false,false,false,true,false,,false,"wordsRelatedTo(dataStr[, wordsNum])
NOTE: This feature needs macOS 10.15.0 or later. If used on older OSs, the function returns no data; i.e. not all users of v8.x maybe able to use this feature as it is macOS version dependent.
The operator tries to return a list (Set) of up to wordsNum (discrete) words related to its dataStr argument. Fewer words may be returned, or no words may be returned if the argument is unusual, or if the current language is not supported.
An optional second argument wordsNum, allows the returned number of related terms to be limited to a specific number of items. wordsNum is 1 or more (integer value), but Tinderbox will only return as many 'related' terms as it can find, i.e. it may return fewer than wordsNum items.
Practically, an wordsNum value of more than 10 items is unlikely to render useful results. Be aware this draws on features still under development in the underlying OS, so there are no certainties.
	$MySet = wordsRelatedTo(""hubris""); 
or to get only 5 (or fewer) values:
	$MySet = wordsRelatedTo(""aspirational"",5); 
It is not certain, but likely, that results returned are ordered by proximity of the relationship in the vector space of the dataStr (bear in mind this is a black-box OS procedure).
Though the product is essentially a Set, i.e. a list without duplicates, Sets may change the order of items during other processes whilst List attributes do not. So if concerned about retaining order exactly as originally returned by the function, it makes would pass the process to an explicit list
	$MyList = wordsRelatedTo(""expectation"",8);","単語関連先(dataStr[, 単語数])
注: この機能には macOS 10.15.0 以降が必要です。古い OS で使用した場合、関数はデータを返しません。つまり、この機能は macOS のバージョンに依存するため、v8.x のすべてのユーザーが使用できるわけではありません。
演算子は、dataStr 引数に関連する最大wordNum (離散) 単語のリスト (Set) を返そうとします。引数が特殊である場合、または現在の言語がサポートされていない場合は、返される単語が少なくなるか、単語が返されないことがあります。
オプションの 2 番目の引数 WordsNum を使用すると、返される関連用語の数を特定の項目数に制限できます。WordsNum は 1 以上 (整数値) ですが、Tinderbox は見つけられる限りの「関連」用語のみを返します。つまり、wordNum よりも少ない項目が返される可能性があります。
実際には、wordsNum 値が 10 項目を超えると、有用な結果が得られる可能性は低くなります。これは基盤となる OS で開発中の機能を利用しているため、確実性はないことに注意してください。
$MySet = 言葉関連To(""ハブリス"");
または、5 つ (またはそれ以下) の値のみを取得するには:
$MySet = WordsManyTo(""願望"",5);
確実ではありませんが、返される結果は dataStr のベクトル空間内の関係の近さによって順序付けされる可能性があります (これはブラックボックス OS プロシージャであることに留意してください)。
プロダクトは本質的にセット、つまり重複のないリストですが、セットは他のプロセス中に項目の順序を変更する可能性がありますが、リスト属性は変更しません。したがって、関数によって最初に返された順序を正確に保持することに懸念がある場合は、プロセスを明示的なリストに渡すことになります。
$MyList = 単語関連To(""期待"",8);"
XML.each(pathStr){action},Function,Item,Stream parsing,iterator,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"XML.each(pathStr){ action(s) }
This operator locates the xml object for each object at the pathStr (within the XML), generating a loop upon it. The .each(pathStr) invokes the action block with the xml item bound in turn to each book element. On completion, it restores the XML object to its previous state.
Consider a note ""Source note"" with this $Text:
&lt;shelf>
	&lt;book price=""9.95"">War and Peace&lt;/book>
	&lt;book price=""4.95"">No et Moi&lt;/book>
	&lt;audio price=""14.95"">Born To Run&lt;/audio>
&lt;/shelf>
Example usage of path:
$MyList(""test"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book""]+""\n"";
};
which sets $MyList of note ""test"" to a list of children of the &lt;shelf> element that are &lt;book> elements, [War and Peace;No et Moi].
$MyList(""test2"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book[2]""]+""\n"";
};
which sets $MyList of note ""test"" to the value of child element of the &lt;shelf> element that represents the second book, ""No et Moi"". Other iterated elements return a blank. See 'Notes' below.
$MyList(""test2"") = """";
$Text(""Source note"").xml.each(""/shelf/book""){
	$MyList(""test2"")+=xml[""book@price""]+""\n"";
};
witch sets $MyList of note ""test"" to a list of the price attribute of each book element, [9.95;4.95].
Notes:
* Acceptable path content is a subset of the XPath standard (see https://www.w3.org/TR/2017/REC-xpath-31-20170321/).
* To accord with standard XML and XPath usage, the first child of an XML node is child [1], not [0].
* XML attributes are not related to Tinderbox attributes.
Consider this source XML string stream:
&lt;shelf>
&lt;book price=""9.95"">War and Peace&lt;/book>
&lt;book price=""4.95"">No et Moi&lt;/book>
&lt;audio price=""14.95"">Born To Run&lt;/book>
&lt;/shelf>
Examples
Stream.xml.each(""/shelf/book"") {action} 
returns every 'book' object in the 'shelf' object and iterates over them, i.e. for each (path-matched) item it invokes the action block with the xml item bound in turn to each book element. In the example above this means the action is run 3 times, once for each of the 3 &lt;book> elements under &lt;shelf>.
Inside the action clause, action code can refer to the value of the iterated item as elementName[], book[]. Any attribute of that item can be addressed as elementName[@attribute] book[@price], i.e. here the 'price' attribute of the XML object in focus.
On completion, it restores the xml object to its previous state.","XML.each(pathStr){ アクション }
この演算子は、(XML 内の) pathStr で各オブジェクトの XML オブジェクトを見つけ、そのオブジェクトに対してループを生成します。.each(pathStr) は、xml 項目を各 book 要素に順番にバインドしたアクション ブロックを呼び出します。完了すると、XML オブジェクトを以前の状態に復元します。
次の $Text を持つメモ「ソース メモ」について考えてみましょう。
<棚>
&lt;book Price=""9.95"">戦争と平和&lt;/book>
&lt;book Price=""4.95"">ノ・エ・モワ&lt;/book>
&lt;audioprice=""14.95"">ボーン・トゥ・ラン&lt;/audio>
&lt;/棚>
パスの使用例:
$MyList(""テスト"") = """";
$Text(""ソースノート"").xml.each(""/shelf/book""){
$MyList(""test2"")+=xml[""book""]+""\n"";
};
これは、メモ「test」の $MyList を、<book> 要素である <shelf> 要素の子のリスト [War and Peace;No et Moi] に設定します。
$MyList(""test2"") = """";
$Text(""ソースノート"").xml.each(""/shelf/book""){
$MyList(""test2"")+=xml[""book[2]""]+""\n"";
};
これは、メモ「test」の $MyList を、2 番目の本「No et Moi」を表す &lt;shelf> 要素の子要素の値に設定します。他の反復​​要素は空白を返します。以下の「注意事項」を参照してください。
$MyList(""test2"") = """";
$Text(""ソースノート"").xml.each(""/shelf/book""){
$MyList(""test2"")+=xml[""book@price""]+""\n"";
};
ウィッチは、メモ「test」の $MyList を各書籍要素の価格属性のリスト [9.95;4.95] に設定します。
注:
* 許容されるパスの内容は、XPath 標準のサブセットです (https://www.w3.org/TR/2017/REC-xpath-31-20170321/ を参照)。
* 標準の XML および XPath の使用法に従って、XML ノードの最初の子は [0] ではなく、子 [1] になります。
* XML 属性は Tinderbox 属性とは関係ありません。
次のソース XML 文字列ストリームを考えてみましょう。
<棚>
&lt;book Price=""9.95"">戦争と平和&lt;/book>
&lt;book Price=""4.95"">ノ・エ・モワ&lt;/book>
&lt;audioprice=""14.95"">ボーン・トゥ・ラン&lt;/book>
&lt;/棚>
例
Stream.xml.each(""/shelf/book"") {アクション}
「shelf」オブジェクト内のすべての「book」オブジェクトを返し、それらを反復処理します。つまり、（パスが一致した）アイテムごとに、各 book 要素に順番にバインドされた xml アイテムを持つアクション ブロックを呼び出します。上記の例では、アクションが、<shelf> の下にある 3 つの <book> 要素ごとに 1 回ずつ、計 3 回実行されることを意味します。
action 句内では、アクション コードは反復項目の値を elementName[]、book[] として参照できます。そのアイテムの属性はすべて elementName[@attribute] book[@price] としてアドレス指定できます。つまり、ここではフォーカスされている XML オブジェクトの「price」属性です。
完了すると、xml オブジェクトを以前の状態に復元します。"
XML.xml(pathStr),Function,Item,Stream parsing,source context dependent,false,9.1.0,Baseline,,,,1,true,true,false,false,false,false,false,false,false,,false,"XML.xml(pathStr)
If there is no current XML object, attempts to parse the string as XML and fails if unsuccessful. If there is a current XML object, it will be reused.
Returns a specific piece of data from the XML object, determined by the pathStr should be an expression or a quoted string.
Consider a note ""Source note"" with this $Text:
&lt;shelf>
	&lt;book price=""9.95"">War and Peace&lt;/book>
	&lt;book price=""4.95"">No et Moi&lt;/book>
	&lt;audio price=""14.95"">Born To Run&lt;/audio>
&lt;/shelf>
Example usage of path:
	$Text(""test"") = $Text(""Source note"").xml(""/shelf/book""); 
sets $Text of note ""test"" to a list of children of the &lt;shelf> element that are &lt;book> elements. ""War and Peace;No et Moi""
	$Text(""test"") = $Text(""Source note"").$Text.xml(""/shelf/book[2]"") 
sets $Text of note ""test"" to the value of child element of the &lt;shelf> element that represents the second book, ""No et Moi"". See 'Notes' below.
	$Text(""test"") = $Text(""Source note"").$Text.xml(""/shelf/book@price"") 
sets $Text of note ""test"" to the price attribute of each book, ""9.954.95""
Notes:
* Acceptable path content is a subset of the XPath standard (see https://www.w3.org/TR/2017/REC-xpath-31-20170321/). This explains the 'book@price' usage above to get the 'price' attribute value from a 'book' element. Explanation of XPath is out of scope for aTbRef.
* To accord with standard XML and XPath usage, the first child of an XML node is child [1], not [0].
* XML attributes are not related to Tinderbox attributes.","XML.xml(パス文字列)
現在の XML オブジェクトがない場合は、文字列を XML として解析しようとしますが、失敗すると失敗します。現在の XML オブジェクトがある場合は、それが再利用されます。
pathStr が式または引用符で囲まれた文字列であるかどうかによって決定される、XML オブジェクトからの特定のデータ部分を返します。
次の $Text を持つメモ「ソース メモ」について考えてみましょう。
<棚>
&lt;book Price=""9.95"">戦争と平和&lt;/book>
&lt;book Price=""4.95"">ノ・エ・モワ&lt;/book>
&lt;audioprice=""14.95"">ボーン・トゥ・ラン&lt;/audio>
&lt;/棚>
パスの使用例:
$Text(""テスト"") = $Text(""ソースノート"").xml(""/shelf/book"");
メモ「test」の $Text を、&lt;book> 要素である &lt;shelf> 要素の子のリストに設定します。「戦争と平和、ノ・エ・モワ」
$Text(""テスト"") = $Text(""ソースノート"").$Text.xml(""/shelf/book[2]"")
メモ「test」の $Text を、2 番目の本「No et Moi」を表す &lt;shelf> 要素の子要素の値に設定します。以下の「注意事項」を参照してください。
$Text(""テスト"") = $Text(""ソースノート"").$Text.xml(""/shelf/book@price"")
メモ「test」の $Text を各書籍の価格属性「9.954.95」に設定します。
注:
* 許容されるパスの内容は、XPath 標準のサブセットです (https://www.w3.org/TR/2017/REC-xpath-31-20170321/ を参照)。これは、「book」要素から「price」属性値を取得するための上記の「book@price」の使用法を説明しています。XPath の説明は aTbRef の範囲外です。
* 標準の XML および XPath の使用法に従って、XML ノードの最初の子は [0] ではなく、子 [1] になります。
* XML 属性は Tinderbox 属性とは関係ありません。"
"year(aDate, yearsNum)",Function,Item,Date-time,Date,false,5.0.0,Baseline,,,,2,true,false,true,false,false,false,false,false,false,,false,"year(aDate,yearsNum) 
creates a new Date based on the theDate date/time expression, but in which the year is set by yearsNum:. For example, if $MyDate is July 4,2009, then 
	$MyDate=hour($MyDate,2011); 
will change $MyDate to July 4, 2011.
If the output is passed back to theDate, its year element is changed
	$MyDate = year($MyDate,2011); $MyDate is changed
but if passed to a different Date object, theDate is not altered:
	$MyDateA = year($MyDate,2011); $MyDate is unaltered

Note that the single-argument version that returns the year segment is documented separately: see year(aDate).","year(aDate,yearNum)
theDate 日付/時刻式に基づいて新しい Date を作成しますが、年は yearsNum: によって設定されます。たとえば、$MyDate が 2009 年 7 月 4 日の場合、
$MyDate=時間($MyDate,2011);
$MyDate は 2011 年 7 月 4 日に変更されます。
出力が theDate に戻されると、その年の要素が変更されます。
$MyDate = 年($MyDate,2011);$MyDate が変更されました
ただし、別の Date オブジェクトに渡された場合、Date は変更されません。
$MyDateA = 年($MyDate,2011);$MyDate は変更されません

年のセグメントを返す単一引数のバージョンについては、別途文書化されていることに注意してください。「year(aDate)」を参照してください。"
year(aDate),Function,Item,Date-time,Number,false,5.0.0,Baseline,,,,1,true,false,true,false,false,false,false,false,false,,false,"year(aDate)
returns the year from the theDate date/time expression:
	$MyNumber = year($MyDate); 
Alternatively, use Date.year.
Note that the double-argument version that alters Dates is documented separately: see year(aDate, yearsNum).","年(日付)
theDate 日付/時刻式から年を返します。
$MyNumber = 年($MyDate);
あるいは、Date.year を使用します。
Dates を変更する二重引数バージョンについては別途文書化されていることに注意してください。year(aDate, yearsNum) を参照してください。"
"years(startDate, endDate)",Function,Item,Date-time,Number,false,6.0.0,Baseline,,,,2,true,false,false,false,false,false,false,false,false,,false,"years(startDate, endDate) 
returns the Number of whole years that elapsed between startDate and endDate. If endDate is earlier than startDate then the result is negative.
If $DateA is 3 January 2016 and $DateB is 9 January 2018, then:
	$MyNumber = years($DateA,$DateB); 
sets $MyNumber to 2.","年(開始日、終了日)
startDate と endDate の間に経過した年数を返します。endDate が startDate より前の場合、結果は負になります。
$DateA が 2016 年 1 月 3 日、$DateB が 2018 年 1 月 9 日の場合、次のようになります。
$MyNumber = 年($DateA,$DateB);
$MyNumber を 2 に設定します。"
