Name,Text,TextJa
Action-Type Attributes,"Action\nThe attribute data type of 'action' represents a string that can be used as an action; under the hood, Tinderbox caches the compiled action so it does not have to constantly re-parse the same expression. Thus these attributes should contain a string [sic] of valid Tinderbox action code. \nSome pre-existing system attributes, such as OnAdd and Rule have been re-classed from 'string' to 'action' type.\nThis data type is not available for user attributes. Use 'string' instead. \nDefault/Empty value\nAn empty string.\nSorting order\nAs for String Data Type.\nAction-type System Attributes\nBuilt-in attributes of the action data type are listed below:",アクション\n属性データ型「action」は、アクションとして使用できる文字列を表します。Tinderbox は内部でコンパイルされたアクションをキャッシュするため、同じ式を常に再解析する必要がありません。したがって、これらの属性には、有効な Tinderbox アクション コードの文字列 [原文どおり] が含まれている必要があります。\nOnAdd や Rule などの一部の既存のシステム属性は、「文字列」タイプから「アクション」タイプに再分類されました。\nこのデータ型はユーザー属性には使用できません。代わりに「文字列」を使用してください。\nデフォルト/空の値\n空の文字列。\n並べ替え順序\n文字列データ型については。\nアクションタイプのシステム属性\nアクション データ型の組み込み属性を以下に示します。
Boolean-Type Attributes,"Boolean\nA binary value: either true or false. These values are case sensitive. If no default value is specified, a Boolean type defaults to a value of false.\nIn the Tinderbox UI, Boolean attributes may often be represented as tick-boxes, e.g. in a note's displayed attributes table. A ticked box equates to true, and an empty box to false.\nWhen coercing a Boolean value—such as an expression result—to Number-type of data, true coerces to 1 and false coerces to 0 (zero).\nDefault/Empty value\nA value of false.\nSorting order\nfalse (un-ticked), then true (ticked).\nBoolean-type System Attributes\nBuilt-in attributes of the boolean data type are listed below:\n\n\nBoolean-type System Attributes set via Document Settings\nA number of Document Settings controls set the defaults for Boolean-type system attributes, directly or indirectly:\n* Text tab: \n** $SmartQuotes.\n** $UpdateTextLinksAfterRename.\n* Maps tab: \n** $Never Composite.",ブール値\nバイナリ値: true または false。これらの値では大文字と小文字が区別されます。デフォルト値が指定されていない場合、ブール型のデフォルト値は false になります。\nTinderbox UI では、ブール属性は多くの場合、チェックボックスとして表されます。ノートの表示属性テーブル内。チェックが入ったボックスは true に相当し、空のボックスは false に相当します。\n式の結果などのブール値を数値型のデータに強制変換する場合、true は 1 に強制され、false は 0 (ゼロ) に強制されます。\nデフォルト/空の値\nfalse の値。\n並べ替え順序\nfalse (チェックなし)、次に true (チェックあり)。\nブール型のシステム属性\nブール データ型の組み込み属性を以下に示します。\n\n\nドキュメント設定で設定されたブール型のシステム属性\n多くのドキュメント設定コントロールは、直接的または間接的にブール型システム属性のデフォルトを設定します。\n* テキストタブ:\n** $SmartQuotes。\n** $UpdateTextLinksAfterRename。\n*「マップ」タブ:\n** $Never Composite。
Color-Type Attributes,"Color\nAny one of the following:\n* Hexadecimal. A colour represented as s string ""#RRGGBB""; a hash sign followed by 6 hexadecimal digits, a pair for the intensity level 0 to 250 in hexadecimal of Red, Green and Blue. This is the same format used for describing colours in HTML. Example: ""#A482BF"". The short form is also accepted, e.g. ""#f00"" for ""#ff0000"", where the two hex characters of each per-colour value are identical and the second character is omitted. Bare hex strings in action code, i.e. unquoted numbers preceded by a hash sign, are correctly identified as hex input values.\n* Named Colours. The name of a colour that either comes pre-defined in Tinderbox, or which you have defined for this Tinderbox document using the Colors pane of the attribute palette. Examples: blue, red, minty-fresh-green. When setting a shade of a named colour in a string the shade value (lighter, darkest, etc.) comes before the colour, unlike listings in Info view and the Inspectors; thus ""dark warm gray"" not ""warm gray dark"", ""light cyan"" not ""cyan light"".\n* HSV (Hue-Saturation-Value) value. Hue: a value from 0 to 360 degrees. Saturation and Value: a value from 0 to 100 percent. Enclosed in parentheses and preceded by 'hsv'. Examples: ""hsv(0,100,50)"", ""hsv(240,80,80)"".\n* RGB (Red-Green-Blue). Intensity levels represented as integers from 0 to 250. Enclosed in parentheses and preceded by 'rgb'. Examples: ""rgb(0,0,0)"" and ""rgb(68,153,68)"". This should not be confused with the rgb() action operator (which sets a hex format value string (see first bullet above).\nWhen displayed in a note's displayed attributes table, Color-type attributes show a colour-chip icon before the attribute value. Pressing the icon opens an OS colour picker dialog.\nIf no default value is specified, a Color type defaults to an empty string (which is treated by Tinderbox as the value 'normal'); in Displayed Attributes table displays a white colour chip is displayed. In some cases, Tinderbox will show a dark red colour as a 'not initialised' colour value; it is hex colour code #6f0000, though its derivation as a value is not clear.\nNote that as 8-bit colour settings are translated within the app into 16-bit colours, rounding errors can occur. So, in some cases—most likely using HSV and HSV based transforms—the values used might not correspond precisely to those set by the user.\nSimilarly, using format() with a colour attribute will always result in a hexadecimal value string regardless of the stored value. Thus it makes sense to export colour attributes as value(format($ColorAttr)) or value($ColorAttr.format()). However, note that coercing a default (blank) colour to a string value using format() or .format() will result in the colour value ""#ffffff"", which is not strictly the blank value. So, be wary of using that formatting as a means to check for a blank colour value; better is to use a short form Boolean test.\nUse in Export code\nWhen accessed via value() export code, it will return either a hex colour value or a named Tinderbox colour, depending on what is set for the destination attribute. \nLegacy only: using the deprecated get() or getFor() export codes, the colour is always returned as a hex figure including a # prefix, e.g. ""#FF9900"". \nDefault/Empty value\nAn empty string.\nSorting order\nNamed colours in decreasing lexical sort order, then #-based codes in decreasing lexical sort order with same valued three-character codes sorting after six-character ones (i.e. #ffffff before #fff).\nColor-type System Attributes\nBuilt-in attributes of the Color data type are listed below:\n\n\nColor-type System Attributes set via Document Settings\nA number of Document Settings controls set the defaults for Color-type system attributes, directly or indirectly:\n* Text tab: \n** $TextBackgroundColor.\n** $TextColor.\n* Maps tab: \n** $MapBackgroundColor.\n** $MapBackgroundAccentColor.\n* Outlines tab: \n** $PrototypeHighlightColor.","色\n次のいずれか:\n* 16 進数。文字列「#RRGGBB」として表される色。ハッシュ記号の後に 6 つの 16 進数が続き、赤、緑、青の 16 進数での強度レベル 0 ～ 250 のペアです。これは、HTML で色を記述するために使用されるのと同じ形式です。例: 「#A482BF」。短い形式も受け入れられます。「#f00」は「#ff0000」の場合、各色ごとの値の 2 つの 16 進文字は同一で、2 番目の文字は省略されます。アクション コード内の裸の 16 進文字列、つまりハッシュ記号が前にある引用符で囲まれていない数値は、16 進入力値として正しく識別されます。\n* 名前付きの色。Tinderbox で事前に定義されている色の名前、または属性パレットの [色] ペインを使用してこの Tinderbox ドキュメントに定義した色の名前。例: 青、赤、ミント、フレッシュ、グリーン。文字列で名前付きの色の色合いを設定する場合、情報ビューやインスペクターのリストとは異なり、色合いの値 (明るい、最も暗いなど) が色の前に来ます。したがって、「ウォームグレーダーク」ではなく「ダークウォームグレー」、「シアンライト」ではなく「ライトシアン」です。\n* HSV (色相-彩度-値) 値。色相: 0 ～ 360 度の値。彩度と値: 0 ～ 100 パーセントの値。括弧で囲まれ、先頭に「hsv」が付きます。例: 「hsv(0,100,50)」、「hsv(240,80,80)」。\n* RGB (赤-緑-青)。強度レベルは 0 ～ 250 の整数で表されます。括弧で囲まれ、先頭に「rgb」が付きます。例: 「rgb(0,0,0)」および「rgb(68,153,68)」。これを rgb() アクション演算子 (16 進形式の値文字列を設定する (上記の最初の箇条書きを参照) と混同しないでください)。\nノートの表示属性テーブルに表示される場合、カラータイプ属性は属性値の前にカラーチップアイコンを表示します。アイコンを押すと、OS のカラー ピッカー ダイアログが開きます。\nデフォルト値が指定されていない場合、Color タイプはデフォルトで空の文字列になります (Tinderbox では値 'normal' として扱われます)。「表示される属性」テーブルには、白色のカラーチップが表示されます。場合によっては、Tinderbox は「初期化されていない」色の値として濃い赤色を表示します。これは 16 進数のカラーコード #6f0000 ですが、値としての派生は明らかではありません。\n8 ビットのカラー設定はアプリ内で 16 ビットのカラーに変換されるため、丸め誤差が発生する可能性があることに注意してください。そのため、場合によっては、HSV および HSV ベースの変換を使用する可能性が高く、使用される値がユーザーが設定した値と正確に一致しない可能性があります。\n同様に、color 属性を指定して format() を使用すると、格納されている値に関係なく、常に 16 進値の文字列が生成されます。したがって、カラー属性を value(format($ColorAttr)) または value($ColorAttr.format()) としてエクスポートすることは理にかなっています。ただし、format() または .format() を使用してデフォルト (空白) 色を文字列値に強制すると、厳密には空白値ではない色の値 ""#ffffff"" が生成されることに注意してください。したがって、空白の色の値を確認する手段としてその書式設定を使用することには注意してください。短い形式のブール テストを使用することをお勧めします。\nエクスポートコードでの使用\nvalue() エクスポート コード経由でアクセスすると、宛先属性に設定されている内容に応じて、16 進数のカラー値または名前付きの Tinderbox カラーが返されます。\nレガシーのみ: 非推奨の get() または getFor() エクスポート コードを使用すると、色は常に # プレフィックスを含む 16 進数値として返されます。「#FF9900」。\nデフォルト/空の値\n空の文字列。\n並べ替え順序\n名前付きカラーは降順の字句ソート順で、次に # ベースのコードは降順の字句ソート順で、同じ値の 3 文字のコードが 6 文字のコードの後にソートされます (つまり、#ffffff の前に #fff)。\nカラータイプのシステム属性\nColor データ型の組み込み属性を以下に示します。\n\n\nドキュメント設定で設定されたカラータイプのシステム属性\n多くのドキュメント設定コントロールは、カラー タイプのシステム属性のデフォルトを直接的または間接的に設定します。\n* テキストタブ:\n** $TextBackgroundColor。\n** $TextColor。\n*「マップ」タブ:\n** $MapBackgroundColor。\n** $MapBackgroundAccentColor。\n* アウトラインタブ:\n** $PrototypeHighlightColor。"
Date-Type Attributes,"Date\nA date and time string. It should always be enclosed in double quotes (legacy code without these may cease to work as expected). Dates can be added/subtracted/compared in mathematical fashion, as per number data types. The resulting 'string' can be formatted by means of date format codes. If no default value is specified, a Date type defaults to a value of never.\nDate includes a time element even if not displayed\nIf a date is specified but not a time, time always defaults to current system time except the seconds are not shown in Displayed Attributes (visual format may vary by locale, e.g. on the use of the colon delimiter).\nThe element in Date comparisons\nTime is used in date comparisons except when the == or != operators are used. Also see Basic Comparison Operators and date comparisons; the same rules hold true for data comparisons in action code expressions. Seconds are acknowledged in comparisons, except those excluding all time elements of a date/time (Previously, seconds were not used and/or are always considered to be 00. To use exact equality tests on full date-time data use interval()).\nConsidering date vs. date-time in queries is discussed here.\nDate keywords\nTinderbox recognises date keywords such as today, now, yesterday, tomorrow, day, week, month, year, hour and minute as date-defining placeholders when working in action code (see date keywords link for a full list). Constructions like ""yesterday + 1 week"", ""tomorrow + 1 year"" or ""tomorrow - 2 hours"" are also possible; note how the whole expression is placed in one set of double quotes. If number is supplied without a date placeholder, e.g. ""today + 1"", then 'day' is assumed as a default unit value, i.e. as if the input was ""today +1 week"". See more on the syntax for setting/adjusting dates using date keyword strings.\nThe 'now' placeholder can be used as an alternate for 'today'. As both the latter use the current system clock time for their time element, note that it is possible to set an explicit time alongside designators (only use 24-hour clock time: ""today 16:00"" or ""tomorrow - 2 days 23:59"". See more on setting times.\nInitialising a Date attribute without time information\nBeware the use of only date placeholders, without time indicators, to initially set a Date attribute will result in the time portion (hours:minutes) being set to the users local OS system time. Entering a time-less date into a Displayed Attribute value box, e.g. ""21 Aug 2001"" will also result in the time portion being set from the OS local time. Using a date designator to alter an existing date never alters the time part of the date attribute value. The time part of a date can be altered either by manually (re-)setting it or by use of time-related action codes. If current time is 17:03:24 (5 PM, 3 minutes and 24 seconds):\n	$StartTime = date(""27/03/2022"") gives a time of 17:03:24 on 27 March 2002 (US users only, reverse day/month order)\n 	$StartTime = date(""27/03/2022 00:00:00"") gives a time of 00:00:00 on 27 March 2002 (US users only, reverse day/month order)\nSimilarly if initialising a Date attribute by typing in a Displayed Attributes or Get Info value, you must explicitly include the h/m/s time unless you wish to use the default (system) time.\nEffects of OS locale. Tinderbox will assume a manually supplied version uses the same day/month order as the user's current locale settings. In other words, if working on a US system using month/day order enter 6 July 2001 as ""7/6/2011"" whereas on a British system using day/month order use ""6/7/2011"", and so on for other locales. Dates that use slashes ""1/7/05"" and the European Continental format with periods, e.g. ""1.7.05"" are both recognised.\nFor years with only one or two digits, e.g. 10CE, you should always enter the year part of the dates as 4 digits (e.g. 0010) when setting dates via code or Displayed Attribute input.\nUsers should check the Formats pane of the International pane (Formats tab) of their macOS System Preferences and ensure the 'short' format uses four-digit year numbers. To do this (for a region), on the Formats tab, click the 'Customize…' button to the right of the example dates. The 'Show' pop-up is most likely set to 'Short'; leave it as that. In the white text box below click on to year; you will see a drop-down menu that will allow you to choose either 2-digit or 4-digit dates, select the four-digit date. US users should note the default US setting for ""short"" date formats is to display 2-digit years, i.e. 10/3/65 (for 1765, 1865, etc.). All numeric reverse-order dates like '20090130' can be used though do test the exact desired format before committing to extensive use.\nUse of negative (BCE) dates\nTinderbox will allow negative dates to allow analysis of data either side of the CE/BCE (AD/BC) boundary. Negative integers from -1 to -2500, when coerced to dates, are interpreted as years BCE (BC). Some current limitations re 'negative' dates:\n* Currently, there is no way in a Displayed Attribute box or in display expressions to display the fact that a date is negative.\n* Negative dates cannot be tested for using greater than/less than comparisons.\n* Negative dates cannot easily be set via a Displayed Attribute input. The easiest method is to make a stamp with code like this: $StartDate.year = ($StartDate.year-(2*$StartDate.year)-1). That code will flip a positive date to a negative one. Given the first limitation above re displaying BCE dates, you will need to check out that the result is correct. \n* Date.year always returns a positive number, even from a negative date.\n* There are no date-format strings that will show the epoch.\nHandling ancient dates\nDates before the common era now appear in displayed attributes as ""BCE"", and may be edited. Date strings such as ""44 BCE"" are now handled appropriately. ""BCE"" is added to BCE dates in OS short format as well as medium format.\nWhen integers are converted to dates, the conversion is as follows:\n* -35000 to +2500: refers to a year between 35,000 BCE and 2500 CE.\n* otherwise: refers to the number of seconds before or after midnight UTC on 1 Jan 1970.\nMiscellanea about Date-type data\nTinderbox XML documents store dates using ISO 8601 format. Tinderbox also recognises date strings entered as Displayed Attributes or converted from strings in actions when in the ISO 8601 format (e.g. 2008-11-20 16:55:00).\nTwo dates may be subtracted with a result in days even if the result is a string. This helps with tasks like setting $DisplayExpression.\nTinderbox offers numerous date formats to allow non-default representations of date/time both in internal action code (use with format()) or for export (use with value(format())).\nDefault/Empty value\nThe string ""never"" (no date set).\nSorting order\nAscending (later) date/time order; the default value ""never"" always sorts last. When sorting lists of Data-type data always use .sort and not .nsort (the latter gives an incorrect sort result).\nStoring date/time durations\nThis is done using the Interval data type. The maximum unit size in an Interval is a day and it can work for up to 30 days. But generally it is for periods of a day or less as thought of in hours, minutes and seconds.\nDoing date/time calculations with Date and Interval types\nThis is described in discussion of the Interval data type and here. Adding or subtracting Interval data from Date data whose value is ""never"", correctly returns ""never"".\nDate-type System Attributes\nBuilt-in attributes of the date data type are listed below:\n\n\nDate-type System Attributes set via Document Settings\nA number of Document Settings controls set the defaults for Date-type system attributes, directly or indirectly:\n* Text tab: \n** $DisplayedAttributesDateFormat.","Date（日付）\n日付と時刻の文字列です。常に二重引用符で囲む必要があります（これがないレガシーコードは期待通りに動作しなくなる可能性があります）。日付は数値データ型と同様に、数学的な手法で加算/減算/比較が可能です。結果の「文字列」は日付フォーマットコードを使用してフォーマットできます。デフォルト値が指定されていない場合、Date型はデフォルトで「never」という値になります。\n\nDateには、表示されていない場合でも時刻要素が含まれます\n日付が指定されていても時刻が指定されていない場合、秒が表示属性（Displayed Attributes）に表示されないことを除き、時刻は常に現在のシステム時刻にデフォルト設定されます（視覚的な形式は、コロン区切りの使用など、ロケールによって異なる場合があります）。\n\nDateの比較における要素\n時刻は、== または != 演算子が使用される場合を除き、日付の比較に使用されます。アクションコード式のデータ比較についても、基本的な比較演算子と日付比較のセクションを参照してください。そこでのルールはアクションコード式にも当てはまります。日付/時刻のすべての時刻要素を除外する場合を除き、比較では秒が認識されます（以前は、秒は使用されないか、常に00と見なされていました。フル日時のデータで正確な等価テストを行うには、interval()を使用してください）。\nクエリにおける日付 vs 日時の検討については、こちらで議論されています。\n\n日付キーワード\nTinderboxは、アクションコードで作業する際、today、now、yesterday、tomorrow、day、week、month、year、hour、minuteなどの日付キーワードを日付定義のプレースホルダーとして認識します（完全なリストについては日付キーワードのリンクを参照）。""yesterday + 1 week""、""tomorrow + 1 year""、""tomorrow - 2 hours""のような構成も可能です。式全体が1セットの二重引用符の中に配置されることに注意してください。日付プレースホルダーなしで数値のみが指定された場合（例: ""today + 1""）、デフォルトの単位値として「day」が想定されます。つまり、""today + 1 day""と入力された場合と同じになります。日付キーワード文字列を使用した日付の設定/調整の構文の詳細については、こちらを参照してください。\n'now' プレースホルダーは 'today' の代替として使用できます。どちらも時刻要素に現在のシステムクロック時間を使用するため、指定子（designators）と一緒に明示的な時刻を設定できることに注意してください（24時間制の時刻のみを使用してください: ""today 16:00"" または ""tomorrow - 2 days 23:59""）。時刻の設定についての詳細を参照してください。\n\n時刻情報なしでのDate属性の初期化\n時刻指定なしで日付プレースホルダーのみを使用してDate属性を初期設定すると、時刻部分（時:分）がユーザーのローカルOSシステム時刻に設定されることに注意してください。表示属性の値ボックスに時刻のない日付（例: ""21 Aug 2001""）を入力しても、時刻部分はOSのローカル時刻から設定されます。日付指定子を使用して既存の日付を変更しても、日付属性値の時刻部分は決して変更されません。日付の時刻部分は、手動で（再）設定するか、時刻関連のアクションコードを使用することで変更できます。現在の時刻が 17:03:24（午後5時3分24秒）の場合：\n	$StartTime = date(""27/03/2022"") は、2022年3月27日の 17:03:24 という時刻になります（米国ユーザーのみ、日/月の順序が逆になります）。\n 	$StartTime = date(""27/03/2022 00:00:00"") は、2022年3月27日の 00:00:00 という時刻になります。\n同様に、表示属性やGet Infoの値に入力してDate属性を初期化する場合、デフォルト（システム）時刻を使用したくない限り、時/分/秒を明示的に含める必要があります。\n\nOSロケールの影響：Tinderboxは、手動で提供された日付がユーザーの現在のロケール設定と同じ日/月の順序を使用していると想定します。つまり、月/日の順序を使用する米国システムで作業している場合は 2001年7月6日を ""7/6/2011"" と入力し、日/月の順序を使用する英国システムでは ""6/7/2011"" を使用します。他のロケールでも同様です。スラッシュを使用した日付 ""1/7/05"" と、ピリオドを使用した欧州大陸形式（例: ""1.7.05""）はどちらも認識されます。\n\n1桁または2桁の年（例: 10CE）については、コードまたは表示属性の入力で日付を設定する際、年の部分は常に4桁（例: 0010）で入力する必要があります。\n\nユーザーはmacOSのシステム設定の「言語と地域」パネルを確認し、「短い」日付形式が4桁の年を使用していることを確認する必要があります。これを行うには、（地域ごとに）「カスタマイズ...」ボタンをクリックします。「表示」ポップアップは「短い」に設定されているはずです。その下のテキストボックスで年をクリックし、ドロップダウンメニューから2桁または4桁の年を選択できます。ここで4桁の年を選択してください。米国ユーザーは、デフォルトの米国の「短い」日付形式の設定が2桁の年（例: 1765年や1865年などの場合に 10/3/65）を表示することに注意してください。'20090130' のようなすべての数値の逆順日付も使用できますが、広範囲に使用する前に目的の形式をテストしてください。\n\n負の（紀元前）日付の使用\nTinderboxでは、CE/BCE（西暦/紀元前）の境界をまたいでデータを分析できるように、負の日付を許可しています。-1から-2500までの負の整数は、日付に強制変換されると、紀元前（BCE）の年として解釈されます。「負の」日付に関する現在の制限事項：\n* 現在、表示属性ボックスや表示式で、日付が負であることを表示する方法はありません。\n* 負の日付は、大なり/小なり比較を使用してテストすることはできません。\n* 負の日付を表示属性の入力で簡単に設定することはできません。最も簡単な方法は、次のようなコードでスタンプを作成することです：$StartDate.year = ($StartDate.year-(2*$StartDate.year)-1)。このコードは、正の日付を負の日付に反転させます。紀元前の日付の表示に関する上記の最初の制限を考慮すると、結果が正しいかどうかを確認する必要があります。\n* Date.year は、負の日付からでも常に正の数値を返します。\n* 時代（epoch）を表示する日付フォーマット文字列はありません。\n\n古代の日付の処理\n紀元前の日付は表示属性で ""BCE"" と表示されるようになり、編集も可能です。""44 BCE"" のような日付文字列も適切に処理されます。""BCE"" は、OSの短い形式および中間の形式の紀元前の日付に追加されます。\n整数が日付に変換される場合、変換は以下の通りです：\n* -35000 から +2500：紀元前35,000年から西暦2500年までの年を指します。\n* それ以外：1970年1月1日午前0時UTC（協定世界時）の前後の秒数を指します。\n\nDate型データに関する雑記\nTinderboxのXMLドキュメントは、ISO 8601形式を使用して日付を保存します。Tinderboxは、表示属性として入力された日付文字列や、アクションで文字列から変換された日付文字列がISO 8601形式（例: 2008-11-20 16:55:00）である場合も認識します。\n2つの日付を減算すると、結果が文字列であっても「日」単位の結果が得られます。これは、$DisplayExpression の設定などのタスクに役立ちます。\nTinderboxは、内部アクションコード（format()を使用）またはエクスポート（value(format())を使用）の両方で、デフォルト以外の表現を可能にする多数の日付フォーマットを提供しています。\n\nデフォルト/空の値\n文字列 ""never""（日付が設定されていない状態）。\n\nソート順\n昇順（後の日時順）。デフォルト値の ""never"" は常に最後にソートされます。Date型データのリストをソートするときは、常に .sort を使用し、.nsort は使用しないでください（後者は誤ったソート結果をもたらします）。\n\n日時の期間の保存\nこれは Interval データ型を使用して行われます。Interval の最大単位サイズは「日」で、最大30日まで機能します。しかし、一般的には、時間、分、秒として考えられる1日以下の期間に使用されます。\n\nDate型とInterval型を使用した日時計算\nこれについては、Interval データ型の説明とこちらで詳しく説明されています。値が ""never"" である Date データに Interval データを加算または減算すると、正しく ""never"" が返されます。\n\nDate型システム属性\n日付データ型の組み込み属性は以下の通りです。\n\nドキュメント設定を介して設定されるDate型システム属性\nいくつかのドキュメント設定コントロールは、直接的または間接的にDate型システム属性のデフォルトを設定します：\n* Text（テキスト）タブ： \n** $DisplayedAttributesDateFormat"
Dictionary-Type Attributes,"Dctionary\n A Dictionary attribute replaces like the older Tinderbox feature of lookup tables, as a list of paired keys with values: key:value; \nThe key part comes first with a terminating colon. The value part follows, terminated by a semi-colon. White space handling in key:value pairs is described below.\nDictionaries are faster to construct, and large dictionaries are far faster to check, than lookup tables. Dictionaries are not generally intended for handing large/complex values or for values including punctuation and symbols. A Dictionary may be considered better for tasks previously configured using look-up lists.\nLike other attribute types, a Dictionary follows normal rules of scope and inheritance. A note using a prototype with a Dictionary holding data, will inherit that data dictionary. Similar to a Set type, a Dictionary does not allow duplicate keys, but multiple keys may use the same value.\nA key may have multiple values; this can be either []-enclosed List-type or {}-enclosed Dictionary-type data. For example, the dictionary:\n	{Tinderbox: 1;Storyspace: {Editor: 2; Reader:3}} \ncontains two elements. The first has a key of ""Tinderbox"" and a value of 1. The second has a key of ""Storyspace"" and the value that is itself a dictionary, {Editor: 2; Reader:3}.\nDictionary key:value syntax\nA dictionary collects pairs of strings separated by a colon. The first string is the key, and the second string is the value. The dictionary() operator creates a dictionary (in the current note), here with 3 such key:value pairs. The first form is best practice:.\n	$MyDictionary={cat:animal; dog:animal; rock: mineral}; \n	$MyDictionary=dictionary(""cat:animal; dog:animal; rock: mineral""); \nThe key ""cat"" has the value ""animal"", while the key ""rock"" has the value ""mineral"".\nAlthough it is still possible, via legacy support, to populate a directory by passing a dictionary-formatted list as a quoted string to a Dictionary-type attribute, this is deprecated in favour of the {} method, or using the dictionary() operator is explicit and indicates intent unambiguously when parsed by Tinderbox. See dictionary() for usage.\nCase-sensitivity\nA key is case-sensitive and must be unique to the dictionary; the value may be the same as values for different keys within the current dictionary. Rather like the Set data type, duplicates are weeded. If a new key:pair is added to a dictionary and the key (case-sensitively) already exists, the existing value (only) for that key is updated to use the value from the new pair.\n	$MyDictionary = dictionary(""cat:animal; dog:animal; rock: mineral""); \n	$MyDictionary = $MyDictionary + ""cat:mammal""; \nNow, the value of key ""cat"" becomes ""mammal"" and the older value is lost.\nQuoting of keys and values\nFrom v11.5.0, the key is always treated as a string, and does not require to be quoted: quoted keys, e.g. in older code, will still work correctly. If the value of that key is a string, it should be quoted. In addiction, the value must be quoted if the string value contains any of the following: {}():// or quotation marks.\nUse of whitespace, symbols, quotes, etc., with keys & values\nAny whitespace either side of a colon (:), or semi-colon (;), or at beginning or end of dictionary data is ignored. As the colon (:) and semi-colon (;) characters are used as delimiters in the stored Dictionary data, they should also not be used within key names or values.\nThe expectation is that keys and values will be simple strings or numbers, so avoid use of characters like punctuation as you may experience unexpected results; additionally avoid using parentheses (), square [] or curly {} brackets, backward \ and forward / slashes, single/double quotes or commas.\nA good rule of thumb is to think hard if using other than A-za-z0-9 or underscore/hyphen/period (the period might be needed for a decimal number value).\nAdding key:value pairs\nTo add to a new key:value pair, use addition, as with Lists and Sets…\n	$MyDictionary = $MyDictionary + {apple:plant}; \n	$MyDictionary += {apple:plant}""; \nadds they key ""apple"" and associates it with the value ""plant"". If the key was already found in the dictionary, its value is replaced by the new value. If the key was not found in the dictionary, both the new key and the new value are added.\nAs well as using a literal value, the key (and value) to be added can be give as an attribute value or variable:\n	$MyString = ""apple:plant""; $MyDictionary += $MyString; \n	var:string vKey = ""apple:plant""; $MyDictionary += vKey; \nDeleting keys (implicitly key:value pairs)\nEntries can be deleted from a dictionary by subtracting the key:\n	$MyDictionary = dictionary(""dog:animal; cat:animal; rock:mineral""); \n	$MyDictionary = $MyDictionary - ""dog"";  // gives ""cat:animal; rock:mineral"" \nor in newer form:\n	$MyDictionary -= ""dog"";  // gives ""cat:animal; rock:mineral"" \nBe aware that setting an empty value for a key doesn't delete the key:\n	$MyDictionary[somekey] = """"; \nleaves the key 'somekey' with no value, which is not encouraged (q.v. below).\nAs well as using a literal value, the key to be removed can be give as an attribute value or variable:\n	$MyString = ""dog""; $MyDictionary -= $MyString; \n	var:string vKey = ""dog""; $MyDictionary -= vKey; \nIt is not possible to subtract a list of keys. Instead, such a list must be iterated as a succession of individual key deletions. The only exception to this is if all keys are to be deleted, in which case set the dictionary object (attribute or variable) to the default value to delete existing data:\n	vDict=; $MyDictionary=;  \nChanging the value of a key\nNew values may be assigned to specific dictionary keys.\n	$MyDictionary[apple] = ""pie"" \nAdds the key ""apple"" to $MyDictionary with the value ""pie"". If the dictionary previously contained a value for ""apple"", it is replaced by ""pie""; if not, a new key and a new value are added to the dictionary. Or, use .add() can be used:\n 	$MyDictionary.add(""apple"",""pie""); \nNote that the += and -= operators are not currently available for changes to dictionary (numerical) values of the form\n	$MyDictionary[key] += 1; WRONG!\nInstead, use the conventional form:\n	$MyDictionary[key] = $MyDictionary[""key""] + 1; \nDeleting the (single) value of a key\nIdeally in such a case remove the key. However is possible to delete a key's value, by setting it to an empty string """" (or reading from a stored value that is such). To set the value of key 'apple' to """":\n	$MyDictionary[apple] = """" \nGenerally, the expectation is that a key has an actual value.\nKeys with multi-item values are supported using [] or {} notation\nDictionary key values can be multi-valued using either the new [] (list or set) or {} (dictionary) notation. This holds for creating dictionaries or setting key values. When retrieving a multi-value result pass the data to an appropriately type attribute or variable. The data can then be accessed using appropriate key or list address syntax. Examples of nested multi-value values:\n	$MyDictionary={cat:animal; dog:animal; rock:{granite:mineral;basalt:mineral}}; \n	$MyDictionary={cat:animal; dog:{terrier:dog;labrador:dog}; rock:mineral}; \nLegacy behaviour: Prior to v9.6.0, a value could not contain more than one value The value for a key 'pie' might reasonably be apple, lemon and quince. Whilst it was possible to define a dictionary like this:\n	$MyDictionary[""pie""] = ""apple;lemon;quince"" \n… the fact a semi-colon is used as both a list delimiter (within the value) and as a key:value pair delimiter, means Tinderbox currently does not know how to parse this; work is in hand to support multi-item value, i.e. lists.\nTemporary note. Presently generating a dictionary with nested multi-values (list/dictionary) may be possible only if using literal string values but not if using variables/attribute values. This is likely a by-product of the newer [ ] and { } data type notations and subject to later changes/fixes.\nMerging Dictionaries\nDictionaries may be merged by adding them.\n	$MyDictionary = $MyDictionary+""apple:plant"" \nadds they key ""apple"" and associates it with the  value ""plant"". If the key was already found in the dictionary, its value is replaced by the new value. If the key was not found in the dictionary, both the new key and the new value are added.\nIt is possible to add two dictionaries.\n	$MyNewDictionary = $MyDictionary+$MyOtherDictionary \nNote that if the dictionaries share (case-sensitive) keys that have differing values, the values from the last-added, therefore those in $MyDictionary, will replace those in $MyDictionary. Thus:\n	$MyFirstDictionary = dictionary(""apple:fruit; granite:mineral""); \n	$MyOtherDictionary =  dictionary(""pear:fruit; granite:rock""); \n	$MyDictionary = $MyFirstDictionary + $MyOtherDictionary; \nMyDictionary now contains ""granite: rock; pear: fruit; apple: fruit"" \nNote the order of dictionary items is re-ordered, reinforcing the point that additions/subtraction of dictionary data may alter item order, and which the user does not control. It is not possible to:\n* subtract a dictionary from a dictionary\n* subtract lists of keys\n* subtract individual values\n"""", so if using a default key, it is a good idea to ensure the source attribute/variable has a default value.\n-->\nDictionaries lack the 'default' key used by look-up lists \nUser of look-up lists with list-type data might assume the same notion holds for Dictionary-type: it does not! It is still possible to define a 'default' key but using it requires a little extra code. Whilst it is possible to check if a key exists with Dictionary.contains(), it may be more useful to check for a default empty ("""") value being returned. For instance, instead of, in a .each(aKey){} loop, where you might code:\n	$MyString = $MyDictionary[aKey]; \nconsider (and assuming a 'default' key/value exists):\n	if($MyDictionary[aKey]){$MyString = $MyDictionary[aKey];}else{$MyString = $MyDictionary[default];}; \nor:\n	if($MyDictionary.contains(aKey)){$MyString = $MyDictionary[aKey];}else{$MyString = $MyDictionary[default];}; \nBut, the key point is that is a default response is needed, the user must (a) define the 'default' key:vale pair and (b) add the code to invoke it. More code-savvy users may choose to encapsulate this in a user function.\nDictionary and values()\nYou can get the values of a Dictionary, but you cannot look up a key that corresponds to a given value. Remember, multiple keys may same value. Therefore, using values() with dictionaries is not recommended as this returns all the unique key:pair values as opposed to only keys or only values.\nIterating Dictionaries\nUse Dictionary.keys to get a list of the keys and then iterate that list using list.each().\nDefault/Empty value\nIf a requested key is not defined, or the key has no value, an empty string is returned.\nDictionary sorting\nNot applicable, as Dictionaries cannot be sorted. As a Dictionary is addressed via a key value rather than a list offset, the stored order for keys is moot. By observation, a Dictionary is generally stored in key lexical sort order but this should not be assumed to always be the case.\nWhilst a Dictionary itself cannot be sorted, it is possible to make a list of the keys then sort and iterate that list. for example:\n		var:list vKeyList = $MyDictionary.keys;\n	vKeyList = vKeyList.sort; // Use .nsort if keys are numbers\n	var:list vSortResults; // Use List so it stays sorted\n	vKeyList.each(aKey){\n		vSortResults+=(aKey+"" | ""+$MyDictionary[aKey]);\n	};\n	//Test\n	//$Text = vSortResults.format(""\n""); \nNote that the initial sort could be lexical (.sort), lexical case insensitive (.isort) or numerical (.nsort)\nAdditional Dictionary definition mark-up\nDictionaries may be written by enclosing them in braces, for example a dictionary with two key:value pair elements:\n	$MyDictionary = dictionary({Dog: animal; Crocus: plant}); \nThe use of the braces removes the need to use quotes around string values.\nThis new form of Dictionary-type data allows for nesting; for example, the dictionary\n	{Tinderbox: 1;Storyspace: {Editor: 2; Reader:3}} \ncontains two elements. The first has a key of ""Tinderbox"" and a value of 1. The second has a key of ""Storyspace"" and the value that is itself a dictionary, {Editor: 2; Reader:3} .\nThe dictionary .add() and .extend() operators now take a single argument — a dictionary of elements which will replace or extend the current elements.\nDictionary-type System Attributes\nBuilt-in attributes of the date data type are listed below:","Dictionary（辞書）\nDictionary（辞書）属性は、従来のTinderboxの機能であるルックアップテーブルに代わるもので、キーと値のペアのリスト（key:value;）として扱われます。\nキー部分が最初に来て、末尾にコロン（:）が付きます。その後に値の部分が続き、末尾はセミコロン（;）で終わります。キー：値のペアにおける空白の処理については後述します。\n辞書はルックアップテーブルよりも作成が速く、大規模な辞書の検索も非常に高速です。辞書は一般的に、大規模で複雑な値や、句読点や記号を含む値を扱うようには設計されていません。以前ルックアップリストを使用して構成していたタスクには、辞書の方が適している場合があります。\n他の属性タイプと同様に、辞書はスコープと継承の通常のルールに従います。辞書にデータを保持しているプロトタイプを使用するノートは、そのデータ辞書を継承します。Set（セット）型と同様に、辞書は重複するキーを許可しませんが、複数のキーが同じ値を持つことは可能です。\nキーは複数の値を持つことができます。これは、[]で囲まれたList（リスト）型、または{}で囲まれたDictionary（辞書）型のデータのいずれかになります。例えば、次の辞書：\n	{Tinderbox: 1;Storyspace: {Editor: 2; Reader:3}} \nには2つの要素が含まれています。最初の要素はキーが ""Tinderbox"" で値が 1 です。2番目の要素はキーが ""Storyspace"" で、値自体が辞書 {Editor: 2; Reader:3} になっています。\n\nDictionary key:value syntax（辞書のキー：値の構文）\n辞書は、コロンで区切られた文字列のペアを収集します。最初の文字列がキーで、2番目の文字列が値です。dictionary() オペレーターは（現在のノート内に）辞書を作成します。以下は3つのキー：値ペアを持つ例です。最初の形式がベストプラクティスです。\n	$MyDictionary={cat:animal; dog:animal; rock: mineral}; \n	$MyDictionary=dictionary(""cat:animal; dog:animal; rock: mineral""); \nキー ""cat"" の値は ""animal""、キー ""rock"" の値は ""mineral"" となります。\nレガシーサポートにより、引用符で囲まれた辞書形式の文字列をDictionary型属性に渡して値を設定することも可能ですが、この方法は非推奨です。代わりに {} メソッドを使用するか、Tinderboxが解析する際に意図が明確になる dictionary() オペレーターを使用することが推奨されます。使用方法については dictionary() を参照してください。\n\nCase-sensitivity（大文字と小文字の区別）\nキーは大文字と小文字を区別し、辞書内で一意である必要があります。値は、現在の辞書内の異なるキーの値と同じであっても構いません。Setデータ型と同様に、重複は取り除かれます。新しいキー：値ペアが辞書に追加され、そのキー（大文字小文字を区別して）が既に存在する場合、そのキーの既存の値のみが新しいペアの値に更新されます。\n	$MyDictionary = dictionary(""cat:animal; dog:animal; rock: mineral""); \n	$MyDictionary = $MyDictionary + ""cat:mammal""; \nこれで、キー ""cat"" の値は ""mammal"" になり、古い値は失われます。\n\nQuoting of keys and values（キーと値の引用符による囲み）\nv11.5.0から、キーは常に文字列として扱われるため、引用符で囲む必要はありません（古いコードなどで引用符で囲まれたキーも、引き続き正しく動作します）。そのキーの値が文字列である場合は、引用符で囲む必要があります。さらに、文字列の値に {}():// や引用符が含まれている場合は、必ず引用符で囲まなければなりません。\n\nUse of whitespace, symbols, quotes, etc., with keys & values（キーと値における空白、記号、引用符などの使用）\nコロン（:）やセミコロン（;）の前後、または辞書データの最初や最後にある空白は無視されます。コロン（:）とセミコロン（;）は、格納された辞書データ内で区切り文字として使用されるため、キー名や値の中では使用しないでください。\nキーと値は単純な文字列または数値であることが想定されているため、句読点などの文字を使用すると予期しない結果が生じる可能性があります。さらに、括弧 ()、角括弧 []、中括弧 {}、バックスラッシュ \、スラッシュ /、シングル/ダブルクォート、カンマの使用も避けてください。\n経験則として、A-Za-z0-9、アンダースコア、ハイフン、ピリオド（ピリオドは小数値に必要かもしれません）以外の文字を使用する場合は、慎重に検討してください。\n\nAdding key:value pairs（キー：値ペアの追加）\n新しいキー：値ペアを追加するには、ListやSetと同様に加算（+）を使用します。\n	$MyDictionary = $MyDictionary + {apple:plant}; \n	$MyDictionary += {apple:plant}; \nこれにより、キー ""apple"" が追加され、値 ""plant"" が関連付けられます。キーが既に辞書に存在していた場合、その値は新しい値に置き換えられます。キーが辞書になかった場合は、新しいキーと新しい値の両方が追加されます。\nリテラル値を使用するだけでなく、追加するキー（および値）を属性値や変数として指定することもできます。\n	$MyString = ""apple:plant""; $MyDictionary += $MyString; \n	var:string vKey = ""apple:plant""; $MyDictionary += vKey; \n\nDeleting keys (implicitly key:value pairs)（キー（暗黙的にキー：値ペア）の削除）\nキーを減算することで、辞書からエントリを削除できます。\n	$MyDictionary = dictionary(""dog:animal; cat:animal; rock:mineral""); \n	$MyDictionary = $MyDictionary - ""dog"";  // ""cat:animal; rock:mineral"" になる \nあるいは新しい形式で：\n	$MyDictionary -= ""dog"";  // ""cat:animal; rock:mineral"" になる \nキーに空の値を設定してもキーは削除されないことに注意してください。\n	$MyDictionary[somekey] = """"; \nこれはキー 'somekey' を値なしの状態で残すだけであり、推奨されません（後述参照）。\nリテラル値を使用するだけでなく、削除するキーを属性値や変数として指定することもできます。\n	$MyString = ""dog""; $MyDictionary -= $MyString; \n	var:string vKey = ""dog""; $MyDictionary -= vKey; \nキーのリストを一度に減算することはできません。代わりに、個別のキー削除を順次繰り返す必要があります。唯一の例外はすべてのキーを削除する場合で、その場合は辞書オブジェクト（属性または変数）をデフォルト値に設定して既存のデータを削除します。\n	vDict=; $MyDictionary=; \n\nChanging the value of a key（キーの値の変更）\n辞書の特定のキーに新しい値を割り当てることができます。\n	$MyDictionary[apple] = ""pie"" \n$MyDictionary にキー ""apple"" を追加し、値 ""pie"" を設定します。辞書に既に ""apple"" の値が含まれていた場合は ""pie"" に置き換えられ、含まれていなかった場合は新しいキーと値が追加されます。または、.add() を使用することもできます。\n 	$MyDictionary.add(""apple"",""pie""); \n現時点では、$MyDictionary[key] += 1; のような形式で辞書の（数値）値を変更するために += や -= オペレーターを使用することはできません。\n代わりに、従来の形式を使用してください。\n	$MyDictionary[key] = $MyDictionary[""key""] + 1; \n\nDeleting the (single) value of a key（キーの（単一の）値の削除）\n理想的には、その場合はキー自体を削除してください。しかし、値を空の文字列 """" に設定することで（あるいはそのような値を読み込むことで）、キーの値を削除することは可能です。キー 'apple' の値を """" に設定するには：\n	$MyDictionary[apple] = """" \n一般的に、キーには実際の値があることが期待されます。\n\nKeys with multi-item values are supported using [] or {} notation（[] または {} 記法を使用した複数項目値のサポート）\n辞書のキーの値は、新しい []（リストまたはセット）または {}（辞書）記法を使用して、複数の値を持つことができます。これは辞書の作成時やキー値の設定時に適用されます。複数項目の結果を取得するときは、適切な型の属性または変数にデータを渡してください。その後、適切なキーまたはリストのアドレス構文を使用してデータにアクセスできます。入れ子になった複数項目値の例：\n	$MyDictionary={cat:animal; dog:animal; rock:{granite:mineral;basalt:mineral}}; \n	$MyDictionary={cat:animal; dog:{terrier:dog;labrador:dog}; rock:mineral}; \nレガシーな挙動：v9.6.0以前は、値に複数の項目を含めることはできませんでした。例えば、キー 'pie' の値が apple, lemon, quince である場合、以前は次のように定義できたかもしれません。\n	$MyDictionary[""pie""] = ""apple;lemon;quince"" \n…しかし、セミコロンがリストの区切り文字（値の内部）とキー：値ペアの区切り文字の両方に使用されているため、Tinderboxは現在これを正しく解析できません。複数項目の値（リストなど）をサポートするための作業が進められています。\n一時的な注意：現在、入れ子になった複数項目値（リスト/辞書）を持つ辞書の生成は、リテラル文字列値を使用する場合のみ可能で、変数や属性値を使用する場合は不可能な場合があります。これは新しい [ ] および { } データ型表記による副作用の可能性があり、今後の変更や修正の対象となります。\n\nMerging Dictionaries（辞書の結合）\n辞書は加算することで結合できます。\n	$MyDictionary = $MyDictionary+""apple:plant"" \nこれによりキー ""apple"" が追加され、値 ""plant"" が関連付けられます。キーが既に辞書に存在していた場合、その値は新しい値に置き換えられます。\n2つの辞書を加算することも可能です。\n	$MyNewDictionary = $MyDictionary+$MyOtherDictionary \n加算される辞書同士で同じキー（大文字小文字を区別）を共有し、異なる値を持っている場合、最後に追加された方の値（この場合は $MyOtherDictionary のもの）が $MyDictionary の値を上書きすることに注意してください。\n	$MyFirstDictionary = dictionary(""apple:fruit; granite:mineral""); \n	$MyOtherDictionary =  dictionary(""pear:fruit; granite:rock""); \n	$MyDictionary = $MyFirstDictionary + $MyOtherDictionary; \nMyDictionary には ""granite: rock; pear: fruit; apple: fruit"" が含まれるようになります。\n辞書項目の順序が並べ替えられることに注意してください。辞書データの追加や削除によって項目の順序が変わる可能性があり、ユーザーがそれを制御することはできません。以下の操作は不可能です。\n* 辞書から辞書を引く\n* キーのリストを引く\n* 個別の値を引く\n\nDictionaries lack the 'default' key used by look-up lists（辞書にはルックアップリストで使用される「default」キーがありません）\nリスト型データでルックアップリストを使用しているユーザーは、Dictionary型でも同じ概念が通用すると考えるかもしれませんが、そうではありません！「default」というキーを定義することは可能ですが、それを使用するには少し追加のコードが必要です。Dictionary.contains() でキーが存在するかどうかを確認できますが、デフォルトの空（""""）の値が返されるかどうかをチェックする方が便利な場合があります。例えば、.each(aKey){} ループ内で次のように記述する代わりに：\n	$MyString = $MyDictionary[aKey]; \n（「default」キーと値が存在すると仮定して）以下を検討してください：\n	if($MyDictionary[aKey]){$MyString = $MyDictionary[aKey];}else{$MyString = $MyDictionary[default];}; \nまたは：\n	if($MyDictionary.contains(aKey)){$MyString = $MyDictionary[aKey];}else{$MyString = $MyDictionary[default];}; \n重要な点は、デフォルトの応答が必要な場合、ユーザー自身が (a) 「default」キーと値のペアを定義し、(b) それを呼び出すためのコードを追加する必要があるということです。コードに詳しいユーザーは、これをユーザー関数にカプセル化することを選択するかもしれません。\n\nDictionary and values()（辞書と values()）\n辞書の「値」を取得することはできますが、特定の値に対応する「キー」を逆引きすることはできません。複数のキーが同じ値を持つ可能性があることを忘れないでください。したがって、辞書に対して values() を使用することは推奨されません。なぜなら、これはキーのみ、あるいは値のみを返すのではなく、一意の「キー：値」ペアをすべて返すためです。\n\nIterating Dictionaries（辞書の反復処理）\nDictionary.keys を使用してキーのリストを取得し、そのリストを list.each() を使用して反復処理します。\n\nDefault/Empty value（デフォルト/空の値）\n要求されたキーが定義されていない場合、またはキーに値がない場合は、空の文字列が返されます。\n\nDictionary sorting（辞書のソート）\n辞書はソートできないため、該当しません。辞書はリストのオフセットではなくキー値によってアドレス指定されるため、キーが格納される順序は重要ではありません。観察によれば、辞書は一般にキーの辞書順（レキシカル）で格納されますが、常にそうであるとは限りません。\n辞書自体をソートすることはできませんが、キーのリストを作成し、そのリストをソートして反復処理することは可能です。例えば：\n		var:list vKeyList = $MyDictionary.keys;\n	vKeyList = vKeyList.sort; // キーが数値の場合は .nsort を使用\n	var:list vSortResults; // ソート状態を維持するために List を使用\n	vKeyList.each(aKey){\n		vSortResults+=(aKey+"" | ""+$MyDictionary[aKey]);\n	};\n最初のソートは、辞書順（.sort）、大文字小文字を区別しない辞書順（.isort）、または数値順（.nsort）のいずれかを選択できます。\n\nAdditional Dictionary definition mark-up（追加の辞書定義マークアップ）\n辞書は中括弧で囲んで記述することができます。例えば、2つのキー：値ペアを持つ辞書は次のようになります。\n	$MyDictionary = dictionary({Dog: animal; Crocus: plant}); \n中括弧を使用すると、文字列値を引用符で囲む必要がなくなります。\nこの新しいDictionary型データの形式では、入れ子（ネスティング）が可能です。例えば、次の辞書：\n	{Tinderbox: 1;Storyspace: {Editor: 2; Reader:3}} \nには2つの要素が含まれています。最初の要素はキーが ""Tinderbox"" で値が 1 です。2番目の要素はキーが ""Storyspace"" で、値自体が辞書 {Editor: 2; Reader:3} になっています。\n辞書の .add() および .extend() オペレーターは、単一の引数（現在の要素を置換または拡張する要素の辞書）を取るようになりました。\n\nDictionary-type System Attributes（Dictionary型のシステム属性）\n日付データ型の組み込み属性は以下の通りです："
Email-Type Attributes,"Email\nAn Email attribute data type is offered to address activities related to parsing/sorting email data.\nAn email address string, e.g. jdoe@example.com. If no default value is specified, an Email type defaults to an empty string. Emails are not delimited (i.e. quotes are not required).\nEmail attributes behave like string attributes, but with a special behaviour when displayed in a note's displayed attributes table. There, Email-type attributes show an envelope icon before the attribute value. Pressing the icon opens a draft email to that address using the default email client using the notes text as the draft content.\nMore precisely, pressing the button composes a message, whose body is the $Text of the note, and opens that message in the default email client (e.g., Apple Mail), from which it might be sent to the address that appears in $Email. There is no validation that the value in $Email is correctly formed.\nDefault/Empty value\nAn empty string.\nSorting order\nAs for String Data Type.\nEmail-type System Attributes\nBuilt-in attributes of the Email data type are listed below:",電子メール\n電子メール属性データ タイプは、電子メール データの解析/並べ替えに関連するアクティビティに対処するために提供されます。\n電子メール アドレス文字列。jdoe@example.com。デフォルト値が指定されていない場合、電子メール タイプのデフォルトは空の文字列です。電子メールは区切られていません (つまり、引用符は必要ありません)。\n電子メール属性は文字列属性と同様に動作しますが、ノートの表示属性テーブルに表示される場合は特別な動作をします。ここでは、電子メール タイプの属性には、属性値の前に封筒のアイコンが表示されます。アイコンを押すと、デフォルトの電子メール クライアントを使用して、メモ テキストを下書きコンテンツとして使用して、そのアドレスに下書き電子メールが開きます。\nより正確には、ボタンを押すと、本文がメモの $Text であるメッセージが作成され、そのメッセージがデフォルトの電子メール クライアント (Apple Mail など) で開かれ、そこから $Email に表示されるアドレスに送信される可能性があります。$Email の値が正しく形成されているかどうかの検証はありません。\nデフォルト/空の値\n空の文字列。\n並べ替え順序\n文字列データ型については。\n電子メールタイプのシステム属性\n電子メール データ型の組み込み属性を以下に示します。
File-Type Attributes,"File\nA path to a file. When setting this type of attribute a file selection dialog is shown instead of a text box. The selected file is entered as the attribute value for that note. If no default value is specified, a File type defaults to an empty string.\nThe path stored is in POSIX form (forward slash delimited) and is the full local path to the file or folder.\nWhen files from the user's directory are dropped into Tinderbox or into a file attribute, Tinderbox uses the tilde (~) abbreviation to represent the path to the user's directory. This should make it easier to share one Tinderbox document across several machines, each of which share files in common locations (e.g. Dropbox) but which have different user names.\nWhen displayed in a note's displayed attributes table, Find-type attributes show a folder icon before the attribute value. Pressing the icon opens that attribute's stored OS file path (if any) for a file, using the in the default app as determined by Finder, or for a folder it opens Finder.\nDefault/Empty value\nAn empty string.\nSorting order\nAs for String Data Type.\nFile-type System Attributes\nBuilt-in attributes of the file data type are listed below:",ファイル\nファイルへのパス。このタイプの属性を設定すると、テキスト ボックスの代わりにファイル選択ダイアログが表示されます。選択したファイルがそのノートの属性値として入力されます。デフォルト値が指定されていない場合、ファイル タイプのデフォルトは空の文字列です。\n保存されるパスは POSIX 形式 (スラッシュ区切り) であり、ファイルまたはフォルダーへの完全なローカル パスです。\nユーザーのディレクトリのファイルが Tinderbox またはファイル属性にドロップされると、Tinderbox はチルダ (~) の省略形を使用してユーザーのディレクトリへのパスを表します。これにより、1 つの Tinderbox ドキュメントを複数のマシン間で共有することが容易になります。各マシンは共通の場所 (Dropbox など) にあるファイルを共有しますが、ユーザー名は異なります。\nノートの表示属性テーブルに表示される場合、検索タイプの属性には属性値の前にフォルダー アイコンが表示されます。アイコンを押すと、その属性に保存されているファイルの OS ファイル パス (存在する場合) が開き、Finder によって決定されたデフォルト アプリ内の を使用するか、フォルダーの場合は Finder が開きます。\nデフォルト/空の値\n空の文字列。\n並べ替え順序\n文字列データ型については。\nファイルタイプのシステム属性\nファイル データ タイプの組み込み属性を以下に示します。
Font-Type Attributes,"Font\nThe attribute data type of 'font' represents a string defining a font name.\nSome pre-existing system attributes, such as $NameFont have been re-classed from 'string' to 'action' type.\nThis data type is not available for user attributes. \nDefault/Empty value\nAn empty string.\nSorting order\nAs for String Data Type.\nFont-type System Attributes\nBuilt-in attributes of the file data type are listed below:\n\n\nFont-type System Attributes set via Document Settings\nA number of Document Settings controls set the defaults for Font-type system attributes, directly or indirectly:\n* Text tab: \n** $TextFont.\n* Maps tab: \n** $NameFont.",フォント\n'font' の属性データ型は、フォント名を定義する文字列を表します。\n$NameFont などの一部の既存のシステム属性は、「文字列」タイプから「アクション」タイプに再分類されました。\nこのデータ型はユーザー属性には使用できません。\nデフォルト/空の値\n空の文字列。\n並べ替え順序\n文字列データ型については。\nフォントタイプのシステム属性\nファイル データ タイプの組み込み属性を以下に示します。\n\n\nドキュメント設定で設定されたフォントタイプのシステム属性\n多くのドキュメント設定コントロールは、フォント タイプのシステム属性のデフォルトを直接的または間接的に設定します。\n* テキストタブ:\n** $TextFont。\n*「マップ」タブ:\n** $NameFont。
Interval-Type Attributes,"Interval\nThe attribute type, Interval, represents time intervals and durations. The general designed/expected usage is for durations shorter than an hour, but intervals of hours or even days are possible—see below.\nReflecting the basic expectation, the default value is a string ""00:00"" representing zero minutes and zero seconds. For example, the interval value\n	01:30 \nrepresents one minute and thirty seconds whilst\n	02:01:00 \nrepresents two hours, one minute and zero seconds. Note the need to include the seconds element (in both input and output) to differentiate the NN:NN form as mm:ss and not hh:mm.\nCreating Interval-type data\nThis is achieved using the interval() operator. The input is a string (see interval(dataStr)). Note that minute and second values do not need zero-padding, inputting ""4:2"" results in a displayed/exported value of ""04:02"".\nIf a time element is supplied is larger than its normal count (e.g. more than 59 minutes or seconds, the input is re-parsed into normally sized units. So ""90:70"" mm:ss will get parsed as ""01:31:10"". This effect is useful if creating inputs from dynamic values and avoids the need to re-parse number before input.  This applies to hours, minute and seconds inputs.\nWhen reading/copying Interval type data, it is always in String form, i.e. ""22:09"", even though the Interval data is stored internally (in the running app) in a different form. As a result, an Interval can be passed directly to a string attribute without needing modification. So, adding an interval to a string:\n	""The answer is:"" + $MyInterval returns a string.\nCreating an Interval from Dates\nA variant of interval() enables returning the time between two Date-type objects as an Interval: see interval(startDate,endDate).\nUsing intervals of an hour or more\nAlthough originally intended for short (sub 1 hour) durations, Intervals can accept hour or day inputs. For long intervals note that hours and days are accepted units: year or month scope inputs are not understood by the interval parser.\nThus the duration\n	01:01:00 \nrepresents a duration of one hour, one minute, and thirty seconds. The seconds cannot be omitted, even if '00' as the above written as ""01:01"" would be parsed as one minute and one second. Only ""01:01:00"" ensures the hour element is detected correctly.\nDays are defined using the word 'day(s)':\n	2 days 01:00:00 represents 49 hours\nDuration components larger than a day (of 24 hours), e.g. months or years, are not supported, though is is possible to use large day values:\n	62 days 01:30:10\nrepresenting an interval of over two months' duration. The maximum length of an interval but it is not advised to exceed 1 year (but specified in days, i.e. 365 days) but ideally intervals are used for a few days or less. If the duration of the interval is desired in whole days only, use normal Date-type arithmetic and store the duration as a Number-type.\nFormatting Interval data\nUsing, Interval.format() only accepts a limited range—two choices—of formatting string options, i.e. not the full range of Date formats. The displayed format of Intervals, in Displayed Attributes and Get Info cannot be modified. If passing the data for use elsewhere, e.g. for export, the string representation can be modified using normal String manipulation operators.\nNegative values\nAn interval may have negative duration, ""-05:30"":\n	-05:30 \nrepresents a negative duration of 5 minutes and 30 seconds. This can be useful when doing short duration date arithmetic (as below).\nUse in Date arithmetic\nIntervals may be added or subtracted from Date-type attributes or variables. They may multiplied or divided by constants or numeric attributes, and may be compared for equality using == and != or for magnitude using .\nFor directly altering a Date's time element, the time() operator is normally a simpler and more convenient choice.\nNote: subtracting two dates does not currently return an interval; rather, it returns the number of days between the two dates in accordance with pre-existing Date-type attribute behaviour. To get the interval between two Dates, use the interval(startDate,endDate) operator syntax. Thus to get the interval between the $StartDate of note ""Session 1' and $StarDate of ""Session 2"":\n	$MyInterval = interval($StartDate(""Session 1""),$StartDate(""Session 2"")); \nIntervals can be added to/subtracted from Dates. If $MyInterval is ""-05:30"" and $MyDate is 24/10/2022 12:00:00 (midday on 24 October 2022):\n	$MyDate = $MyDate + $MyInterval; \nresults in $MyDate being 24/10/2022 11:54:30. By accepting negative intervals the same action code can deal with positive and negative durations. So to find the number of (whole) minutes in the interval:\n	$MyNumberOfMinutes = minutes($MyDate,$MyDate+$MyInterval); \nA more generalised approach to the last:\n	$MyNumberOfMinutes = minutes(date(""now""),date(""now"")+$MyInterval); \nHere minutes are tested but the method could test days, hours or seconds (not bigger units as Interval data is usually a few days at biggest and generally less than a whole day).\nAlternative syntax\nSome alternative syntax is supported, including an 'h' suffix/separator for hours and 'd' for days. Thus the duration\n	1h30 \nrepresents one hour and thirty minutes, whilst:\n	1 day 01:00:00 represents 25 hours\n	2d2h30  represents two days, two hours and 30 minutes\nwhilst:\n	2d5 \nis treated as 2 days, 5 hours, as hours is the next smaller duration measure than days.\nThe 'd' marker is always resaved/displayed as 'day(s)':\n	2d5 is resaved as ""2 days 05:00:00\n	1d5 is resaved as ""1 day 05:00:00\nNote that whilst 'm' and 's' suffixes are understood for minutes and seconds; the 's' is superfluous anyway as it is always the last segment if used. If a duration is entered as ""3m20"" Tinderbox will re-save the value in the default format of ""03:20"" so use of 'm' is deprecated. Thus a duration entered as follows will be understood:\n	1h30m10s \nbut it is treated as one hour, thirty minutes and 10 seconds but will be re-saved as:\n 	1:30:10 \nNote slight variations in accepted abbreviations compared to pre-existing Date-type attribute date arithmetic usage.\nUse of floating point (decimal) numbers\nAssigning a floating point (i.e. 'decimal') number to an interval is supported, and interpreted as a number in seconds; the numbers after the decimal point are discarded—no rounding up/down occurs. This can be useful as time codes, e.g. as in offsets within audio or video files, may be given with a decimal element: '45.3' vs. '45'. Thus:\n	$MyInterval  = 5406; \ngives in interval of ""01:30:06"". Note however that \n	$MyInterval  = 5406.8;\ngives the same result of ""01:30:06"". The '0.8' of a second in the input value does not cause the seconds element of the interval to round up to ':07'. This latter is the equivalent of a floor() operation where a decimal number is always rounds down the the existing whole integer:\n	$MyInterval  = floor(5406.8); (returns integer '5406')\nDefault/Empty value\nThe string ""00:00"" (zero hours:minutes).\nSorting order\nIncreasing duration, so unset (""00:00"") values list first.\nCoercing interval data \nInterval-type System attributes\nBuilt-in attributes of the file data type are listed below:","インターバル（Interval）\nインターバル（Interval）型は、時間の長さや期間を表します。一般的に1時間未満の期間での使用が想定されていますが、数時間や数日のインターバルを扱うことも可能です（詳細は後述）。\nこの基本的な想定を反映し、デフォルト値は0分0秒を表す文字列「00:00」です。例えば、インターバルの値が\n	01:30 \nであれば1分30秒を表し、\n	02:01:00 \nであれば2時間1分0秒を表します。NN:NNの形式を hh:mm ではなく mm:ss として区別するために、（入力と出力の両方で）秒の要素を含める必要がある点に注意してください。\n\nインターバル型データの作成\nこれは interval() オペレーターを使用して行います。入力は文字列です（interval(dataStr) を参照）。分と秒の値はゼロ埋めする必要はなく、「4:2」と入力すると表示・エクスポートされる値は「04:02」になります。\n指定された時間の要素が通常の範囲（59分や59秒など）を超えている場合、入力は適切な単位に再計算されます。そのため、mm:ss として「90:70」と入力すると「01:31:10」として解析されます。この仕様は、動的な値から入力を作成する場合に便利で、入力前に数値を再計算する手間を省けます。これは時、分、秒の入力すべてに適用されます。\nインターバル型のデータを読み取ったりコピーしたりする場合、実行中のアプリ内部では別の形式で保持されていても、常に「22:09」のような文字列形式になります。その結果、インターバルは加工することなくそのまま文字列属性に渡すことができます。例えば、文字列にインターバルを加算すると：\n	""The answer is:"" + $MyInterval は文字列を返します。\n\n日付からのインターバルの作成\ninterval() のバリエーションとして、2つの日付（Date）型オブジェクトの間の時間をインターバルとして返す interval(startDate, endDate) があります。\n\n1時間以上のインターバルの使用\nもともとは短時間（1時間未満）の持続時間を想定していましたが、インターバルは時（hour）や日（day）の入力も受け付けます。長期間のインターバルの場合、時と日の単位は受け付けられますが、月（month）や年（year）の範囲の入力はインターバル解析プログラムでは理解されないことに注意してください。\nしたがって、持続時間\n	01:01:00 \nは1時間1分0秒を表します。「01:01」と書くと1分1秒として解析されるため、たとえ「00」であっても秒を省略することはできません。「01:01:00」と記述することでのみ、時の要素が正しく検出されます。\n日は「day(s)」という言葉を使って定義します：\n	2 days 01:00:00 は49時間を表します。\n24時間を超える要素（月や年など）はサポートされていませんが、大きな「日」の値を使用することは可能です：\n	62 days 01:30:10\nこれは2ヶ月以上のインターバルを表します。インターバルの最大長に制限はありませんが、1年（365日として指定）を超えないことが推奨されます。理想的には、インターバルは数日以内の期間に使用するのが最適です。もし期間を「日」単位のみで取得したい場合は、通常のDate型の演算を行い、その結果を数値（Number）型として保存してください。\n\nインターバルデータのフォーマット\nInterval.format() が受け付けるフォーマット文字列の範囲は限定的（2つの選択肢のみ）で、Date型のフルセットのフォーマットは使用できません。「表示属性（Displayed Attributes）」や「情報の取得（Get Info）」におけるインターバルの表示形式を変更することはできません。エクスポートなどで他の場所で使用するためにデータを渡す場合は、通常の文字列操作オペレーターを使用して文字列表現を修正できます。\n\n負の値\nインターバルは「-05:30」のように負の期間を持つことができます：\n	-05:30 \nこれはマイナス5分30秒の期間を表します。これは、後述するように短時間の構成要素を持つ日付演算を行う際に便利です。\n\n日付演算での使用\nインターバルは、日付（Date）型の属性や変数に対して加算または減算できます。また、定数や数値属性によって乗算や除算を行ったり、== や != を使った等価比較、あるいはマグニチュード（大小）の比較を行ったりすることも可能です。\n日付の時間要素を直接変更したい場合は、通常は time() オペレーターを使用する方が単純で便利です。\n注意：現在、2つの日付を引き算してもインターバルは返されません。代わりに、従来のDate型属性の挙動に従って、2つの日付の間の日数が返されます。2つの日付の間のインターバルを取得するには、interval(startDate, endDate) オペレーターの構文を使用してください。例えば、ノート「Session 1」の $StartDate と「Session 2」の $StartDate の間のインターバルを取得するには：\n	$MyInterval = interval($StartDate(""Session 1""),$StartDate(""Session 2"")); \nインターバルは日付に加算・減算できます。もし $MyInterval が「-05:30」で、$MyDate が 2022/10/24 12:00:00（2022年10月24日正午）の場合：\n	$MyDate = $MyDate + $MyInterval; \nの結果、$MyDate は 2022/10/24 11:54:30 になります。負のインターバルを許容することで、同じアクションコードで正負両方の期間を扱うことができます。例えば、インターバルに含まれる（整数の）分数を求めるには：\n	$MyNumberOfMinutes = minutes($MyDate, $MyDate + $MyInterval); \nより一般的なアプローチとしては以下のようになります：\n	$MyNumberOfMinutes = minutes(date(""now""), date(""now"") + $MyInterval); \nここでは分（minutes）をテストしていますが、この方法で日（days）、時（hours）、秒（seconds）をテストすることも可能です（インターバルデータは通常せいぜい数日で、一般的には1日未満であるため、それ以上の大きな単位はテストしません）。\n\n代替構文\n時間のサフィックス/セパレーターとして「h」、日のサフィックスとして「d」を使用するなどの代替構文もサポートされています。したがって、\n	1h30 \nという期間は1時間30分を表し、\n	1 day 01:00:00 は25時間を表し、\n	2d2h30 は2日と2時間30分を表します。\n一方で：\n	2d5 \nは、日の次に小さい時間単位は時であるため、2日と5時間として扱われます。\n「d」マーカーは、常に「day(s)」として再保存・表示されます：\n	2d5 は「2 days 05:00:00」として再保存されます\n	1d5 は「1 day 05:00:00」として再保存されます\nなお、「m」と「s」のサフィックスも分と秒として理解されますが、秒は常に最後のセグメントになるため「s」は本来不要です。持続時間を「3m20」と入力すると、Tinderboxはデフォルト形式の「03:20」で値を再保存するため、「m」の使用は非推奨です。したがって、以下のような形式で入力された持続時間は理解されます：\n	1h30m10s \nこれは1時間30分10秒として扱われますが、再保存される際は以下のようになります：\n 	1:30:10 \n既存のDate型属性の日付演算で使用される略語と比較して、受け入れられる略語に若干の違いがあることに注意してください。\n\n浮動小数点数（小数）の使用\nインターバルへの浮動小数点数（「デシマル」）の代入はサポートされており、秒数として解釈されます。小数点以下の数値は破棄され、切り上げや四捨五入は行われません。これは、オーディオやビデオファイル内のオフセットなどのタイムコードが「45.3」のように小数の要素を伴って与えられる場合に便利です。例えば：\n	$MyInterval  = 5406; \nは「01:30:06」というインターバルになります。しかし、\n	$MyInterval  = 5406.8;\nも同じ結果「01:30:06」になります。入力値の「0.8」秒によってインターバルの秒の要素が「:07」に切り上がることはありません。これは、小数を常に既存の整数に切り下げる floor() 演算と同等です：\n	$MyInterval  = floor(5406.8); （整数「5406」を返す）\n\nデフォルト値 / 空の値\n文字列「00:00」（0時0分）。\n\nソート順\n期間が短い順に並びます。そのため、未設定（「00:00」）の値が最初にリストされます。\n\nインターバル型データの強制変換\n\nインターバル型のシステム属性\n組み込みのインターバル型属性は以下の通りです："
List-Type Attributes,"List\nA semi-colon delimited list of string values. In terms of stored data Sets and Lists are the same: a string containing one or more semi-colon delimited items. The difference is in the way Tinderbox handles the two data types, as lists may contain duplicate items. Although the Set-type pre-dates List-type in Tinderbox, Lists should be thought of as the underlying form and Sets as a type of List with special features (de-duplicated, always sorted, etc.).\nList items can be read/set via their list order number (see below) but note that this is zero-based, i.e. list item #1 has address value zero (0).\nA List, even a list of numbers or boolean values, is stored as a semi-colon delimited string, i.e. list items are not stored with an explicit data type, though multi-value value can be list or dictionaries.\nDeclaring a new List\nIf setting a List's literal values via action code use the square bracket [ ] List definition:\n	$MyList=[Frogs;Dogs;Logs]; \nAbove, the brackets replace the older now-deprecated method of enclosing quotes:\n	$MyList=""Frogs;Dogs;Logs""; NOTE: do not use this for new code!\nWhilst both methods work and the latter, older, method will be found in many demos and tutorials, the bracketed notation is now the preferred method.\nImportantly, when typing/pasting a List's values into a UI input box such as the Inspector, Get Info, or Displayed Attributes, the enclosing brackets or quotes (as used above) should be omitted, i.e. using planes;trains;automobiles not [planes;trains;automobiles]. If brackets are used by mistake, the Tinderbox parser should ignore an outmost pair (as it would quotes) abut still honour brackets within the overall list value as implying a nested list. If Tinderbox reads from a List via code and reports (logs) a value with enclosing brackets, Tinderbox knows—in code—to ignore those as simply being list delimiters. \nAdding new list items\nWith a List you can add/remove individual or multiple values and test its contents. In actions, + adds an item to a set if it is not already present. Values should be enclosed in square brackets (previous, and still supported is to use enclosing double quotes). If $PetTypes' value is ""cats;dogs"", then:\n	$PetTypes=$PetTypes+[rabbits]; adds the new value\n	$PetTypes=$PetTypes+[rabbits]; unlike a Set, this adds a second instance of ""dogs"" to the end of the List.\nThe += increment operator can also be used. If the List is 'cats;dogs;frogs':\n	$PetTypes=$PetTypes+[cats;frogs]; this gives a value of 'cats;dogs;frogs;cats;frogs'; the new values appended to the list in the order supplied.\nTo add new—not replacement—item(s) to the beginning of a list, use the [] list declaration method:\n	$PetTypes= [rabbits;hamsters]+$PetTypes; \nN.B. the last fails if using to old quote-enclosed format instead of square brackets.\nTo add a new item that is itself a list, note the extra set of brackets needed. The following adds a new list item whose value is a two-item list.\n	$PetTypes=$PetTypes+[[rabbits;bunnies]]; \nTo insert a new list at a specified location, i.e. adding a list item as opposed to replacing an existing value, iterate the list using List.each() with a custom counter. Store existing items in a new list and add the term when the loop reaches the desired place in the list. At the end of the loop write the new list back over the original List.\nDeleting items\nIn actions using a - (minus) removes the supplied value(s) if present. Importantly, this removes all occurrences if the deleted item;\n	$PetTypes=$PetTypes-[dogs]; leaves only ""cats"" as a value.\nTo delete only specific instances would require using List.each() with a custom counter.\nThe += increment operator can also be used. If the List is 'cats;dogs;frogs':\n	$PetTypes=$PetTypes+[cats;frogs]; this gives a value of 'cats;dogs;frogs;cats;frogs'; the new values appended to the list in the order supplied.\nThe -= decrement operator can also be used. If the Set is 'cats;dogs;frogs':\n	$PetTypes=$PetTypes-[cats;frogs]; this leaves only 'dogs' as a value.\nReplacing a list item's value\nThe List[N] notation addresses any single List item using a zero-based address. Thus List[1] addresses item #2, whilst  List[0] addresses the first. To replace item #3 in a list (assuming a big enough list):\n	$MyList=[Frogs;Dogs;Logs]; \n	$MyList[2]=[Pogs]; results in a list of ""Frogs;Dogs;Pogs""\nAdditional list definition mark-up\nLists and Sets may be written by enclosing them in square brackets, rather than inside quotes, as in the past. The newer form is more declarative of intent to the user and the app, so is recommended. Lists may be nested; for example, the list\n	[ 1; [2;3]; 4] \ncontains a 3 elements — 1, the nested list 2;3, and 4.\nLong Tinderbox precedent holds that list addition adds each element of the two lists. For example\n	$MyList = [1] + [2;3] \nor\n	$MyList += [2;3] \nboth result in the list 1;2;3 and not 1;[2;3]. To add a sublist to a list, use the operator list.extend(). Thus:\n	$MyList = [1].extend( [2;3])  \nresults in the list [1;[2;3]].\nOffset assignment to a list of notes recognises bracket-enclosed lists correctly, for example:\n	$Status([this;parent])=""urgent""; \nImplicit evaluation is no longer performed in bracketed lists. Thus,\n	$DisplayedAttributes=[MyList;MyString]; \nis now equivalent to\n	$DisplayedAttributes=""MyList;MyString""; \nIf new List terms need evaluation, use list() instead.\nAccessing nested lists\nConsider the following:\n	$MyTestList = [1;[a;b];3]; \nTo retrieve the nested list:\n	$MyString = $MyTestList[1]; results in '[a;b]'\nNote the square brackets are retrieved too, so for further use of the list this might be better:\n	$MyString = $MyTestList[1].substr(1,-1); results in '[a;b]'\nTo retrieve a value from that list:\n	$MyString = $MyTestList[1][1]; results in 'b'\nDe-duplicating a List: List vs. Sets\nLists, unlike Sets, allow duplicate values. To de-dupe a List, use the .unique dot-operator:\n	$MyList=$MyList.unique; \nAn older alternate method, which may be found in old demos is simply put its contents into a Set-type attribute:\n	$MySet=$MyList; (deprecated in favour of the method above)\nIf $MySet and $MyList both have the value [cats;dogs]: the following have different outcomes:\n	$MySet=$MySet + [dogs]; gives 'cats;dogs'\n	$MyList=$MyList + [dogs]; gives 'cats;dogs;dogs'\nThe Set attribute does not add the duplicate value but the List attribute does. List data values are stored in the order added.\nTesting (querying) Sets & Lists\nTo test a set or list, use the .contains() operator, syntax AttributeName.contains(""tested_value""), returns true if any Set/List discrete value exactly matches the designated tested_value; if case sensitivity is irrelevant for the query use .icontains(). If a user attribute $PetTypes has a value of 'dogs;cats' then\n	$PetTypes.contains(""dogs"") is true,\nbut\n	$PetTypes.contains(""dog"") is false \nThis is because Let/List matching does not allow partial matches, as via regex, unlike with String-type data.\nOther variants:\n	$PetTypes.contains(""Dogs"").lowercase is true \n	$PetTypes.icontains(""DOGS"") is true \nIt can be useful to use a stored value as the search term, for instance using the name of an agent as the search term:\n	$PetTypes.contains($MyString) is true \nEscaping literal semi-colons\nIf a list item must contain a semi-colon, it must be escaped, using a backslash, '\;'. Once the backslash is entered, it disappears and the list item containing the semi-colon is enclosed in double-quotes. Do not try to escape a value by adding the quotes directly, use the backslash method. Action code methods to make lists will treat a '\;' in an input string as an escape and act accordingly. Consider using String.replace() as a method for escaping backslashes (though only where intended!).\nListing and Exporting sets\nThe format() action operator and more recent .format() dot operator offer ways to turn sets into HTML lists for export. See Exporting Set-type data for more.\nSystem Attributes: Sets vs. Lists\nMost group-scope operators can work with lists or sets, as well as the find() operator (whose own output is a list) and literal list-based group designators; exceptions include $DisplayedAttributes where duplicates would not be helpful. It is the declared data type of the attribute being collected that informs the operator to return a list or set.\nDefault/Empty value\nAn empty string.\nSorting order\nLists are not sorted, so retain the order in which items were passed into the list, most recent being at the end. Lists can be sorted using action code sort operators or by setting the sort attributes of containers.\nList-type System Attributes\nBuilt-in attributes of the List data type are listed below:","リスト\nセミコロンで区切られた文字列値のリスト。保存されるデータの点では、セット（Set）とリスト（List）は同じであり、1つ以上のセミコロン区切りの項目を含む文字列です。違いはTinderboxによるこれら2つのデータ型の処理方法にあり、リストは重複した項目を含むことができます。Tinderboxにおいてセット型はリスト型より先に登場しましたが、リストを基本的な形式、セットを特別な機能を備えた（重複が除去される、常にソートされるなど）リストの一種と考えるべきです。\nリスト項目はリストの順序番号（下記参照）を介して読み書きできますが、これは0ベースであることに注意してください。つまり、リスト項目#1のアドレス値は0になります。\nリストは、数値やブール値のリストであっても、セミコロン区切りの文字列として保存されます。つまり、リスト項目は明示的なデータ型を持って保存されませんが、マルチ値（multi-value）はリストまたは辞書（dictionary）にすることができます。\n\n新しいリストの宣言\nアクションコードを介してリストのリテラル値を設定する場合は、角括弧 [ ] によるリスト定義を使用します。\n	$MyList=[Frogs;Dogs;Logs]; \n上記のように、角括弧は引用符で囲むという、現在では非推奨となった古い方法に取って代わるものです。\n	$MyList=""Frogs;Dogs;Logs""; 注意：新しいコードにはこれを使用しないでください！\n両方の方法とも機能し、多くのデモやチュートリアルで後者の古い方法が見られますが、現在は角括弧による記法が推奨される方法です。\n重要な点として、インスペクタ、情報の取得（Get Info）、表示属性（Displayed Attributes）などのUI入力ボックスにリストの値を入力または貼り付けるときは、上記の角括弧や引用符を省略する必要があります。つまり、[planes;trains;automobiles] ではなく planes;trains;automobiles を使用します。誤って角括弧が使用された場合、Tinderboxのパーサーは、外側のペアを（引用符と同様に）無視しますが、リスト値内の角括弧は入れ子になったリストを意味するものとして尊重されます。Tinderboxがコードを介してリストから読み取り、囲み角括弧付きで値を報告（ログ出力）する場合、Tinderboxはコード内でそれらを単なるリストのデリミタとして無視することを認識しています。\n\n新しいリスト項目の追加\nリストでは、個別の値または複数の値を追加/削除し、その内容をテストできます。アクションにおいて、+ は項目がまだ存在しない場合にセットに項目を追加します。値は角括弧で囲む必要があります（以前、および現在もサポートされている方法は、二重引用符で囲む方法です）。$PetTypes の値が ""cats;dogs"" である場合：\n	$PetTypes=$PetTypes+[rabbits]; 新しい値を追加します。\n	$PetTypes=$PetTypes+[rabbits]; セットとは異なり、これはリストの末尾に2つ目の ""dogs"" インスタンスを追加します。\n+= 加算演算子も使用できます。リストが 'cats;dogs;frogs' の場合：\n	$PetTypes=$PetTypes+[cats;frogs]; これにより、値は 'cats;dogs;frogs;cats;frogs' になります。新しい値は提供された順序でリストに付加されます。\nリストの先頭に、置換ではなく新しい項目を追加するには、[] リスト宣言メソッドを使用します。\n	$PetTypes= [rabbits;hamsters]+$PetTypes; \n注意：角括弧の代わりに古い引用符で囲む形式を使用すると、上記は失敗します。\nそれ自体がリストである新しい項目を追加するには、追加の角括弧のセットが必要であることに注意してください。以下は、値が2項目のリストである新しいリスト項目を追加します。\n	$PetTypes=$PetTypes+[[rabbits;bunnies]]; \n指定した場所に新しいリストを挿入する場合、つまり既存の値を置き換えるのではなくリスト項目を追加する場合は、カスタムカウンターを使用して List.each() でリストを反復処理します。既存の項目を新しいリストに保存し、ループがリストの目的の場所に達したときに用語を追加します。ループの最後に、新しいリストを元のリストに書き戻します。\n\n項目の削除\nアクションで -（マイナス）を使用すると、指定した値が存在する場合、その値が削除されます。重要なのは、これにより削除対象の項目のすべての出現箇所が削除されることです。\n	$PetTypes=$PetTypes-[dogs]; 値として ""cats"" だけが残ります。\n特定のインスタンスのみを削除するには、カスタムカウンターを使用して List.each() を使用する必要があります。\n+= 加算演算子も使用できます。リストが 'cats;dogs;frogs' の場合：\n	$PetTypes=$PetTypes+[cats;frogs]; これにより、値は 'cats;dogs;frogs;cats;frogs' になります。新しい値は提供された順序でリストに付加されます。\n-= 減算演算子も使用できます。セットが 'cats;dogs;frogs' の場合：\n	$PetTypes=$PetTypes-[cats;frogs]; これにより、値として 'dogs' だけが残ります。\n\nリスト項目の値の置換\nList[N] 記法は、0ベースのアドレスを使用して、任意の単一のリスト項目を指定します。したがって、List[1] は2番目の項目を指定し、List[0] は最初の項目を指定します。リスト内の3番目の項目を置き換えるには（リストに十分な項目があることを前提とします）：\n	$MyList=[Frogs;Dogs;Logs]; \n	$MyList[2]=[Pogs]; 結果は ""Frogs;Dogs;Pogs"" というリストになります。\n\n追加のリスト定義マークアップ\nリストとセットは、以前のように引用符で囲むのではなく、角括弧で囲んで記述することができます。新しい形式は、ユーザーやアプリに対して意図をより明確に宣言するため、推奨されます。リストは入れ子にすることができます。たとえば、以下のリスト\n	[ 1; [2;3]; 4] \nには、1、入れ子になったリスト 2;3、および 4 という3つの要素が含まれています。\n長年のTinderboxの慣例では、リストの加算は2つのリストの各要素を追加します。たとえば\n	$MyList = [1] + [2;3] \nまたは\n	$MyList += [2;3] \nはいずれも、1;[2;3] ではなく、1;2;3 というリストになります。リストにサブリストを追加するには、演算子 list.extend() を使用します。したがって：\n	$MyList = [1].extend( [2;3])  \nの結果は、リスト [1;[2;3]] となります。\nノートのリストへのオフセット代入は、角括弧で囲まれたリストを正しく認識します。例：\n	$Status([this;parent])=""urgent""; \n角括弧付きリストでは、暗黙的な評価（Implicit evaluation）は行われなくなりました。したがって、\n	$DisplayedAttributes=[MyList;MyString]; \nは現在、\n	$DisplayedAttributes=""MyList;MyString""; \nと同等です。新しいリスト項目を評価する必要がある場合は、代わりに list() を使用してください。\n\n入れ子になったリストへのアクセス\n次の場合を考えてみましょう：\n	$MyTestList = [1;[a;b];3]; \n入れ子になったリストを取得するには：\n	$MyString = $MyTestList[1]; 結果は '[a;b]' になります。\n角括弧も取得されることに注意してください。そのため、そのリストをさらに使用するには、次の方が良い場合があります：\n	$MyString = $MyTestList[1].substr(1,-1); 結果は '[a;b]' になります。\nそのリストから値を取得するには：\n	$MyString = $MyTestList[1][1]; 結果は 'b' になります。\n\nリストの重複除去：リスト対セット\nリストはセットとは異なり、重複した値を許可します。リストの重複を除去するには、.unique ドット演算子を使用します。\n	$MyList=$MyList.unique; \n古い代替方法（古いデモで見られる場合があります）は、単にその内容をセット型の属性に入れることです：\n	$MySet=$MyList; （上記の方法が推奨されるため、現在は非推奨です）\n$MySet と $MyList の両方が [cats;dogs] という値を持っている場合、以下の実行結果は異なります。\n	$MySet=$MySet + [dogs]; 結果は 'cats;dogs'\n	$MyList=$MyList + [dogs]; 結果は 'cats;dogs;dogs'\nセット属性は重複した値を追加しませんが、リスト属性は追加します。リストのデータ値は、追加された順序で保存されます。\n\nセットとリストのテスト（クエリ）\nセットまたはリストをテストするには、.contains() 演算子を使用します。構文は AttributeName.contains(""tested_value"") で、セット/リストの個別の値のいずれかが指定された tested_value と完全に一致する場合に true を返します。クエリで大文字と小文字の区別が不要な場合は、.icontains() を使用します。ユーザー属性 $PetTypes の値が 'dogs;cats' である場合：\n	$PetTypes.contains(""dogs"") は true ですが、\n	$PetTypes.contains(""dog"") は false です。\nこれは、String型のデータとは異なり、セット/リストの一致では正規表現による部分一致が許可されないためです。\nその他のバリエーション：\n	$PetTypes.contains(""Dogs"").lowercase は true \n	$PetTypes.icontains(""DOGS"") は true \n検索語として保存された値を使用すると便利な場合があります。たとえば、エージェントの名前を検索語として使用する場合などです：\n	$PetTypes.contains($MyString) は true \n\nリテラルのセミコロンのエスケープ\nリスト項目にセミコロンを含める必要がある場合は、バックスラッシュを使用して '\;' とエスケープする必要があります。バックスラッシュが入力されると、それは消え、セミコロンを含むリスト項目は二重引用符で囲まれます。引用符を直接追加して値をエスケープしようとせず、バックスラッシュによる方法を使用してください。リストを作成するアクションコードのメソッドは、入力文字列内の '\;' をエスケープとして処理し、それに応じて動作します。バックスラッシュをエスケープする方法として String.replace() を使用することを検討してください（ただし、意図した場所のみに限定してください）。\n\nセットの一覧表示と書き出し\nformat() アクション演算子や、より新しい .format() ドット演算子は、書き出しのためにセットをHTMLリストに変換する方法を提供します。詳細については、「セット型データの書き出し（Exporting Set-type data）」を参照してください。\n\nシステム属性：セット対リスト\nほとんどのグループスコープ演算子は、find() 演算子（それ自体の出力はリストです）やリテラルのリストベースのグループ指定子と同様に、リストまたはセットで使用できます。例外には、重複が役に立たない $DisplayedAttributes が含まれます。演算子がリストを返すかセットを返すかを決定するのは、収集される属性の宣言されたデータ型です。\n\nデフォルト/空の値\n空の文字列。\n\nソート順\nリストはソートされないため、項目がリストに渡された順序が保持され、最新の項目が末尾になります。リストはアクションコードのソート演算子を使用するか、コンテナのソート属性を設定することでソートできます。\n\nリスト型のシステム属性\nリストデータ型の組み込み属性を以下に示します。"
Number-Type Attributes,"Number\nA numerical value. If no default value is specified, a Number type defaults to the value 0 (zero). User attributes of Number type may be configured, at first creation, as 'sequential'. \nA sequential number attribute is like a database counter field, where the next unused number is issued and values no longer used are not re-issued; i.e. the next number is always higher than the last. Sequential numbers start at 1. When a new sequential attribute is added to an existing document, the already-created notes are initialised with sequential values of the new attribute, starting with the first notes in $OutlineOrder sequence. Thereafter notes are numbered in the order added, regardless of $OutlineOrder.\nVery large or small numbers may be displayed (and set) in exponential notation:\n	0.000001 = 1e-06 \n	$MyNumber = 1.2e+3 sets '1200'\nWhen very large or small number strings are typed into a Displayed Attributes box the result may be '0', in which case use exponential notation. \nThe Displayed Attributes display will also truncate the number of decimal places shown. The display limits seem to be:\n* Whole (non decimal) numbers will display up to 9 digits, i.e. between -999999999 and 999999999.\n* Numbers over 1, positive or negative, will display 6 digits e.g. 150.123 or 1.12346.\n* Numbers over 1, positive or negative, will display 6 decimal places e.g. 0.012345.\nWhen typing/pasting in number values to a KA box the input value is stored and not the rounded/truncated visible value. To see the decimal places in full coerce the value to a string, e.g. set a string attribute to the value of the number attribute. Beware that values copied from a Displayed Attributes display box use the visible value and not the real underlying value, so passing the number to a string and reading the latter is useful if data fidelity is required.\nDefault/Empty value\nThe value 0 (zero).\nSorting order\nAscending value in numeric sort order; default (0) thus lists first.\nNumber-type System Attributes\nBuilt-in attributes of the number data type are listed below:\n\n\nNumber-type System Attributes set via Document Settings\nA number of Document Settings controls set the defaults for Number-type system attributes, directly or indirectly:\n* Text tab: \n** $ParagraphSpacing.\n** $TextFontSize.\n* Maps tab: \n** $MapTextSize.\n** $OutlineTextSize. (Deprecated)\n** $InteriorScale.",番号\n数値。デフォルト値が指定されていない場合、数値型のデフォルト値は 0 (ゼロ) になります。数値タイプのユーザー属性は、最初の作成時に「シーケンシャル」として構成できます。\n連続番号属性はデータベース カウンター フィールドに似ており、次の未使用の番号が発行され、使用されなくなった値は再発行されません。つまり、次の数値は常に最後の数値より大きくなります。連続番号は 1 から始まります。新しい連続属性が既存のドキュメントに追加されると、作成済みのノートは、$OutlineOrder シーケンスの最初のノートから始まる、新しい属性の連続した値で初期化されます。以降、$OutlineOrder に関係なく、メモには追加された順序で番号が付けられます。\n非常に大きい数値または小さい数値は、指数表記で表示 (および設定) できます。\n0.000001 = 1e-06\n$MyNumber = 1.2e+3 セット '1200'\n非常に大きいまたは小さい数値文字列を [表示属性] ボックスに入力すると、結果が「0」になる場合があります。その場合は指数表記を使用します。\n「表示された属性」表示でも、表示される小数点以下の桁数が切り捨てられます。表示制限は次のようです。\n* 整数 (10 進数以外) は最大 9 桁、つまり -999999999 ～ 999999999 まで表示されます。\n* 1 を超える数値は、正でも負でも 6 桁で表示されます。150.123 または 1.12346。\n* 1 を超える数値は、正でも負でも、小数点以下 6 桁が表示されます。0.012345。\nKA ボックスに数値を入力/貼り付けすると、丸め/切り捨てられた表示値ではなく、入力値が保存されます。小数点以下の桁を完全に表示するには、値を文字列に強制変換します。文字列属性を数値属性の値に設定します。[表示属性] 表示ボックスからコピーされた値は、実際の基礎となる値ではなく、表示されている値を使用することに注意してください。そのため、データの忠実性が必要な場合は、数値を文字列に渡して文字列を読み取ると便利です。\nデフォルト/空の値\n値 0 (ゼロ)。\n並べ替え順序\n数値ソート順の昇順の値。したがって、default (0) が最初にリストされます。\n数値型のシステム属性\n数値データ型の組み込み属性を以下に示します。\n\n\nドキュメント設定で設定された数値タイプのシステム属性\n多くのドキュメント設定コントロールは、数値タイプのシステム属性のデフォルトを直接的または間接的に設定します。\n* テキストタブ:\n** $ParagraphSpacing。\n** $TextFontSize。\n*「マップ」タブ:\n** $MapTextSize。\n** $OutlineTextSize。(非推奨)\n** $インテリアスケール。
Set-Type Attributes,"Set\nA Set date type is a special type of string, within which discrete values are delimited by semicolons. When defining a Set in code, use the conventions are described for the List data type.\nIn terms of stored data the Set and List lists are the same: a string containing one or more semi-colon delimited items. The difference is in the way Tinderbox handles the two data types, as lists may contain duplicate items. Although the Set-type pre-dates List-type in Tinderbox, Lists should be thought of as the underlying form and Sets as a refined (de-duplicated) form of List.\nA Set is useful for lists of topics, categories, and tags where duplication of listed items is not wanted:\n	[astronomy;marine biology;chemistry] \n	[dogs;cats] \n	[3;9;15] \nNote that the Set is always a string even if the values happen to be numbers: item values in a Set do not have explicit data types. A Set can have a single value, e.g. the third example above. With a single value there is no need to add a final semicolon and the same holds for the last of multiple values. Tinderbox will not mind if you supply a semicolon there (or after the last of multiple values), it will just strip it off as it processes the data. The default Set value is an empty string. A Set-type differs from a List-type in that duplicate values are not allowed, and the list of values is always A–Z lexically sorted.\nTo apply values directly to a Set-type attribute via the Displayed Attributes or via Info view or via the Inspector's Quickstamp, simply type the values as seen into the data box. In all these methods, you do not need to add enclosing quotes, but each discrete value should be separated with a semi-colon.\nLegacy: Sets and auto-sorting\nPrior to v9, sets did not always re-sort. Sets were then reimplemented to improve performance with large sets, which makes a Set more aggressive in asserting its control of the sequence of their elements. Compared to previous use, the stored order of items in the Set's value list are much more likely to change from the order as originally entered into case-sensitive lexical sort order. This may catch out long term users being used to Sets generally retaining their as-created item order. If the latter is needed, it may make more sense to use a List type instead.\nDeclaring a new Set\nIf setting a Set's literal values via action code use the square bracket [ ] Set definition:\n	$MySet=[Frogs;Dogs;Logs]; \nAbove, the brackets replace the older now-deprecated method of enclosing quotes:\n	$MySet=""Frogs;Dogs;Logs""; NOTE: do not use this for new code!\nWhilst both methods work and the latter, older, method will be found in many demos and tutorials, the bracketed notation is now the preferred method.\nImportantly, when typing/pasting a Set's values into a UI input box such as the Inspector, Get Info, or Displayed Attributes, the enclosing brackets or quotes (as used above) should be omitted, i.e. using planes;trains;automobiles not [planes;trains;automobiles]. If brackets are used by mistake, the Tinderbox parser should ignore an outmost pair (as it would quotes) abut still honour brackets within the overall list value as implying a nested list. If Tinderbox reads from a Set via code and reports (logs) a value with enclosing brackets, Tinderbox knows—in code—to ignore those as simply being list delimiters. \nAdding values\nWith a Set you can add/remove individual or multiple values and test its contents. In actions, + adds an item to a set if it is not already present, and -- removes it if it is present. Values must be enclosed in double quotes. If $PetTypes' value is ""cats;dogs""\n	$PetTypes=$PetTypes+[dogs] leaves $PetTypes unchanged, since 'dogs' is already in $PetTypes\nThe += increment operator can also be used. If the Set is 'cats;dogs;frogs':\n	$PetTypes=$PetTypes+[owls;dogs]; the Set is 'cats;dogs;frogs;owls'.\nDeleting values\nIn actions using a - (minus) removes the supplied value(s) if present. Importantly, this removes all occurrences if the deleted item;\n	$PetTypes=$PetTypes-[dogs]; leaves only 'cats' as a value.\nThe -= decrement operator can also be used. If the Set is 'cats;dogs;frogs':\n	$PetTypes=$PetTypes-[cats;frogs]; this leaves only 'dogs' as a value.\nTesting (querying) Sets & Lists\nTo test a Set or List, use the .contains() operator, syntax AttributeName.contains(""tested_value""), returns true if any set/list discrete value exactly matches the designated tested_value; if case sensitivity is irrelevant for the query use .icontains(). If a user attribute $PetTypes has a value of 'dogs;cats' then\n	$PetTypes.contains(""dogs""); istrue,\nbut\n	$PetTypes.contains(""dog""); is false \nThis is because Set/List matching does not allow partial matches, as via regex, unlike with String-type data.\nOther variants:\n	$PetTypes.contains(""Dogs"").lowercase() is true \n	$PetTypes.icontains(""DOGS"") is true \nIt can be useful to use a stored value as the search term, for instance using the name of an agent as the search term:\n	$PetTypes.contains($MyString) is true \nListing and exporting Sets\nThe format() action operator, and newer .format() dot operator offer ways to turn sets into HTML lists for export. See Exporting Set-type data for more.\nSet data vs. List data\nList-type attributes came to Tinderbox after Sets. Lists, unlike Sets, allow duplicate values and Sets can better be thought of as de-duped versions of Lists, i.e. lists with no duplicate entries. \nTo de-dupe a List, simply put its contents into a Set-type attribute:\n	$MySet=$MyList; \nEscaping literal semi-colons\nIf a list item must contain a semi-colon, it must be escaped, using a backslash, '\;'. Once the backslash is entered, it disappears and the list item containing the semi-colon is enclosed in double-quotes. Do not try to escape a value by adding the quotes directly, use the backslash method. Action code methods to make lists will treat a '\;' in an input string as an escape and act accordingly. Consider using String.replace() as a method for escaping backslashes (though only where intended!).\nDefault/Empty value\nAn empty string.\nSorting order\nAs for a String Data Type, using the literal string values of the Set in case-sensitive lexical sort order. For example, the 5-item of values 'Ant', 'ant', 'bee', 'Cow', 'cow' when passed to a set would store as ""Ant;Cow;ant;bee;cow"".\nSet-type System Attributes\nBuilt-in attributes of the set data type are listed below:","Set（セット）\nSetデータ型は特殊な文字列型で、その内部では個別の値がセミコロンで区切られます。コード内でSetを定義する際は、Listデータ型で説明されている慣習に従ってください。\n保存されるデータに関しては、SetとListは同じです。つまり、1つ以上のセミコロン区切りの項目を含む文字列です。違いはTinderboxがこれら2つのデータ型を処理する方法にあり、Listは重複する項目を含むことができます。TinderboxではSet型の方がList型よりも先に登場しましたが、Listを基本形、SetをListの洗練された（重複を取り除いた）形と考えるべきです。\nSetは、項目の重複を望まないトピック、カテゴリ、タグのリストに役立ちます：\n	[astronomy;marine biology;chemistry]\n	[dogs;cats]\n	[3;9;15]\nSetは、値がたまたま数字であっても常に文字列であることに注意してください。Set内の項目の値には明示的なデータ型はありません。Setは単一の値を持つこともできます（上記の3番目の例など）。単一の値の場合、末尾にセミコロンを追加する必要はありません。複数の値の最後についても同様です。Tinderboxはそこにセミコロンがあっても（あるいは複数の値の最後にセミコロンがあっても）気にしません。データを処理する際にそれを取り除くだけです。Setのデフォルト値は空の文字列です。Set型がList型と異なる点は、重複する値が許可されないことと、値のリストが常にA-Zの辞書順でソートされることです。\n表示属性（Displayed Attributes）、Infoビュー、またはインスペクタのQuickstampを介してSet型の属性に値を直接適用するには、データボックスに表示されている通りに値を入力するだけです。これらの方法では、囲み引用符を追加する必要はありませんが、個々の値はセミコロンで区切る必要があります。\n\nレガシー：Setと自動ソート\nv9より前では、Setは常に再ソートされるわけではありませんでした。その後、大規模なSetでのパフォーマンスを向上させるためにSetが再実装され、要素の順序に対する制御がより強力になりました。以前の使用法と比較して、Setの値リストに保存される項目の順序は、最初に入力された順序から、大文字小文字を区別する辞書順に変更される可能性が非常に高くなっています。これにより、Setが作成時の項目の順序を概ね保持することに慣れている長年のユーザーは戸惑うかもしれません。もし後者が必要な場合は、代わりにList型を使用する方が理にかなっているかもしれません。\n\n新しいSetの宣言\nアクションコードを介してSetのリテラル値を設定する場合は、角括弧 [ ] を使用したSet定義を使用します：\n	$MySet=[Frogs;Dogs;Logs];\n上記において、括弧は古い（現在は非推奨の）引用符で囲む方法に代わるものです：\n	$MySet=""Frogs;Dogs;Logs""; 注：新しいコードにはこれを使用しないでください！\nどちらの方法も機能し、後者の古い方法は多くのデモやチュートリアルで見られますが、現在は括弧による表記が推奨される方法です。\n重要な点として、インスペクタ、情報の取得、表示属性などのUI入力ボックスにSetの値を入力または貼り付ける場合は、上記のような囲み括弧や引用符を省略する必要があります。つまり、[planes;trains;automobiles] ではなく planes;trains;automobiles を使用します。誤って括弧が使用された場合、Tinderboxのパーサーは一番外側のペアを無視しますが（引用符の場合と同様）、全体のリスト値の中にある括弧は、ネストされたリストを意味するものとして尊重します。Tinderboxがコードを介してSetから読み取り、囲み括弧付きの値を報告（ログ出力）する場合、Tinderboxはコード内でそれらを単なるリストの区切り文字として無視することを認識しています。\n\n値の追加\nSetでは、個別の値または複数の値を追加/削除したり、その内容をテストしたりできます。アクションでは、+ は項目がまだ存在しない場合にSetに項目を追加し、-- は項目が存在する場合にそれを削除します。値はダブルクォーテーションで囲む必要があります。$PetTypesの値が ""cats;dogs"" の場合：\n	$PetTypes=$PetTypes+[dogs] は $PetTypes を変更しません。「dogs」はすでに $PetTypes に存在するためです。\n+= インクリメント演算子も使用できます。Setが 'cats;dogs;frogs' の場合：\n	$PetTypes=$PetTypes+[owls;dogs]; Setは 'cats;dogs;frogs;owls' になります。\n\n値の削除\nアクションで -（マイナス）を使用すると、指定した値が存在する場合にそれらを削除します。重要なことに、これは削除対象の項目のすべての出現を削除します：\n	$PetTypes=$PetTypes-[dogs]; 値として 'cats' だけが残ります。\n-= デクリメント演算子も使用できます。Setが 'cats;dogs;frogs' の場合：\n	$PetTypes=$PetTypes-[cats;frogs]; これにより 'dogs' だけが値として残ります。\n\nSetとListのテスト（クエリ）\nSetまたはListをテストするには、.contains() 演算子を使用します。構文は AttributeName.contains(""tested_value"") で、指定した tested_value に完全に一致する個別の値がSet/List内にあれば true を返します。クエリで大文字小文字を区別しない場合は .icontains() を使用します。ユーザー属性 $PetTypes の値が 'dogs;cats' の場合：\n	$PetTypes.contains(""dogs""); は true ですが、\n	$PetTypes.contains(""dog""); は false です。\nこれは、Set/Listの一致では、文字列型データとは異なり、正規表現による部分一致が許可されないためです。\nその他のバリエーション：\n	$PetTypes.contains(""Dogs"").lowercase() は true\n	$PetTypes.icontains(""DOGS"") は true\n検索語として保存されている値を使用すると便利な場合があります。例えば、エージェントの名前を検索語として使用する場合などです：\n	$PetTypes.contains($MyString) は true\n\nSetのリスト表示とエクスポート\nformat() アクション演算子や、新しい .format() ドット演算子は、Setをエクスポート用のHTMLリストに変換する方法を提供します。詳細は「Set型データのエクスポート」を参照してください。\n\nSetデータ vs. Listデータ\nList型属性はSetの後にTinderboxに追加されました。ListはSetとは異なり重複する値を許可します。SetはListの重複排除版、つまり重複エントリのないリストと考えるのが最適です。\nListの重複を排除するには、その内容をSet型の属性に入れるだけです：\n	$MySet=$MyList;\n\nリテラルのセミコロンのエスケープ\nリスト項目にセミコロンを含める必要がある場合は、バックスラッシュを使用して '\;' とエスケープする必要があります。バックスラッシュが入力されると、それは消え、セミコロンを含むリスト項目はダブルクォーテーションで囲まれます。引用符を直接追加して値をエスケープしようとしないでください。バックスラッシュによる方法を使用してください。リストを作成するアクションコードのメソッドは、入力文字列内の '\;' をエスケープとして扱い、それに応じて動作します。String.replace() を、バックスラッシュをエスケープするための方法として検討してください（ただし、意図した場所のみに使用してください！）。\n\nデフォルト値/空の値\n空の文字列。\n\nソート順\n文字列データ型と同様に、Setのリテラル文字列値を使用して、大文字小文字を区別する辞書順でソートされます。例えば、'Ant', 'ant', 'bee', 'Cow', 'cow' という5つの値をSetに渡すと、""Ant;Cow;ant;bee;cow"" として保存されます。\n\nSet型システム属性\nSetデータ型の組み込み属性を以下に示します。"
String-Type Attributes,"String\nA sequence of characters, most often as words and sentences. If no default value is specified, a String type defaults to an empty string.\nStrings are not delimited (i.e. quotes are not required).\nThe set and action data types effectively special forms of the string data type.\nDefault/Empty value\nAn empty string.\nSorting order\nAscending order using literal string value in lexical sort order.\nString-type System Attributes\nBuilt-in attributes of the string data type are listed below:\n\n\nString-type System Attributes set via Document Settings\nA number of Document Settings controls set the defaults for String-type system attributes, directly or indirectly:\n* Text tab: \n** $TextAlign. (Deprecated)\n* Maps tab: \n** $Fill.\n** $MapBackgroundPattern.",文字列\n一連の文字。ほとんどの場合は単語や文です。デフォルト値が指定されていない場合、String 型のデフォルトは空の文字列です。\n文字列は区切られていません (つまり、引用符は必要ありません)。\nセット データ型とアクション データ型は、実質的に文字列データ型の特殊な形式です。\nデフォルト/空の値\n空の文字列。\n並べ替え順序\n字句ソート順でリテラル文字列値を使用した昇順。\n文字列型のシステム属性\n文字列データ型の組み込み属性を以下に示します。\n\n\nドキュメント設定で設定された文字列型のシステム属性\n多くのドキュメント設定コントロールは、文字列型のシステム属性のデフォルトを直接的または間接的に設定します。\n* テキストタブ:\n** $TextAlign。(非推奨)\n*「マップ」タブ:\n** $Fill。\n** $MapBackgroundPattern。
URL-Type Attributes,"URL\nA URL string. If no default value is specified, a URL type defaults to an empty string. URLs are not delimited (i.e. quotes are not required).\nURL attributes behave like string attributes. When displayed in a note's displayed attributes table, URL-type attributes show a globe icon before the attribute value. Pressing the icon opens that attribute's stored URL (if any) in the default web browser.\nLinks dropped on a URL-type Displayed Attribute populate that attribute; links dropped on any other data type Displayed Attributes populate the system $URL.\nIf using a local path to a file, e.g. to enable AutoFetch use, you must use the file:// protocol rather than a bare file path.\nDefault/Empty value\nAn empty string.\nSorting order\nAs for String Data Type.\nURL-type System Attributes\nBuilt-in attributes of the URL data type are listed below:",URL\nURL 文字列。デフォルト値が指定されていない場合、URL タイプはデフォルトで空の文字列になります。URL は区切られていません (つまり、引用符は必要ありません)。\nURL 属性は文字列属性のように動作します。ノートの表示属性テーブルに表示される場合、URL タイプの属性には属性値の前に地球のアイコンが表示されます。アイコンを押すと、その属性に保存されている URL (存在する場合) がデフォルトの Web ブラウザで開きます。\nURL タイプの表示属性にドロップされたリンクには、その属性が設定されます。他のデータ タイプにドロップされたリンク 表示される属性には、システムの $URL が設定されます。\nファイルへのローカル パスを使用する場合、例:AutoFetch の使用を有効にするには、裸のファイル パスではなく file:// プロトコルを使用する必要があります。\nデフォルト/空の値\n空の文字列。\n並べ替え順序\n文字列データ型については。\nURL タイプのシステム属性\nURL データ型の組み込み属性を以下に示します。
