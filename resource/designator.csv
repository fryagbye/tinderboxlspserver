Name,Text,TextJa
adornment,"The designator adornment allows notes on an adornment to refer to the adornment's attributes. Only available in an adornment's $OnAdd action and in no other contexts. This is similar to the 'Link type honouring operators' designator.\nIn this context, using parent would result in the value being taken from the parent of the current map view.\nIn all other contexts than the above, the adornment refers to the map view adornment(s) on which the current note rests. If the note overlaps two or more adornments, adornment designates the uppermost (front-most) adornment.\nIf the note overlaps no adornment, then adornment is bound to this. For example, the rule\n	$Color=$Color(adornment); \nwill change the note's colour to match the colour of an adornment, but leaves the colour unchanged if the note does not overlap an adornment. This latter usage, with an inherent 'if on adornment' switch makes for more flexible coding in maps.",指定子装飾により、装飾に関するメモで装飾の属性を参照できるようになります。装飾品の $OnAdd アクションでのみ使用可能で、他のコンテキストでは使用できません。これは、「演算子を尊重するリンク タイプ」指定子に似ています。\nこのコンテキストでは、parent を使用すると、現在のマップ ビューの親から値が取得されます。\n上記以外のすべてのコンテキストでは、装飾は、現在のノートが置かれているマップ ビューの装飾を指します。音符が 2 つ以上の装飾音と重なっている場合、装飾音は最も上 (最前面) の装飾音を指定します。\nノートが装飾音と重なっている場合、装飾音はこれにバインドされます。たとえば、次のようなルールがあります。\n$Color=$Color(装飾品);\n装飾の色と一致するようにメモの色が変更されますが、メモが装飾と重ならない場合は色は変更されません。後者の使用法では、固有の「if on 装飾」スイッチを使用すると、マップでのコーディングがより柔軟になります。
agent,"The designator agent allows the children of an agent (always aliases) to refer to the agent's attributes. N.B. this is only available in agent queries and actions (i.e. $AgentQuery and $AgentAction) and no other contexts. This is similar to the 'adornment' designator.\nIn this context, using parent would result in the value being taken from the parent of the original note to which the alias refers.",指定子エージェントを使用すると、エージェントの子 (常にエイリアス) がエージェントの属性を参照できるようになります。注：これはエージェントのクエリとアクション (つまり、$AgentQuery と $AgentAction) でのみ使用でき、他のコンテキストでは使用できません。これは「装飾」指定子に似ています。\nこのコンテキストで、parent を使用すると、エイリアスが参照する元のノートの親から値が取得されます。
child,"child\nThe designator child represents the oldest child (note) of the note currently in focus, thus the first as listed in Outline view. Mention in various references of 'oldest' deriving from creation/modification date are erroneous. 'Oldest' equates to the note whose $OutlineOrder attribute value is 1 greater than the current note's OutlineOrder value.\nThe logical opposite of this (first) child designator is lastChild; there is no firstChild designator.\nchild[N]\nThe designator can take an optional numbered offset N, in square brackets. N numbers up from zero and down from -1. Thus:\n	child[0] is the same as child\nwhilst:\n	child[1] is the second child\n	child[-1] is the last child (i.e. lastChild)\n	child[-2] is the last but one child\nLegacy code issue\nTo avoid ambiguity, the old group-scope 'child' designator is deprecated in favour of 'children'.",子供\n指示子の子は、現在フォーカスされているノートの最も古い子 (ノート) を表します。したがって、アウトライン ビューにリストされている最初の子になります。さまざまな参考文献で、作成日/変更日から派生した「最も古い」という記述は誤りです。「最も古い」は、$OutlineOrder 属性値が現在のノートの OutlineOrder 値より 1 大きいノートに相当します。\nこの (最初の) 子指定子の論理的反対は lastChild です。firstChild 指定子はありません。\n子供[N]\n指定子には、角括弧内にオプションの番号付きオフセット N を指定できます。N は 0 から増加し、-1 から減少する数値です。したがって:\nchild[0] は child と同じです\n一方:\nchild[1] は 2 番目の子です\nchild[-1] は最後の子 (つまり、lastChild) です。\nchild[-2] は最後から 1 人の子です\nレガシーコードの問題\n曖昧さを避けるために、古いグループスコープの「子」指定子は非推奨になり、「子」が優先されます。
cover,"The designator cover represents the top level note in the hierarchy, or the first listed if there is more than one at this level. It will be the first listed in an outline window that shows the whole document. It has an $OutlineOrder value of '1'. The cover note will be the first listed root note if there is more than one note at the highest Outline level.",デジグネータ カバーは、階層内の最上位ノート、またはこのレベルに複数のノートがある場合は最初にリストされるノートを表します。これは、ドキュメント全体を表示するアウトライン ウィンドウの最初にリストされます。$OutlineOrder 値は「1」です。最も高いアウトライン レベルに複数のノートがある場合、カバー ノートは最初にリストされるルート ノートになります。
current,"The designator current refers to the note which Tinderbox is currently exporting. Where a note is exported to its own page, current is the same as this.\nHowever, if a note includes children or other notes, current differs from this in the included notes reflecting the note actually being processed (and not the note that initiated the export). It is extremely useful for boilerplate-style includes that need to use attribute values from the calling note.\nFor instance, if 'Note X' is calling an include of the text of 'Note Y' and the latter makes a code reference to the note title then, in the include's code:\n	value($Name) gives Note Y.\n	value($Name(current)) gives Note X.\nNote that, when it appears outside an export template (e.g. in an agent or container action), current is synonymous with this.",現在の指定子は、Tinderbox が現在エクスポートしているメモを指します。ノートが独自のページにエクスポートされる場合、current はこれと同じです。\nただし、ノートに子ノートまたは他のノートが含まれている場合、current は、実際に処理されているノート (エクスポートを開始したノートではなく) を反映する含まれるノートという点でこれとは異なります。これは、呼び出し元のメモの属性値を使用する必要があるボイラープレート スタイルのインクルードに非常に役立ちます。\nたとえば、「ノート X」が「ノート Y」のテキストのインクルードを呼び出しており、後者がノート タイトルへのコード参照を作成する場合、インクルードのコードでは次のようになります。\nvalue($Name) は Note Y を与えます。\nvalue($Name(current)) は Note X を与えます。\nエクスポート テンプレートの外側 (エージェントまたはコンテナ アクションなど) に表示される場合、 current はこれと同義であることに注意してください。
firstSibling,"The designator firstSibling refers to the first sibling of this note, in outline order. Note that, if a note has no siblings, firstSibling, this, and lastSibling refer to the same note.",指定子 firstSibling は、アウトライン順でこのノートの最初の兄弟を指します。ノートに兄弟がない場合、firstSibling、this、lastSibling は同じノートを参照することに注意してください。
grandparent,"The designator grandparent describes the parent note of the current note's parent, i.e. its grandparent.\nIt is especially useful for representing the relationship of an exploded note to its source note as the former do not automatically inherit the latter's attributes.",指定子の祖父母は、現在のノートの親ノート、つまりその祖父母を表します。\nこれは、分解されたノートとそのソースノートの関係を表すのに特に便利です。前者は後者の属性を自動的には継承しないからです。
lastChild,"The designator lastChild refers to the last immediate child of the current note. For example:\n I. A note\nIa. Another Note\nIb. Yet Another Note\n II. Some Note\nIIc. Subsidiary stuff\n III. Different stuff\n IV. More Stuff\nThe lastChild of I is Ib. The lastChild of II is IIc. III has no lastChild.\nThe logical opposite of lastChild, i.e. the first child, is child [sic].\nUsing the optional child[N] notation, the equivalent of lastChild is child[-1]",指定子 lastChild は、現在のノートの最後の直接の子を参照します。たとえば:\nI. 注意事項\nああ。別のメモ\nIb.さらに別のメモ\nII.メモ\nIIc.補助的なもの\nⅢ．違うもの\nIV.もっと見る\nI の最後の子供は Ib です。II の最後の子は IIc です。III には lastChild がありません。\nlastChild の論理的反対、つまり最初の子は child [原文のまま] です。\nオプションの child[N] 表記を使用すると、lastChild に相当するのは child[-1] になります。
lastSibling,"The designator lastSibling refers to the last sibling of this note, in outline order. Note that, if a note has no siblings, firstSibling, this, and lastSibling refer to the same note.",指定子 lastSibling は、アウトライン順でこのノートの最後の兄弟を指します。ノートに兄弟がない場合、firstSibling、this、lastSibling は同じノートを参照することに注意してください。
library,"In a function call the designator library binds to, i.e. calls data from, the (library) note holding the function. this allows a function to have 'internal' attribute settings to assist with configuration of function process or to store global values.\nThe designator meaning has no value outside a function call. So in a note:\n	$MyResult = fDoSomething($ID,$MakeLists(designator)); \nwould return data from the calling note (accessed via $ID) and with the function's code modified by it reading the value of its $MakeLists attribute (in this case likely a boolean: do/do not make lists.\nOtherwise:\n	$MyResult = $MakeLists(designator); Dont' do this!\nreturns nothing. To read fDoSomething()'s $MakeList value externally, requires giving the name/path/ID of the library note whose $text contains the function. Thus if fDoSomething() is in the $Text of library note 'Test Library', $MakeList can be read thus:\n	$MyResult = $MakeLists(""Test Library""); \nNOTE: function 'designator' attribute values are thus shared by all functions in the same note. this may affect whether a single library note is used for multiple values or functions are store in discrete note or as groups of functions.","関数呼び出しでは、指定子ライブラリは、関数を保持する (ライブラリ) ノートにバインドされます。つまり、そこからデータが呼び出されます。これにより、関数プロセスの構成を支援したり、グローバル値を保存したりするために、関数に「内部」属性設定を持たせることができます。\n指定子の意味は、関数呼び出しの外では値を持ちません。したがって、メモでは次のようになります。\n$MyResult = fDoSomething($ID,$MakeLists(指定子));\n呼び出し元のメモ ($ID 経由でアクセス) からデータを返し、その $MakeLists 属性の値 (この場合はおそらくブール値: リストを作成する/しない) を読み取ることで関数のコードが変更されます。\nそれ以外の場合:\n$MyResult = $MakeLists(指定子);こんなことはしないでください！\n何も返しません。fDoSomething() の $MakeList 値を外部から読み取るには、$text に関数が含まれるライブラリ ノートの名前/パス/ID を指定する必要があります。したがって、 fDoSomething() がライブラリ ノート「Test Library」の $Text にある場合、$MakeList は次のように読み取ることができます。\n$MyResult = $MakeLists(""テスト ライブラリ"");\n注: したがって、関数の「デジグネータ」属性値は、同じメモ内のすべての関数で共有されます。これは、単一のライブラリ ノートが複数の値に使用されるか、関数が個別のノートに保存されるか関数のグループとして保存されるかに影響する可能性があります。"
next,"The designator next describes the next note in $OutlineOrder following current note.\nnext is a less closely designed test than nextSibling as the former may be at a different outline depth.\nnext will not match an adornment, separator, or item set to not export, but see nextItem.",次に、指定子は、$OutlineOrder 内の現在のノートに続く次のノートを記述します。\nnext は、nextSibling よりも厳密に設計されたテストではありません。前者は、アウトラインの深さが異なる可能性があるためです。\nnext は、エクスポートしないように設定された装飾、区切り文字、または項目と一致しません。ただし、nextItem を参照してください。
nextItem,"The designator nextItem describes the next note in $OutlineOrder following current note.\nnextItem differs from next in that it will match an adornment, separator, or item set to not export.",指定子 nextItem は、$OutlineOrder 内の現在のノートに続く次のノートを記述します。\nnextItem は、エクスポートしないように設定された装飾、セパレータ、または項目と一致するという点で next とは異なります。
nextSibling,"The designator nextSibling describes the sibling note in $OutlineOrder after the note in current focus; the next note on the same level, i.e. excluding children.\nnextSibling is a more closely designed test than next as the latter may be at a different outline depth.\nnextSibling will not match an adornment, separator, or item set to not export, but see nextSiblingItem.",指定子 nextSibling は、$OutlineOrder 内で現在フォーカスされているノートの後の兄弟ノートを記述します。同じレベルの次のノート、つまり子を除外します。\nnextSibling は、next よりも厳密に設計されたテストです。後者はアウトラインの深さが異なる可能性があるためです。\nnextSibling は、エクスポートしないように設定された装飾、セパレーター、または項目と一致しません。ただし、nextSiblingItem を参照してください。
nextSiblingItem,"The designator nextSiblingItem describes the sibling note in $OutlineOrder after the note in current focus; the next note on the same level, i.e. excluding children.\nnextSiblingItem differs from nextSibling in that it will match an adornment, separator, or item set to not export.",指定子 nextSiblingItem は、$OutlineOrder 内で現在フォーカスされているノートの後の兄弟ノートを記述します。同じレベルの次のノート、つまり子を除外します。\nnextSiblingItem は、エクスポートしないように設定された装飾、セパレータ、または項目と一致するという点で nextSibling とは異なります。
original,"The designator original is synonymous with this for all notes except alias. In the context of an alias, original is the alias's original note.\nThis designator is most useful in the context of an agent's action. For instance:\n	$Container=""/Bin""; \nwill move any matching aliases to the root-level note 'Bin' but the query will spawn a new alias next cycle; unless stopped, 'Bin' will fill with aliases as new ones are added each agent cycle. However:\n	$Container(original)=""/Bin""; \nwill move the original not of the alias to 'Bin' causing the original to be out of scope of the agent query and thus having the expected effect.","指定子のオリジナルは、エイリアスを除くすべてのノートについてこれと同義です。エイリアスのコンテキストでは、オリジナルはエイリアスの元のノートです。\nこの指定子は、エージェントのアクションのコンテキストで最も役立ちます。たとえば:\n$Container=""/Bin"";\n一致するエイリアスをルートレベルのメモ「Bin」に移動しますが、クエリは次のサイクルで新しいエイリアスを生成します。停止しない限り、エージェント サイクルごとに新しいエイリアスが追加されるため、「Bin」はエイリアスでいっぱいになります。ただし:\n$Container(original)=""/Bin"";\nエイリアスではないオリジナルが「Bin」に移動され、オリジナルがエージェント クエリの範囲外になり、期待どおりの効果が得られます。"
parent,"The designator parent describes the note containing the note currently in focus. In Tinderbox there is only one parent note per child or set of sibling children.\nTesting the 'parent' of an alias\nThe parent of an alias is the alias' own container (note or agent), not that of its original note. However, in more complex scenarios care needs to be taken to establish which alias/original note the user intends to reference. Where multiple aliases exist whether inside agents or elsewhere, there is scope for ambiguity if the user is not careful with their code. When using parent with aliases there are several useful considerations\n* The original designator, as in parent(original), will unambiguously indicate that it is the parent of the alias' original note that is being referenced\n* Only in agents, the Link type honouring operators designator can be used to allow agent aliases to refer to their 'parent' rather than the parent of the original note on which the alias is based.\n* The $Container attribute is intrinsic to an alias and potentially less ambiguous than $Name(parent) if trying to establish an aliases parentage within code.",指定子の親は、現在フォーカスされているノートを含むノートを説明します。Tinderbox では、子または兄弟の子のセットごとに親ノートが 1 つだけあります。\nエイリアスの「親」をテストする\nエイリアスの親は、元のノートのコンテナではなく、エイリアス自身のコンテナ (ノートまたはエージェント) です。ただし、より複雑なシナリオでは、ユーザーが参照する予定のエイリアス/オリジナル ノートを確立するために注意が必要です。エージェント内またはその他の場所に複数のエイリアスが存在する場合、ユーザーがコードを注意深く扱わないとあいまいさが生じる可能性があります。エイリアスを持つ親を使用する場合、いくつかの有益な考慮事項があります。\n*parent(original) のような元の指定子は、参照されているエイリアスの元のノートの親であることを明確に示します。\n* エージェント内でのみ、リンク タイプ優先演算子指定子を使用して、エージェント エイリアスがエイリアスの基になっている元のノートの親ではなく、その「親」を参照できるようにすることができます。\n* $Container 属性はエイリアスに固有のものであり、コード内でエイリアスの親子関係を確立しようとする場合、$Name(parent) よりも曖昧ではない可能性があります。
previous,"The designator previous describes the note in $OutlineOrder preceding current note.\nprevious is a less closely designed test than prevSibling as the former may be at a different outline depth.\nprevious will not match an adornment, separator, or item set to not export, but see previousItem.",指定子previousは、現在のノートの前にある$OutlineOrder内のノートを記述します。\nprevSibling はアウトラインの深さが異なる可能性があるため、prevsibling よりも厳密に設計されたテストではありません。\nprevious は、エクスポートしないように設定された装飾、区切り文字、または項目と一致しませんが、previousItem を参照してください。
previousItem,"The designator previousItem describes the note in $OutlineOrder preceding current note.\npreviousItem differs from previous in that it will match an adornment, separator, or item set to not export.",指定子previousItemは、現在のメモの前にある$OutlineOrder内のメモを記述します。\npreviousItem は、エクスポートしないように設定された装飾、セパレータ、または項目と一致するという点で、以前とは異なります。
previousSiblingItem,"The designator prevSiblingItem describes the sibling note in $OutlineOrder before the note in current focus; the previous note on the same outline level with the same parent, i.e. excluding children. \nprevSiblingItem differs from prevSibling in that it will match an adornment, separator, or item set to not export.",指定子 prevSiblingItem は、現在フォーカスされているノートの前に $OutlineOrder 内の兄弟ノートを記述します。同じ親を持つ同じアウトライン レベルにある前のノート、つまり子を除外します。\nprevSiblingItem は、エクスポートしないように設定された装飾、セパレータ、または項目と一致するという点で prevSibling とは異なります。
prevSibling,"The designator prevSibling describes the sibling note in $OutlineOrder before the note in current focus; the previous note on the same outline level with the same parent, i.e. excluding children. \nNote that whilst prevSibling is the normal assumed spelling, the alternate of previousSibling is supported, though deprecated.\nprevSibling is a more closely designed test than previous as the latter may be at a different outline depth.\nprevSibling will not match an adornment, separator, or item set to not export but see previousSiblingItem.",指定子 prevSibling は、$OutlineOrder 内で現在フォーカスされているノートの前に兄弟ノートを記述します。同じ親を持つ同じアウトライン レベルにある前のノート、つまり子を除外します。\nprevSibling は通常想定されるスペルですが、previousSibling の代替もサポートされていますが、非推奨であることに注意してください。\nprevSibling は、前のものよりも厳密に設計されたテストであり、後者はアウトラインの深さが異なる可能性があります。\nprevSibling は、エクスポートしないように設定された装飾、セパレーター、または項目と一致しませんが、previousSiblingItem を参照してください。
randomChild,"The designator randomChild returns a randomly-chosen child of the current note (i.e. this note). If the current note has no children, randomChild returns the name of the current note. For example:\n	$MyString = $Name(randomChild)",指定子randomChildは、現在のノート(つまり、このノート)のランダムに選択された子を返します。現在のノートに子がない場合、randomChild は現在のノートの名前を返します。たとえば:\n$MyString = $Name(ランダムチャイルド)
selection,"The group designator selection designates notes that are selected at the time the action is run. Thus:\n	$Color(selected)=""red""; \nturns the selected note(s) red.","グループ指定子の選択は、アクションの実行時に選択されるノートを指定します。したがって:\n$Color(selected)=""赤"";\n選択したノートを赤にします。"
that,"The designator 'that' refers to note running a query within find() code. As expressions like find() change the meaning of 'this', that provides access to the original value of this. that is evaluated in stamps.\nFor instance, it makes it possible to use an attribute value from the calling notes within a find() query in an expression. In such contexts, 'this' would apply to the note being queried by find() rather than the note calling find().\nFor example if Note A, has 'Note B' stored in $MyString and runs a rule (or some other action code) the following would fail to test each note in find() for a $MyString value of Note B:\n	find($MyString(this)==""Note B"") Fail!\nBut:\n	find($MyString(that)==""Note B"") \nwill test each note in scope of the find() query for the $MyString value stored in the calling note, i.e. Note A.","指定子「that」は、find() コード内でクエリを実行していることを示します。find() のような式は「this」の意味を変更するため、this の元の値にアクセスできるようになります。それはスタンプで評価されます。\nたとえば、式内の find() クエリ内の呼び出しメモからの属性値を使用できるようになります。このようなコンテキストでは、「this」は、find() を呼び出すノートではなく、find() によってクエリされるノートに適用されます。\nたとえば、ノート A の $MyString に「ノート B」が保存されており、ルール (またはその他のアクション コード) を実行する場合、次のコードでは、find() でノート B の $MyString 値について各ノートをテストできません。\nfind($MyString(this)==""メモ B"") 失敗しました!\nしかし:\nfind($MyString(that)==""メモ B"")\nfind() クエリのスコープ内の各ノートを、呼び出し元のノート、つまりノート A に格納されている $MyString 値をテストします。"
this,"The designator this describes the current note (i.e.the note currently in focus). The focus of this can vary slightly by context:\n* in $Rule & $Edict: the note whose rule is running\n* in $OnAdd/OnRemove: the note that is being added/removed. In context, an attribute with no designator thus refers to the note running the action\n* in $AgentQuery: the note that is being examined\n* in $AgentAction: the alias that is being examined\n* in find(), collect(), etc.: the note that is being examined\nBeware of nesting changing the context. Consider the following rule:\n	$Text=find($MyString==$Name(this)) \nAlthough the overall context is a rule, the rule contains a find, which in turn holds the 'this' designator. Therefore in the above example 'this' is evaluated in the context of the nested find() and not as in a simple $Rule. The problem is resolved by using a different designator: see 'that'.",現在のノート (つまり、現在フォーカスされているノート) を表す指定子です。この焦点はコンテキストによって若干異なる場合があります。\n* $Rule & $Edict: ルールが実行されているメモ\n* $OnAdd/OnRemove: 追加/削除されるメモ。したがって、コンテキストでは、指定子のない属性は、アクションを実行するメモを指します。\n* $AgentQuery 内: 調査対象のメモ\n* $AgentAction 内: 検査されるエイリアス\n* find()、collect() など: 調査対象のメモ\nコンテキストを変更するネストに注意してください。次のルールを考慮してください。\n$Text=find($MyString==$Name(this))\n全体的なコンテキストはルールですが、ルールには検索が含まれており、その検索には「this」指定子が保持されます。したがって、上記の例では、「this」は単純な $Rule ではなく、ネストされた find() のコンテキストで評価されます。この問題は、別の指定子を使用することで解決されます。「that」を参照してください。
adorments,"The designator adornments returns all the adornments that are contained inside the current note, i.e. this container's child map. The data is returned as a List of the adornments' in ascending $OutlineOrder.\nSiblings vs. children\nFor any given map, in terms of $OutlineDepth/$OutlineOrder, notes on the map are siblings of the maps' adornment(s). However, for adornments any adornments are for the addressed item's child map. If the logic seems odd, bear in mind that a map (timeline, etc.) is normally addressed in terms of its enclosing—and thus parent–container.\nThus, for an item on a map to get its sibling adornments use either of these relative references, use either:\n	$MyList = $Name(adornments(parent)) \n	$MyList = $Name(adornments(..)) \nnoting that .. is the unix term for the parent folder. For most Tinderbox users, who aren't familiar with Unix structures, the parent designator as the offset address argument is the most sensible to use.\nTitle vs. ID and action code\nWhen using a large number of adornments, e.g. to set out a time or date grid, many of the individual adornments may not have a unique $Name. For instance if there is an adornment '10' mapping the first 10 minutes of an hour, there may be multiple adornments on the same map with the same $Name and $Path. Recall that when accessing a note via a not unique title/path, Tinderbox always matches the first match by $OutlineOrder, even when processing a list. In other words, processing a list of $Name values with multiple '10' values, the action will act on the same, first match target, every time.\n$ID offers a sensible workaround, not least because within the action code context the use of item titles ($Name) is a convenience. If you want to process a list of adornments for whatever ever reason it may therefore make sense to use their $ID instead as this will always be unique. For example:\n	$MyList = $ID(adornments) → a list of child adornment IDs\n	$MyList = $Name(adornments(parent)) → a list of sibling adornment IDs",指定子の装飾は、現在のノート (つまり、このコンテナの子マップ) 内に含まれるすべての装飾を返します。データは、装飾品のリストとして昇順の $OutlineOrder として返されます。\n兄弟対子供\n任意のマップについて、$OutlineDepth/$OutlineOrder に関して、マップ上のメモはマップの装飾の兄弟です。ただし、装飾品の場合、すべての装飾品はアド​​レス指定された項目の子マップ用です。ロジックが奇妙に見える場合は、マップ (タイムラインなど) は通常、それを囲むコンテナ、つまり親コンテナの観点から扱われることに留意してください。\nしたがって、マップ上のアイテムがその兄弟装飾を取得するには、次のいずれかの相対参照を使用します。\n$MyList = $Name(装飾品(親))\n$MyList = $Name(装飾品(..))\n.. は親フォルダーを表す UNIX 用語であることに注意してください。Unix 構造に詳しくないほとんどの Tinderbox ユーザーにとって、オフセット アドレス引数として親指定子を使用するのが最も賢明です。\nタイトルと ID およびアクション コードの比較\n多数の装飾品を使用する場合。時間や日付のグリッドを設定する場合、個々の装飾品の多くは一意の $Name を持たない場合があります。たとえば、1 時間の最初の 10 分をマッピングする装飾「10」がある場合、同じ $Name と $Path を持つ同じマップ上に複数の装飾が存在する可能性があります。一意ではないタイトル/パスを介してメモにアクセスする場合、リストを処理する場合でも、Tinderbox は常に $OutlineOrder によって最初に一致するものと一致することを思い出してください。つまり、複数の「10」値を含む $Name 値のリストを処理すると、アクションは毎回、最初に一致した同じターゲットに対して動作します。\n$ID は、特にアクション コードのコンテキスト内で項目タイトル ($Name) を使用すると便利であるため、賢明な回避策を提供します。したがって、何らかの理由で装飾品のリストを処理したい場合は、$ID が常に一意であるため、代わりに $ID を使用するのが合理的です。たとえば:\n$MyList = $ID(装飾品) → 子装飾品 ID のリスト\n$MyList = $Name(adornments(parent)) → 兄弟装飾品 ID のリスト
all,"The designator all describes all notes in the current TBX. 'all' is assumed as a value by some group-based operators if no explicit group name is supplied. The returned List is all items ordered by ascending $OutlineOrder value.\nIt appears all is explicitly supported for group-based work in actions & rules, but not for group-based export codes.",指定子 all は、現在の TBX 内のすべてのノートを表します。明示的なグループ名が指定されていない場合、一部のグループベースの演算子では値として「all」が想定されます。返されるリストは、$OutlineOrder 値の昇順で並べられたすべての項目です。\nアクションとルールのグループベースの作業についてはすべて明示的にサポートされているようですが、グループベースのエクスポート コードについてはサポートされていないようです。
ancestors,"The designator ancestors returns a List of all notes in a direct line of ascent from the current note to its root-level container and so the List is returned in descending $OutlineOrder.\nAs the list of ancestors is returned in reverse order, i.e. deepest nested first and root item last. So:\n	$MyString = collect(ancestors,$Path)[-1]; is the root-level container for this note\n	$MyString = collect(ancestors,$Path)[0]; is the parent container for this note","指定子の祖先は、現在のノートからそのルートレベルのコンテナへの上昇の直線にあるすべてのノートのリストを返すため、リストは降順の $OutlineOrder で返されます。\n祖先のリストは逆の順序で返されるため、つまり、最も深いネストが最初に、ルート項目が最後に返されます。それで:\n$MyString = 収集(祖先,$Path)[-1];このメモのルートレベルのコンテナです\n$MyString =collect(ancestors,$Path)[0];このメモの親コンテナです"
children,"The designator children describes any direct child of the current note. The List returned gives all immediate children sorted in ascending $OutlineOrder.\nThis designator removes the contextual ambiguity of older usage of 'child' for both group and item scope usage. By comparison the child designator is always assumed to apply to item scope (i.e. one referenced container only).\nAs designators ignore map adornments, a container note with just adornments on it but child notes with evaluate as having a $ChildCount (the number of adornments) but no children (the number of notes).",指定子 Children は、現在のノートの直接の子を表します。返される List には、$OutlineOrder の昇順で並べ替えられたすべての直接の子が表示されます。\nこの指定子により、グループと項目の両方のスコープの使用法における「子」の古い使用法にあった文脈上の曖昧さが解消されます。比較すると、子指定子は常に項目スコープ (つまり、参照される 1 つのコンテナのみ) に適用されると想定されます。\nデジグネータはマップ装飾を無視するため、装飾のみを含むコンテナ ノートと子ノートは $ChildCount (装飾の数) を持つが、子 (ノートの数) は持たないと評価されます。
descendants,"The designator descendants describes all direct and indirect children of the current note, i.e. all those for whom the current note is an ancestor.\nThe list returned is all descendants is in ascending $OutlineOrder, i.e. as you would see in Outline view with all containers expanded and then reading the order vertically",指定子の子孫は、現在のノートのすべての直接的および間接的な子、つまり現在のノートが祖先であるすべての子を表します。\n返されるリストは、すべての子孫が昇順の $OutlineOrder にあります。つまり、すべてのコンテナーが展開されたアウトライン ビューで順序が垂直に読み取られるのと同じです。
find,"Using a suitable query, find() can be used as a special item or group designator. The function returns a List of the $Path value for every matching note. The likely order of the returned items is $OutlineOrder ascending but it cannot be assumed. If sort order matters apply and explicit sort operation before further use.\nIn an item-scope context, care should be taken in constructing the query so that only one note is matched.",適切なクエリを使用すると、find() を特別な項目またはグループ指定子として使用できます。この関数は、一致するすべての音符の $Path 値のリストを返します。返されるアイテムの順序はおそらく $OutlineOrder の昇順ですが、これを仮定することはできません。ソート順序が重要な場合は、さらに使用する前に明示的なソート操作を適用してください。\n項目スコープのコンテキストでは、1 つのメモのみが一致するようにクエリを構築する際に注意する必要があります。
siblings,"The designator siblings describes all notes at the same outline level as the current note that share a common parent. This includes the current note.  The returned List is in ascending $OutlineOrder.\nThus for a note with three sibling notes, siblings will be a list of four items (i.e. this note and all its siblings).",指定子の兄弟は、共通の親を共有する現在のノートと同じアウトライン レベルにあるすべてのノートを記述します。これには現在のメモも含まれます。返されるリストは $OutlineOrder の昇順です。\nしたがって、3 つの兄弟ノートを持つノートの場合、兄弟は 4 つの項目 (つまり、このノートとそのすべての兄弟) のリストになります。
destination,"Used (only) by export codes that create link lists and action code links(), and by OnLink actions.\nThe designator destination refers to the note to which the exported links will point. This object allows users to access data generically from the destination of the link.\nSee also: source.\nFor example,\nbasicLinks(&lt;ul>,&lt;li>,"" : (modified value($Modified(destination)))&lt;/li>"",&lt;/ul>) \nwill export a list of links, each destination note's Name followed by followed by the modification time for the link's destination. Note this designator cannot be used with value and attribute references.\nNote that the designator can be used in the link export code's item prefix and/or suffix arguments but this designator cannot be used with value and attribute references. Meanwhile, the link's anchor text always remains the $Name (i.e. title) of the link's destination note, linked to that note's page's URL.","リンク リストとアクション コード links() を作成するエクスポート コード、および OnLink アクションによって (のみ) 使用されます。\n指定子の宛先は、エクスポートされたリンクが指すメモを指します。このオブジェクトにより、ユーザーはリンク先から一般的にデータにアクセスできるようになります。\nソースも参照してください。\nたとえば、\nBasicLinks(<ul>,<li>,"" : (変更された値($Modified(宛先)))</li>"",</ul>)\nリンクのリストをエクスポートします。各宛先ノートの名前の後に、リンクの宛先の変更時刻が続きます。この指定子は、値および属性の参照では使用できないことに注意してください。\n指定子はリンク エクスポート コードの項目プレフィックスおよび/またはサフィックス引数で使用できますが、この指定子は値および属性参照では使用できないことに注意してください。一方、リンクのアンカー テキストは常に、リンク先のノートの $Name (つまりタイトル) のままであり、そのノートのページの URL にリンクされます。"
source,"Used (only) by export codes that create link lists and action code links(), and by OnLink actions.\nThe designator source refers to the note from which the exported links will arise. In most (all?) cases this equates to both this and current, so the object 'source' makes it easier for the user to specify generically from where data is drawn.\nSee also: destination.\nFor example,\nbasicLinks(""&lt;ul>"",""&lt;li>value($Name(source)) =&gt; "",""&lt;/li>"",""&lt;/ul>"") \nwill export a list of links, each destination note's Name preceded by the source note's name and a =&gt; pointing to the destination note's name.\nNote that the designator can be used in the link export code's item prefix and/or suffix arguments but this designator cannot be used with value and attribute references. Meanwhile, the link's anchor text always remains the Name (i.e. title) of the link's destination note, linked to that note's page's URL.","リンク リストとアクション コード links() を作成するエクスポート コード、および OnLink アクションによって (のみ) 使用されます。\n指定子のソースは、エクスポートされたリンクの元となるメモを参照します。ほとんど (すべて?) の場合、これは this と current の両方に相当するため、オブジェクト「source」を使用すると、ユーザーはデータの抽出元を一般的に指定しやすくなります。\n「目的地」も参照してください。\nたとえば、\nBasicLinks(""<ul>"",""<li>value($Name(source)) =>"",""</li>"",""</ul>"")\nリンクのリスト、各宛先ノートの名前の前にソースノートの名前と =&gt; がエクスポートされます。宛先ノートの名前を指します。\n指定子はリンク エクスポート コードの項目プレフィックスおよび/またはサフィックス引数で使用できますが、この指定子は値および属性参照では使用できないことに注意してください。一方、リンクのアンカー テキストは常に、リンク先のノートの名前 (つまり、タイトル) のままとなり、そのノートのページの URL にリンクされます。"
document,The document designator refers to the overall TBX document. Used with word cloud exports.,文書指定子は、TBX 文書全体を指します。ワード クラウド エクスポートで使用されます。
my,"The my designator is used in action code in the context of composites, specifically when referring to the composite containing the note using the code, i.e. this note.\nmy can be used as a short form of compositeFor(this) when using with colon-operators used (only) with composites. For example, the pair of examples below have the same functional effect:\n	compositeFor(this):role(""someRole"") \n	my:role(""someRole"") \nThus the use of 'my' makes for more compact code; it has no effect on performance.\nIf using compositeFor() in an any other context, e.g. a composite of which the current note is not a member then the 'my' designator can not be used.","my 指定子は、コンポジットのコンテキストでアクション コード内で使用されます。特に、コードを使用してノート (つまり、このノート) を含むコンポジットを参照する場合に使用されます。\nmy は、コンポジットで (のみ) 使用されるコロン演算子と一緒に使用する場合、compositeFor(this) の短縮形として使用できます。たとえば、以下の 2 つの例には同じ機能的効果があります。\n複合対象(この):role(""someRole"")\nmy:role(""ある役割"")\nしたがって、「my」を使用するとコードがよりコンパクトになります。パフォーマンスには影響しません。\n他のコンテキストで complexFor() を使用する場合。現在のノートがメンバーではないコンポジットの場合、「my」指定子は使用できません。"
